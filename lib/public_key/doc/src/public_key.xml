<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>2008</year>
      <year>2014</year>
      <holder>Ericsson AB, All Rights Reserved</holder>
    </copyright>
    <legalnotice>
  The contents of this file are subject to the Erlang Public License,
  Version 1.1, (the "License"); you may not use this file except in
  compliance with the License. You should have received a copy of the
  Erlang Public License along with this software. If not, it can be
  retrieved online at http://www.erlang.org/.

  Software distributed under the License is distributed on an "AS IS"
  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
  the License for the specific language governing rights and limitations
  under the License.

  The Initial Developer of the Original Code is Ericsson AB.
    </legalnotice>

    <title>public_key</title>
    <prepared>Ingela Anderton Andin</prepared>
    <responsible></responsible>
    <docno></docno>
    <date></date>
    <rev></rev>
  </header>
  <module>public_key</module>
  <modulesummary> API module for public key infrastructure.</modulesummary>
  <description>
    <p>This module provides functions to handle public key infrastructure. It can
    encode/decode different file formats (PEM, openssh), sign and verify digital signatures and validate
    certificate paths and certificate revocation lists.
    </p>
  </description>

  <section>
    <title>public_key</title>

    <list type="bulleted">
      <item>public_key requires the crypto and asn1 applications, the latter since R16 (hopefully the runtime dependency on asn1 will
      be removed again in the future).</item>

      <item>Supports <url href="http://www.ietf.org/rfc/rfc5280.txt">RFC 5280 </url> -
      Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile </item>
      <item>Supports <url href="http://www.ietf.org/rfc/rfc3447.txt"> PKCS-1 </url> - RSA Cryptography Standard </item>
      <item>Supports <url href="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf"> DSS</url>- Digital Signature Standard (DSA - Digital Signature Algorithm)</item>
      <item>Supports <url href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-3-diffie-hellman-key-agreement-standar.htm"> PKCS-3 </url> - Diffie-Hellman Key Agreement Standard </item>
      <item>Supports <url href="http://www.ietf.org/rfc/rfc2898.txt"> PKCS-5</url> - Password-Based Cryptography Standard </item>
      <item>Supports <url href="http://www.ietf.org/rfc/rfc5208.txt"> PKCS-8</url> - Private-Key Information Syntax Standard</item>
      <item>Supports <url href="http://www.ietf.org/rfc/rfc5967.txt"> PKCS-10</url> - Certification Request Syntax Standard</item>
    </list>
  </section>

  <section>
    <title>COMMON DATA TYPES </title> 
    
    <note><p>All records used in this manual 
    <!--     except #policy_tree_node{}  -->
    are generated from ASN.1 specifications
    and are documented in the User's Guide. See <seealso 
    marker="public_key_records">Public key records</seealso> and <seealso 
    marker="cert_records">X.509 Certificate records</seealso>. 
    </p></note>
    
    <p>Use the following include directive to get access to the 
    records and constant macros described here and in the User's Guide.</p>
    
    <code> -include_lib("public_key/include/public_key.hrl").</code>

    <p><em>Data Types </em></p>
    
    <p><code>oid() - Object Identifier, a tuple of integers as generated by the ASN1 compiler.</code></p>

    <p><code>boolean() = true | false</code></p>

    <p><code>string() = [bytes()]</code></p>

    <p><code>der_encoded() = binary()</code></p>
   
    <p><code>pki_asn1_type() = 'Certificate' | 'RSAPrivateKey'| 'RSAPublicKey' |
    'DSAPrivateKey' | 'DSAPublicKey' | 'DHParameter' |
    'SubjectPublicKeyInfo' | 'PrivateKeyInfo' |
    'CertificationRequest' | 'ECPrivateKey' | 'EcpkParameters'</code></p>
    
    <p><code>pem_entry () = {pki_asn1_type(), binary(), %% DER or encrypted DER
    not_encrypted | cipher_info()}</code></p>

    <p><code>cipher_info()  =  {"RC2-CBC | "DES-CBC" | "DES-EDE3-CBC",
    crypto:rand_bytes(8) | {#'PBEParameter{}, digest_type()} |#'PBES2-params'{}}</code></p>
	  
    <p><code>public_key()  = rsa_public_key() | dsa_public_key() | ec_public_key()</code></p>
    <p><code>private_key() = rsa_private_key() | dsa_private_key() | ec_private_key()</code></p>
    <p><code>rsa_public_key()  = #'RSAPublicKey'{}</code></p>

    <p><code>rsa_private_key() = #'RSAPrivateKey'{}</code></p>

    <p><code>dsa_public_key()  = {integer(),  #'Dss-Parms'{}}</code></p>

    <p><code>dsa_private_key() = #'DSAPrivateKey'{}</code></p>

    <p><code>ec_public_key()   = {#'ECPoint'{}, #'EcpkParameters'{} |
    {namedCurve, oid()}}</code></p>
    
    <p><code>ec_private_key()  = #'ECPrivateKey'{}</code></p>

    <p><code>public_crypt_options() = [{rsa_pad, rsa_padding()}].</code></p>

    <p><code>rsa_padding() =  'rsa_pkcs1_padding' | 'rsa_pkcs1_oaep_padding' |
    'rsa_no_padding'</code></p>

    <p><code>digest_type() - Union of below digest types</code></p>
    
    <p><code>rsa_digest_type()   = 'md5' | 'sha' | 'sha224' | 'sha256' | 'sha384' |
    'sha512'</code></p>

    <p><code>dss_digest_type()   = 'sha'</code></p>

    <p><code>ecdsa_digest_type() = 'sha'| 'sha224' | 'sha256' | 'sha384' | 'sha512'</code></p>

    <p><code>crl_reason()  = unspecified | keyCompromise | cACompromise |
    affiliationChanged | superseded | cessationOfOperation |
    certificateHold | privilegeWithdrawn | aACompromise</code></p>

    <p><code>ssh_file()  = openssh_public_key | rfc4716_public_key | known_hosts |
    auth_keys</code></p>
    
<!--     <p><code>policy_tree() = [Root, Children]</code></p> -->
    
<!--     <p><code>Root = #policy_tree_node{}</code></p>    -->

<!--     <p><code>Children = [] | policy_tree()</code></p> -->
	
<!--     <p> The policy_tree_node record has the following fields:</p> -->
    
<!--     <taglist> -->
      
<!--       <tag>valid_policy</tag> -->
<!--       <item> Is a single policy OID representing a -->
<!--          valid policy for the path of length x.</item> -->
      
<!--       <tag>qualifier_set</tag> -->
<!--       <item>A set of policy qualifiers associated -->
<!--          with the valid policy in certificate x.</item> -->
      
<!--       <tag>critically_indicator</tag> -->
<!--       <item>The critically_indicator indicates whether the -->
<!--          certificate policy extension in certificate x was marked as -->
<!--          critical. </item> -->
      
<!--       <tag>expected_policy_set</tag> -->
<!--       <item>The expected_policy_set contains one or more policy OIDs -->
<!--          that would satisfy this policy in the certificate x+1. </item>         -->
<!--     </taglist> -->
  </section> 

<funcs>    

  <func>
    <name>compute_key(OthersKey, MyKey)-></name>
    <name>compute_key(OthersKey, MyKey, Params)-></name>
    <fsummary> Compute shared secret</fsummary>
    <type>
      <v>OthersKey = #'ECPoint'{} | binary(), MyKey = #'ECPrivateKey'{} | binary()</v>
      <v>Params =  #'DHParameter'{}</v>
    </type>
  <desc>
    <p> Compute shared secret </p>
  </desc>
  </func>

  <func>
    <name>decrypt_private(CipherText, Key) -> binary()</name>
    <name>decrypt_private(CipherText, Key, Options) -> binary()</name>
    <fsummary>Public key decryption.</fsummary>
    <type>
      <v>CipherText = binary()</v>
      <v>Key = rsa_private_key()</v>
      <v>Options = public_crypt_options()</v>
  </type> 
  <desc> 
    <p>Public key decryption using the private key. See also <seealso
	marker="crypto:crypto#private_decrypt/4">crypto:private_decrypt/4</seealso></p> 
  </desc> 
  </func>

  <func>
    <name>decrypt_public(CipherText, Key) - > binary()</name>
    <name>decrypt_public(CipherText, Key, Options) - > binary()</name>
    <fsummary></fsummary>
    <type>
      <v>CipherText = binary()</v>
      <v>Key = rsa_public_key()</v>
      <v>Options = public_crypt_options()</v>
  </type> 
  <desc> 
    <p> Public key decryption using the public key. See also <seealso
	marker="crypto:crypto#public_decrypt/4">crypto:public_decrypt/4</seealso></p> 
  </desc> 
  </func> 

  <func>
    <name>der_decode(Asn1type, Der) -> term()</name>
    <fsummary> Decodes a public key ASN.1 DER encoded entity.</fsummary>
    <type>
      <v>Asn1Type = atom()</v>
      <d> ASN.1 type present in the public_key applications
      asn1 specifications.</d>
      <v>Der = der_encoded()</v>
    </type> 
    <desc> 
      <p> Decodes a public key ASN.1 DER encoded entity.</p>
    </desc> 
  </func>
    
  <func>
    <name>der_encode(Asn1Type, Entity) -> der_encoded()</name>
    <fsummary> Encodes a public key entity with asn1 DER encoding.</fsummary>
    <type>
      <v>Asn1Type = atom()</v>
      <d> Asn1 type present in the public_key applications
	 ASN.1 specifications.</d>
      <v>Entity = term()</v>
      <d>The erlang representation of <c>Asn1Type</c></d>
  </type> 
  <desc> 
    <p> Encodes a public key entity with ASN.1 DER encoding.</p>
  </desc> 
  </func>

  <func>
    <name>generate_key(Params) -> {Public::binary(), Private::binary()}  | #'ECPrivateKey'{} </name>
    <fsummary>Generates a new keypair</fsummary>
    <type>
      <v> Params = #'DHParameter'{} |  {namedCurve, oid()} |  #'ECParameters'{} </v>
    </type>
  <desc>
    <p>Generates a new keypair</p>
  </desc>
  </func>

  <func>
    <name>pem_decode(PemBin) -> [pem_entry()]</name>
    <fsummary>Decode PEM binary data and return
    entries as ASN.1 DER encoded entities. </fsummary>
    <type>
      <v>PemBin = binary()</v>
      <d>Example {ok, PemBin} = file:read_file("cert.pem").</d>
    </type> 
  <desc> 
    <p>Decode PEM binary data and return
    entries as ASN.1 DER encoded entities.</p>
  </desc> 
  </func> 
    
   <func>
    <name>pem_encode(PemEntries) -> binary()</name>
    <fsummary>Creates a PEM binary</fsummary>
    <type>
      <v> PemEntries = [pem_entry()] </v> 
  </type> 
  <desc> 
    <p>Creates a PEM binary</p> 
  </desc> 
  </func>

   <func>
    <name>pem_entry_decode(PemEntry) -> term()</name>
    <name>pem_entry_decode(PemEntry, Password) -> term()</name>
    <fsummary>Decodes a pem entry.</fsummary>
    <type>
      <v> PemEntry = pem_entry() </v> 
      <v> Password = string() </v> 
  </type> 
  <desc> 
    <p>Decodes a PEM entry. pem_decode/1 returns a list of PEM
    entries. Note that if the PEM entry is of type
    'SubjectPublickeyInfo' it will be further decoded to an
    rsa_public_key() or dsa_public_key().</p>
  </desc> 
  </func>

   <func>
    <name>pem_entry_encode(Asn1Type, Entity) -> pem_entry()</name>
    <name>pem_entry_encode(Asn1Type, Entity, {CipherInfo, Password}) -> pem_entry()</name>
    <fsummary> Creates a PEM entry that can be fed to pem_encode/1.</fsummary>
    <type>
      <v>Asn1Type = pki_asn1_type()</v>
      <v>Entity = term()</v>
      <d>The Erlang representation of
      <c>Asn1Type</c>.  If <c>Asn1Type</c> is 'SubjectPublicKeyInfo'
      then <c>Entity</c> must be either an rsa_public_key() or a
      dsa_public_key() and this function will create the appropriate
      'SubjectPublicKeyInfo' entry.
      </d>
      <v>CipherInfo = cipher_info()</v>
      <v>Password = string()</v> 
  </type> 
  <desc> 
    <p> Creates a PEM entry that can be feed to pem_encode/1.</p>
  </desc> 
  </func>

  <func>
    <name>encrypt_private(PlainText, Key) -> binary()</name>
    <fsummary> Public key encryption using the private key.</fsummary>
    <type>
      <v>PlainText = binary()</v>
      <v>Key = rsa_private_key()</v> 
  </type> 
  <desc> 
    <p> Public key encryption using the private key.
     See also <seealso
	marker="crypto:crypto#private_encrypt/4">crypto:private_encrypt/4</seealso></p> 
  </desc> 
  </func>   

  <func>
    <name>encrypt_public(PlainText, Key) -> binary()</name>
    <fsummary> Public key encryption using the public key.</fsummary>
    <type>
      <v>PlainText = binary()</v>
      <v>Key = rsa_public_key()</v> 
  </type> 
  <desc> 
    <p> Public key encryption using the public key.  See also <seealso
	marker="crypto:crypto#public_encrypt/4">crypto:public_encrypt/4</seealso></p> 
  </desc> 
  </func>   
  
  <func>
    <name>pkix_decode_cert(Cert, otp|plain) ->  #'Certificate'{} | #'OTPCertificate'{}</name>
    <fsummary> Decodes an ASN.1 DER encoded PKIX x509 certificate.</fsummary>
    <type>
      <v>Cert = der_encoded()</v> 
  </type> 
  <desc> 
    <p>Decodes an ASN.1 DER encoded PKIX certificate.  The otp option
    will use the customized ASN.1 specification OTP-PKIX.asn1 for
    decoding and also recursively decode most of the standard
    parts.</p>
  </desc> 
  </func>

  <func>
    <name>pkix_encode(Asn1Type, Entity, otp | plain) -> der_encoded()</name>
    <fsummary>DER encodes a PKIX x509 certificate or part of such a
    certificate.</fsummary>
    <type>
      <v>Asn1Type = atom()</v>
      <d>The ASN.1 type can be 'Certificate', 'OTPCertificate' or a subtype of either .</d>
      <v>Entity = #'Certificate'{} | #'OTPCertificate'{} | a valid subtype</v>
  </type> 
  <desc> 
    <p>DER encodes a PKIX x509 certificate or part of such a
    certificate. This function must be used for encoding certificates or parts of certificates
    that are decoded/created in the otp format, whereas for the plain format this
    function will directly call der_encode/2. </p> 
  </desc> 
  </func>

 <func>
    <name>pkix_is_issuer(Cert, IssuerCert) -> boolean()</name>
    <fsummary> Checks if <c>IssuerCert</c> issued <c>Cert</c> </fsummary>
    <type>
      <v>Cert = der_encode() | #'OTPCertificate'{}</v> 
      <v>IssuerCert = der_encode() | #'OTPCertificate'{}</v> 
  </type> 
  <desc> 
    <p> Checks if <c>IssuerCert</c> issued <c>Cert</c> </p> 
  </desc> 
  </func>
  
  <func>
    <name>pkix_is_fixed_dh_cert(Cert) -> boolean()</name>
    <fsummary> Checks if a Certificate is a fixed Diffie-Hellman Cert.</fsummary>
    <type>
        <v>Cert = der_encode() | #'OTPCertificate'{}</v> 
  </type> 
  <desc> 
    <p> Checks if a Certificate is a fixed Diffie-Hellman Cert.</p> 
  </desc> 
  </func>  
  
  <func>
    <name>pkix_is_self_signed(Cert) -> boolean()</name>
    <fsummary> Checks if a Certificate is self signed.</fsummary>
    <type>
       <v>Cert = der_encode() | #'OTPCertificate'{}</v> 
  </type> 
  <desc> 
    <p> Checks if a Certificate is self signed.</p> 
  </desc> 
  </func>

  <func>
    <name>pkix_issuer_id(Cert, IssuedBy) -> {ok, IssuerID} | {error, Reason}</name>
    <fsummary> Returns the issuer id.</fsummary>
    <type>
        <v>Cert = der_encode() | #'OTPCertificate'{}</v>
	<v>IssuedBy = self | other</v>
	<v>IssuerID = {integer(), {rdnSequence, [#'AttributeTypeAndValue'{}]}}</v>
	<d>The issuer id consists of the serial number and the issuers name.</d>
	<v>Reason = term()</v>
  </type> 
  <desc> 
    <p> Returns the issuer id.</p> 
  </desc> 
  </func>

  <func>
    <name>pkix_normalize_name(Issuer) -> Normalized</name>
    <fsummary>Normalizes a issuer name so that it can be easily
    compared to another issuer name. </fsummary>
    <type>
      <v>Issuer = {rdnSequence,[#'AttributeTypeAndValue'{}]}</v>
      <v>Normalized = {rdnSequence, [#'AttributeTypeAndValue'{}]}</v>
  </type> 
  <desc> 
    <p>Normalizes a issuer name so that it can be easily
    compared to another issuer name.</p> 
  </desc> 
  </func>
   
  <func>
    <name>pkix_path_validation(TrustedCert, CertChain, Options) -> {ok, {PublicKeyInfo, PolicyTree}} | {error, {bad_cert, Reason}} </name>
    <fsummary> Performs a basic path validation according to RFC 5280.</fsummary>
     <type>
       <v> TrustedCert =  #'OTPCertificate'{} | der_encode() | atom()  </v>
       <d>Normally a trusted certificate but it can also be a path validation
       error that can be discovered while
       constructing the input to this function and that should be run through the <c>verify_fun</c>.
       For example <c>unknown_ca </c> or <c>selfsigned_peer </c>
       </d>
       <v> CertChain = [der_encode()]</v>
       <d>A list of DER encoded certificates in trust order ending with the peer certificate.</d>
       <v> Options = proplists:proplist()</v>
       <v>PublicKeyInfo = {?'rsaEncryption' | ?'id-dsa',
       rsa_public_key() | integer(), 'NULL' | 'Dss-Parms'{}}</v>
       <v> PolicyTree = term() </v>
       <d>At the moment this will always be an empty list as Policies are not currently supported</d>
       <v> Reason = cert_expired | invalid_issuer | invalid_signature | name_not_permitted |
       missing_basic_constraint | invalid_key_usage | {revoked, crl_reason()} | atom()
       </v>
     </type>
     <desc>
       <p>
	 Performs a basic path validation according to
	 <url href="http://www.ietf.org/rfc/rfc5280.txt">RFC 5280.</url>
	 However CRL validation is done separately by <seealso
	 marker="#pkix_crls_validate-3">pkix_crls_validate/3 </seealso> and should be called
	 from the supplied <c>verify_fun</c>
       </p>

       <taglist>
	 <p> Available options are: </p>

	<tag>{verify_fun, fun()}</tag>
	<item>
	  <p>The fun should be defined as:</p>

	  <code>
fun(OtpCert :: #'OTPCertificate'{},
    Event :: {bad_cert, Reason :: atom() | {revoked, atom()}} |
             {extension, #'Extension'{}},
    InitialUserState :: term()) ->
	{valid, UserState :: term()} |
	{valid_peer, UserState :: term()} |
	{fail, Reason :: term()} |
	{unknown, UserState :: term()}.
	  </code>

	<p>If the verify callback fun returns {fail, Reason}, the
	verification process is immediately stopped. If the verify
	callback fun returns {valid, UserState}, the verification
	process is continued, this can be used to accept specific path
	validation errors such as <c>selfsigned_peer</c> as well as
	verifying application specific extensions.  If called with an
	extension unknown to the user application the return value
	{unknown, UserState} should be used.</p>

	</item>
	<tag>{max_path_length, integer()}</tag>
	<item>
	  The <c>max_path_length</c> is the maximum number of non-self-issued
	  intermediate certificates that may follow the peer certificate
	  in a valid certification path.  So if <c>max_path_length</c> is 0 the PEER must
	  be signed by the trusted ROOT-CA directly, if 1 the path can
	  be PEER, CA, ROOT-CA, if it is 2 PEER, CA, CA, ROOT-CA and so
	  on.
	</item>
      </taglist>

      <p> Possible reasons for a bad certificate are: </p>
      <taglist>
	<tag>cert_expired</tag>
	<item>The certificate is no longer valid as its expiration date has passed.</item>

	<tag>invalid_issuer</tag>
	<item>The certificate issuer name does not match the name of the issuer certificate in the chain.</item>

	<tag>invalid_signature</tag>
	<item>The certificate was not signed by its issuer certificate in the chain.</item>

	<tag>name_not_permitted</tag>
	<item>Invalid Subject Alternative Name extension.</item>

	<tag>missing_basic_constraint</tag>
	<item>Certificate, required to have the basic constraints extension, does not have
	a basic constraints extension.</item>

	<tag>invalid_key_usage</tag>
	<item>Certificate key is used in an invalid way according to the key usage extension.</item>

	<tag>{revoked, crl_reason()}</tag>
	<item>Certificate has been revoked.</item>

	<tag>atom()</tag>
	<item>Application specific error reason that should be checked by the verify_fun</item>
      </taglist>

    </desc>
   </func>

   <func>
     <name>pkix_crls_validate(OTPCertificate, DPAndCRLs, Options) -> CRLStatus()</name>
     <fsummary> Performs CRL validation.</fsummary>
     <type>
       <v> OTPCertificate =  #'OTPCertificate'{}</v>
       <v> DPAndCRLs  = [{DP::#'DistributionPoint'{}, {DerCRL::der_encoded(), CRL::#'CertificateList'{}}}] </v>
       <v> Options = proplists:proplist()</v>
       <v> CRLStatus() =  valid | {bad_cert, revocation_status_undetermined} |
       {bad_cert, {revoked, crl_reason()}}</v>
     </type>
     <desc>
      <p> Performs CRL validation. It is intended to be called from
      the verify fun of  <seealso marker="#pkix_path_validation-3"> pkix_path_validation/3
       </seealso></p>
      <taglist>
	<p> Available options are: </p>
	<tag>{update_crl, fun()}</tag>
	<item>
	  <p>The fun has the following type spec:</p>

	  <code> fun(#'DistributionPoint'{}, #'CertificateList'{}) ->
        #'CertificateList'{}</code>

	  <p>The fun should use the information in the distribution point to acesses
	  the lates possible version of the CRL. If this fun is not specified
	  public_key will use the default implementation:
	  </p>
	  <code> fun(_DP, CRL) -> CRL end</code>
	</item>

	<tag>{issuer_fun, fun()}</tag>
	<item>
	  <p>The fun has the following type spec:</p>

	  <code>
fun(#'DistributionPoint'{}, #'CertificateList'{},
    {rdnSequence,[#'AttributeTypeAndValue'{}]}, term()) ->
	{ok, #'OTPCertificate'{}, [der_encoded]}</code>

	  <p>The fun should return the root certificate and certificate chain
	  that has signed the CRL. 
	  </p>
	  <code> fun(DP, CRL, Issuer, UserState) -> {ok, RootCert, CertChain}</code>
	</item>	
      </taglist>
    </desc>
   </func>

  <func>
    <name>pkix_sign(#'OTPTBSCertificate'{}, Key) -> der_encode()</name>
    <fsummary>Signs certificate.</fsummary>
    <type>
      <v>Key = rsa_public_key() | dsa_public_key()</v> 
    </type> 
    <desc> 
      <p>Signs a 'OTPTBSCertificate'. Returns the corresponding
      der encoded certificate.</p> 
    </desc> 
  </func> 

  <func>
    <name>pkix_sign_types(AlgorithmId) -> {DigestType, SignatureType}</name>
    <fsummary>Translates signature algorithm oid to erlang digest and signature algorithm types.</fsummary>
    <type>
      <v>AlgorithmId = oid()</v>
      <d>Signature oid from a certificate or a certificate revocation list</d>
      <v>DigestType = rsa_digest_type() | dss_digest_type() </v>
      <v>SignatureType = rsa | dsa</v>
    </type>
    <desc>
      <p>Translates signature algorithm oid to erlang digest and signature types.
      </p>
    </desc>
  </func>

  <func>  
    <name>pkix_verify(Cert, Key) -> boolean()</name>
    <fsummary> Verify pkix x.509 certificate signature.</fsummary>
    <type>
      <v>Cert = der_encode()</v> 
      <v>Key = rsa_public_key() | dsa_public_key()</v> 
    </type> 
  <desc> 
    <p> Verify PKIX x.509 certificate signature.</p>
  </desc> 
  </func> 

  <func>
    <name>sign(Msg, DigestType, Key) -> binary()</name>
    <fsummary> Create digital signature.</fsummary>
    <type>
       <v>Msg = binary() | {digest,binary()}</v>
       <d>The msg is either the binary "plain text" data to be
       signed or it is the hashed value of "plain text" i.e. the
       digest.</d>
       <v>DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()</v>
       <v>Key = rsa_private_key() | dsa_private_key() | ec_private_key()</v>
  </type>
  <desc>
    <p> Creates a digital signature.</p> 
  </desc> 
  </func>   

  <func>
    <name>ssh_decode(SshBin,  Type) -> [{public_key(), Attributes::list()}]</name>
    <fsummary>Decodes a ssh file-binary. </fsummary>
    <type>
      <v>SshBin = binary()</v>
      <d>Example {ok, SshBin} = file:read_file("known_hosts").</d>
      <v> Type = public_key | ssh_file()</v>
      <d>If <c>Type</c> is <c>public_key</c> the binary may be either
      a rfc4716 public key or a openssh public key.</d>
    </type>
  <desc>
    <p> Decodes a ssh file-binary. In the case of know_hosts or
    auth_keys the binary may include one or more lines of the
    file. Returns a list of public keys and their attributes, possible
    attribute values depends on the file type represented by the
    binary.
    </p>

    <taglist>
      <tag>rfc4716 attributes - see RFC 4716</tag>
      <item>{headers, [{string(), utf8_string()}]}</item>
      <tag>auth_key attributes - see man sshd </tag>
      <item>{comment, string()}</item>
      <item>{options, [string()]}</item>
      <item>{bits, integer()} - In ssh version 1 files</item>
      <tag>known_host attributes - see man sshd</tag>
      <item>{hostnames, [string()]}</item>
      <item>{comment, string()}</item>
      <item>{bits, integer()} - In ssh version 1 files</item>
    </taglist>

  </desc>
  </func>

  <func>
    <name>ssh_encode([{Key, Attributes}], Type) -> binary()</name>
    <fsummary> Encodes a list of ssh file entries to a binary.</fsummary>
    <type>
      <v>Key = public_key()</v>
      <v>Attributes = list()</v>
      <v>Type = ssh_file()</v>
    </type>
  <desc>
    <p>Encodes a list of ssh file entries (public keys and attributes) to a binary. Possible
    attributes depends on the file type, see <seealso
    marker="#ssh_decode-2"> ssh_decode/2 </seealso></p>
  </desc>
  </func>

  <func>
    <name>verify(Msg, DigestType, Signature, Key) -> boolean()</name>
    <fsummary>Verifies a digital signature.</fsummary>
    <type>
      <v>Msg = binary() | {digest,binary()}</v>
       <d>The msg is either the binary "plain text" data 
        or it is the hashed value of "plain text" i.e. the digest.</d>
      <v>DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()</v>
      <v>Signature = binary()</v>
      <v>Key = rsa_public_key() | dsa_public_key() | ec_public_key()</v>
  </type>
  <desc>
    <p>Verifies a digital signature</p>
  </desc> 
  </func>
  
</funcs>

</erlref>
