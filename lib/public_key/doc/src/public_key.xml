<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>2008</year>
      <year>2022</year>
      <holder>Ericsson AB, All Rights Reserved</holder>
    </copyright>
    <legalnotice>
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
 
      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  The Initial Developer of the Original Code is Ericsson AB.
    </legalnotice>

    <title>public_key</title>
    <prepared>Ingela Anderton Andin</prepared>
    <responsible></responsible>
    <docno></docno>
    <date></date>
    <rev></rev>
  </header>
  <module since="">public_key</module>
  <modulesummary>API module for public-key infrastructure.</modulesummary>
  <description>
    <p>Provides functions to handle public-key infrastructure,
    for details see
    <seeapp marker="public_key_app">public_key(6)</seeapp>.
    </p>
  </description>

  <section>
    <title>Common Records and ASN.1 Types</title> 
    
    <note><p>All records used in this Reference Manual 
    <!--     except #policy_tree_node{}  -->
    are generated from ASN.1 specifications
    and are documented in the User's Guide. See <seeguide 
    marker="public_key_records">Public-key Records</seeguide>.
    </p></note>
    
    <p>Use the following include directive to get access to the 
    records and constant macros described here and in the User's Guide:</p>
    
    <code> -include_lib("public_key/include/public_key.hrl").</code>
  </section>

  <datatypes>
    <datatype>
      <name name="oid"/>
      <desc>
	<p>Object identifier, a tuple of integers as generated by the <c>ASN.1</c> compiler.</p>
      </desc>
    </datatype>

    <datatype>
      <name name="key_oid_name"/>
      <desc>
	<p>Macro names for key object identifiers used by prefixing with ?</p>
      </desc>
    </datatype>


    <datatype>
      <name name="der_encoded"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="pki_asn1_type"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="asn1_type"/>
      <desc>
	<p>ASN.1 type present in the Public Key applications ASN.1 specifications.</p>
      </desc>
    </datatype>

    <datatype>
      <name name="pem_entry"/>
      <name name="der_or_encrypted_der"/>
      <name name="cipher_info"/>
      <name name="cipher"/>
      <name name="salt"/>
      <name name="cipher_info_params"/>
      <desc>
	<code>Cipher = "RC2-CBC" | "DES-CBC" | "DES-EDE3-CBC"</code>
	<p><c>Salt</c> could be generated with
	<seemfa marker="crypto:crypto#strong_rand_bytes/1"><c>crypto:strong_rand_bytes(8)</c></seemfa>.</p>
      </desc>
    </datatype>

    <datatype>
      <name name="public_key"/>
      <name name="rsa_public_key"/>
      <name name="dss_public_key"/>
      <name name="rsa_pss_public_key"/>
      <name name="dsa_public_key"/>
      <name name="ec_public_key"/>
      <name name="public_key_params"/>
      <name name="ecpk_parameters"/>
      <name name="ecpk_parameters_api"/>
      <name name="public_key_info"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="ed_public_key"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="ed_params"/>
    </datatype>

    <datatype>
      <name name="private_key"/>
      <name name="rsa_private_key"/>
      <name name="rsa_pss_private_key"/>
      <name name="dsa_private_key"/>
      <name name="ec_private_key"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="ed_private_key"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="ed_oid_name"/>
      <desc>
	<p>Macro names for object identifiers for EDDSA curves used by prefixing with ?</p>
      </desc>
    </datatype>

    <datatype>
      <name name="key_params"/>
      <desc>
      </desc>
    </datatype>


    <datatype>
      <name name="digest_type"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="issuer_name"/>
      <desc>
      </desc>
    </datatype>


    <datatype>
      <name name="referenceIDs"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="referenceID"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="cert_id"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="cert"/>
      <desc>
      </desc>
    </datatype>

     <datatype>
      <name name="otp_cert"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="der_cert"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="combined_cert"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="bad_cert_reason"/>
      <desc>
      </desc>
    </datatype>


    <datatype>
      <name name="crl_reason"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="chain_opts"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="chain_end"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="cert_opt"/>
      <desc>
      </desc>
    </datatype>

    <datatype>
      <name name="test_root_cert"/>
      <desc>
      </desc>
    </datatype>

     <datatype>
      <name name="test_config"/>
      <desc>
      </desc>
     </datatype>


     <datatype>
      <name name="conf_opt"/>
      <desc>
      </desc>
     </datatype>

  </datatypes>


<funcs>    

  <func>
    <name name="cacerts_clear" arity="0" since="OTP 25.0"/>
    <fsummary>Clears any loaded CA certificates.</fsummary>
    <desc>
      <p>Clears any loaded CA certificates, returns true if any was loaded.
      </p>
    </desc>
  </func>

  <func>
    <name name="cacerts_get" arity="0" since="OTP 25.0"/>
    <fsummary>Returns CA certificates.</fsummary>
    <desc>
      <p>Returns the trusted CA certificates if any are loaded, otherwise
      uses <seemfa marker="#cacerts_load/0">cacerts_load/0</seemfa> to load them.
      The function fails if no <c>cacerts</c> could be loaded.</p>
    </desc>
  </func>

  <func>
    <name name="cacerts_load" arity="0" since="OTP 25.0"/>
    <fsummary>Loads OS specific CA certificates.</fsummary>
    <desc>
      <p>Loads the OS supplied trusted CA certificates.
      </p>
    </desc>
  </func>

  <func>
    <name name="cacerts_load" arity="1" since="OTP 25.0"/>
    <fsummary>Loads CA certificates.</fsummary>
    <desc>
      <p>Loads the trusted CA certificates from a file.
      </p>
    </desc>
  </func>

  <func>
    <name name="compute_key" arity="2" since="OTP R16B01"/>
    <fsummary>Computes shared secret.</fsummary>
  <desc>
    <p>Computes shared secret.</p>
  </desc>
  </func>

  <func>
    <name name="compute_key" arity="3" since="OTP R16B01"/>
    <fsummary>Computes shared secret.</fsummary>
  <desc>
    <p>Computes shared secret.</p>
  </desc>
  </func>

  <func>
    <name name="decrypt_private" arity="2" since="OTP R14B"/>
    <name name="decrypt_private" arity="3" since="OTP R14B"/>
    <fsummary>Public-key decryption.</fsummary>
  <desc> 
    <p>Public-key decryption using the private key. See also <seemfa
	marker="crypto:crypto#private_decrypt/4">crypto:private_decrypt/4</seemfa></p> 
  </desc> 
  </func>

  <func>
    <name name="decrypt_public" arity="2" since="OTP R14B"/>
    <name name="decrypt_public" arity="3" since="OTP R14B"/>
    <fsummary>Public-key decryption.</fsummary>
  <desc> 
    <p>Public-key decryption using the public key. See also <seemfa
	marker="crypto:crypto#public_decrypt/4">crypto:public_decrypt/4</seemfa></p> 
  </desc> 
  </func> 

  <func>
    <name name="der_decode" arity="2" since="OTP R14B"/>
    <fsummary>Decodes a public-key ASN.1 DER encoded entity.</fsummary>
    <desc>
      <p>Decodes a public-key ASN.1 DER encoded entity.</p>
    </desc> 
  </func>

  <func>
    <name name="der_encode" arity="2" since="OTP R14B"/>
    <fsummary>Encodes a public-key entity with ASN.1 DER encoding.</fsummary>
  <desc> 
    <p>Encodes a public-key entity with ASN.1 DER encoding.</p>
  </desc> 
  </func>

  <func>
    <name name="dh_gex_group" arity="4" since="OTP 18.2"/>
    <fsummary>Selects a group for Diffie-Hellman key exchange</fsummary>
    <desc>
      <p>Selects a group for Diffie-Hellman key exchange with the key size in the range <c>MinSize...MaxSize</c>
      and as close to <c>SuggestedSize</c> as possible. If <c>Groups == undefined</c> a default set will be
      used, otherwise the group is selected from <c>Groups</c>.</p>
      <p>First a size, as close as possible to SuggestedSize, is selected. Then one group with that key size
      is randomly selected from the specified set of groups. If no size within the limits of <c>MinSize</c>
      and <c>MaxSize</c> is available, <c>{error,no_group_found}</c> is returned.</p>
      <p>The default set of groups is listed in <c>lib/public_key/priv/moduli</c>. This file may be regenerated like this:</p>
      <pre>
	$> cd $ERL_TOP/lib/public_key/priv/
	$> generate
         ---- wait until all background jobs has finished. It may take several days !
	$> cat moduli-* > moduli
	$> cd ..; make 
      </pre>
    </desc>
  </func>

  <func>
    <name name="encrypt_private" arity="2" since="OTP R14B"/>
    <name name="encrypt_private" arity="3" since="OTP 21.1"/>
    <fsummary>Public-key encryption using the private key.</fsummary>
  <desc> 
    <p>Public-key encryption using the private key.
     See also <seemfa
	marker="crypto:crypto#private_encrypt/4">crypto:private_encrypt/4</seemfa>.</p> 
  </desc> 
  </func>   

  <func>
    <name name="encrypt_public" arity="2" since="OTP R14B"/>
    <name name="encrypt_public" arity="3" since="OTP 21.1"/>
    <fsummary>Public-key encryption using the public key.</fsummary>
  <desc> 
    <p>Public-key encryption using the public key. See also <seemfa
	marker="crypto:crypto#public_encrypt/4">crypto:public_encrypt/4</seemfa>.</p> 
  </desc> 
  </func>   
  
  <func>
    <name name="generate_key" arity="1" since="OTP R16B01"/>
    <fsummary>Generates a new key pair.</fsummary>
  <desc>
    <p>Generates a new key pair. Note that except for Diffie-Hellman
    the public key is included in the private key structure. See also
    <seemfa marker="crypto:crypto#generate_key/2">crypto:generate_key/2</seemfa>
    </p>
  </desc>
  </func>

  <func>
    <name name="pem_decode" arity="1" since="OTP R14B"/>
    <fsummary>Decodes PEM binary data and returns
    entries as ASN.1 DER encoded entities.</fsummary>
  <desc> 
    <p>Decodes PEM binary data and returns entries as ASN.1 DER encoded entities.</p>
    <p>Example <c>{ok, PemBin} = file:read_file("cert.pem").
    PemEntries = public_key:pem_decode(PemBin).    
    </c></p>
  </desc> 
  </func> 
    
  <func>
    <name name="pem_encode" arity="1" since="OTP R14B"/>
    <fsummary>Creates a PEM binary.</fsummary>
    <desc> 
      <p>Creates a PEM binary.</p> 
    </desc> 
  </func>

  <func>
    <name name="pem_entry_decode" arity="1" since="OTP R14B"/>
    <name name="pem_entry_decode" arity="2" since="OTP R14B"/>
    <fsummary>Decodes a PEM entry.</fsummary>
  <desc> 
    <p>Decodes a PEM entry. <c>pem_decode/1</c> returns a list of PEM
    entries. Notice that if the PEM entry is of type
    'SubjectPublickeyInfo', it is further decoded to an
    <c>rsa_public_key()</c> or <c>dsa_public_key()</c>.</p>
    <p>Password can be either an octet string or function which returns same type.</p>
  </desc> 
  </func>

  <func>
    <name name="pem_entry_encode" arity="2" since="OTP R14B"/>
    <name name="pem_entry_encode" arity="3" since="OTP R14B"/>
    <fsummary>Creates a PEM entry that can be fed to <c>pem_encode/1</c>.</fsummary>
    <desc> 
      <p>Creates a PEM entry that can be feed to <c>pem_encode/1</c>.</p>
      <p>If <c>Asn1Type</c> is <c>'SubjectPublicKeyInfo'</c>,
      <c>Entity</c> must be either an <c>rsa_public_key()</c>, 
      <c>dsa_public_key()</c> or an <c>ec_public_key()</c>
      and this function creates the appropriate
      <c>'SubjectPublicKeyInfo'</c> entry.
      </p>
    </desc> 
  </func>

  <func>
    <name name="pkix_decode_cert" arity="2" since=""/>
    <fsummary>Decodes an ASN.1 DER-encoded PKIX x509 certificate.</fsummary>
    <desc> 
      <p>Decodes an ASN.1 DER-encoded PKIX certificate. Option <c>otp</c>
      uses the customized ASN.1 specification OTP-PKIX.asn1 for
      decoding and also recursively decode most of the standard
      parts.</p>
    </desc> 
  </func>

  <func>
    <name name="pkix_encode" arity="3" since="OTP R14B"/>
    <fsummary>DER encodes a PKIX x509 certificate or part of such a
    certificate.</fsummary>
  <desc> 
    <p>DER encodes a PKIX x509 certificate or part of such a
    certificate. This function must be used for encoding certificates or parts of certificates
    that are decoded/created in the <c>otp</c> format, whereas for the plain format this
    function directly calls <c>der_encode/2</c>.</p> 

    <note><p>Subtle ASN-1 encoding errors in certificates may be worked around when decoding, this may have the affect that
    the encoding a certificate back to DER may generate different bytes then the supplied original.</p></note>

  </desc>
  </func>

 <func>
   <name name="pkix_is_issuer" arity="2" since="OTP R14B"/>
   <fsummary>Checks if <c>IssuerCert</c> issued <c>Cert</c>.</fsummary>
   <desc> 
     <p>Checks if <c>IssuerCert</c> issued <c>Cert</c>.</p> 
   </desc> 
 </func>
  
 <func>
   <name name="pkix_is_fixed_dh_cert" arity="1" since="OTP R14B"/>
   <fsummary>Checks if a certificate is a fixed Diffie-Hellman certificate.</fsummary>
   <desc> 
     <p>Checks if a certificate is a fixed Diffie-Hellman certificate.</p> 
   </desc> 
 </func>  
  
 <func>
   <name name="pkix_is_self_signed" arity="1" since="OTP R14B"/>
   <fsummary>Checks if a certificate is self-signed.</fsummary>
   <desc> 
     <p>Checks if a certificate is self-signed.</p> 
   </desc> 
 </func>

 <func>
   <name name="pkix_issuer_id" arity="2" since="OTP R14B"/>
   <fsummary>Returns the x509 certificate issuer id.</fsummary>
   <desc> 
     <p>Returns the x509 certificate issuer id, if it can be determined.</p>
   </desc> 
 </func>
 
 <func>
   <name name="pkix_normalize_name" arity="1" since="OTP R14B"/>
   <fsummary>Normalizes an issuer name so that it can be easily
   compared to another issuer name.</fsummary>
   <desc> 
     <p>Normalizes an issuer name so that it can be easily
     compared to another issuer name.</p> 
   </desc> 
 </func>

  <func>
    <name since="OTP R16B" name="pkix_path_validation" arity="3"/>
    <fsummary>Performs a basic path validation according to RFC 5280.</fsummary>
     <desc>
       <p>
	 Performs a basic path validation according to
	 <url href="http://www.ietf.org/rfc/rfc5280.txt">RFC 5280.</url>
	 However, CRL validation is done separately by <seemfa
	 marker="#pkix_crls_validate/3">pkix_crls_validate/3 </seemfa> and is to be called
	 from the supplied <c>verify_fun</c>. The optional policy tree check is currently not implemented
	 but an empty place holder list is returned instead.
       </p>

       <p>Available options:</p>

       <taglist>
	<tag>{verify_fun, {fun(), InitialUserState::term()}</tag>
	<item>
	  <p>The fun must be defined as:</p>

	  <code>
fun(OtpCert :: #'OTPCertificate'{},
    Event :: {bad_cert, Reason :: atom() | {revoked, atom()}} |
             {extension, #'Extension'{}},
    InitialUserState :: term()) ->
	{valid, UserState :: term()} |
	{valid_peer, UserState :: term()} |
	{fail, Reason :: term()} |
	{unknown, UserState :: term()}.
	  </code>

	<p>If the verify callback fun returns <c>{fail, Reason}</c>, the
	verification process is immediately stopped. If the verify
	callback fun returns <c>{valid, UserState}</c>, the verification
	process is continued. This can be used to accept specific path
	validation errors, such as <c>selfsigned_peer</c>, as well as
	verifying application-specific extensions. If called with an
	extension unknown to the user application, the return value
	<c>{unknown, UserState}</c> is to be used.</p>
  <warning><p>
  Note that user defined custom <c>verify_fun</c> may alter original
  path validation error (e.g <c>selfsigned_peer</c>). Use with caution.
  </p></warning>

	</item>
	<tag>{max_path_length, integer()}</tag>
	<item>
	  The <c>max_path_length</c> is the maximum number of non-self-issued
	  intermediate certificates that can follow the peer certificate
	  in a valid certification path. So, if <c>max_path_length</c> is 0, the PEER must
	  be signed by the trusted ROOT-CA directly, if it is 1, the path can
	  be PEER, CA, ROOT-CA, if it is 2, the path can
	  be PEER, CA, CA, ROOT-CA, and so on.
	</item>
      </taglist>

      <p>Explanations of reasons for a bad certificate: </p>
      <taglist>
	<tag>cert_expired</tag>
	<item><p>Certificate is no longer valid as its expiration date has passed.</p></item>

	<tag>invalid_issuer</tag>
	<item><p>Certificate issuer name does not match the name of the issuer certificate in the chain.</p></item>

	<tag>invalid_signature</tag>
	<item><p>Certificate was not signed by its issuer certificate in the chain.</p></item>

	<tag>name_not_permitted</tag>
	<item><p>Invalid Subject Alternative Name extension.</p></item>

	<tag>missing_basic_constraint</tag>
	<item><p>Certificate, required to have the basic constraints extension, does not have
	a basic constraints extension.</p></item>

	<tag>invalid_key_usage</tag>
	<item><p>Certificate key is used in an invalid way according to the key-usage extension.</p></item>

	<tag>{revoked, crl_reason()}</tag>
	<item><p>Certificate has been revoked.</p></item>

	<tag>atom()</tag>
	<item><p>Application-specific error reason that is to be checked by the <c>verify_fun</c>.</p></item>
      </taglist>

    </desc>
   </func>

    <func>  
      <name name="pkix_crl_issuer" arity="1" since="OTP 17.5"/>
      <fsummary>Returns the issuer of the <c>CRL</c>.</fsummary>
      <desc> 
	<p>Returns the issuer of the <c>CRL</c>.</p>
      </desc> 
    </func> 
   
   <func>
     <name name="pkix_crls_validate" arity="3" since="OTP R16B"/>
     <fsummary>Performs CRL validation.</fsummary>
     <desc>
      <p>Performs CRL validation. It is intended to be called from
      the verify fun of  <seemfa marker="#pkix_path_validation/3"> pkix_path_validation/3
       </seemfa>.</p>

       <p>Available options:</p>

      <taglist>
	
	<tag>{update_crl, fun()}</tag>
	<item>
	  <p>The fun has the following type specification:</p>

	  <code> fun(#'DistributionPoint'{}, #'CertificateList'{}) ->
        #'CertificateList'{}</code>

	  <p>The fun uses the information in the distribution point to access
	  the latest possible version of the CRL. If this fun is not specified,
	  Public Key uses the default implementation:
	  </p>
	  <code> fun(_DP, CRL) -> CRL end</code>
	</item>

	<tag>{issuer_fun, fun()}</tag>
	<item>
	  <p>The fun has the following type specification:</p>
	  
	  <code>
fun(#'DistributionPoint'{}, #'CertificateList'{},
    {rdnSequence,[#'AttributeTypeAndValue'{}]}, term()) ->
	{ok, #'OTPCertificate'{}, [der_encoded]}</code>

	  <p>The fun returns the root certificate and certificate chain
	  that has signed the CRL. 
	  </p>
	  <code> fun(DP, CRL, Issuer, UserState) -> {ok, RootCert, CertChain}</code>
	</item>

	<tag>{undetermined_details, boolean()}</tag>
	<item>
	  <p>Defaults to false. When revocation status cannot be
	  determined, and this option is set to true, details of why no
	  CRLs where accepted are included in the return value.</p>
	</item>

      </taglist>
    </desc>
   </func>
   
   <func>  
     <name name="pkix_crl_verify" arity="2" since="OTP 17.5"/>
     <fsummary> Verify that  <c>Cert</c>  is the <c> CRL</c>  signer. </fsummary>
     <desc> 
       <p>Verify that <c>Cert</c> is the <c>CRL</c> signer.</p>
     </desc> 
   </func>

   <func>  
     <name name="pkix_dist_point" arity="1" since="OTP 17.5"/>
     <fsummary>Creates a distribution point for CRLs issued by the same issuer as <c>Cert</c>.</fsummary>
     <desc> 
       <p>Creates a distribution point for CRLs issued by the same issuer as <c>Cert</c>.
       Can be used as input to <seemfa
       marker="#pkix_crls_validate/3">pkix_crls_validate/3 </seemfa>
       </p>
     </desc> 
   </func>
   
   <func>  
     <name name="pkix_dist_points" arity="1" since="OTP 17.5"/>
     <fsummary> Extracts distribution points from the certificates extensions.</fsummary>
     <desc> 
       <p> Extracts distribution points from the certificates extensions.</p>
     </desc> 
 </func>

 <func>
    <name name="pkix_hash_type" arity="1" since="OTP 23.0"/>
    <fsummary>Translates OID to Erlang digest type</fsummary>
    <desc> 
      <p>Translates OID to Erlang digest type</p> 
    </desc> 
  </func> 

  <func>
    <name name="pkix_match_dist_point" arity="2" since="OTP 19.0"/>
    <fsummary>Checks whether the given distribution point matches the
    Issuing Distribution Point of the CRL.</fsummary>
    <desc>
      <p>Checks whether the given distribution point matches the
      Issuing Distribution Point of the CRL, as described in RFC 5280.
      If the CRL doesn't have an Issuing Distribution Point extension,
      the distribution point always matches.</p>
    </desc>
  </func>

  <func>
    <name name="pkix_sign" arity="2" since="OTP R14B"/>
    <fsummary>Signs certificate.</fsummary>
    <desc> 
      <p>Signs an 'OTPTBSCertificate'. Returns the corresponding
      DER-encoded certificate.</p> 
    </desc> 
  </func> 

  <func>
    <name name="pkix_sign_types" arity="1" since="OTP R16B01"/>
    <fsummary>Translates signature algorithm OID to Erlang digest and signature algorithm types.</fsummary>
    <desc>
      <p>Translates signature algorithm OID to Erlang digest and signature types.
      </p>
      <p>The <c>AlgorithmId</c> is the signature OID from a certificate or a certificate revocation list.</p>
    </desc>
  </func>

  <func>
    <name  name="pkix_test_data" arity="1" since="OTP 20.1"></name>
    <fsummary>Creates certificate test data.</fsummary>

    <desc>
      <p>
	Creates certificate configuration(s) consisting of certificate
	and its private key plus CA certificate bundle, for a client
	and a server, intended to facilitate automated testing
	of applications using X509-certificates,
	often through SSL/TLS. The test data can be used
	when you have control over both the client and the server
	in a test scenario.
      </p>
      <p>
	When this function is called with a map containing
	client and server chain specifications;
	it generates both a client and a server certificate chain
	where the <c>cacerts</c>
	returned for the server contains the root cert the server
	should trust and the intermediate certificates the server
	should present to connecting clients.
	The root cert the server should trust is the one used
	as root of the client certificate chain.
	Vice versa applies to the <c>cacerts</c> returned for the client.
	The root cert(s) can either be pre-generated with
	<seemfa marker="#pkix_test_root_cert/2">
	  pkix_test_root_cert/2
	</seemfa>, or if options are specified; it is (they are)
	 generated.
      </p>
      <p>
	When this function is called with a list of certificate options;
	it generates a configuration with just one node certificate
	where <c>cacerts</c> contains the root cert
	and the intermediate certs that should be presented to a peer.
	In this case the same root cert must be used for all peers.
	This is useful in for example an Erlang distributed cluster
	where any node,	towards another node, acts either
	as a server or as a client depending on who connects to whom.
	The generated certificate contains a subject altname,
	which is not needed in a client certificate,
	but makes the certificate useful for both roles.
      </p>
      <p>
	Explanation of the options used to customize certificates
	in the generated chains:
      </p>
      <taglist>
	<tag> {digest, digest_type()}</tag>
	<item><p>Hash algorithm to be used for
	signing the certificate together with the key option. Defaults to sha that is sha1.
	</p></item>
	<tag> {key, key_params() | private_key()}</tag>
	<item><p>Parameters to be used to call public_key:generate_key/1, to generate a key, or an existing
	key. Defaults to generating an ECDSA key. Note this could fail if Erlang/OTP is compiled with a very old
	cryptolib.</p></item>
	<tag> {validity, {From::erlang:timestamp(), To::erlang:timestamp()}} </tag>
	<item><p>The validity period of the certificate.</p></item>
	<tag> {extensions, [#'Extension'{}]}</tag>
	<item><p> Extensions to include in the certificate.</p>
	      
	  <p>Default extensions included in CA certificates if not
	  otherwise specified are: </p>
	  <code>[#'Extension'{extnID = ?'id-ce-keyUsage',
              extnValue = [keyCertSign, cRLSign],
              critical = false},
#'Extension'{extnID = ?'id-ce-basicConstraints',
             extnValue = #'BasicConstraints'{cA = true},
             critical = true}]
	  </code>

	  <p>Default extensions included in the server peer cert if not
	  otherwise specified are: </p>
	  <code>[#'Extension'{extnID = ?'id-ce-keyUsage',
              extnValue = [digitalSignature, keyAgreement],
              critical = false},
#'Extension'{extnID = ?'id-ce-subjectAltName',
             extnValue = [{dNSName, Hostname}],
             critical = false}]
	  </code>
	  <p>Hostname is the result of calling net_adm:localhost() in the Erlang node
	  where this function is called.
	  </p></item>

	</taglist>
	  
	<note><p>
	Note that the generated certificates and keys does not provide a formally correct PKIX-trust-chain 
	and they cannot be used to achieve real security. This function is provided for testing purposes only.
</p></note>
    </desc>
  </func>
  
  <func>
    <name name="pkix_test_root_cert" arity="2" since="OTP 20.2"/>
    <fsummary>Generates a test data root cert.</fsummary>
    <desc>
      <p>
	Generates a root certificate that can be used
	in multiple calls to
	<seemfa marker="#pkix_test_data/1">pkix_test_data/1</seemfa>
	when you want the same root certificate for
	several generated certificates.
      </p>
    </desc>
  </func>

  <func>
    <name name="pkix_subject_id" arity="1" since="OTP 23.1"/>
    <fsummary>Returns the X509 certificate subject id.</fsummary>
    <desc> 
      <p>Returns the X509 certificate subject id.</p> 
    </desc> 
  </func>
  
  <func>  
    <name name="pkix_verify" arity="2" since="OTP R14B"/>
    <fsummary>Verifies PKIX x.509 certificate signature.</fsummary>
  <desc> 
    <p>Verifies PKIX x.509 certificate signature.</p>
  </desc> 
  </func> 

  <func>
    <name name="pkix_verify_hostname" arity="2"  since="OTP 19.3"/>
    <name name="pkix_verify_hostname" arity="3"  since="OTP 19.3"/>
    <fsummary>Verifies that a PKIX x.509 certificate <i>presented identifier</i> (e.g hostname) is
    an expected one.</fsummary>

    <desc>
      <p>This function checks that the <i>Presented Identifier</i> (e.g hostname) in a peer certificate
      is in agreement with at least one of the <i>Reference Identifier</i> that the client expects to be connected to.
      The function is intended to be added as an extra client check of the peer certificate when performing
      <seemfa marker="public_key:public_key#pkix_path_validation/3">public_key:pkix_path_validation/3</seemfa>
      </p>
      <p>See <url href="https://tools.ietf.org/html/rfc6125">RFC 6125</url>
      for detailed information about hostname verification.
      The <seeguide marker="using_public_key#verify_hostname">User's Guide</seeguide>
      and
      <seeguide marker="using_public_key#verify_hostname_examples">code examples</seeguide>
      describes this function more detailed.
      </p>

      <p>The option funs are described here:</p>
      <taglist>
	<tag><c>match_fun</c></tag>
	<item>
	  <code>
fun(ReferenceId::ReferenceId() | FQDN::string(),
    PresentedId::{dNSName,string()} | {uniformResourceIdentifier,string() |
                 {iPAddress,list(byte())} | {OtherId::atom()|oid(),term()}})</code>
          This function replaces the default host name matching rules. The fun should return a
	  boolean to tell if the Reference ID and Presented ID matches or not.

	   The match fun can also return a third value,
	   value, the atom <c>default</c>, if the default matching rules shall apply.
	   This makes it possible to augment the tests with a special case:
	  <code>
fun(....) -> true;   % My special case
   (_, _) -> default % all others falls back to the inherit tests
end
	  </code>
	  <br/>See <seemfa marker="#pkix_verify_hostname_match_fun/1">pkix_verify_hostname_match_fun/1</seemfa> for a
	  function that takes a protocol name as argument and returns a <c>fun/2</c> suitable for this option and
	  <seeguide marker="using_public_key#redefining_match_op">Re-defining the match operation</seeguide>
	  in the User's Guide for an example.

	  <note><p> Reference Id values given as binaries will be converted to strings, and ip
           references may be given in string format that is "10.0.1.1" or "1234::5678:9012" as
           well as on the format <seetype marker="kernel:inet#ip_address">inet:ip_address()</seetype></p></note>

	</item>

	<tag><c>fail_callback</c></tag>
	<item>If a matching fails, there could be circumstances when the certificate should be accepted anyway. Think for
	example of a web browser where you choose to accept an outdated certificate. This option enables implementation
	of such an exception but for hostnames. This <c>fun/1</c> is called when no <c>ReferenceID</c> matches. The return value of the fun
	(a <c>boolean()</c>) decides the outcome. If <c>true</c> the the certificate is accepted otherwise
	it is rejected. See
	<seeguide marker="using_public_key#-pinning--a-certificate">"Pinning" a Certificate</seeguide>
	in the User's Guide.
	</item>

	<tag><c>fqdn_fun</c></tag>
	<item>This option augments the host name extraction from URIs and other Reference IDs. It could for example be
	a very special URI that is not standardised. The fun takes a Reference ID as argument and returns one of:
	<list>
	  <item>the hostname</item>
	  <item>the atom <c>default</c>: the default host name extract function will be used</item>
	  <item>the atom <c>undefined</c>: a host name could not be extracted. The pkix_verify_hostname/3
	  will return <c>false</c>.</item>
	</list>
	<br/>For an example, see
	<seeguide marker="using_public_key#hostname_extraction">Hostname extraction</seeguide>
	in the User's Guide.
	</item>
      </taglist>

    </desc>
  </func>

  <func>
    <name name="pkix_verify_hostname_match_fun" arity="1"  since="OTP 21.0"/>
    <fsummary>Returns a fun that is intended as argument to the match_fun option in pkix_verify_hostname/3.
    </fsummary>
    <desc>
	<p>The return value of calling this function is intended to be used in the <c>match_fun</c> option in
	<seemfa marker="#pkix_verify_hostname/3">pkix_verify_hostname/3</seemfa>.</p>

	<p>The returned fun augments the verify hostname matching according to the specific rules for
	the protocol in the argument.</p>

	<note><p>Currently supported https fun will allow wildcard certificate matching
	as specified by the HTTP standard. Note that for instance LDAP have a different set of wildcard matching
	rules. If you do not want to allow wildcard certificates (recommended from a security perspective)
	or otherwise customize the hostname match the default match function used by ssl application will be sufficient.
	</p></note>
   </desc>
  </func>

  <func>
    <name name="sign" arity="3" since=""/>
    <name name="sign" arity="4" since="OTP 20.1"/>
    <fsummary>Creates a digital signature.</fsummary>
  <desc>
    <p>Creates a digital signature.</p> 
    <p>The <c>Msg</c> is either the binary "plain text" data to be
    signed or it is the hashed value of "plain text", that is, the
    digest.</p>
  </desc> 
  </func>   

  <func>
    <name name="verify" arity="4" since="OTP R14B"/>
    <name name="verify" arity="5" since="OTP 20.1"/>
    <fsummary>Verifies a digital signature.</fsummary>
  <desc>
    <p>Verifies a digital signature.</p>
    <p>The <c>Msg</c> is either the binary "plain text" data 
    or it is the hashed value of "plain text", that is, the digest.</p>
  </desc> 
  </func>

  <func>
    <name name="short_name_hash" arity="1" since="OTP 19.0"/>
    <fsummary>Generates a short hash of an issuer name.</fsummary>
    <desc>
      <p>Generates a short hash of an issuer name.  The hash is
      returned as a string containing eight hexadecimal digits.</p>

      <p>The return value of this function is the same as the result
      of the commands <c>openssl crl -hash</c> and
      <c>openssl x509 -issuer_hash</c>, when passed the issuer name of
      a CRL or a certificate, respectively.  This hash is used by the
      <c>c_rehash</c> tool to maintain a directory of symlinks to CRL
      files, in order to facilitate looking up a CRL by its issuer
      name.</p>
    </desc>
  </func>

</funcs>

</erlref>
