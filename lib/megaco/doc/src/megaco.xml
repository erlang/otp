<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>2000</year><year>2024</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>

    <title>megaco</title>
    <prepared>H&aring;kan Mattsson</prepared>
    <responsible>H&aring;kan Mattsson</responsible>
    <docno></docno>
    <approved>H&aring;kan Mattsson</approved>
    <checked></checked>
    <date>2007-06-15</date>
    <rev>%VSN%</rev>
    <file>megaco.xml</file>
  </header>
  <module since="">megaco</module>
  <modulesummary>Main API of the Megaco application</modulesummary>
  <description>
    <p>Interface module for the Megaco application</p>
  </description>

  <datatypes>
    <datatype>
      <name name="void"/>
      <desc>
	<p>
	  The type is used when a functions return is to be ignored.
	</p>
      </desc>
    </datatype>

    <datatype>
      <name name="mid"/>
      <desc>
	<p>
	  The Megaco Identifier.
	</p>
      </desc>
    </datatype>

    <datatype>
      <name name="megaco_message"/>
      <!--
      <desc>
	<p>
	  TBD.
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="action_request"/>
      <!--
      <desc>
	<p>
	  TBD.
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="action_reply"/>
      <!--
      <desc>
	<p>
	  TBD.
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="error_desc"/>
      <!--
      <desc>
	<p>
	  TBD.
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="transaction_reply"/>
      <!--
      <desc>
	<p>
	  TBD.
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="protocol_version"/>
      <!--
      <desc>
	<p>
	  TBD.
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="segment_no"/>
      <!--
      <desc>
	<p>
	  TBD.
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="receive_handle"/>
      <!--
      <desc>
	<p>
	  TBD.
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="conn_handle"/>
      <!--
      <desc>
	<p>
	  TBD.
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="megaco_timer"/>
      <!--
      <desc>
	<p>
	  TBD.
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="action_reqs"/>
      <!--
      <desc>
	<p>
	  TBD.
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="action_reps"/>
      <!--
      <desc>
	<p>
	  TBD.
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="transaction_id"/>
      <!--
      <desc>
	<p>
	  TBD.
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="conn_info_item"/>
      <desc>
	<p>
	  This type is a basic (atom) lookup key
	  (for info on an active connection).
	  The corresponding value can be of any type.

	  <marker id="ci_control_pid"></marker>
	</p>
        <taglist>
          <tag><c><![CDATA[control_pid]]></c></tag>
          <item>
            <p>The process identifier of the controlling process for a
              connection.</p>

	    <p>Value type:
	    <seetype marker="erlang#pid">pid()</seetype></p>

	    <marker id="ci_send_handle"></marker>
          </item>

          <tag><c><![CDATA[send_handle]]></c></tag>
          <item>
            <p>Opaque send handle whose contents is internal for the
              send module. </p>

	    <p>Value type:
	    <seetype marker="#send_handle">send_handle()</seetype></p>

	    <marker id="ci_local_mid"></marker>
          </item>

          <tag><c><![CDATA[local_mid]]></c></tag>
          <item>
            <p>The local mid (of the connection, i.e. the own mid). </p>

	    <p>Value type:
	    <seetype marker="#mid">mid()</seetype></p>

	    <marker id="ci_remote_mid"></marker>
          </item>

          <tag><c><![CDATA[remote_mid]]></c></tag>
          <item>
            <p>The remote mid (of the connection). </p>

	    <p>Value type:
	    <seetype marker="#mid">mid()</seetype></p>

	    <marker id="ci_receive_handle"></marker>
          </item>

          <tag><c><![CDATA[receive_handle]]></c></tag>
          <item>
            <p>Construct a megaco_receive_handle record.</p>

	    <p>Value type:
	    <seetype marker="#receive_handle">receive_handle()</seetype></p>

	    <marker id="ci_trans_id"></marker>
          </item>

          <tag><c><![CDATA[trans_id]]></c></tag>
          <item>
            <p>Next transaction id. </p>
            <p>Note that transaction id's are (currently) maintained 
	    on a per user basis so there is no way to be sure that 
	    the value returned will actually be used for a transaction 
	    sent on this connection (in case a user has several 
	    connections, which is not at all unlikely). </p>

	    <p>Value type: 
	    <seetype marker="#transaction_id">transaction_id()</seetype> |
	    <c><![CDATA[undefined_serial]]></c></p>

	    <marker id="ci_max_trans_id"></marker>
          </item>

          <tag><c><![CDATA[max_trans_id]]></c></tag>
          <item>
            <p>Last transaction id. </p>

	    <p>Value type: 
	    <seetype marker="#transaction_id">transaction_id()</seetype> |
	    <c><![CDATA[infinity]]></c> </p>

	    <marker id="ci_request_timer"></marker>
          </item>

          <tag><c><![CDATA[request_timer]]></c></tag>
          <item>
            <p>Wait for reply. </p>
            <p>The timer is cancelled when a reply is received. </p>
            <p>When a pending message is received, the timer is 
	    cancelled and the <c><![CDATA[long_request_timer]]></c>
	    is started instead 
	    (see below). No resends will be performed from this point 
	    (since we now know that the other side has received the 
	    request). </p>
            <p>When the timer reaches an intermediate expire, the request
	    is resent and the timer is restarted. </p>
            <p>When the timer reaches the final expire, either the function 
	    <c><![CDATA[megaco:call]]></c> will return with
	    <c><![CDATA[{error, timeout}]]></c>
	    or the callback function <c><![CDATA[handle_trans_reply]]></c>
	    will be 
	    called with <c><![CDATA[UserReply = {error, timeout}]]></c> (if 
	    <c><![CDATA[megaco:cast]]></c> was used).</p>

	    <p>Value type: 
	    <seetype marker="#megaco_timer">megaco_timer()</seetype></p>
	    <p>Defaults to <c><![CDATA[#megaco_incr_timer{}]]></c>.</p>

	    <marker id="ci_long_request_timer"></marker>
          </item>

          <tag><c><![CDATA[long_request_timer]]></c></tag>
          <item>
            <p>Wait for reply after having received a pending message. </p>
            <p>When the timer reaches an intermediate expire, the timer 
	    restarted. </p>
            <p>When a pending message is received, and the 
	    <c><![CDATA[long_request_timer]]></c> 
	    is <em>not</em> "on its final leg", the timer will be 
	    restarted, and, if <c><![CDATA[long_request_resend = true]]></c>,
	    the request will be re-sent. </p>

	    <p>Value type: 
	    <seetype marker="#megaco_timer">megaco_timer()</seetype></p>
            <p>Defaults to <c><![CDATA[60 seconds]]></c>.</p>

	    <marker id="ci_request_keep_alive_timeout"></marker>
          </item>

          <tag><c><![CDATA[request_keep_alive_timeout]]></c></tag>
          <item>
            <p>Specifies the timeout time for the request-keep-alive timer. </p>
	    <p>This timer is started when the <em>first</em> reply to an
	    asynchronous request (issued using the 
	    <seeerl marker="megaco#cast">megaco:cast/3</seeerl> function)
	    arrives. As long as this timer is running, replies will 
	    be delivered via the 
	    <seeerl marker="megaco_user#trans_reply">handle_trans_reply/4,5</seeerl> 
	    callback function, with their "arrival number" 
	    (see <c><![CDATA[UserReply]]></c> of the 
	    <seeerl marker="megaco_user#trans_reply">handle_trans_reply/4,5</seeerl> 
	    callback function). </p>
	    <p>Replies arriving after the timer has expired, will be 
	    delivered using the 
	    <seeerl marker="megaco_user#unexpected_trans">handle_unexpected_trans/3,4</seeerl> 
	    callback function. </p>

	    <p>Value type: 
	    <c><![CDATA[plain]]></c> |
	    <seetype marker="erlang#non_neg_integer">non_neg_integer()</seetype></p>
            <p>Defaults to <c><![CDATA[plain]]></c>.</p>

	    <marker id="ci_long_request_resend"></marker>
          </item>

          <tag><c><![CDATA[long_request_resend]]></c></tag>
          <item>
            <p>This option indicates weather the request should be 
	    resent until the reply is received,
	    <em>even</em> though a pending message has been received. </p>
            <p>Normally, after a pending message has been received, 
	    the request is not resent 
	    (since a pending message is an indication that the
	    request has been received). But since the reply (to the 
	    request) can be
	    lost, this behaviour has its values.</p>
	    <p>It is of course pointless to set this value to <em>true</em>
	    unless the <c><![CDATA[long_request_timer]]></c> (see above)
	    is also set to an incremental timer
	    (<c><![CDATA[#megaco_incr_timer{}]]></c>). </p>

	    <p>Value type: 
	    <seetype marker="erlang#boolean">boolean()</seetype></p>
            <p>Defaults to <c><![CDATA[false]]></c>.</p>

	    <marker id="ci_reply_timer"></marker>
          </item>

          <tag><c><![CDATA[reply_timer]]></c></tag>
          <item>
            <p>Wait for an ack. </p>
            <p>When a request is received, some info
	    related to the reply is store internally (e.g. the
	    binary of the reply). This info will live until either
	    an ack is received or this timer expires. For instance,
	    if the same request is received again (e.g. a request
	    with the same transaction id), the (stored) reply will
	    be (re-) sent automatically by megaco.</p>
            <p>If the timer is of type <c><![CDATA[#megaco_incr_timer{}]]></c>, 
	    then for each intermediate timout, the reply will be resent
	    (this is valid until the ack is received or 
	    the timer expires). </p>

	    <p>Value type: 
	    <seetype marker="#megaco_timer">megaco_timer()</seetype></p>
            <p>Defaults to <c><![CDATA[30000]]></c>.</p>

	    <marker id="ci_call_proxy_gc_timeout"></marker>
	  </item>

          <tag><c><![CDATA[call_proxy_gc_timeout]]></c></tag>
          <item>
            <p>Timeout time for the call proxy. </p>
            <p>When a request is sent using the 
	    <seeerl marker="megaco#call">call/3</seeerl> function, 
	    a proxy process is started to handle
	    all replies. When the reply has been received and delivered 
	    to the user, the proxy process continue to exist for as long
	    as this option specifies. Any received messages, is passed on 
	    to the user via the 
	    <seeerl marker="megaco_user#handle_unexpected_trans">handle_unexpected_trans</seeerl> 
	    callback function. </p>
	    <p>The timeout time is in milliseconds. A value of 0 (zero) means
	    that the proxy process will exit directly after the reply has 
	    been delivered. </p>

	    <p>Value type: 
	    <seetype marker="erlang#non_neg_integer">non_neg_integer()</seetype></p>
            <p>Defaults to <c><![CDATA[5000]]></c> (= 5 seconds).</p>

	    <!-- <marker id="ci_auto_ack"></marker> -->
          </item>

          <tag><c><![CDATA[auto_ack]]></c></tag>
          <item>
            <p>Automatic send transaction ack when the transaction
	    reply has been received
	    (see <c><![CDATA[trans_ack]]></c> below). </p>
            <p>This is used for <em>three-way-handshake</em>. </p>

	    <p>Value type: 
	    <seetype marker="erlang#boolean">boolean()</seetype></p>
            <p>Defaults to <c><![CDATA[false]]></c>.</p>

	    <marker id="ci_trans_ack"></marker>
          </item>

          <tag><c><![CDATA[trans_ack]]></c></tag>
          <item>
            <p>Shall ack's be accumulated or not. </p>
            <p>This property is only valid if <c><![CDATA[auto_ack]]></c>
	    is true. </p>
	    <p>If <c><![CDATA[auto_ack]]></c> is true, then if
	    <c><![CDATA[trans_ack]]></c> is
	    <c><![CDATA[false]]></c>, ack's will be sent immediately. 
	    If <c><![CDATA[trans_ack]]></c> is
	    <c><![CDATA[true]]></c>, then ack's will instead be sent to
	    the transaction sender process for accumulation and later sending 
	    (see <c><![CDATA[trans_ack_maxcount]]></c>,
	    <c><![CDATA[trans_req_maxcount]]></c>, 
	    <c><![CDATA[trans_req_maxsize]]></c>,
	    <c><![CDATA[trans_ack_maxcount]]></c> and 
	    <c><![CDATA[trans_timer]]></c>). </p>
	    <p>See also <seeguide marker="megaco_run#transaction_sender">transaction sender</seeguide> for more info. </p>

	    <p>Value type: 
	    <seetype marker="erlang#boolean">boolean()</seetype></p>
            <p>Defaults to <c><![CDATA[false]]></c>.</p>

	    <marker id="ci_trans_ack_maxcount"></marker>
          </item>

          <tag><c><![CDATA[trans_ack_maxcount]]></c></tag>
          <item>
            <p>Maximum number of accumulated ack's. At most this many ack's
	    will be accumulated by the transaction sender (if started and 
	    configured to accumulate ack's).</p>
	    <p>See also
	    <seeguide marker="megaco_run#transaction_sender">transaction sender</seeguide>
	    for more info.</p>

	    <p>Value type: 
	    <seetype marker="erlang#non_neg_integer">non_neg_integer()</seetype></p>
            <p>Defaults to <c><![CDATA[10]]></c>.</p>

	    <marker id="ci_trans_req"></marker>
          </item>

          <tag><c><![CDATA[trans_req]]></c></tag>
          <item>
            <p>Shall requests be accumulated or not. </p>
            <p>If <c><![CDATA[trans_req]]></c> is <c><![CDATA[false]]></c>,
	    then request(s) will be sent immediately (in its own message). </p>
            <p>If <c><![CDATA[trans_req]]></c> is true, then request(s) will 
	    instead be sent to the transaction sender process for 
	    accumulation and later sending 
	    (see <c><![CDATA[trans_ack_maxcount]]></c>,
	    <c><![CDATA[trans_req_maxcount]]></c>, 
	    <c><![CDATA[trans_req_maxsize]]></c>,
	    <c><![CDATA[trans_ack_maxcount]]></c> and 
	    <c><![CDATA[trans_timer]]></c>). </p>
            <p>See also
	    <seeguide marker="megaco_run#transaction_sender">transaction sender</seeguide>
	    for more info. </p>

	    <p>Value type: 
	    <seetype marker="erlang#boolean">boolean()</seetype></p>
            <p>Defaults to <c><![CDATA[false]]></c>.</p>

	    <marker id="ci_trans_req_maxcount"></marker>
          </item>

          <tag><c><![CDATA[trans_req_maxcount]]></c></tag>
          <item>
            <p>Maximum number of accumulated requests. At most this many 
	    requests will be accumulated by the transaction sender 
	    (if started and configured to accumulate requests). </p>
	    <p>See also
	    <seeguide marker="megaco_run#transaction_sender">transaction sender</seeguide>
	    for more info. </p>

	    <p>Value type: 
	    <seetype marker="erlang#non_neg_integer">non_neg_integer()</seetype></p>
            <p>Defaults to <c><![CDATA[10]]></c>.</p>

	    <marker id="ci_trans_req_maxsize"></marker>
          </item>

          <tag><c><![CDATA[trans_req_maxsize]]></c></tag>
          <item>
            <p>Maximum size of the accumulated requests. At most this much
	    requests will be accumulated by the transaction sender 
	    (if started and configured to accumulate requests). </p>
            <p>See also
	    <seeguide marker="megaco_run#transaction_sender">transaction sender</seeguide>
	    for more info. </p>

	    <p>Value type: 
	    <seetype marker="erlang#non_neg_integer">non_neg_integer()</seetype></p>
            <p>Defaults to <c><![CDATA[2048]]></c>.</p>

	    <marker id="ci_trans_timer"></marker>
          </item>

          <tag><c><![CDATA[trans_timer]]></c></tag>
          <item>
            <p>Transaction sender timeout time. Has two functions. First, if 
	    the value is 0, then transactions will not be accumulated 
	    (e.g. the transaction sender process will not be started). 
	    Second, if the value is greater then 0 and <c><![CDATA[auto_ack]]></c> 
	    and <c><![CDATA[trans_ack]]></c> is true or if
	    <c><![CDATA[trans_req]]></c> is true, 
	    then transaction sender will be started and transactions 
	    (which is depending on the values of <c><![CDATA[auto_ack]]></c>, 
	    <c><![CDATA[trans_ack]]></c> and
	    <c><![CDATA[trans_req]]></c>) will be accumulated,
	    for later sending. </p>
            <p>See also
	    <seeguide marker="megaco_run#transaction_sender">transaction sender</seeguide>
	    for more info. </p>

	    <p>Value type: 
	    <seetype marker="erlang#non_neg_integer">non_neg_integer()</seetype></p>
            <p>Defaults to <c><![CDATA[0]]></c>.</p>

	    <marker id="ci_pending_timer"></marker>
          </item>

          <tag><c><![CDATA[pending_timer]]></c></tag>
          <item>
            <p>Automatic send transaction pending if the timer expires
	    before a transaction reply has been sent. This timer is
	    also called provisional response timer. </p>

	    <p>Value type: 
	    <seetype marker="#megaco_timer">megaco_timer()</seetype></p>
            <p>Defaults to <c><![CDATA[30000]]></c> (= 30 seconds).</p>

	    <marker id="ci_sent_pending_limit"></marker>
          </item>

          <tag><c><![CDATA[sent_pending_limit]]></c></tag>
          <item>
            <p>Sent pending limit (see the MGOriginatedPendingLimit
	    and the MGCOriginatedPendingLimit of the megaco root package).
	    This parameter specifies how many pending messages that can
	    be sent (for a given received transaction request).
	    When the limit is exceeded, the transaction is aborted
	    (see
	    <seeerl marker="megaco_user#request_abort">handle_trans_request_abort</seeerl>)
	    and an error message is sent to the other side. </p>
	    <p>Note that this has no effect on the actual sending of
	    pending transactions. This is either implicit (e.g. when 
	    receiving a re-sent transaction request for a request which
	    is being processed) or controlled by the pending_timer,
	    see above. </p>

	    <p>Value type: 
	    <seetype marker="erlang#pos_integer">pos_integer()</seetype> |
	    <c><![CDATA[infinity]]></c> </p>
	    <p>Defaults to <c><![CDATA[infinity]]></c>.</p>

	    <marker id="ci_recv_pending_limit"></marker>
          </item>

          <tag><c><![CDATA[recv_pending_limit]]></c></tag>
          <item>
            <p>Receive pending limit (see the MGOriginatedPendingLimit
	    and the MGCOriginatedPendingLimit of the megaco root package).
	    This parameter specifies how many pending messages that can
	    be received (for a sent transaction request).
	    When the limit is exceeded, the transaction is considered
	    lost, and an error returned to the user (through the call-back
	    function <em>handle_trans_reply</em>). </p>

	    <p>Value type: 
	    <seetype marker="erlang#pos_integer">pos_integer()</seetype> |
	    <c><![CDATA[infinity]]></c> </p>
	    <p>Defaults to <c><![CDATA[infinity]]></c>.</p>

	    <marker id="ci_send_mod"></marker>
          </item>

          <tag><c><![CDATA[send_mod]]></c></tag>
          <item>
            <p>Send callback module which exports send_message/2. The
	    function SendMod:send_message(SendHandle, Binary) is
	    invoked when the bytes needs to be transmitted to
	    the remote user. </p>

	    <p>Value type: 
	    <seetype marker="erlang#module">module()</seetype>. </p>
	    <p>Defaults to <c><![CDATA[megaco_tcp]]></c>.</p>

	    <marker id="ci_encoding_mod"></marker>
          </item>

          <tag><c><![CDATA[encoding_mod]]></c></tag>
          <item>
            <p>Encoding callback module which exports encode_message/2
	    and decode_message/2. The function
	    EncodingMod:encode_message(EncodingConfig, MegacoMessage)
	    is invoked whenever a 'MegacoMessage' record needs to be
	    translated into an Erlang binary. The function
	    EncodingMod:decode_message(EncodingConfig, Binary) is
	    invoked whenever an Erlang binary needs to be translated
	    into a 'MegacoMessage' record. </p>

	    <p>Value type: 
	    <seetype marker="erlang#module">module()</seetype>. </p>
	    <p>Defaults to <c><![CDATA[megaco_pretty_text_encoder]]></c>.</p>

	    <marker id="ci_encoding_config"></marker>
          </item>

          <tag><c><![CDATA[encoding_config]]></c></tag>
          <item>
            <p>Encoding module config. </p>

	    <p>Value type: 
	    <seetype marker="erlang#list">loist()</seetype>. </p>
	    <p>Defaults to <c><![CDATA[[]]]></c>.</p>

	    <marker id="ci_protocol_version"></marker>
          </item>

          <tag><c><![CDATA[protocol_version]]></c></tag>
          <item>
            <p>Actual protocol version. </p>

	    <p>Value type: 
	    <seetype marker="#protocol_version">protocol_version()</seetype></p>
	    <p>Defaults to <c><![CDATA[1]]></c>.</p>

	    <marker id="ci_strict_version"></marker>
          </item>

	  <tag><c><![CDATA[strict_version]]></c></tag>
          <item>
            <p>Strict version control, i.e. when a message is received,
	    verify that the version is that which was negotiated. </p>

	    <p>Value type: 
	    <seetype marker="erlang#boolean">boolean()</seetype></p>
            <p>Defaults to <c><![CDATA[true]]></c>.</p>

	    <marker id="ci_reply_data"></marker>
          </item>

          <tag><c><![CDATA[reply_data]]></c></tag>
          <item>
            <p>Default reply data. </p>

	    <p>Value type: 
	    <seetype marker="erlang#term">term()</seetype></p>
            <p>Defaults to <c><![CDATA[undefined]]></c>.</p>

	    <marker id="ci_threaded"></marker>
          </item>

          <tag><c><![CDATA[threaded]]></c></tag>
          <item>
            <p>If a received message contains several transaction requests, 
	    this option indicates whether the requests should be handled
	    sequentially in the same process (<c><![CDATA[false]]></c>),
	    or if each request should be handled by its own process
	    (<c><![CDATA[true]]></c>
	    i.e. a separate process is spawned for each request). </p>

	    <p>Value type: 
	    <seetype marker="erlang#boolean">boolean()</seetype></p>
            <p>Defaults to <c><![CDATA[false]]></c>.</p>

	    <marker id="ci_resend_indication"></marker>
          </item>

	  <tag><c><![CDATA[resend_indication]]></c></tag>
          <item>
            <p>This option indicates weather the transport module
	    should be told if a message send is a resend or not. </p>
            <p>If <em>false</em>, megaco messages are sent using the
	    <seeerl marker="megaco_transport#send_message">send_message/2</seeerl> 
	    function. </p>
	    <p>If <em>true</em>, megaco message <em>re-sends</em> are made
	    using the
	    <seeerl marker="megaco_transport#resend_message">resend_message</seeerl> 
	    function. The initial message send is still done using the
	    <seeerl marker="megaco_transport#send_message">send_message</seeerl> 
	    function. </p>
	    <p>The special value <em>flag</em> instead indicates that the 
	    function 
	    <seeerl marker="megaco_transport#send_message">send_message/3</seeerl> 
	    shall be used. </p>

	    <p>Value type: 
	    <c><![CDATA[flag]]></c> |
	    <seetype marker="erlang#boolean">boolean()</seetype></p>
            <p>Defaults to <c><![CDATA[false]]></c>.</p>

	    <marker id="ci_segment_reply_ind"></marker>
          </item>

          <tag><c><![CDATA[segment_reply_ind]]></c></tag>
          <item>
            <p>This option specifies if the user shall be notified of received
	    segment replies or not. </p>
            <p>See 
	    <seeerl marker="megaco_user#segment_reply">handle_segment_reply</seeerl> 
	    callback function for more information. </p>

	    <p>Value type: 
	    <seetype marker="erlang#boolean">boolean()</seetype></p>
            <p>Defaults to <c><![CDATA[false]]></c>.</p>

	    <marker id="ci_segment_recv_timer"></marker>
          </item>

          <tag><c><![CDATA[segment_recv_timer]]></c></tag>
          <item>
            <p>This timer is started when the segment indicated by the
	    <c><![CDATA[segmentation complete token]]></c>
	    (e.g. the last of the segment
	    which makes up the reply) is received, but all 
	    segments has not yet been received.</p>
            <p>When the timer finally expires, a "megaco segments not
	    received" (459) error message is sent to the other side
	    and the user is notified with a 
	    <c><![CDATA[segment timeout]]></c>
	    <c><![CDATA[UserReply]]></c> in either the
	    <seeerl marker="megaco_user#trans_reply">handle_trans_reply</seeerl> 
	    callback function or the return value of the 
	    <seeerl marker="megaco#call">call</seeerl> function. </p>

	    <p>Value type: 
	    <seetype marker="#megaco_timer">megaco_timer()</seetype></p>
            <p>Defaults to <c><![CDATA[10000]]></c> (= 10 seconds).</p>

            <marker id="ci_segment_send"></marker>
          </item>

          <tag><c><![CDATA[segment_send]]></c></tag>
          <item>
            <p>Shall outgoing messages be segmented or not. </p>
	    <p>Value type: 
	    <c><![CDATA[none]]></c> |
	    <seetype marker="erlang#pos_integer">pos_integer()</seetype> |
	    <c><![CDATA[infinity]]></c></p>
            <taglist>
              <tag><c><![CDATA[none]]></c></tag>
              <item>
                <p>Do not segment outgoing reply messages. This is useful when
		either it is known that messages are never to large or
		that the transport protocol can handle such things
		on its own (e.g. TCP or SCTP).</p>
              </item>
              <tag><c><![CDATA[pos_integer()]]></c></tag>
              <item>
                <p>Outgoing reply messages will be segmented as needed 
		(see <c><![CDATA[max_pdu_size]]></c> below).
		This value, K, indicate the outstanding window,
		i.e. how many segments can be outstanding
		(not acknowledged) at any given time. </p>
              </item>
              <tag><c><![CDATA[infinity]]></c></tag>
              <item>
                <p>Outgoing reply messages will be segmented as needed 
		(see <c><![CDATA[max_pdu_size]]></c> below). Segment messages 
		are sent all at once (i.e. no acknowledgement awaited 
		before sending the next segment). </p>
              </item>
            </taglist>
            <p>Defaults to <c><![CDATA[none]]></c>. </p>

	    <marker id="ci_max_pdu_size"></marker>
          </item>

          <tag><c><![CDATA[max_pdu_size]]></c></tag>
          <item>
            <p>Max message size. If the encoded message (PDU) exceeds 
	    this size, the message should be segmented, and then 
	    encoded. </p>

	    <p>Value type: 
	    <c><![CDATA[infinity]]></c> |
	    <seetype marker="erlang#pos_integer">pos_integer()</seetype></p>
            <p>Defaults to <c><![CDATA[infinity]]></c>.</p>

          </item>

	</taglist>

      </desc>
    </datatype>

    <datatype>
      <name name="send_handle"/>
      <desc>
	<p>
	  Opaque send handle whose contents is internal for the send module.
	  May be any term.
	</p>
      </desc>
    </datatype>

    <datatype>
      <name name="digit_map_value"/>
      <!--
      <desc>
	<p>
	  TBD!
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="digit_map_value"/>
      <!--
      <desc>
	<p>
	  TBD
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="digit_map_kind"/>
      <!--
      <desc>
	<p>
	  TBD
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="digit_map_event"/>
      <!--
      <desc>
	<p>
	  TBD
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="digit_map_letter"/>
      <!--
      <desc>
	<p>
	  <c><![CDATA[$0..$9 | $a..$k | $A..$K]]></c>
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="property_parm"/>
      <!--
      <desc>
	<p>
	  TBD
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="property_group"/>
      <!--
      <desc>
	<p>
	  TBD
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="property_groups"/>
      <!--
      <desc>
	<p>
	  TBD
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="sdp"/>
      <!--
      <desc>
	<p>
	  TBD
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="sdp_property_parm"/>
      <!--
      <desc>
	<p>
	  TBD
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="sdp_property_group"/>
      <!--
      <desc>
	<p>
	  TBD
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="sdp_property_groups"/>
      <!--
      <desc>
	<p>
	  TBD
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="trace_level"/>
      <desc>
	<p>
	  How much trace events should be produced.
	  <c><![CDATA[min]]></c> (=<c><![CDATA[0]]></c>) means no trace
	  events are produced, which is the default.
	</p>
      </desc>
    </datatype>

    <datatype>
      <name name="trace_event"/>
      <desc>
	<p>
	  The trace event generated by dbg.
	</p>
      </desc>
    </datatype>

    <datatype>
      <name name="trace_data"/>
      <desc>
	<p>
	  The trace data passed to the trace handler fun (in the
	  second argument) and returned by same.
	  For instance this could be a file descriptor, that the
	  trace handler fun can use to print the event to a file.
	</p>
      </desc>
    </datatype>

    <datatype>
      <name name="trace_handler"/>
      <desc>
	<p>
	  The trace handler fun is used to "process" each trace event
	  (for instance print to file or to stdout after formating).
	</p>
      </desc>
    </datatype>

    <datatype>
      <name name="counter"/>
      <!--
      <desc>
	<p>
	  TBD
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="global_counter"/>
      <!--
      <desc>
	<p>
	  TBD
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="counter_value"/>
      <!--
      <desc>
	<p>
	  TBD
	</p>
      </desc>
      -->
    </datatype>

    <datatype>
      <name name="user_info_item"/>
      <!-- <marker id="ui_connections"></marker> -->
      <desc>
        <taglist>
          <tag><c><![CDATA[connections]]></c></tag>
          <item>
            <p>Lists all active connections for this user. Returns a
	    list of megaco_conn_handle records.</p>

	    <p>Value type:
	    [<seetype marker="#conn_handle">conn_handle()</seetype>]</p>

	    <marker id="ui_receive_handle"></marker>
          </item>


	  <tag><c><![CDATA[receive_handle]]></c></tag>
          <item>
            <p>Construct a receive_handle from user config.</p>

	    <p>Value type: 
	    <seetype marker="#receive_handle">receive_handle()</seetype></p>

	    <marker id="ui_trans_id"></marker>
          </item>


	  <tag><c><![CDATA[trans_id]]></c></tag>
          <item>
            <p>Current transaction id. </p>

	    <p>Value type: 
	    <seetype marker="#transaction_id">transaction_id()</seetype> |
	    <c><![CDATA[undefined_serial]]></c></p>

	    <marker id="ui_min_trans_id"></marker>
          </item>


	  <tag><c><![CDATA[min_trans_id]]></c></tag>
          <item>
            <p>First transaction id. </p>

	    <p>Value type: 
	    <seetype marker="#transaction_id">transaction_id()</seetype></p>
	    <p>Defaults to <c><![CDATA[1]]></c>.</p>

	    <marker id="ui_max_trans_id"></marker>
          </item>


	  <tag><c><![CDATA[max_trans_id]]></c></tag>
          <item>
            <p>Last transaction id. </p>

	    <p>Value type: 
	    <seetype marker="#transaction_id">transaction_id()</seetype> |
	    <c><![CDATA[infinity]]></c> </p>
	    <p>Defaults to <c><![CDATA[infinity]]></c>.</p>

	    <marker id="ui_trans_id"></marker>
          </item>


	  <tag><c><![CDATA[request_timer]]></c></tag>
          <item>
            <p>Wait for reply. </p>
            <p>The timer is cancelled when a reply is received. </p>
            <p>When a pending message is received, the timer is 
	    cancelled and the <c><![CDATA[long_request_timer]]></c>
	    is started instead (see below).
	    No resends will be performed from this point 
	    (since we now know that the other side has received the 
	    request). </p>
            <p>When the timer reaches an intermediate expire, the request
	    is resent and the timer is restarted. </p>
            <p>When the timer reaches the final expire, either the function 
	    <c><![CDATA[megaco:call]]></c> will return with
	    <c><![CDATA[{error, timeout}]]></c>
	    or the callback function <c><![CDATA[handle_trans_reply]]></c>
	    will be called with
	    <c><![CDATA[UserReply = {error, timeout}]]></c> (if 
	    <c><![CDATA[megaco:cast]]></c> was used).</p>

	    <p>Value type: 
	    <seetype marker="#megaco_timer">megaco_timer()</seetype></p>
	    <p>Defaults to <c><![CDATA[#megaco_incr_timer{}]]></c>.</p>

	    <marker id="ui_long_request_timer"></marker>
          </item>


	  <tag><c><![CDATA[long_request_timer]]></c></tag>
          <item>
            <p>Wait for reply after having received a pending message. </p>
            <p>When the timer reaches an intermediate expire, the timer 
	    is restarted. </p>
	    <p>When a pending message is received, and the 
	    <c><![CDATA[long_request_timer]]></c>  
	    is <em>not</em> "on its final leg", the timer will be 
	    restarted, and, if <c><![CDATA[long_request_resend = true]]></c>,
	    the request will be re-sent. </p>

	    <p>Value type: 
	    <seetype marker="#megaco_timer">megaco_timer()</seetype></p>
            <p>Defaults to <c><![CDATA[60000]]></c> (= 60 seconds).</p>

	    <marker id="ui_long_request_resend"></marker>
          </item>


	  <tag><c><![CDATA[long_request_resend]]></c></tag>
          <item>
            <p>This option indicates weather the request should be 
	    resent until the reply is received,
	    <em>even</em> though a pending message has been received. </p>
            <p>Normally, after a pending message has been received, 
	    the request is not resent 
	    (since a pending message is an indication that the
	    request has been received). But since the reply (to the 
	    request) can be lost, this behaviour has its values.</p>
            <p>It is of course pointless to set this value to <em>true</em>
	    unless the <c><![CDATA[long_request_timer]]></c>
	    (see above) is also set
	    to an incremental timer
	    (<c><![CDATA[#megaco_incr_timer{}]]></c>). </p>

	    <p>Value type: 
	    <seetype marker="erlang#boolean">boolean()</seetype></p>
            <p>Defaults to <c><![CDATA[false]]></c>.</p>

	    <marker id="ui_reply_timer"></marker>
          </item>


	  <tag><c><![CDATA[reply_timer]]></c></tag>
          <item>
            <p>Wait for an ack. </p>
            <p>When a request is received, some info
	    related to the reply is store internally (e.g. the
	    binary of the reply). This info will live until either
	    an ack is received or this timer expires. For instance,
	    if the same request is received again (e.g. a request
	    with the same transaction id), the (stored) reply will
	    be (re-) sent automatically by megaco.</p>
            <p>If the timer is of type <c><![CDATA[#megaco_incr_timer{}]]></c>, 
	    then for each intermediate timout, the reply will be resent
	    (this is valid until the ack is received or 
	    the timer expires). </p>

	    <p>Value type: 
	    <seetype marker="#megaco_timer">megaco_timer()</seetype></p>
            <p>Defaults to <c><![CDATA[30 seconds]]></c>.</p>

	    <marker id="ui_request_keep_alive_timeout"></marker>
          </item>


	  <tag><c><![CDATA[request_keep_alive_timeout]]></c></tag>
          <item>
            <p>Specifies the timeout time for the request-keep-alive timer. </p>
	    <p>This timer is started when the <em>first</em> reply to an
	    asynchronous request (issued using the 
	    <seeerl marker="megaco#cast">megaco:cast/3</seeerl> function)
	    arrives. As long as this timer is running, replies will 
	    be delivered via the 
	    <seeerl marker="megaco_user#trans_reply">handle_trans_reply/4,5</seeerl> 
	    callback function, with their "arrival number" 
	    (see <c><![CDATA[UserReply]]></c> of the 
	    <seeerl marker="megaco_user#trans_reply">handle_trans_reply/4,5</seeerl> 
	    callback function). </p>
	    <p>Replies arriving after the timer has expired, will be 
	    delivered using the 
	    <seeerl marker="megaco_user#unexpected_trans">handle_unexpected_trans/3,4</seeerl> 
	    callback function. </p>

	    <p>Value type: 
	    <c><![CDATA[plain]]></c> |
	    <seetype marker="erlang#non_neg_integer">non_neg_integer()</seetype></p>
            <p>Defaults to <c><![CDATA[plain]]></c>.</p>

	    <marker id="ui_call_proxy_gc_timeout"></marker>
          </item>


	  <tag><c><![CDATA[call_proxy_gc_timeout]]></c></tag>
          <item>
            <p>Timeout time for the call proxy. </p>
            <p>When a request is sent using the 
	    <seeerl marker="megaco#call">call/3</seeerl> function, 
	    a proxy process is started to handle
	    all replies. When the reply has been received and delivered 
	    to the user, the proxy process continue to exist for as long
	    as this option specifies. Any received messages, is passed on 
	    to the user via the 
	    <seeerl marker="megaco_user#handle_unexpected_trans">handle_unexpected_trans</seeerl> 
	    callback function. </p>
	    <p>The timeout time is in milliseconds. A value of 0 (zero) means
	    that the proxy process will exit directly after the reply has 
	    been delivered. </p>

	    <p>Value type: 
	    <seetype marker="erlang#pos_integer">pos_integer()</seetype></p>
            <p>Defaults to <c><![CDATA[5000]]></c> (= 5 seconds).</p>

	    <marker id="ui_auto_ack"></marker>
          </item>


	  <tag><c><![CDATA[auto_ack]]></c></tag>
          <item>
            <p>Automatic send transaction ack when the transaction
	    reply has been received
	    (see <c><![CDATA[trans_ack]]></c> below). </p>
            <p>This is used for <em>three-way-handshake</em>.</p>

	    <p>Value type: 
	    <seetype marker="erlang#boolean">boolean()</seetype></p>
            <p>Defaults to <c><![CDATA[false]]></c>.</p>

	    <marker id="ui_trans_ack"></marker>
          </item>


	  <tag><c><![CDATA[trans_ack]]></c></tag>
          <item>
            <p>Shall ack's be accumulated or not. </p>
	    <p>This property is only valid if <c><![CDATA[auto_ack]]></c>
	    is true.</p>
	    <p>If <c><![CDATA[auto_ack]]></c> is true, then if
	    <c><![CDATA[trans_ack]]></c> is
	    <c><![CDATA[false]]></c>, ack's will be sent immediately. 
	    If <c><![CDATA[trans_ack]]></c> is <c><![CDATA[true]]></c>, then 
	    ack's will instead be sent to the transaction 
	    sender process for accumulation and later sending 
	    (see <c><![CDATA[trans_ack_maxcount]]></c>,
	    <c><![CDATA[trans_req_maxcount]]></c>, 
	    <c><![CDATA[trans_req_maxsize]]></c>,
	    <c><![CDATA[trans_ack_maxcount]]></c> and 
	    <c><![CDATA[trans_timer]]></c>). </p>
	    <p>See also
	    <seeguide marker="megaco_run#transaction_sender">transaction sender</seeguide>
	    for more info.</p>

	    <p>Value type: 
	    <seetype marker="erlang#boolean">boolean()</seetype></p>
            <p>Defaults to <c><![CDATA[false]]></c>.</p>

	    <marker id="ui_trans_ack_maxcount"></marker>
          </item>


	  <tag><c><![CDATA[trans_ack_maxcount]]></c></tag>
          <item>
            <p>Maximum number of accumulated ack's. At most this many ack's
	    will be accumulated by the transaction sender (if started and 
	    configured to accumulate ack's).</p>
	    <p>See also
	    <seeguide marker="megaco_run#transaction_sender">transaction sender</seeguide>
	    for more info. </p>

	    <p>Value type: 
	    <seetype marker="erlang#integer">integer()</seetype></p>
            <p>Defaults to <c><![CDATA[10]]></c>.</p>

	    <marker id="ui_trans_req"></marker>
          </item>


	  <tag><c><![CDATA[trans_req]]></c></tag>
          <item>
            <p>Shall requests be accumulated or not. </p>
	    <p>If <c><![CDATA[trans_req]]></c> is <c><![CDATA[false]]></c>,
	    then request(s) will be sent immediately (in its own message).</p>
            <p>If <c><![CDATA[trans_req]]></c> is true, then request(s) will 
	    instead be sent to the transaction sender process for 
	    accumulation and later sending 
	    (see <c><![CDATA[trans_ack_maxcount]]></c>, <c><![CDATA[trans_req_maxcount]]></c>, 
	    <c><![CDATA[trans_req_maxsize]]></c>, <c><![CDATA[trans_ack_maxcount]]></c> and 
	    <c><![CDATA[trans_timer]]></c>). </p>

	    <p>See also
	    <seeguide marker="megaco_run#transaction_sender">transaction sender</seeguide>
	    for more info. </p>

	    <p>Value type: 
	    <seetype marker="erlang#boolean">boolean()</seetype></p>
            <p>Defaults to <c><![CDATA[false]]></c>.</p>

	    <marker id="ui_trans_req_maxcount"></marker>
          </item>


	  <tag><c><![CDATA[trans_req_maxcount]]></c></tag>
          <item>
            <p>Maximum number of accumulated requests. At most this many 
	    requests will be accumulated by the transaction sender 
	    (if started and configured to accumulate requests). </p>
	    <p>See also
	    <seeguide marker="megaco_run#transaction_sender">transaction sender</seeguide>
	    for more info.</p>

	    <p>Value type: 
	    <seetype marker="erlang#integer">integer()</seetype></p>
            <p>Defaults to <c><![CDATA[10]]></c>.</p>

	    <marker id="ui_trans_req_maxsize"></marker>
          </item>


          <tag><c><![CDATA[trans_req_maxsize]]></c></tag>
          <item>
            <p>Maximum size of the accumulated requests. At most this much
	    requests will be accumulated by the transaction sender 
	    (if started and configured to accumulate requests).</p>
	    <p>See also
	    <seeguide marker="megaco_run#transaction_sender">transaction sender</seeguide>
	    for more info.</p>

	    <p>Value type: 
	    <seetype marker="erlang#integer">integer()</seetype></p>
            <p>Defaults to <c><![CDATA[2048]]></c>.</p>

	    <marker id="ui_trans_timer"></marker>
          </item>


	  <tag><c><![CDATA[trans_timer]]></c></tag>
          <item>
            <p>Transaction sender timeout time. Has two functions. First, if 
	    the value is 0, then transactions will not be accumulated 
	    (e.g. the transaction sender process will not be started). 
	    Second, if the value is greater then 0 and
	    <c><![CDATA[auto_ack]]></c> and <c><![CDATA[trans_ack]]></c>
	    are both true or if <c><![CDATA[trans_req]]></c> is true, 
	    then transaction sender will be started and transactions 
	    (which is depending on the values of <c><![CDATA[auto_ack]]></c>, 
	    <c><![CDATA[trans_ack]]></c> and <c><![CDATA[trans_req]]></c>)
	    will be accumulated, for later sending. </p>
	    <p>See also
	    <seeguide marker="megaco_run#transaction_sender">transaction sender</seeguide>
	    for more info. </p>

	    <p>Value type: 
	    <seetype marker="erlang#integer">integer()</seetype></p>
            <p>Defaults to <c><![CDATA[0]]></c>.</p>

	    <marker id="ui_pending_timer"></marker>
          </item>


	  <tag><c><![CDATA[pending_timer]]></c></tag>
          <item>
            <p>Automatically send pending if the timer expires before a
	    transaction reply has been sent. This timer is also called 
	    provisional response timer. </p>

	    <p>Value type: 
	    <seetype marker="#megaco_timer">megaco_timer()</seetype></p>
            <p>Defaults to <c><![CDATA[30000]]></c>.</p>

	    <marker id="ui_sent_pending_limit"></marker>
          </item>


	  <tag><c><![CDATA[sent_pending_limit]]></c></tag>
          <item>
            <p>Sent pending limit (see the MGOriginatedPendingLimit
	    and the MGCOriginatedPendingLimit of the megaco root package).
	    This parameter specifies how many pending messages that can
	    be sent (for a given received transaction request).
	    When the limit is exceeded, the transaction is aborted
	    (see
	    <seeerl marker="megaco_user#request_abort">handle_trans_request_abort</seeerl>)
	    and an error message is sent to the other side. </p>
            <p>Note that this has no effect on the actual sending of
	    pending transactions. This is either implicit (e.g. when 
	    receiving a re-sent transaction request for a request which
	    is being processed) or controlled by the pending_timer,
	    see above. </p>

	    <p>Value type: 
	    <c><![CDATA[infinity]]></c> |
	    <seetype marker="erlang#pos_integer">pos_integer()</seetype></p>
            <p>Defaults to <c><![CDATA[infinity]]></c>.</p>

	    <marker id="ui_recv_pending_limit"></marker>
          </item>


	  <tag><c><![CDATA[recv_pending_limit]]></c></tag>
          <item>
            <p>Receive pending limit (see the MGOriginatedPendingLimit
	    and the MGCOriginatedPendingLimit of the megaco root package).
	    This parameter specifies how many pending messages that can
	    be received (for a sent transaction request).
	    When the limit is exceeded, the transaction is considered
	    lost, and an error returned to the user (through the call-back
	    function <em>handle_trans_reply</em>). </p>

	    <p>Value type: 
	    <c><![CDATA[infinity]]></c> |
	    <seetype marker="erlang#pos_integer">pos_integer()</seetype></p>
            <p>Defaults to <c><![CDATA[infinity]]></c>.</p>

	    <marker id="ui_send_mod"></marker>
          </item>


	  <tag><c><![CDATA[send_mod]]></c></tag>
          <item>
            <p>Send callback module which exports send_message/2. The
	    function SendMod:send_message(SendHandle, Binary) is
	    invoked when the bytes needs to be transmitted to the
	    remote user. </p>

	    <p>Value type: 
	    <seetype marker="erlang#module">module()</seetype></p>
            <p>Defaults to <c><![CDATA[megaco_tcp]]></c>.</p>

	    <marker id="ui_encoding_mod"></marker>
          </item>


	  <tag><c><![CDATA[encoding_mod]]></c></tag>
          <item>
            <p>Encoding callback module which exports encode_message/2
	    and decode_message/2. The function
	    EncodingMod:encode_message(EncodingConfig,
	    MegacoMessage) is invoked whenever a 'MegacoMessage'
	    record needs to be translated into an Erlang binary. The
	    function EncodingMod:decode_message(EncodingConfig,
	    Binary) is invoked whenever an Erlang binary needs to be
	    translated into a 'MegacoMessage' record. </p>

	    <p>Value type: 
	    <seetype marker="erlang#module">module()</seetype></p>
            <p>Defaults to <c><![CDATA[megaco_pretty_text_encoder]]></c>.</p>

	    <marker id="ui_encoding_config"></marker>
          </item>


	  <tag><c><![CDATA[encoding_config]]></c></tag>
          <item>
            <p>Encoding module config. </p>

	    <p>Value type: 
	    <seetype marker="erlang#list">list()</seetype></p>
            <p>Defaults to <c><![CDATA[[]]]></c>.</p>

	    <marker id="ui_protocol_version"></marker>
          </item>


	  <tag><c><![CDATA[protocol_version]]></c></tag>
          <item>
            <p>Actual protocol version. </p>

	    <p>Value type: 
	    <seetype marker="#protocol_version">protocol_version()</seetype></p>
            <p>Defaults to <c><![CDATA[1]]></c>.</p>

	    <marker id="ui_strict_version"></marker>
          </item>


	  <tag><c><![CDATA[strict_version]]></c></tag>
          <item>
            <p>Strict version control, i.e. when a message is received,
	    verify that the version is that which was negotiated. </p>

	    <p>Value type: 
	    <seetype marker="erlang#boolean">boolean()</seetype></p>
            <p>Defaults to <c><![CDATA[true]]></c>.</p>

	    <marker id="ui_reply_data"></marker>
          </item>


	  <tag><c><![CDATA[reply_data]]></c></tag>
          <item>
            <p>Default reply data. </p>

	    <p>Value type: 
	    <seetype marker="erlang#term">term()</seetype></p>
            <p>Defaults to <c><![CDATA[undefined]]></c>.</p>

	    <marker id="ui_user_mod"></marker>
          </item>


	  <tag><c><![CDATA[user_mod]]></c></tag>
          <item>
            <p>Name of the user callback module. See the the reference
	    manual for megaco_user for more info.</p>

	    <p>Value type: 
	    <seetype marker="erlang#module">module()</seetype></p>
	    <p>Has no default value since its an mandatory config option. </p>

	    <marker id="ui_user_args"></marker>
          </item>


	  <tag><c><![CDATA[user_args]]></c></tag>
          <item>
            <p>List of extra arguments to the user callback
	    functions. See the the reference manual for megaco_user
	    for more info.</p>

	    <p>Value type: 
	    <seetype marker="erlang#list">list()</seetype></p>
	    
	    <marker id="ui_threaded"></marker>
          </item>


	  <tag><c><![CDATA[threaded]]></c></tag>
          <item>
            <p>If a received message contains several transaction requests, 
	    this option indicates whether the requests should be handled
	    sequentially in the same process (<c><![CDATA[false]]></c>),
	    or if each request should be handled by its own process
	    (<c><![CDATA[true]]></c> i.e. a separate process is spawned
	    for each request). </p>

	    <p>Value type: 
	    <seetype marker="erlang#boolean">boolean()</seetype></p>
            <p>Defaults to <c><![CDATA[false]]></c>.</p>

            <marker id="ui_resend_indication"></marker>
          </item>


	  <tag><c><![CDATA[resend_indication]]></c></tag>
          <item>
            <p>This option indicates weather the transport module
	    should be told if a message send is a resend or not. </p>
            <p>If <em>false</em>, megaco messages are sent using the
	    <seeerl marker="megaco_transport#send_message">send_message</seeerl> 
	    function. </p>
	    <p>If <em>true</em>,
	    megaco message <em>re-sends</em> are made using the
	    <seeerl marker="megaco_transport#resend_message">resend_message</seeerl> 
	    function. The initial message send is still done using the
	    <seeerl marker="megaco_transport#send_message">send_message</seeerl> 
	    function. </p>
	    <p>The special value <em>flag</em> instead indicates that the 
	    function 
	    <seeerl marker="megaco_transport#send_message">send_message/3</seeerl> 
	    shall be used. </p>

	    <p>Value type: 
	    <seetype marker="erlang#boolean">boolean()</seetype></p>
            <p>Defaults to <c><![CDATA[false]]></c>.</p>

	    <marker id="ui_segment_reply_ind"></marker>
          </item>


	  <tag><c><![CDATA[segment_reply_ind]]></c></tag>
          <item>
            <p>This option specifies if the user shall be notified of received
	    segment replies or not. </p>
            <p>See 
	    <seeerl marker="megaco_user#segment_reply">handle_segment_reply</seeerl> 
	    callback function for more information. </p>

	    <p>Value type: 
	    <seetype marker="erlang#boolean">boolean()</seetype></p>
            <p>Defaults to <c><![CDATA[false]]></c>.</p>

	    <marker id="ui_segment_recv_timer"></marker>
          </item>


	  <tag><c><![CDATA[segment_recv_timer]]></c></tag>
          <item>
            <p>This timer is started when the segment indicated by the
	    <c><![CDATA[segmentation complete token]]></c> is received, but all 
	    segments has not yet been received.</p>
            <p>When the timer finally expires, a "megaco segments not
	    received" (459) error message is sent to the other side
	    and the user is notified with a <c><![CDATA[segment timeout]]></c>
	    <c><![CDATA[UserReply]]></c> in either the
	    <seeerl marker="megaco_user#trans_reply">handle_trans_reply</seeerl>
	    callback function or the return value of the 
	    <seeerl marker="megaco#call">call</seeerl> function. </p>

	    <p>Value type: 
	    <seetype marker="#megaco_timer">megaco_timer()</seetype></p>
            <p>Defaults to <c><![CDATA[10000]]></c>.</p>

	    <marker id="ui_segment_send"></marker>
          </item>


	  <tag><c><![CDATA[segment_send]]></c></tag>
          <item>
            <p>Shall outgoing messages be segmented or not.</p>
	    <p>Value type: 
	    <c><![CDATA[none]]></c> |
	    <seetype marker="erlang#pos_integer">pos_integer()</seetype> |
	    <c><![CDATA[infinity]]></c></p>
            <taglist>
              <tag><c><![CDATA[none]]></c></tag>
              <item>
                <p>Do not segment outgoing reply messages. This is useful when
		either it is known that messages are never to large or
		that the transport protocol can handle such things
		on its own (e.g. TCP or SCTP).</p>
              </item>
              <tag><c><![CDATA[pos_integer()]]></c></tag>
              <item>
                <p>Outgoing reply messages will be segmented as needed 
		(see <c><![CDATA[max_pdu_size]]></c> below).
		This value, K, indicate 
		the outstanding window, i.e. how many segments can be 
		outstanding (not acknowledged) at any given time. </p>
              </item>
              <tag><c><![CDATA[infinity]]></c></tag>
              <item>
                <p>Outgoing reply messages will be segmented as needed 
		(see <c><![CDATA[max_pdu_size]]></c> below). Segment messages 
		are sent all at once (i.e. no acknowledgement awaited 
		before sending the next segment). </p>
              </item>
            </taglist>
            <p>Defaults to <c><![CDATA[none]]></c>. </p>

	    <marker id="ui_max_pdu_size"></marker>
          </item>


	  <tag><c><![CDATA[max_pdu_size]]></c></tag>
          <item>
            <p>Max message size. If the encoded message (PDU) exceeds 
	    this size, the message should be segmented, and then 
	    encoded. </p>

	    <p>Value type: 
	    <c><![CDATA[infinity]]></c> |
	    <seetype marker="erlang#pos_integer">pos_integer()</seetype></p>
            <p>Defaults to <c><![CDATA[infinity]]></c>.</p>

          </item>

	</taglist>
      </desc>
    </datatype>


    <datatype>
      <name name="system_info_item"/>
      <desc>
	<marker id="si_text_config"></marker>
        <taglist>
          <tag><c><![CDATA[text_config]]></c></tag>
          <item>
            <p>The text encoding config.</p>
	    <p>Value type:
	    <seetype marker="erlang#term">term()</seetype></p>

	    <marker id="si_connections"></marker>
          </item>


	  <tag><c><![CDATA[connections]]></c></tag>
          <item>
            <p>Lists all active connections. Returns a
	    list of megaco_conn_handle records.</p>

	    <p>Value type:
	    [<seetype marker="#conn_handle">conn_handle()</seetype>]</p>

	    <marker id="si_users"></marker>
          </item>


	  <tag><c><![CDATA[users]]></c></tag>
          <item>
            <p>Lists all active users.</p>

	    <p>Value type:
	    [<seetype marker="#mid">mid()</seetype>]</p>

	    <marker id="si_active_requests"></marker>
          </item>

	  
          <tag><c><![CDATA[n_active_requests]]></c></tag>
          <item>
	    <p>Returns number of requests that has originated from
	    this Erlang node and still are active
	    (and therefore consumes system resources).</p>

	    <p>Value type:
	    <seetype marker="erlang#non_neg_integer">non_neg_integer()</seetype></p>
	    <marker id="si_active_replies"></marker>
          </item>


	  <tag><c><![CDATA[n_active_replies]]></c></tag>
          <item>
	    <p>Returns the number of replies that has originated
	    from this Erlang node and still are active (and
	    therefore consumes system resources).</p>

	    <p>Value type:
	    <seetype marker="erlang#non_neg_integer">non_neg_integer()</seetype></p>

	    <marker id="si_active_connections"></marker>
          </item>


	  <tag><c><![CDATA[n_active_connections]]></c></tag>
          <item>
            <p>Returns the number of active connections.</p>

	    <p>Value type:
	    <seetype marker="erlang#non_neg_integer">non_neg_integer()</seetype></p>
	    <marker id="si_reply_counters"></marker>
          </item>


	  <tag><c><![CDATA[reply_counters]]></c></tag>
          <item>
            <p>Returns a list of the reply counters.</p>

	    <p>Value type:
	    [{<seetype marker="#conn_handle">conn_handle()</seetype>,
	      <seetype marker="#transaction_id">transaction_id()</seetype>,
	      <seetype marker="erlang#non_neg_integer">non_neg_integer()</seetype>}]</p>

	    <marker id="si_pending_counters"></marker>
          </item>


	  <tag><c><![CDATA[pending_counters]]></c></tag>
          <item>
            <p>Returns a list of the receive and sent pending counters.</p>

	    <p>Value type:
	    [{recv | sent,
	    [{<seetype marker="#transaction_id">transaction_id()</seetype>,
	    <seetype marker="erlang#non_neg_integer">non_neg_integer()</seetype>}]}]</p>

	  </item>

	</taglist>

	<marker id="start"></marker>
      </desc>
    </datatype>

  </datatypes>


  <funcs>
    <func>
      <name name="start" arity="0" clause_i="1" since=""/>
      <fsummary>Starts the Megaco application</fsummary>
      <desc>
        <p>Starts the Megaco application</p>
        <p>Users may either explicitly be registered with
          megaco:start_user/2 and/or be statically configured by
          setting the application environment variable 'users' to a
          list of {UserMid, Config} tuples. See the function
          megaco:start_user/2 for details.</p>

        <marker id="stop"></marker>
      </desc>
    </func>

    <func>
      <name name="stop" arity="0" clause_i="1" since=""/>
      <fsummary>Stops the Megaco application</fsummary>
      <type>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Stops the Megaco application</p>

        <marker id="start_user"></marker>
      </desc>
    </func>

    <func>
      <name name="start_user" arity="2" clause_i="1" since=""/>
      <fsummary>Initial configuration of a user</fsummary>
      <desc>
        <p>Initial configuration of a user</p>
        <p>Requires the megaco application to be started. A user is
          either a Media Gateway (MG) or a Media Gateway Controller
          (MGC). One Erlang node may host many users.</p>
        <p>A user is identified by its UserMid, which must be a legal
          Megaco MID.</p>
        <p>Config is a list of {Item, Value} tuples.  See
          megaco:user_info/2 about which items and values that are valid.</p>

        <marker id="stop_user"></marker>
      </desc>
    </func>

    <func>
      <name name="stop_user" arity="1" clause_i="1" since=""/>
      <fsummary>Delete the configuration of a user</fsummary>
      <desc>
        <p>Delete the configuration of a user</p>
        <p>Requires that the user does not have any active connection.</p>

        <marker id="user_info"></marker>
        <marker id="user_info_11"></marker>
        <marker id="user_info_23"></marker>
      </desc>
    </func>

    <func>
      <name name="user_info" arity="1" clause_i="1" since=""/>
      <name name="user_info" arity="2" clause_i="3" since=""/>
      <fsummary>Lookup user information</fsummary>
      <desc>
        <p>Lookup user information</p>

        <marker id="user_info_21"></marker>
      </desc>
    </func>

    <func>
      <name name="user_info" arity="2" clause_i="1" since=""/>
      <fsummary>Lookup user information</fsummary>
      <desc>
        <p>Lookup user information about currently active requests. </p>

        <marker id="user_info_22"></marker>
      </desc>
    </func>

    <func>
      <name name="user_info" arity="2" clause_i="2" since=""/>
      <fsummary>Lookup user information</fsummary>
      <desc>
        <p>Lookup user information about currently active replies. </p>

        <marker id="update_user_info"></marker>
      </desc>
    </func>

    <func>
      <name name="update_user_info" arity="3" clause_i="1" since=""/>
      <fsummary>Update information about a user</fsummary>
      <desc>
        <p>Update information about a user</p>
        <p>Requires that the user is started. </p>

        <marker id="conn_info"></marker>
        <marker id="conn_info_11"></marker>
        <marker id="conn_info_24"></marker>
      </desc>
    </func>

    <func>
      <name name="conn_info" arity="1" clause_i="1" since=""/>
      <name name="conn_info" arity="2" clause_i="4" since=""/>
      <fsummary>Lookup information about an active connection</fsummary>
      <desc>
        <p>Lookup information about an active connection</p>
        <p>Requires that the connection is active.</p>

	<p>Failure: <c>exit</c> if, for instance,
	<c><anno>ConnHandle</anno></c> refers to a connection
	that no longer exists.</p>

	<marker id="conn_info_21"></marker>
      </desc>
    </func>

    <func>
      <name name="conn_info" arity="2" clause_i="1" since=""/>
      <fsummary>Lookup information about an active connection</fsummary>
      <desc>
	<p>Lookup all connection information about an <em>active</em>
	connection</p>

	<p>See <seeerl marker="#conn_info_24">conn_info</seeerl> for
	more info.</p>

	<p>Failure: <c>exit</c> if, for instance,
	<c><anno>ConnHandle</anno></c> refers to a connection
	that no longer exists.</p>

	<marker id="conn_info_22"></marker>
      </desc>
    </func>

    <func>
      <name name="conn_info" arity="2" clause_i="2" since=""/>
      <fsummary>Lookup information about an active connection</fsummary>
      <desc>
	<p>Lookup information about currently active requests for an
	<em>active</em> connection</p>

	<p>Failure: <c>exit</c> if, for instance,
	<c><anno>ConnHandle</anno></c> refers to a connection
	that no longer exists.</p>

	<marker id="conn_info_23"></marker>
      </desc>
    </func>

    <func>
      <name name="conn_info" arity="2" clause_i="3" since=""/>
      <fsummary>Lookup information about an active connection</fsummary>
      <desc>
	<p>Lookup information about currently active replies for an
	<em>active</em> connection</p>

	<p>Failure: <c>exit</c> if, for instance,
	<c><anno>ConnHandle</anno></c> refers to a connection
	that no longer exists.</p>

	<marker id="update_conn_info"></marker>
      </desc>
    </func>

    <func>
      <name name="update_conn_info" arity="3" clause_i="1" since=""/>
      <fsummary>Update information about an active connection</fsummary>
      <desc>
        <p>Update information about an active connection</p>
	<p>Requires that the connection is activated. See
	<seetype marker="#conn_info_item">conn_info_item()</seetype>
	about which items and values that are valid.</p>

        <marker id="system_info"></marker>
      </desc>
    </func>

    <func>
      <name name="system_info" arity="0" clause_i="1" since=""/>
      <name name="system_info" arity="1" clause_i="1" since=""/>
      <fsummary>Lookup system information</fsummary>
      <desc>
        <p>Lookup system information. </p>

	<marker id="info"></marker>
      </desc>
    </func>

    <func>
      <name name="info" arity="0" clause_i="1" since=""/>
      <fsummary>All the information of the application</fsummary>
      <desc>
        <p>This function produces a list of information about the megaco 
          application. Such as users and their config, connections 
          and their config, statistics and so on.</p>

        <p>This information can be produced by the functions 
          <seeerl marker="#user_info">user_info</seeerl>, 
          <seeerl marker="#conn_info">conn_info</seeerl>, 
          <seeerl marker="#system_info">system_info</seeerl> and 
          <seeerl marker="#get_stats">get_stats</seeerl> 
          but this is a simple way to get it all at once.</p>

        <marker id="connect"></marker> <!-- Belongs to NEXT function(s) -->
      </desc>
    </func>

    <func>
      <name name="connect" arity="4" clause_i="1" since=""/>
      <name name="connect" arity="5" clause_i="1" since=""/>
      <fsummary>Establish a "virtual" connection</fsummary>
      <desc>
        <p>Establish a "virtual" connection</p>

	<p>Activates a connection to a remote user. When this is done
	the connection can be used to send messages (with
	<c><![CDATA[SendMod:send_message/2]]></c>).
	The <c><![CDATA[ControlPid]]></c> is the identifier
	of a process that controls the connection. That process will
	be supervised and if it dies, this will be detected and the
	<c><![CDATA[UserMod:handle_disconnect/2]]></c> callback function
	will be
	invoked. See the megaco_user module for more info about the
	callback arguments. The connection may also explicitly be
	deactivated by invoking
	<c><![CDATA[megaco:disconnect/2]]></c>.</p>

	<p>The <c><![CDATA[ControlPid]]></c> may be the identity of a
	process residing on
	another Erlang node. This is useful when you want to
	distribute a user over several Erlang nodes. In such a case
	one of the nodes has the physical connection. When a user
	residing on one of the other nodes needs to send a request
	(with <c><![CDATA[megaco:call/3]]></c> or
	<c><![CDATA[megaco:cast/3]]></c>), the message will
	encoded on the originating Erlang node, and then be
	forwarded to the node with the physical connection. When the
	reply arrives, it will be forwarded back to the originator.
	The distributed connection may explicitly be deactivated by
	a local call to <c><![CDATA[megaco:disconnect/2]]></c> or
	implicitly when the physical connection is deactivated
	(with <c><![CDATA[megaco:disconnect/2]]></c>,
	killing the controlling process, halting the other node, ...).</p>

	<p>The call of this function will trigger the callback
	function <c><![CDATA[UserMod:handle_connect/2]]></c> to be invoked.
	See the megaco_user module for more info about the callback
	arguments.</p>

	<p>A connection may be established in several ways:</p>
        <taglist>
          <tag><c><![CDATA[provisioned MID]]></c></tag>
          <item>
            <p>The MG may explicitly invoke megaco:connect/4 and use
              a provisioned MID of the MGC as the RemoteMid.</p>
          </item>
          <tag><c><![CDATA[upgrade preliminary MID]]></c></tag>
          <item>
            <p>The MG may explicitly invoke megaco:connect/4 with the
              atom 'preliminary_mid' as a temporary MID of the MGC,
              send an intial message, the Service Change Request, to
              the MGC and then wait for an initial message, the
              Service Change Reply. When the reply arrives, the Megaco
              application will pick the MID of the MGC from the
              message header and automatically upgrade the connection
              to be a "normal" connection. By using this method of
              establishing the connection, the callback function
	      <c><![CDATA[UserMod:handle_connect/2]]></c> to be invoked twice.
	      First with
              a <c><![CDATA[ConnHandle]]></c> with the remote_mid-field set to
              preliminary_mid, and then when the connection upgrade is
              done with the remote_mid-field set to the actual MID of
              the MGC.</p>
          </item>
          <tag><c><![CDATA[automatic]]></c></tag>
          <item>
            <p>When the MGC receives its first message, the Service
              Change Request, the Megaco application will
              automatically establish the connection by using the MG
              MID found in the message header as remote mid.</p>
          </item>
          <tag><c><![CDATA[distributed]]></c></tag>
          <item>
            <p>When a user (MG/MGC) is distributed over several nodes,
              it is required that the node hosting the connection
              already has activated the connection and that it is
	      in the "normal" state. The <c><![CDATA[RemoteMid]]></c>
	      must be a real
              Megaco MID and not a <c><![CDATA[preliminary_mid]]></c>.</p>
          </item>
        </taglist>
        <p>An initial megaco_receive_handle record may be obtained
	with <c><![CDATA[megaco:user_info(UserMid, receive_handle)]]></c></p>
        <p>The send handle is provided by the preferred transport
          module, e.g. megaco_tcp, megaco_udp. Read the documentation
          about each transport module about the details.</p>

	<p>The connect is done in two steps: first an internal 
          <c>connection setup</c> and then by calling the user 
          <seeerl marker="megaco_user#connect">handle_connect</seeerl> 
          callback function. The first step could result in 
	  an error with
	  <c><![CDATA[Reason = ConnectReason]]></c>
	  and the second 
	  an error with
	<c><![CDATA[Reason = HandleConnectReason]]></c>: </p>

	<taglist>
	  <tag><c>ConnectReason</c></tag>
	  <item>
	    <p>An error with this reason is generated by the 
	    megaco application itself.</p>
	  </item>

	  <tag><c>HandleConnectReason</c></tag>
	  <item>
	    <p>An error with this reason is caused by the user 
              <seeerl marker="megaco_user#connect">handle_connect</seeerl> 
              callback function either returning an error 
              or an invalid value.</p>
	  </item>

	</taglist>

        <p><c><![CDATA[Extra]]></c> can be any <c><![CDATA[term()]]></c> 
          except the atom <c><![CDATA[ignore_extra]]></c>. 
          It is passed (back) to the user via the callback function 
          <seeerl marker="megaco_user#connect">handle_connect/3</seeerl>. </p>

        <marker id="disconnect"></marker> <!-- Belongs to NEXT function(s) -->
      </desc>
    </func>

    <func>
      <name name="disconnect" arity="2" clause_i="1" since=""/>
      <fsummary>Tear down a "virtual" connection</fsummary>
      <desc>
        <p>Tear down a "virtual" connection</p>
	<p>Causes the <c><![CDATA[UserMod:handle_disconnect/2]]></c>
	callback function to be invoked.
	See the megaco_user module for more info about
	the callback arguments.</p>

        <marker id="call"></marker> <!-- Belongs to NEXT function(s) -->
      </desc>
    </func>

    <func>
      <name name="call" arity="3" clause_i="1" since=""/>
      <fsummary>Sends one or more transaction request(s) and waits for the reply</fsummary>
      <desc>
        <p>Sends one or more transaction request(s) and waits for the reply.</p>

	<p>When sending one transaction in a message,
	<c><![CDATA[ActionRequests]]></c> should be 
	<c><![CDATA[action_reqs()]]></c> (the reply
	will then be <c><![CDATA[UserReply]]></c>).
	When sending several transactions in a message,
	<c><![CDATA[ActionRequests]]></c> should be
	<c><![CDATA[[action_reqs()]]]></c> (the reply
	will then be <c><![CDATA[[UserReply]]]></c>).
	Each element of the list is 
	part of one transaction.</p>

	<p>For some of <em>our</em> codecs (not binary), it is also possible 
	to pre-encode the actions, in which case
	<c><![CDATA[ActionRequests]]></c>
	will be either a <c><![CDATA[binary()]]></c> or
	<c><![CDATA[[binary()]]]></c>.</p>

	<p>The function returns when the reply arrives, when the
	request timer eventually times out or when the outstanding
	requests are explicitly cancelled.</p>

	<p>The default values of the send options are obtained by
	<c><![CDATA[megaco:conn_info(ConnHandle, Item)]]></c>.
	But the send options above, may explicitly be overridden.</p>

	<p>The <c><![CDATA[ProtocolVersion]]></c> version is the version
	actually encoded in the reply message.</p>

	<p>At <c><![CDATA[Success]]></c>, the <c><![CDATA[UserReply]]></c>
	contains a list of 'ActionReply' records possibly containing
	error indications.</p>

	<p>A <c><![CDATA[Failure]]></c>, indicates that the remote user has
	replied with an explicit transactionError.</p>

	<p>A <c><![CDATA[UserCancelReason]]></c>, indicates that the
	request has been canceled by the user.
	<c><![CDATA[ReasonForUserCancel]]></c> is the reason
	given in the call to the <seeerl marker="#cancel">cancel</seeerl>
	function. </p>

	<p>A send error (<c><![CDATA[SendReason]]></c>),
	indicates that the send function of the 
	megaco transport callback module failed to send the request. 
	There are two separate cases:
	<c><![CDATA[SendCancelledReason]]></c> and 
	<c><![CDATA[SendFailedReason]]></c>. 
	The first is the result of the send function returning 
	<c><![CDATA[{cancel, Reason}]]></c> and the second is some other
	kind of erroneous return value.
	See the 
	<seeerl marker="megaco_transport#send_message">send_message</seeerl>
	function for more info. </p>

	<p>An <c><![CDATA[OtherReason]]></c>, indicates some other
	error such as timeout.</p>

	<p>For more info about the 'extra' part of the result
	(<c><![CDATA[SuccessExtra]]></c> and <c><![CDATA[ErrorExtra]]></c>),
	see the 
	<seeerl marker="megaco_user#extra_argument">note</seeerl>
	in the user callback module documentation. </p>

        <marker id="cast"></marker>
      </desc>
    </func>

    <func>
      <name name="cast" arity="3" clause_i="1" since=""/>
      <fsummary>Sends one or more transaction request(s) but does NOT wait for a reply</fsummary>
      <desc>
	<p>Sends one or more transaction request(s)
	but does NOT wait for a reply</p>

	<p>When sending one transaction in a message,
	<c><![CDATA[ActionRequests]]></c> should be 
	<c><![CDATA[action_reqs()]]></c>.
	When sending several transactions in a message,
	<c><![CDATA[ActionRequests]]></c> should be
	<c><![CDATA[[action_reqs()]]]></c>. Each element of the 
	list is part of one transaction.</p>

	<p>For some of <em>our</em> codecs (not binary), it is also possible 
	to pre-encode the actions, in which case <c><![CDATA[Actions]]></c>
	will be 
	either a <c><![CDATA[binary()]]></c> or
	<c><![CDATA[[binary()]]]></c>.</p>

	<p>The default values of the send options are obtained by
	megaco:conn_info(ConnHandle, Item). But the send options above,
	may explicitly be overridden.</p>

	<p>The ProtocolVersion version is the version actually encoded
	in the reply message.</p>

	<p>The callback function UserMod:handle_trans_reply/4 is invoked
	when the reply arrives, when the request timer eventually
	times out or when the outstanding requests are explicitly
	cancelled. See the megaco_user module for more info about
	the callback arguments.</p>
	<p>Given as <c><![CDATA[ReplyData]]></c> argument to
	UserMod:handle_trans_reply/4.</p>

        <marker id="encode_actions"></marker>
      </desc>
    </func>

    <func>
      <name name="encode_actions" arity="3" clause_i="1" since=""/>
      <fsummary>Encode action requests for one or more transaction request(s)</fsummary>
      <desc>
        <p>Encodes lists of action requests for one or more transaction 
          request(s).</p>
        <p>When encoding action requests for one transaction, 
          <c><![CDATA[Actions]]></c> should be <c><![CDATA[action_reqs()]]></c>. 
          When encoding action requests for several transactions,
          <c><![CDATA[Actions]]></c> should be <c><![CDATA[[action_reqs()]]]></c>. Each element 
          of the list is part of one transaction.</p>

        <marker id="token_tag2string"></marker>
      </desc>
    </func>

    <func>
      <name name="token_tag2string" arity="1" clause_i="1" since=""/>
      <name name="token_tag2string" arity="2" clause_i="1" since=""/>
      <name name="token_tag2string" arity="3" clause_i="1" since=""/>
      <fsummary>Convert a token tag to a string</fsummary>
      <desc>
        <p>Convert a token tag to a string</p>
        <p>If no encoder module is given, the default is used 
	(which is pretty).</p>
	<p>If no or an unknown version is given, 
	the <em>best</em> version is used (which is v3).</p>
	<p>If no match is found for
	<c><![CDATA[Tag]]></c>, <c><![CDATA[Result]]></c> will be the 
	empty string (<c><![CDATA[[]]]></c>).</p>

        <marker id="cancel"></marker>
      </desc>
    </func>

    <func>
      <name name="cancel" arity="2" clause_i="1" since=""/>
      <fsummary>Cancel all outstanding messages for this connection</fsummary>
      <desc>
        <p>Cancel all outstanding messages for this connection</p>
        <p>This causes outstanding megaco:call/3 requests to return.
          The callback functions UserMod:handle_reply/4 and
          UserMod:handle_trans_ack/4 are also invoked where it
          applies.  See the megaco_user module for more info about the
          callback arguments.</p>

        <marker id="process_received_message"></marker>
      </desc>
    </func>

    <func>
      <name name="process_received_message" arity="4" clause_i="1" since=""/>
      <name name="process_received_message" arity="5" clause_i="1" since=""/>
      <fsummary>Process a received message</fsummary>
      <desc>
        <p>Process a received message</p>

        <p>This function is intended to be invoked by some
          transport modules when get an incoming message. Which
          transport that actually is used is up to the user to
          choose.</p>

        <p>The message is delivered as an Erlang binary and is decoded
          by the encoding module stated in the receive handle together
          with its encoding config (also in the receive
          handle). Depending of the outcome of the decoding various
          callback functions will be invoked. See megaco_user for more
          info about the callback arguments.</p>

	  <p>The argument <c>Extra</c> is just an opaque data structure passed
	  to the user 
          via the callback functions in the 
          <seeerl marker="megaco_user">user callback module</seeerl>. 
          Note however that if <c>Extra</c> has the value 
          <c>extra_undefined</c> the argument will be ignored (same as if 
          <c>process_received_message/4</c> had been called). 
          See the documentation for the behaviour of the callback module,
	  <seeerl marker="megaco_user">megaco_user</seeerl>,
	  for more info. </p> 
	  <p>Note that all processing is done in the context of the calling 
          process. A transport module could call this function via one of the
	  <c><![CDATA[spawn]]></c> functions
	  (e.g. <c><![CDATA[spawn_opt]]></c>).
	  See also <c><![CDATA[receive_message/4,5]]></c>.
          </p>
        <p>If the message cannot be decoded the following callback
          function will be invoked:</p>
        <list type="bulleted">
          <item>
            <p>UserMod:handle_syntax_error/3</p>
          </item>
        </list>
        <p>If the decoded message instead of transactions contains a
          message error, the following callback function will be
          invoked:</p>
        <list type="bulleted">
          <item>
            <p>UserMod:handle_message_error/3</p>
          </item>
        </list>
        <p>If the decoded message happens to be received before the
          connection is established, a new "virtual" connection is
          established. This is typically the case for the Media
          Gateway Controller (MGC) upon the first Service Change.
          When this occurs the following callback function will be
          invoked:</p>
        <list type="bulleted">
          <item>
            <p>UserMod:handle_connect/2</p>
          </item>
        </list>
        <p>For each transaction request in the decoded message the
          following callback function will be invoked:</p>
        <list type="bulleted">
          <item>
            <p>UserMod:handle_trans_request/3</p>
          </item>
        </list>
        <p>For each transaction reply in the decoded message the reply
          is returned to the user. Either the originating function
          megaco:call/3 will return.  Or in case the originating
          function was megaco:case/3 the following callback function
          will be invoked:</p>
        <list type="bulleted">
          <item>
            <p>UserMod:handle_trans_reply/4</p>
          </item>
        </list>
        <p>When a transaction acknowledgement is received it is
          possible that user has decided not to bother about the
          acknowledgement. But in case the return value from
          UserMod:handle_trans_request/3 indicates that the
          acknowledgement is important the following callback function
          will be invoked:</p>
        <list type="bulleted">
          <item>
            <p>UserMod:handle_trans_ack/4</p>
          </item>
        </list>
        <p>See the megaco_user module for more info about the callback
          arguments.</p>

        <marker id="receive_message"></marker>
      </desc>
    </func>

    <func>
      <name name="receive_message" arity="4" clause_i="1" since=""/>
      <name name="receive_message" arity="5" clause_i="1" since=""/>
      <fsummary>Process a received message</fsummary>
      <desc>
        <p>Process a received message</p>
        <p>This is a callback function intended to be invoked by some
	transport modules when get an incoming message. Which
	transport that actually is used is up to the user to
	choose.</p>
	<p>In principle, this function calls the 
	<c><![CDATA[process_received_message/4,5]]></c>
	function via a <c><![CDATA[spawn]]></c> to
	perform the actual processing.</p>
        <p>For further information see the 
	<seeerl marker="#process_received_message">process_received_message/4,5</seeerl> 
	function.</p>

        <marker id="parse_digit_map"></marker>
      </desc>
    </func>

    <func>
      <name name="parse_digit_map" arity="1" clause_i="1" since=""/>
      <fsummary>Parses a digit map body</fsummary>
      <desc>
        <p>Parses a digit map body</p>
        <p>Parses a digit map body, represented as a list of
	characters, into a list of state transitions suited to
	be evaluated by megaco:eval_digit_map/1,2.</p>

        <marker id="eval_digit_map"></marker>
      </desc>
    </func>

    <func>
      <name name="eval_digit_map" arity="1" clause_i="1" since=""/>
      <name name="eval_digit_map" arity="2" clause_i="1" since=""/>
      <fsummary>Collect digit map letters according to the digit map</fsummary>
      <desc>
        <p>Collect digit map letters according to the digit map.</p>
        <p>When evaluating a digit map, a state machine waits for
          timeouts and letters reported by
          megaco:report_digit_event/2. The length of the various
          timeouts are defined in the digit_map_value() record.</p>
        <p>When a complete sequence of valid events has been received,
          the result is returned as a list of letters.</p>
        <p>There are two options for handling syntax errors (that is
          when an unexpected event is received when the digit map
          evaluator is expecting some other event). The unexpected
          events may either be ignored or rejected. The latter means
          that the evaluation is aborted and an error is returned. </p>

        <marker id="report_digit_event"></marker>
      </desc>
    </func>

    <func>
      <name name="report_digit_event" arity="2" clause_i="1" since=""/>
      <fsummary>Send one or more events to the event collector process</fsummary>
      <desc>
        <p>Send one or more events to the event collector process.</p>
        <p>Send one or more events to a process that is evaluating a
          digit map, that is a process that is executing
          megaco:eval_digit_map/1,2.</p>
        <p>Note that the events <c><![CDATA[$s | $S]]></c>, <c><![CDATA[l | $L]]></c> and
          <c><![CDATA[$z | $Z]]></c> has nothing to do with the timers using
          the same characters.</p>

        <marker id="test_digit_event"></marker>
      </desc>
    </func>

    <func>
      <name name="test_digit_event" arity="2" clause_i="1" since=""/>
      <fsummary>Feed digit map collector with events and return the result</fsummary>
      <desc>
        <p>Feed digit map collector with events and return the result</p>
        <p>This function starts the evaluation of a digit map with
	megaco:eval_digit_map/1 and sends a sequence of events to it with
	megaco:report_digit_event/2 in order to simplify testing of
	digit maps.</p>

        <marker id="encode_sdp"></marker>
      </desc>
    </func>

    <func>
      <name name="encode_sdp" arity="1" clause_i="1" since=""/>
      <fsummary>Encode an SDP construct</fsummary>
      <desc>
        <p>Encode (generate) an SDP construct.</p>
        <p>If a <c><![CDATA[property_parm()]]></c> is found as part of the input
          (<c><![CDATA[SDP]]></c>) then it is left unchanged.</p>
        <p>This function performs the following transformation:</p>
        <list type="bulleted">
          <item>
            <p>sdp()                 -&gt; property_parm()</p>
          </item>
          <item>
            <p>sdp_property_group()  -&gt; property_group()</p>
          </item>
          <item>
            <p>sdp_property_groups() -&gt; property_groups()</p>
          </item>
        </list>

        <marker id="decode_sdp"></marker>
      </desc>
    </func>

    <func>
      <name name="decode_sdp" arity="1" clause_i="1" since=""/>
      <fsummary>Decode an property parameter construct</fsummary>
      <desc>
        <p>Decode (parse) a property parameter construct.</p>
        <p>When decoding <c><![CDATA[property_group()]]></c> or 
          <c><![CDATA[property_groups()]]></c>, 
          those property parameter constructs that cannot be decoded
          (either because of decode error or because they are unknown),
          will be returned as a two-tuple. The first element of which 
          will be the (undecoded) property parameter and the other the 
          actual reason. 
          This means that the caller of this function has to expect not 
          only sdp-records, but also this two-tuple construct.</p>
        <p>This function performs the following transformation:</p>
        <list type="bulleted">
          <item>
            <p>property_parm()   -&gt; sdp()</p>
          </item>
          <item>
            <p>property_group()  -&gt; sdp_property_group()</p>
          </item>
          <item>
            <p>property_groups() -&gt; sdp_property_groups()</p>
          </item>
        </list>

	<marker id="versions"></marker>
	<marker id="versions1"></marker>
	<marker id="versions2"></marker>
      </desc>
    </func>

    <func>
      <name name="versions1" arity="0" clause_i="1" since=""/>
      <name name="versions2" arity="0" clause_i="1" since=""/>
      <fsummary>Retreive various system and application info</fsummary>
      <desc>
        <p>Utility functions used to retrieve some system and
	application info.</p>
        <p>The difference between the two functions is in how they get
	the modules to check. <c><![CDATA[versions1]]></c> uses the 
	app-file and <c><![CDATA[versions2]]></c> uses the function 
	<c><![CDATA[application:get_key]]></c>.</p>

	<marker id="print_version_info"></marker>
      </desc>
    </func>

    <func>
      <name name="print_version_info" arity="0" clause_i="1" since=""/>
      <name name="print_version_info" arity="1" clause_i="1" since=""/>
      <fsummary>Formated print of result of the versions functions</fsummary>
      <desc>
        <p>Utility function to produce a formated printout of the versions 
          info generated by the <c><![CDATA[versions1]]></c> and <c><![CDATA[versions2]]></c> 
          functions.</p>
        <p>The function print_version_info/0 uses the result of function
          version1/0 as <c><![CDATA[VersionInfo]]></c>.</p>
        <p>Example: </p>
        <pre type="erl">
           {ok, V} = megaco:versions1(), megaco:format_versions(V). 
        </pre>
        <marker id="enable_trace"></marker>
      </desc>
    </func>

    <func>
      <name name="enable_trace" arity="2" clause_i="1" since=""/>
      <fsummary>Start megaco tracing</fsummary>
      <desc>
        <p>This function is used to start megaco tracing at a given 
          <c><![CDATA[Level]]></c> and direct result to the given <c><![CDATA[Destination]]></c>.</p>
        <p>It starts a tracer server and then sets the proper match spec 
          (according to <c><![CDATA[Level]]></c>).</p>
        <p>In the case when <c><![CDATA[Destination]]></c> is <c><![CDATA[File]]></c>, the printable 
          megaco trace events will be printed to the file <c><![CDATA[File]]></c> using
          plain <c><![CDATA[io:format/2]]></c>. </p>
        <p>In the case when <c><![CDATA[Destination]]></c> is <c><![CDATA[io]]></c>, the printable 
          megaco trace events will be printed on stdout using plain 
          <c><![CDATA[io:format/2]]></c>. </p>
        <p>See <c><![CDATA[dbg]]></c> for further information.</p>
        <marker id="disable_trace"></marker>
      </desc>
    </func>

    <func>
      <name name="disable_trace" arity="0" clause_i="1" since=""/>
      <fsummary>Stop megaco tracing</fsummary>
      <desc>
        <p>This function is used to stop megaco tracing.</p>
        <marker id="set_trace"></marker>
      </desc>
    </func>

    <func>
      <name name="set_trace" arity="1" clause_i="1" since=""/>
      <fsummary>Change megaco trace level</fsummary>
      <desc>
        <p>This function is used to change the megaco trace level.</p>
        <p>It is assumed that tracing has already been enabled (see 
          <c><![CDATA[enable_trace]]></c> above).</p>

        <marker id="stats"></marker>
        <marker id="get_stats"></marker>
        <marker id="get_stats_0"></marker>
      </desc>
    </func>

    <func>
      <name name="get_stats" arity="0" clause_i="1" since=""/>
      <fsummary></fsummary>
      <desc>
        <p>Retreive all (SNMP) statistic counters maintained by the 
	megaco application. </p>
	<p>The global
	counters handle events that cannot be attributed to 
	a single connection (e.g. protocol errors that occur 
	before the connection has been properly setup).</p>
        <marker id="get_stats_1_1"></marker>
      </desc>
    </func>

    <func>
      <name name="get_stats" arity="1" clause_i="1" since=""/>
      <fsummary></fsummary>
      <desc>
        <p>Retreive a (SNMP) (global) statistic counter maintained by the 
	megaco application. </p>
	<p>The global
	counters handle events that cannot be attributed to 
	a single connection (e.g. protocol errors that occur 
	before the connection has been properly setup).</p>
	<marker id="get_stats_1_2"></marker>
      </desc>
    </func>

    <func>
      <name name="get_stats" arity="1" clause_i="2" since=""/>
      <fsummary></fsummary>
      <desc>
        <p>Retreive all (SNMP) statistic counters maintained by the 
          megaco application, for a specific connection.</p>
        <marker id="get_stats_2"></marker>
      </desc>
    </func>

    <func>
      <name name="get_stats" arity="2" clause_i="1" since=""/>
      <fsummary></fsummary>
      <desc>
        <p>Retreive a (SNMP) statistic counter maintained by the 
          megaco application.</p>
        <marker id="reset_stats"></marker>
        <marker id="reset_stats_0"></marker>
      </desc>
    </func>

    <func>
      <name name="reset_stats" arity="0" clause_i="1" since=""/>
      <fsummary></fsummary>
      <desc>
        <p>Reset all (SNMP) statistics counters.</p>
        <marker id="reset_stats_1_1"></marker>
      </desc>
    </func>

    <func>
      <name name="reset_stats" arity="1" clause_i="1" since=""/>
      <fsummary></fsummary>
      <desc>
        <p>Reset the specified (SNMP) statistics counter.</p>
        <marker id="reset_stats_1_2"></marker>
      </desc>
    </func>

    <func>
      <name name="reset_stats" arity="1" clause_i="2" since=""/>
      <fsummary></fsummary>
      <desc>
        <p>Reset all (SNMP) statistics counters for a connection.</p>
        <marker id="test_request"></marker>
      </desc>
    </func>

    <func>
      <name name="test_request" arity="5" clause_i="1" since=""/>
      <fsummary>Tests if the Actions argument is correct</fsummary>
      <desc>
        <p>Tests if the Actions argument is correctly composed.</p>
        <p>This function is only intended for testing purposes. It's
	supposed to have a same kind of interface as the
	<seeerl marker="#call">call</seeerl> or
	<seeerl marker="#cast">cast</seeerl> functions (with the additions
	of the
	<c><![CDATA[EncodingMod]]></c> and <c><![CDATA[EncodingConfig]]></c>
	arguments). It composes a complete megaco message end
	attempts to encode it. The return value, will be a tuple of
	the composed megaco message and the encode result. </p>

	<marker id="test_reply"></marker>
      </desc>
    </func>

    <func>
      <name name="test_reply" arity="5" clause_i="1" since=""/>
      <fsummary>Tests if the Reply argument is correct</fsummary>
      <desc>
        <p>Tests if the Reply argument is correctly composed.</p>
        <p>This function is only intended for testing purposes. It's
	supposed to test the <c><![CDATA[actual_reply()]]></c> return value of
	the callback functions 
	<seeerl marker="megaco_user#trans_request">handle_trans_request</seeerl>
	and 
	<seeerl marker="megaco_user#trans_long_request">handle_trans_long_request</seeerl>
	functions (with the additions of the <c><![CDATA[EncodingMod]]></c> and
	<c><![CDATA[EncodingConfig]]></c> arguments). It composes a complete
	megaco message end attempts to encode it. The return value,
	will be a tuple of the composed megaco message and the
	encode result.</p>
      </desc>
    </func>
  </funcs>

</erlref>

