<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<!-- THIS FILE IS GENERATED DO NOT EDIT -->


<erlref>
<header>
  <copyright>
    <year>2020</year><year>2021</year>
    <holder>wxWidgets team.</holder></copyright>
  <legalnotice>Licensed under the wxWindows Free Documentation Licence, Version 3
  </legalnotice>
  <title>wxKeyEvent</title>
</header>
<module>wxKeyEvent</module>
<modulesummary>Functions for wxKeyEvent class</modulesummary>
<description><p>This event class contains information about key press and release events.
      </p><p>The main information carried by this event is the key being pressed or released. It can be accessed using either <seemfa marker="#getKeyCode/1"><c>getKeyCode/1</c></seemfa> function or <seemfa marker="#getUnicodeKey/1"><c>getUnicodeKey/1</c></seemfa>. For the printable characters, the latter should be used as it works for any keys, including non-Latin-1 characters that can be entered when using national keyboard layouts. <seemfa marker="#getKeyCode/1"><c>getKeyCode/1</c></seemfa> should be used to handle special characters (such as cursor arrows keys or <c>HOME</c> or <c>INS</c> and so on) which correspond to ?wxKeyCode enum elements above the <c>WXK_START</c> constant. While <seemfa marker="#getKeyCode/1"><c>getKeyCode/1</c></seemfa> also returns the character code for Latin-1 keys for compatibility, it doesn't work for Unicode characters in general and will return <c>WXK_NONE</c> for any non-Latin-1 ones. For this reason, it's recommended to always use <seemfa marker="#getUnicodeKey/1"><c>getUnicodeKey/1</c></seemfa> and only fall back to <seemfa marker="#getKeyCode/1"><c>getKeyCode/1</c></seemfa> if <seemfa marker="#getUnicodeKey/1"><c>getUnicodeKey/1</c></seemfa> returned <c>WXK_NONE</c> meaning that the event corresponds to a non-printable special keys.
      </p><p>While both of these functions can be used with the events of <c>wxEVT_KEY_DOWN</c>, <c>wxEVT_KEY_UP</c> and <c>wxEVT_CHAR</c> types, the values returned by them are different for the first two events and the last one. For the latter, the key returned corresponds to the character that would appear in e.g. a text zone if the user pressed the key in it. As such, its value depends on the current state of the Shift key and, for the letters, on the state of Caps Lock modifier. For example, if <c>A</c> key is pressed without Shift being held down, <seeerl marker="wxKeyEvent"><c>wxKeyEvent</c></seeerl> of type <c>wxEVT_CHAR</c> generated for this key press will return (from either <seemfa marker="#getKeyCode/1"><c>getKeyCode/1</c></seemfa> or <seemfa marker="#getUnicodeKey/1"><c>getUnicodeKey/1</c></seemfa> as their meanings coincide for ASCII characters) key code of 97 corresponding the ASCII value of <c>a</c>. And if the same key is pressed but with Shift being held (or Caps Lock being active), then the key could would be 65, i.e. ASCII value of capital <c>A</c>.
      </p><p>However for the key down and up events the returned key code will instead be <c>A</c> independently of the state of the modifier keys i.e. it depends only on physical key being pressed and is not translated to its logical representation using the current keyboard state. Such untranslated key codes are defined as follows:
      </p><p>Notice that the first rule applies to all Unicode letters, not just the usual Latin-1 ones. However for non-Latin-1 letters only <seemfa marker="#getUnicodeKey/1"><c>getUnicodeKey/1</c></seemfa> can be used to retrieve the key code as <seemfa marker="#getKeyCode/1"><c>getKeyCode/1</c></seemfa> just returns <c>WXK_NONE</c> in this case.
      </p><p>To summarize: you should handle <c>wxEVT_CHAR</c> if you need the translated key and <c>wxEVT_KEY_DOWN</c> if you only need the value of the key itself, independent of the current keyboard state.
      </p><p>Note: Not all key down events may be generated by the user. As an example, <c>wxEVT_KEY_DOWN</c> with <c>=</c> key code can be generated using the standard US keyboard layout but not using the German one because the <c>=</c> key corresponds to Shift-0 key combination in this layout and the key code for it is <c>0</c>, not <c>=</c>. Because of this you should avoid requiring your users to type key events that might be impossible to enter on their keyboard.
      </p><p> Another difference between key and char events is that another kind of translation is done for the latter ones when the Control key is pressed: char events for ASCII letters in this case carry codes corresponding to the ASCII value of Ctrl-Latter, i.e. 1 for Ctrl-A, 2 for Ctrl-B and so on until 26 for Ctrl-Z. This is convenient for terminal-like applications and can be completely ignored by all the other ones (if you need to handle Ctrl-A it is probably a better idea to use the key event rather than the char one). Notice that currently no translation is done for the presses of [, <c>\</c>, ], <c>^</c> and <c>_</c> keys which might be mapped to ASCII values from 27 to 31. Since version 2.9.2, the enum values <c>WXK_CONTROL_A</c> - <c>WXK_CONTROL_Z</c> can be used instead of the non-descriptive constant values 1-26.
      </p><p>Finally, modifier keys only generate key events but no char events at all. The modifiers keys are <c>WXK_SHIFT</c>, <c>WXK_CONTROL</c>, <c>WXK_ALT</c> and various <c>WXK_WINDOWS_XXX</c> from ?wxKeyCode enum.
      </p><p>Modifier keys events are special in one additional aspect: usually the keyboard state associated with a key press is well defined, e.g. <seemfa marker="#shiftDown/1"><c>shiftDown/1</c></seemfa> returns <c>true</c> only if the Shift key was held pressed when the key that generated this event itself was pressed. There is an ambiguity for the key press events for Shift key itself however. By convention, it is considered to be already pressed when it is pressed and already released when it is released. In other words, <c>wxEVT_KEY_DOWN</c> event for the Shift key itself will have <c>wxMOD_SHIFT</c> in <seemfa marker="#getModifiers/1"><c>getModifiers/1</c></seemfa> and <seemfa marker="#shiftDown/1"><c>shiftDown/1</c></seemfa> will return true while the <c>wxEVT_KEY_UP</c> event for Shift itself will not have <c>wxMOD_SHIFT</c> in its modifiers and <seemfa marker="#shiftDown/1"><c>shiftDown/1</c></seemfa> will return false.
      </p><p><c>Tip:</c> You may discover the key codes and modifiers generated by all the keys on your system interactively by running the page_samples_keyboard wxWidgets sample and pressing some keys in it.
      </p><p>Note: If a key down (<c>EVT_KEY_DOWN</c>) event is caught and the event handler does not call <c>event.Skip()</c> then the corresponding char event (<c>EVT_CHAR</c>) will not happen. This is by design and enables the programs that handle both types of events to avoid processing the same key twice. As a consequence, if you do not want to suppress the <c>wxEVT_CHAR</c> events for the keys you handle, always call <c>event.Skip()</c> in your <c>wxEVT_KEY_DOWN</c> handler. Not doing may also prevent accelerators defined using this key from working.
      </p><p>Note: If a key is maintained in a pressed state, you will typically get a lot of (automatically generated) key down events but only one key up one at the end when the key is released so it is wrong to assume that there is one up event corresponding to each down one.
      </p><p>Note: For Windows programmers: The key and char events in wxWidgets are similar to but slightly different from Windows <c>WM_KEYDOWN</c> and <c>WM_CHAR</c> events. In particular, Alt-x combination will generate a char event in wxWidgets (unless it is used as an accelerator) and almost all keys, including ones without ASCII equivalents, generate char events too.
      </p><p>See: <c>wxKeyboardState</c> (not implemented in wx)
      </p>
  <p>This class is derived (and can use functions) from: 
    <seeerl marker="wxEvent"><c>wxEvent</c></seeerl></p>
  
  <p>wxWidgets docs: <url href="https://docs.wxwidgets.org/3.1/classwx_key_event.html">wxKeyEvent</url></p>
  </description><section><title>Events</title><p>Use <seemfa marker="wxEvtHandler#connect/3"><c>wxEvtHandler:connect/3</c></seemfa> with <seetype marker="#wxKeyEventType"><c>wxKeyEventType</c></seetype> to subscribe to events of this type.</p></section>
<datatypes>
    <datatype><name name="wxKeyEvent"/></datatype>
    <datatype><name name="wxKey"/></datatype>
    <datatype><name name="wxKeyEventType"/></datatype></datatypes>

<funcs>
  <func>
    <name name="altDown" arity="1" clause_i="1" since=""/>
    <fsummary>Returns true if the Alt key is pressed. </fsummary>
    <desc><p>Returns true if the Alt key is pressed. 
      </p><p>Notice that <seemfa marker="#getModifiers/1"><c>getModifiers/1</c></seemfa> should usually be used instead of this one. 
      </p></desc>
  </func>
  
  <func>
    <name name="cmdDown" arity="1" clause_i="1" since=""/>
    <fsummary>Returns true if the key used for command accelerators is pressed. </fsummary>
    <desc><p>Returns true if the key used for command accelerators is pressed. 
      </p><p>Same as <seemfa marker="#controlDown/1"><c>controlDown/1</c></seemfa>. Deprecated.
      </p><p>Notice that <seemfa marker="#getModifiers/1"><c>getModifiers/1</c></seemfa> should usually be used instead of this one. 
      </p></desc>
  </func>
  
  <func>
    <name name="controlDown" arity="1" clause_i="1" since=""/>
    <fsummary>Returns true if the Control key or Apple/Command key under macOS is pressed. </fsummary>
    <desc><p>Returns true if the Control key or Apple/Command key under macOS is pressed. 
      </p><p>This function doesn't distinguish between right and left control keys.
      </p><p>Notice that <seemfa marker="#getModifiers/1"><c>getModifiers/1</c></seemfa> should usually be used instead of this one. 
      </p></desc>
  </func>
  
  <func>
    <name name="getKeyCode" arity="1" clause_i="1" since=""/>
    <fsummary>Returns the key code of the key that generated this event. </fsummary>
    <desc><p>Returns the key code of the key that generated this event. 
      </p><p>ASCII symbols return normal ASCII values, while events from special keys such as "left cursor arrow" (<c>WXK_LEFT</c>) return values outside of the ASCII range. See ?wxKeyCode for a full list of the virtual key codes.
      </p><p>Note that this method returns a meaningful value only for special non-alphanumeric keys or if the user entered a Latin-1 character (this includes ASCII and the accented letters found in Western European languages but not letters of other alphabets such as e.g. Cyrillic). Otherwise it simply method returns <c>WXK_NONE</c> and <seemfa marker="#getUnicodeKey/1"><c>getUnicodeKey/1</c></seemfa> should be used to obtain the corresponding Unicode character.
      </p><p>Using <seemfa marker="#getUnicodeKey/1"><c>getUnicodeKey/1</c></seemfa> is in general the right thing to do if you are interested in the characters typed by the user, <seemfa marker="#getKeyCode/1"><c>getKeyCode/1</c></seemfa> should be only used for special keys (for which <seemfa marker="#getUnicodeKey/1"><c>getUnicodeKey/1</c></seemfa> returns <c>WXK_NONE</c>). To handle both kinds of keys you might write: 
      </p></desc>
  </func>
  
  <func>
    <name name="getModifiers" arity="1" clause_i="1" since=""/>
    <fsummary>Return the bit mask of all pressed modifier keys. </fsummary>
    <desc><p>Return the bit mask of all pressed modifier keys. 
      </p><p>The return value is a combination of <c>wxMOD_ALT</c>, <c>wxMOD_CONTROL</c>, <c>wxMOD_SHIFT</c> and <c>wxMOD_META</c> bit masks. Additionally, <c>wxMOD_NONE</c> is defined as 0, i.e. corresponds to no modifiers (see <c>HasAnyModifiers()</c> (not implemented in wx)) and <c>wxMOD_CMD</c> is either <c>wxMOD_CONTROL</c> (MSW and Unix) or <c>wxMOD_META</c> (Mac), see <seemfa marker="#cmdDown/1"><c>cmdDown/1</c></seemfa>. See ?wxKeyModifier for the full list of modifiers.
      </p><p>Notice that this function is easier to use correctly than, for example, <seemfa marker="#controlDown/1"><c>controlDown/1</c></seemfa> because when using the latter you also have to remember to test that none of the other modifiers is pressed:
      </p><p>and forgetting to do it can result in serious program bugs (e.g. program not working with European keyboard layout where <c>AltGr</c> key which is seen by the program as combination of CTRL and ALT is used). On the other hand, you can simply write:
      </p><p>with this function. 
      </p></desc>
  </func>
  
  <func>
    <name name="getPosition" arity="1" clause_i="1" since=""/>
    <fsummary>Obtains the position (in client coordinates) at which the key was pressed. </fsummary>
    <desc><p>Obtains the position (in client coordinates) at which the key was pressed. 
      </p><p>Notice that under most platforms this position is simply the current mouse pointer position and has no special relationship to the key event itself.
      </p><p><c>x</c> and <c>y</c> may be NULL if the corresponding coordinate is not needed. 
      </p></desc>
  </func>
  
  <func>
    <name name="getRawKeyCode" arity="1" clause_i="1" since=""/>
    <fsummary>Returns the raw key code for this event. </fsummary>
    <desc><p>Returns the raw key code for this event. 
      </p><p>The flags are platform-dependent and should only be used if the functionality provided by other <seeerl marker="wxKeyEvent"><c>wxKeyEvent</c></seeerl> methods is insufficient.
      </p><p>Under MSW, the raw key code is the value of <c>wParam</c> parameter of the corresponding message.
      </p><p>Under GTK, the raw key code is the <c>keyval</c> field of the corresponding GDK event.
      </p><p>Under macOS, the raw key code is the <c>keyCode</c> field of the corresponding NSEvent.
      </p><p>Note: Currently the raw key codes are not supported by all ports, use #ifdef wxHAS_RAW_KEY_CODES to determine if this feature is available. 
      </p></desc>
  </func>
  
  <func>
    <name name="getRawKeyFlags" arity="1" clause_i="1" since=""/>
    <fsummary>Returns the low level key flags for this event. </fsummary>
    <desc><p>Returns the low level key flags for this event. 
      </p><p>The flags are platform-dependent and should only be used if the functionality provided by other <seeerl marker="wxKeyEvent"><c>wxKeyEvent</c></seeerl> methods is insufficient.
      </p><p>Under MSW, the raw flags are just the value of <c>lParam</c> parameter of the corresponding message.
      </p><p>Under GTK, the raw flags contain the <c>hardware_keycode</c> field of the corresponding GDK event.
      </p><p>Under macOS, the raw flags contain the modifiers state.
      </p><p>Note: Currently the raw key flags are not supported by all ports, use #ifdef wxHAS_RAW_KEY_CODES to determine if this feature is available. 
      </p></desc>
  </func>
  
  <func>
    <name name="getUnicodeKey" arity="1" clause_i="1" since=""/>
    <fsummary>Returns the Unicode character corresponding to this key event. </fsummary>
    <desc><p>Returns the Unicode character corresponding to this key event. 
      </p><p>If the key pressed doesn't have any character value (e.g. a cursor key) this method will return <c>WXK_NONE</c>. In this case you should use <seemfa marker="#getKeyCode/1"><c>getKeyCode/1</c></seemfa> to retrieve the value of the key.
      </p><p>This function is only available in Unicode build, i.e. when <c>wxUSE_UNICODE</c> is 1. 
      </p></desc>
  </func>
  
  <func>
    <name name="getX" arity="1" clause_i="1" since=""/>
    <fsummary>Returns the X position (in client coordinates) of the event. </fsummary>
    <desc><p>Returns the X position (in client coordinates) of the event. 
      </p><p>See: <seemfa marker="#getPosition/1"><c>getPosition/1</c></seemfa>
      </p></desc>
  </func>
  
  <func>
    <name name="getY" arity="1" clause_i="1" since=""/>
    <fsummary>Returns the Y position (in client coordinates) of the event. </fsummary>
    <desc><p>Returns the Y position (in client coordinates) of the event. 
      </p><p>See: <seemfa marker="#getPosition/1"><c>getPosition/1</c></seemfa>
      </p></desc>
  </func>
  
  <func>
    <name name="hasModifiers" arity="1" clause_i="1" since=""/>
    <fsummary>Returns true if Control or Alt are pressed. </fsummary>
    <desc><p>Returns true if Control or Alt are pressed. 
      </p><p>Checks if Control, Alt or, under macOS only, Command key are pressed (notice that the real Control key is still taken into account under OS X too).
      </p><p>This method returns false if only Shift is pressed for compatibility reasons and also because pressing Shift usually doesn't change the interpretation of key events, see <c>HasAnyModifiers()</c> (not implemented in wx) if you want to take Shift into account as well. 
      </p></desc>
  </func>
  
  <func>
    <name name="metaDown" arity="1" clause_i="1" since=""/>
    <fsummary>Returns true if the Meta/Windows/Apple key is pressed. </fsummary>
    <desc><p>Returns true if the Meta/Windows/Apple key is pressed. 
      </p><p>This function tests the state of the key traditionally called Meta under Unix systems, Windows keys under MSW Notice that <seemfa marker="#getModifiers/1"><c>getModifiers/1</c></seemfa> should usually be used instead of this one.
      </p><p>See: <seemfa marker="#cmdDown/1"><c>cmdDown/1</c></seemfa>
      </p></desc>
  </func>
  
  <func>
    <name name="shiftDown" arity="1" clause_i="1" since=""/>
    <fsummary>Returns true if the Shift key is pressed. </fsummary>
    <desc><p>Returns true if the Shift key is pressed. 
      </p><p>This function doesn't distinguish between right and left shift keys.
      </p><p>Notice that <seemfa marker="#getModifiers/1"><c>getModifiers/1</c></seemfa> should usually be used instead of this one. 
      </p></desc>
  </func>
  </funcs>
</erlref>
