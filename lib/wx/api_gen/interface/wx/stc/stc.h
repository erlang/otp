/////////////////////////////////////////////////////////////////////////////
// Name:        stc/stc.h
// Purpose:     interface of wxStyledTextCtrl
// Author:      wxWidgets team
// Licence:     wxWindows licence
/////////////////////////////////////////////////////////////////////////////

/*
    IMPORTANT: This file is generated by src/stc/gen_iface.py from
               src/stc/stc.interface.h.in.  Do not edit the file in
               interface/wx/stc or your changes will be lost.
*/


// STC constants {{{

#define wxSTC_INVALID_POSITION -1

/// Define start of Scintilla messages to be greater than all Windows edit (EM_*) messages
/// as many EM_ messages can be used although that use is deprecated.
#define wxSTC_START 2000
#define wxSTC_OPTIONAL_START 3000
#define wxSTC_LEXER_START 4000
#define wxSTC_WS_INVISIBLE 0
#define wxSTC_WS_VISIBLEALWAYS 1
#define wxSTC_WS_VISIBLEAFTERINDENT 2
#define wxSTC_WS_VISIBLEONLYININDENT 3
#define wxSTC_TD_LONGARROW 0
#define wxSTC_TD_STRIKEOUT 1
#define wxSTC_EOL_CRLF 0
#define wxSTC_EOL_CR 1
#define wxSTC_EOL_LF 2

/// The SC_CP_UTF8 value can be used to enter Unicode mode.
/// This is the same value as CP_UTF8 in Windows
#define wxSTC_CP_UTF8 65001
#define wxSTC_IME_WINDOWED 0
#define wxSTC_IME_INLINE 1
#define wxSTC_MARKER_MAX 31
#define wxSTC_MARK_CIRCLE 0
#define wxSTC_MARK_ROUNDRECT 1
#define wxSTC_MARK_ARROW 2
#define wxSTC_MARK_SMALLRECT 3
#define wxSTC_MARK_SHORTARROW 4
#define wxSTC_MARK_EMPTY 5
#define wxSTC_MARK_ARROWDOWN 6
#define wxSTC_MARK_MINUS 7
#define wxSTC_MARK_PLUS 8

/// Shapes used for outlining column.
#define wxSTC_MARK_VLINE 9
#define wxSTC_MARK_LCORNER 10
#define wxSTC_MARK_TCORNER 11
#define wxSTC_MARK_BOXPLUS 12
#define wxSTC_MARK_BOXPLUSCONNECTED 13
#define wxSTC_MARK_BOXMINUS 14
#define wxSTC_MARK_BOXMINUSCONNECTED 15
#define wxSTC_MARK_LCORNERCURVE 16
#define wxSTC_MARK_TCORNERCURVE 17
#define wxSTC_MARK_CIRCLEPLUS 18
#define wxSTC_MARK_CIRCLEPLUSCONNECTED 19
#define wxSTC_MARK_CIRCLEMINUS 20
#define wxSTC_MARK_CIRCLEMINUSCONNECTED 21

/// Invisible mark that only sets the line background colour.
#define wxSTC_MARK_BACKGROUND 22
#define wxSTC_MARK_DOTDOTDOT 23
#define wxSTC_MARK_ARROWS 24
#define wxSTC_MARK_PIXMAP 25
#define wxSTC_MARK_FULLRECT 26
#define wxSTC_MARK_LEFTRECT 27
#define wxSTC_MARK_AVAILABLE 28
#define wxSTC_MARK_UNDERLINE 29
#define wxSTC_MARK_RGBAIMAGE 30
#define wxSTC_MARK_BOOKMARK 31
#define wxSTC_MARK_CHARACTER 10000

/// Markers used for outlining column.
#define wxSTC_MARKNUM_FOLDEREND 25
#define wxSTC_MARKNUM_FOLDEROPENMID 26
#define wxSTC_MARKNUM_FOLDERMIDTAIL 27
#define wxSTC_MARKNUM_FOLDERTAIL 28
#define wxSTC_MARKNUM_FOLDERSUB 29
#define wxSTC_MARKNUM_FOLDER 30
#define wxSTC_MARKNUM_FOLDEROPEN 31
#define wxSTC_MASK_FOLDERS 0xFE000000
#define wxSTC_MAX_MARGIN 4
#define wxSTC_MARGIN_SYMBOL 0
#define wxSTC_MARGIN_NUMBER 1
#define wxSTC_MARGIN_BACK 2
#define wxSTC_MARGIN_FORE 3
#define wxSTC_MARGIN_TEXT 4
#define wxSTC_MARGIN_RTEXT 5
#define wxSTC_MARGIN_COLOUR 6

/// Styles in range 32..38 are predefined for parts of the UI and are not used as normal styles.
/// Style 39 is for future use.
#define wxSTC_STYLE_DEFAULT 32
#define wxSTC_STYLE_LINENUMBER 33
#define wxSTC_STYLE_BRACELIGHT 34
#define wxSTC_STYLE_BRACEBAD 35
#define wxSTC_STYLE_CONTROLCHAR 36
#define wxSTC_STYLE_INDENTGUIDE 37
#define wxSTC_STYLE_CALLTIP 38
#define wxSTC_STYLE_FOLDDISPLAYTEXT 39
#define wxSTC_STYLE_LASTPREDEFINED 39
#define wxSTC_STYLE_MAX 255

/// Character set identifiers are used in StyleSetCharacterSet.
/// The values are the same as the Windows *_CHARSET values.
#define wxSTC_CHARSET_ANSI 0
#define wxSTC_CHARSET_DEFAULT 1
#define wxSTC_CHARSET_BALTIC 186
#define wxSTC_CHARSET_CHINESEBIG5 136
#define wxSTC_CHARSET_EASTEUROPE 238
#define wxSTC_CHARSET_GB2312 134
#define wxSTC_CHARSET_GREEK 161
#define wxSTC_CHARSET_HANGUL 129
#define wxSTC_CHARSET_MAC 77
#define wxSTC_CHARSET_OEM 255
#define wxSTC_CHARSET_RUSSIAN 204
#define wxSTC_CHARSET_OEM866 866
#define wxSTC_CHARSET_CYRILLIC 1251
#define wxSTC_CHARSET_SHIFTJIS 128
#define wxSTC_CHARSET_SYMBOL 2
#define wxSTC_CHARSET_TURKISH 162
#define wxSTC_CHARSET_JOHAB 130
#define wxSTC_CHARSET_HEBREW 177
#define wxSTC_CHARSET_ARABIC 178
#define wxSTC_CHARSET_VIETNAMESE 163
#define wxSTC_CHARSET_THAI 222
#define wxSTC_CHARSET_8859_15 1000
#define wxSTC_CASE_MIXED 0
#define wxSTC_CASE_UPPER 1
#define wxSTC_CASE_LOWER 2
#define wxSTC_CASE_CAMEL 3
#define wxSTC_FONT_SIZE_MULTIPLIER 100
#define wxSTC_WEIGHT_NORMAL 400
#define wxSTC_WEIGHT_SEMIBOLD 600
#define wxSTC_WEIGHT_BOLD 700

/// Indicator style enumeration and some constants
#define wxSTC_INDIC_PLAIN 0
#define wxSTC_INDIC_SQUIGGLE 1
#define wxSTC_INDIC_TT 2
#define wxSTC_INDIC_DIAGONAL 3
#define wxSTC_INDIC_STRIKE 4
#define wxSTC_INDIC_HIDDEN 5
#define wxSTC_INDIC_BOX 6
#define wxSTC_INDIC_ROUNDBOX 7
#define wxSTC_INDIC_STRAIGHTBOX 8
#define wxSTC_INDIC_DASH 9
#define wxSTC_INDIC_DOTS 10
#define wxSTC_INDIC_SQUIGGLELOW 11
#define wxSTC_INDIC_DOTBOX 12
#define wxSTC_INDIC_SQUIGGLEPIXMAP 13
#define wxSTC_INDIC_COMPOSITIONTHICK 14
#define wxSTC_INDIC_COMPOSITIONTHIN 15
#define wxSTC_INDIC_FULLBOX 16
#define wxSTC_INDIC_TEXTFORE 17
#define wxSTC_INDIC_POINT 18
#define wxSTC_INDIC_POINTCHARACTER 19
#define wxSTC_INDIC_IME 32
#define wxSTC_INDIC_IME_MAX 35
#define wxSTC_INDIC_MAX 35
#define wxSTC_INDIC_CONTAINER 8
#define wxSTC_INDICVALUEBIT 0x1000000
#define wxSTC_INDICVALUEMASK 0xFFFFFF
#define wxSTC_INDICFLAG_VALUEFORE 1
#define wxSTC_IV_NONE 0
#define wxSTC_IV_REAL 1
#define wxSTC_IV_LOOKFORWARD 2
#define wxSTC_IV_LOOKBOTH 3

/// PrintColourMode - use same colours as screen.
#define wxSTC_PRINT_NORMAL 0

/// PrintColourMode - invert the light value of each style for printing.
#define wxSTC_PRINT_INVERTLIGHT 1

/// PrintColourMode - force black text on white background for printing.
#define wxSTC_PRINT_BLACKONWHITE 2

/// PrintColourMode - text stays coloured, but all background is forced to be white for printing.
#define wxSTC_PRINT_COLOURONWHITE 3

/// PrintColourMode - only the default-background is forced to be white for printing.
#define wxSTC_PRINT_COLOURONWHITEDEFAULTBG 4
#define wxSTC_FIND_WHOLEWORD 0x2
#define wxSTC_FIND_MATCHCASE 0x4
#define wxSTC_FIND_WORDSTART 0x00100000
#define wxSTC_FIND_REGEXP 0x00200000
#define wxSTC_FIND_POSIX 0x00400000
#define wxSTC_FOLDLEVELBASE 0x400
#define wxSTC_FOLDLEVELWHITEFLAG 0x1000
#define wxSTC_FOLDLEVELHEADERFLAG 0x2000
#define wxSTC_FOLDLEVELNUMBERMASK 0x0FFF
#define wxSTC_FOLDDISPLAYTEXT_HIDDEN 0
#define wxSTC_FOLDDISPLAYTEXT_STANDARD 1
#define wxSTC_FOLDDISPLAYTEXT_BOXED 2
#define wxSTC_FOLDACTION_CONTRACT 0
#define wxSTC_FOLDACTION_EXPAND 1
#define wxSTC_FOLDACTION_TOGGLE 2
#define wxSTC_AUTOMATICFOLD_SHOW 0x0001
#define wxSTC_AUTOMATICFOLD_CLICK 0x0002
#define wxSTC_AUTOMATICFOLD_CHANGE 0x0004
#define wxSTC_FOLDFLAG_LINEBEFORE_EXPANDED 0x0002
#define wxSTC_FOLDFLAG_LINEBEFORE_CONTRACTED 0x0004
#define wxSTC_FOLDFLAG_LINEAFTER_EXPANDED 0x0008
#define wxSTC_FOLDFLAG_LINEAFTER_CONTRACTED 0x0010
#define wxSTC_FOLDFLAG_LEVELNUMBERS 0x0040
#define wxSTC_FOLDFLAG_LINESTATE 0x0080
#define wxSTC_TIME_FOREVER 10000000
#define wxSTC_IDLESTYLING_NONE 0
#define wxSTC_IDLESTYLING_TOVISIBLE 1
#define wxSTC_IDLESTYLING_AFTERVISIBLE 2
#define wxSTC_IDLESTYLING_ALL 3
#define wxSTC_WRAP_NONE 0
#define wxSTC_WRAP_WORD 1
#define wxSTC_WRAP_CHAR 2
#define wxSTC_WRAP_WHITESPACE 3
#define wxSTC_WRAPVISUALFLAG_NONE 0x0000
#define wxSTC_WRAPVISUALFLAG_END 0x0001
#define wxSTC_WRAPVISUALFLAG_START 0x0002
#define wxSTC_WRAPVISUALFLAG_MARGIN 0x0004
#define wxSTC_WRAPVISUALFLAGLOC_DEFAULT 0x0000
#define wxSTC_WRAPVISUALFLAGLOC_END_BY_TEXT 0x0001
#define wxSTC_WRAPVISUALFLAGLOC_START_BY_TEXT 0x0002
#define wxSTC_WRAPINDENT_FIXED 0
#define wxSTC_WRAPINDENT_SAME 1
#define wxSTC_WRAPINDENT_INDENT 2
#define wxSTC_CACHE_NONE 0
#define wxSTC_CACHE_CARET 1
#define wxSTC_CACHE_PAGE 2
#define wxSTC_CACHE_DOCUMENT 3
#define wxSTC_PHASES_ONE 0
#define wxSTC_PHASES_TWO 1
#define wxSTC_PHASES_MULTIPLE 2

/// Control font anti-aliasing.
#define wxSTC_EFF_QUALITY_MASK 0xF
#define wxSTC_EFF_QUALITY_DEFAULT 0
#define wxSTC_EFF_QUALITY_NON_ANTIALIASED 1
#define wxSTC_EFF_QUALITY_ANTIALIASED 2
#define wxSTC_EFF_QUALITY_LCD_OPTIMIZED 3
#define wxSTC_MULTIPASTE_ONCE 0
#define wxSTC_MULTIPASTE_EACH 1
#define wxSTC_EDGE_NONE 0
#define wxSTC_EDGE_LINE 1
#define wxSTC_EDGE_BACKGROUND 2
#define wxSTC_EDGE_MULTILINE 3
#define wxSTC_POPUP_NEVER 0
#define wxSTC_POPUP_ALL 1
#define wxSTC_POPUP_TEXT 2
#define wxSTC_STATUS_OK 0
#define wxSTC_STATUS_FAILURE 1
#define wxSTC_STATUS_BADALLOC 2
#define wxSTC_STATUS_WARN_START 1000
#define wxSTC_STATUS_WARN_REGEX 1001
#define wxSTC_CURSORNORMAL -1
#define wxSTC_CURSORARROW 2
#define wxSTC_CURSORWAIT 4
#define wxSTC_CURSORREVERSEARROW 7

/// Constants for use with SetVisiblePolicy, similar to SetCaretPolicy.
#define wxSTC_VISIBLE_SLOP 0x01
#define wxSTC_VISIBLE_STRICT 0x04

/// Caret policy, used by SetXCaretPolicy and SetYCaretPolicy.
/// If CARET_SLOP is set, we can define a slop value: caretSlop.
/// This value defines an unwanted zone (UZ) where the caret is... unwanted.
/// This zone is defined as a number of pixels near the vertical margins,
/// and as a number of lines near the horizontal margins.
/// By keeping the caret away from the edges, it is seen within its context,
/// so it is likely that the identifier that the caret is on can be completely seen,
/// and that the current line is seen with some of the lines following it which are
/// often dependent on that line.
#define wxSTC_CARET_SLOP 0x01

/// If CARET_STRICT is set, the policy is enforced... strictly.
/// The caret is centred on the display if slop is not set,
/// and cannot go in the UZ if slop is set.
#define wxSTC_CARET_STRICT 0x04

/// If CARET_JUMPS is set, the display is moved more energetically
/// so the caret can move in the same direction longer before the policy is applied again.
#define wxSTC_CARET_JUMPS 0x10

/// If CARET_EVEN is not set, instead of having symmetrical UZs,
/// the left and bottom UZs are extended up to right and top UZs respectively.
/// This way, we favour the displaying of useful information: the beginning of lines,
/// where most code reside, and the lines after the caret, eg. the body of a function.
#define wxSTC_CARET_EVEN 0x08
#define wxSTC_SEL_STREAM 0
#define wxSTC_SEL_RECTANGLE 1
#define wxSTC_SEL_LINES 2
#define wxSTC_SEL_THIN 3
#define wxSTC_CASEINSENSITIVEBEHAVIOUR_RESPECTCASE 0
#define wxSTC_CASEINSENSITIVEBEHAVIOUR_IGNORECASE 1
#define wxSTC_MULTIAUTOC_ONCE 0
#define wxSTC_MULTIAUTOC_EACH 1
#define wxSTC_ORDER_PRESORTED 0
#define wxSTC_ORDER_PERFORMSORT 1
#define wxSTC_ORDER_CUSTOM 2
#define wxSTC_CARETSTICKY_OFF 0
#define wxSTC_CARETSTICKY_ON 1
#define wxSTC_CARETSTICKY_WHITESPACE 2
#define wxSTC_ALPHA_TRANSPARENT 0
#define wxSTC_ALPHA_OPAQUE 255
#define wxSTC_ALPHA_NOALPHA 256
#define wxSTC_CARETSTYLE_INVISIBLE 0
#define wxSTC_CARETSTYLE_LINE 1
#define wxSTC_CARETSTYLE_BLOCK 2
#define wxSTC_MARGINOPTION_NONE 0
#define wxSTC_MARGINOPTION_SUBLINESELECT 1
#define wxSTC_ANNOTATION_HIDDEN 0
#define wxSTC_ANNOTATION_STANDARD 1
#define wxSTC_ANNOTATION_BOXED 2
#define wxSTC_ANNOTATION_INDENTED 3
#define wxSTC_UNDO_MAY_COALESCE 1
#define wxSTC_VS_NONE 0
#define wxSTC_VS_RECTANGULARSELECTION 1
#define wxSTC_VS_USERACCESSIBLE 2
#define wxSTC_VS_NOWRAPLINESTART 4
#define wxSTC_TECHNOLOGY_DEFAULT 0
#define wxSTC_TECHNOLOGY_DIRECTWRITE 1

/// Line end types which may be used in addition to LF, CR, and CRLF
/// SC_LINE_END_TYPE_UNICODE includes U+2028 Line Separator,
/// U+2029 Paragraph Separator, and U+0085 Next Line
#define wxSTC_LINE_END_TYPE_DEFAULT 0
#define wxSTC_LINE_END_TYPE_UNICODE 1

/// Maximum value of keywordSet parameter of SetKeyWords.
#define wxSTC_KEYWORDSET_MAX 8
#define wxSTC_TYPE_BOOLEAN 0
#define wxSTC_TYPE_INTEGER 1
#define wxSTC_TYPE_STRING 2

/// Notifications
/// Type of modification and the action which caused the modification.
/// These are defined as a bit mask to make it easy to specify which notifications are wanted.
/// One bit is set from each of SC_MOD_* and SC_PERFORMED_*.
#define wxSTC_MOD_INSERTTEXT 0x1
#define wxSTC_MOD_DELETETEXT 0x2
#define wxSTC_MOD_CHANGESTYLE 0x4
#define wxSTC_MOD_CHANGEFOLD 0x8
#define wxSTC_PERFORMED_USER 0x10
#define wxSTC_PERFORMED_UNDO 0x20
#define wxSTC_PERFORMED_REDO 0x40
#define wxSTC_MULTISTEPUNDOREDO 0x80
#define wxSTC_LASTSTEPINUNDOREDO 0x100
#define wxSTC_MOD_CHANGEMARKER 0x200
#define wxSTC_MOD_BEFOREINSERT 0x400
#define wxSTC_MOD_BEFOREDELETE 0x800
#define wxSTC_MULTILINEUNDOREDO 0x1000
#define wxSTC_STARTACTION 0x2000
#define wxSTC_MOD_CHANGEINDICATOR 0x4000
#define wxSTC_MOD_CHANGELINESTATE 0x8000
#define wxSTC_MOD_CHANGEMARGIN 0x10000
#define wxSTC_MOD_CHANGEANNOTATION 0x20000
#define wxSTC_MOD_CONTAINER 0x40000
#define wxSTC_MOD_LEXERSTATE 0x80000
#define wxSTC_MOD_INSERTCHECK 0x100000
#define wxSTC_MOD_CHANGETABSTOPS 0x200000
#define wxSTC_MODEVENTMASKALL 0x3FFFFF
#define wxSTC_UPDATE_CONTENT 0x1
#define wxSTC_UPDATE_SELECTION 0x2
#define wxSTC_UPDATE_V_SCROLL 0x4
#define wxSTC_UPDATE_H_SCROLL 0x8

/// Symbolic key codes and modifier flags.
/// ASCII and other printable characters below 256.
/// Extended keys above 300.
#define wxSTC_KEY_DOWN 300
#define wxSTC_KEY_UP 301
#define wxSTC_KEY_LEFT 302
#define wxSTC_KEY_RIGHT 303
#define wxSTC_KEY_HOME 304
#define wxSTC_KEY_END 305
#define wxSTC_KEY_PRIOR 306
#define wxSTC_KEY_NEXT 307
#define wxSTC_KEY_DELETE 308
#define wxSTC_KEY_INSERT 309
#define wxSTC_KEY_ESCAPE 7
#define wxSTC_KEY_BACK 8
#define wxSTC_KEY_TAB 9
#define wxSTC_KEY_RETURN 13
#define wxSTC_KEY_ADD 310
#define wxSTC_KEY_SUBTRACT 311
#define wxSTC_KEY_DIVIDE 312
#define wxSTC_KEY_WIN 313
#define wxSTC_KEY_RWIN 314
#define wxSTC_KEY_MENU 315
#define wxSTC_KEYMOD_NORM 0
#define wxSTC_KEYMOD_SHIFT 1
#define wxSTC_KEYMOD_CTRL 2
#define wxSTC_KEYMOD_ALT 4
#define wxSTC_KEYMOD_SUPER 8
#define wxSTC_KEYMOD_META 16
#define wxSTC_AC_FILLUP 1
#define wxSTC_AC_DOUBLECLICK 2
#define wxSTC_AC_TAB 3
#define wxSTC_AC_NEWLINE 4
#define wxSTC_AC_COMMAND 5

/// For SciLexer.h
#define wxSTC_LEX_CONTAINER 0
#define wxSTC_LEX_NULL 1
#define wxSTC_LEX_PYTHON 2
#define wxSTC_LEX_CPP 3
#define wxSTC_LEX_HTML 4
#define wxSTC_LEX_XML 5
#define wxSTC_LEX_PERL 6
#define wxSTC_LEX_SQL 7
#define wxSTC_LEX_VB 8
#define wxSTC_LEX_PROPERTIES 9
#define wxSTC_LEX_ERRORLIST 10
#define wxSTC_LEX_MAKEFILE 11
#define wxSTC_LEX_BATCH 12
#define wxSTC_LEX_XCODE 13
#define wxSTC_LEX_LATEX 14
#define wxSTC_LEX_LUA 15
#define wxSTC_LEX_DIFF 16
#define wxSTC_LEX_CONF 17
#define wxSTC_LEX_PASCAL 18
#define wxSTC_LEX_AVE 19
#define wxSTC_LEX_ADA 20
#define wxSTC_LEX_LISP 21
#define wxSTC_LEX_RUBY 22
#define wxSTC_LEX_EIFFEL 23
#define wxSTC_LEX_EIFFELKW 24
#define wxSTC_LEX_TCL 25
#define wxSTC_LEX_NNCRONTAB 26
#define wxSTC_LEX_BULLANT 27
#define wxSTC_LEX_VBSCRIPT 28
#define wxSTC_LEX_BAAN 31
#define wxSTC_LEX_MATLAB 32
#define wxSTC_LEX_SCRIPTOL 33
#define wxSTC_LEX_ASM 34
#define wxSTC_LEX_CPPNOCASE 35
#define wxSTC_LEX_FORTRAN 36
#define wxSTC_LEX_F77 37
#define wxSTC_LEX_CSS 38
#define wxSTC_LEX_POV 39
#define wxSTC_LEX_LOUT 40
#define wxSTC_LEX_ESCRIPT 41
#define wxSTC_LEX_PS 42
#define wxSTC_LEX_NSIS 43
#define wxSTC_LEX_MMIXAL 44
#define wxSTC_LEX_CLW 45
#define wxSTC_LEX_CLWNOCASE 46
#define wxSTC_LEX_LOT 47
#define wxSTC_LEX_YAML 48
#define wxSTC_LEX_TEX 49
#define wxSTC_LEX_METAPOST 50
#define wxSTC_LEX_POWERBASIC 51
#define wxSTC_LEX_FORTH 52
#define wxSTC_LEX_ERLANG 53
#define wxSTC_LEX_OCTAVE 54
#define wxSTC_LEX_MSSQL 55
#define wxSTC_LEX_VERILOG 56
#define wxSTC_LEX_KIX 57
#define wxSTC_LEX_GUI4CLI 58
#define wxSTC_LEX_SPECMAN 59
#define wxSTC_LEX_AU3 60
#define wxSTC_LEX_APDL 61
#define wxSTC_LEX_BASH 62
#define wxSTC_LEX_ASN1 63
#define wxSTC_LEX_VHDL 64
#define wxSTC_LEX_CAML 65
#define wxSTC_LEX_BLITZBASIC 66
#define wxSTC_LEX_PUREBASIC 67
#define wxSTC_LEX_HASKELL 68
#define wxSTC_LEX_PHPSCRIPT 69
#define wxSTC_LEX_TADS3 70
#define wxSTC_LEX_REBOL 71
#define wxSTC_LEX_SMALLTALK 72
#define wxSTC_LEX_FLAGSHIP 73
#define wxSTC_LEX_CSOUND 74
#define wxSTC_LEX_FREEBASIC 75
#define wxSTC_LEX_INNOSETUP 76
#define wxSTC_LEX_OPAL 77
#define wxSTC_LEX_SPICE 78
#define wxSTC_LEX_D 79
#define wxSTC_LEX_CMAKE 80
#define wxSTC_LEX_GAP 81
#define wxSTC_LEX_PLM 82
#define wxSTC_LEX_PROGRESS 83
#define wxSTC_LEX_ABAQUS 84
#define wxSTC_LEX_ASYMPTOTE 85
#define wxSTC_LEX_R 86
#define wxSTC_LEX_MAGIK 87
#define wxSTC_LEX_POWERSHELL 88
#define wxSTC_LEX_MYSQL 89
#define wxSTC_LEX_PO 90
#define wxSTC_LEX_TAL 91
#define wxSTC_LEX_COBOL 92
#define wxSTC_LEX_TACL 93
#define wxSTC_LEX_SORCUS 94
#define wxSTC_LEX_POWERPRO 95
#define wxSTC_LEX_NIMROD 96
#define wxSTC_LEX_SML 97
#define wxSTC_LEX_MARKDOWN 98
#define wxSTC_LEX_TXT2TAGS 99
#define wxSTC_LEX_A68K 100
#define wxSTC_LEX_MODULA 101
#define wxSTC_LEX_COFFEESCRIPT 102
#define wxSTC_LEX_TCMD 103
#define wxSTC_LEX_AVS 104
#define wxSTC_LEX_ECL 105
#define wxSTC_LEX_OSCRIPT 106
#define wxSTC_LEX_VISUALPROLOG 107
#define wxSTC_LEX_LITERATEHASKELL 108
#define wxSTC_LEX_STTXT 109
#define wxSTC_LEX_KVIRC 110
#define wxSTC_LEX_RUST 111
#define wxSTC_LEX_DMAP 112
#define wxSTC_LEX_AS 113
#define wxSTC_LEX_DMIS 114
#define wxSTC_LEX_REGISTRY 115
#define wxSTC_LEX_BIBTEX 116
#define wxSTC_LEX_SREC 117
#define wxSTC_LEX_IHEX 118
#define wxSTC_LEX_TEHEX 119
#define wxSTC_LEX_JSON 120
#define wxSTC_LEX_EDIFACT 121

/// When a lexer specifies its language as SCLEX_AUTOMATIC it receives a
/// value assigned in sequence from SCLEX_AUTOMATIC+1.
#define wxSTC_LEX_AUTOMATIC 1000

/// Lexical states for SCLEX_PYTHON
#define wxSTC_P_DEFAULT 0
#define wxSTC_P_COMMENTLINE 1
#define wxSTC_P_NUMBER 2
#define wxSTC_P_STRING 3
#define wxSTC_P_CHARACTER 4
#define wxSTC_P_WORD 5
#define wxSTC_P_TRIPLE 6
#define wxSTC_P_TRIPLEDOUBLE 7
#define wxSTC_P_CLASSNAME 8
#define wxSTC_P_DEFNAME 9
#define wxSTC_P_OPERATOR 10
#define wxSTC_P_IDENTIFIER 11
#define wxSTC_P_COMMENTBLOCK 12
#define wxSTC_P_STRINGEOL 13
#define wxSTC_P_WORD2 14
#define wxSTC_P_DECORATOR 15

/// Lexical states for SCLEX_CPP, SCLEX_BULLANT, SCLEX_COBOL, SCLEX_TACL, SCLEX_TAL
#define wxSTC_C_DEFAULT 0
#define wxSTC_C_COMMENT 1
#define wxSTC_C_COMMENTLINE 2
#define wxSTC_C_COMMENTDOC 3
#define wxSTC_C_NUMBER 4
#define wxSTC_C_WORD 5
#define wxSTC_C_STRING 6
#define wxSTC_C_CHARACTER 7
#define wxSTC_C_UUID 8
#define wxSTC_C_PREPROCESSOR 9
#define wxSTC_C_OPERATOR 10
#define wxSTC_C_IDENTIFIER 11
#define wxSTC_C_STRINGEOL 12
#define wxSTC_C_VERBATIM 13
#define wxSTC_C_REGEX 14
#define wxSTC_C_COMMENTLINEDOC 15
#define wxSTC_C_WORD2 16
#define wxSTC_C_COMMENTDOCKEYWORD 17
#define wxSTC_C_COMMENTDOCKEYWORDERROR 18
#define wxSTC_C_GLOBALCLASS 19
#define wxSTC_C_STRINGRAW 20
#define wxSTC_C_TRIPLEVERBATIM 21
#define wxSTC_C_HASHQUOTEDSTRING 22
#define wxSTC_C_PREPROCESSORCOMMENT 23
#define wxSTC_C_PREPROCESSORCOMMENTDOC 24
#define wxSTC_C_USERLITERAL 25
#define wxSTC_C_TASKMARKER 26
#define wxSTC_C_ESCAPESEQUENCE 27

/// Lexical states for SCLEX_D
#define wxSTC_D_DEFAULT 0
#define wxSTC_D_COMMENT 1
#define wxSTC_D_COMMENTLINE 2
#define wxSTC_D_COMMENTDOC 3
#define wxSTC_D_COMMENTNESTED 4
#define wxSTC_D_NUMBER 5
#define wxSTC_D_WORD 6
#define wxSTC_D_WORD2 7
#define wxSTC_D_WORD3 8
#define wxSTC_D_TYPEDEF 9
#define wxSTC_D_STRING 10
#define wxSTC_D_STRINGEOL 11
#define wxSTC_D_CHARACTER 12
#define wxSTC_D_OPERATOR 13
#define wxSTC_D_IDENTIFIER 14
#define wxSTC_D_COMMENTLINEDOC 15
#define wxSTC_D_COMMENTDOCKEYWORD 16
#define wxSTC_D_COMMENTDOCKEYWORDERROR 17
#define wxSTC_D_STRINGB 18
#define wxSTC_D_STRINGR 19
#define wxSTC_D_WORD5 20
#define wxSTC_D_WORD6 21
#define wxSTC_D_WORD7 22

/// Lexical states for SCLEX_TCL
#define wxSTC_TCL_DEFAULT 0
#define wxSTC_TCL_COMMENT 1
#define wxSTC_TCL_COMMENTLINE 2
#define wxSTC_TCL_NUMBER 3
#define wxSTC_TCL_WORD_IN_QUOTE 4
#define wxSTC_TCL_IN_QUOTE 5
#define wxSTC_TCL_OPERATOR 6
#define wxSTC_TCL_IDENTIFIER 7
#define wxSTC_TCL_SUBSTITUTION 8
#define wxSTC_TCL_SUB_BRACE 9
#define wxSTC_TCL_MODIFIER 10
#define wxSTC_TCL_EXPAND 11
#define wxSTC_TCL_WORD 12
#define wxSTC_TCL_WORD2 13
#define wxSTC_TCL_WORD3 14
#define wxSTC_TCL_WORD4 15
#define wxSTC_TCL_WORD5 16
#define wxSTC_TCL_WORD6 17
#define wxSTC_TCL_WORD7 18
#define wxSTC_TCL_WORD8 19
#define wxSTC_TCL_COMMENT_BOX 20
#define wxSTC_TCL_BLOCK_COMMENT 21

/// Lexical states for SCLEX_HTML, SCLEX_XML
#define wxSTC_H_DEFAULT 0
#define wxSTC_H_TAG 1
#define wxSTC_H_TAGUNKNOWN 2
#define wxSTC_H_ATTRIBUTE 3
#define wxSTC_H_ATTRIBUTEUNKNOWN 4
#define wxSTC_H_NUMBER 5
#define wxSTC_H_DOUBLESTRING 6
#define wxSTC_H_SINGLESTRING 7
#define wxSTC_H_OTHER 8
#define wxSTC_H_COMMENT 9
#define wxSTC_H_ENTITY 10

/// XML and ASP
#define wxSTC_H_TAGEND 11
#define wxSTC_H_XMLSTART 12
#define wxSTC_H_XMLEND 13
#define wxSTC_H_SCRIPT 14
#define wxSTC_H_ASP 15
#define wxSTC_H_ASPAT 16
#define wxSTC_H_CDATA 17
#define wxSTC_H_QUESTION 18

/// More HTML
#define wxSTC_H_VALUE 19

/// X-Code
#define wxSTC_H_XCCOMMENT 20

/// SGML
#define wxSTC_H_SGML_DEFAULT 21
#define wxSTC_H_SGML_COMMAND 22
#define wxSTC_H_SGML_1ST_PARAM 23
#define wxSTC_H_SGML_DOUBLESTRING 24
#define wxSTC_H_SGML_SIMPLESTRING 25
#define wxSTC_H_SGML_ERROR 26
#define wxSTC_H_SGML_SPECIAL 27
#define wxSTC_H_SGML_ENTITY 28
#define wxSTC_H_SGML_COMMENT 29
#define wxSTC_H_SGML_1ST_PARAM_COMMENT 30
#define wxSTC_H_SGML_BLOCK_DEFAULT 31

/// Embedded Javascript
#define wxSTC_HJ_START 40
#define wxSTC_HJ_DEFAULT 41
#define wxSTC_HJ_COMMENT 42
#define wxSTC_HJ_COMMENTLINE 43
#define wxSTC_HJ_COMMENTDOC 44
#define wxSTC_HJ_NUMBER 45
#define wxSTC_HJ_WORD 46
#define wxSTC_HJ_KEYWORD 47
#define wxSTC_HJ_DOUBLESTRING 48
#define wxSTC_HJ_SINGLESTRING 49
#define wxSTC_HJ_SYMBOLS 50
#define wxSTC_HJ_STRINGEOL 51
#define wxSTC_HJ_REGEX 52

/// ASP Javascript
#define wxSTC_HJA_START 55
#define wxSTC_HJA_DEFAULT 56
#define wxSTC_HJA_COMMENT 57
#define wxSTC_HJA_COMMENTLINE 58
#define wxSTC_HJA_COMMENTDOC 59
#define wxSTC_HJA_NUMBER 60
#define wxSTC_HJA_WORD 61
#define wxSTC_HJA_KEYWORD 62
#define wxSTC_HJA_DOUBLESTRING 63
#define wxSTC_HJA_SINGLESTRING 64
#define wxSTC_HJA_SYMBOLS 65
#define wxSTC_HJA_STRINGEOL 66
#define wxSTC_HJA_REGEX 67

/// Embedded VBScript
#define wxSTC_HB_START 70
#define wxSTC_HB_DEFAULT 71
#define wxSTC_HB_COMMENTLINE 72
#define wxSTC_HB_NUMBER 73
#define wxSTC_HB_WORD 74
#define wxSTC_HB_STRING 75
#define wxSTC_HB_IDENTIFIER 76
#define wxSTC_HB_STRINGEOL 77

/// ASP VBScript
#define wxSTC_HBA_START 80
#define wxSTC_HBA_DEFAULT 81
#define wxSTC_HBA_COMMENTLINE 82
#define wxSTC_HBA_NUMBER 83
#define wxSTC_HBA_WORD 84
#define wxSTC_HBA_STRING 85
#define wxSTC_HBA_IDENTIFIER 86
#define wxSTC_HBA_STRINGEOL 87

/// Embedded Python
#define wxSTC_HP_START 90
#define wxSTC_HP_DEFAULT 91
#define wxSTC_HP_COMMENTLINE 92
#define wxSTC_HP_NUMBER 93
#define wxSTC_HP_STRING 94
#define wxSTC_HP_CHARACTER 95
#define wxSTC_HP_WORD 96
#define wxSTC_HP_TRIPLE 97
#define wxSTC_HP_TRIPLEDOUBLE 98
#define wxSTC_HP_CLASSNAME 99
#define wxSTC_HP_DEFNAME 100
#define wxSTC_HP_OPERATOR 101
#define wxSTC_HP_IDENTIFIER 102

/// PHP
#define wxSTC_HPHP_COMPLEX_VARIABLE 104

/// ASP Python
#define wxSTC_HPA_START 105
#define wxSTC_HPA_DEFAULT 106
#define wxSTC_HPA_COMMENTLINE 107
#define wxSTC_HPA_NUMBER 108
#define wxSTC_HPA_STRING 109
#define wxSTC_HPA_CHARACTER 110
#define wxSTC_HPA_WORD 111
#define wxSTC_HPA_TRIPLE 112
#define wxSTC_HPA_TRIPLEDOUBLE 113
#define wxSTC_HPA_CLASSNAME 114
#define wxSTC_HPA_DEFNAME 115
#define wxSTC_HPA_OPERATOR 116
#define wxSTC_HPA_IDENTIFIER 117

/// PHP
#define wxSTC_HPHP_DEFAULT 118
#define wxSTC_HPHP_HSTRING 119
#define wxSTC_HPHP_SIMPLESTRING 120
#define wxSTC_HPHP_WORD 121
#define wxSTC_HPHP_NUMBER 122
#define wxSTC_HPHP_VARIABLE 123
#define wxSTC_HPHP_COMMENT 124
#define wxSTC_HPHP_COMMENTLINE 125
#define wxSTC_HPHP_HSTRING_VARIABLE 126
#define wxSTC_HPHP_OPERATOR 127

/// Lexical states for SCLEX_PERL
#define wxSTC_PL_DEFAULT 0
#define wxSTC_PL_ERROR 1
#define wxSTC_PL_COMMENTLINE 2
#define wxSTC_PL_POD 3
#define wxSTC_PL_NUMBER 4
#define wxSTC_PL_WORD 5
#define wxSTC_PL_STRING 6
#define wxSTC_PL_CHARACTER 7
#define wxSTC_PL_PUNCTUATION 8
#define wxSTC_PL_PREPROCESSOR 9
#define wxSTC_PL_OPERATOR 10
#define wxSTC_PL_IDENTIFIER 11
#define wxSTC_PL_SCALAR 12
#define wxSTC_PL_ARRAY 13
#define wxSTC_PL_HASH 14
#define wxSTC_PL_SYMBOLTABLE 15
#define wxSTC_PL_VARIABLE_INDEXER 16
#define wxSTC_PL_REGEX 17
#define wxSTC_PL_REGSUBST 18
#define wxSTC_PL_LONGQUOTE 19
#define wxSTC_PL_BACKTICKS 20
#define wxSTC_PL_DATASECTION 21
#define wxSTC_PL_HERE_DELIM 22
#define wxSTC_PL_HERE_Q 23
#define wxSTC_PL_HERE_QQ 24
#define wxSTC_PL_HERE_QX 25
#define wxSTC_PL_STRING_Q 26
#define wxSTC_PL_STRING_QQ 27
#define wxSTC_PL_STRING_QX 28
#define wxSTC_PL_STRING_QR 29
#define wxSTC_PL_STRING_QW 30
#define wxSTC_PL_POD_VERB 31
#define wxSTC_PL_SUB_PROTOTYPE 40
#define wxSTC_PL_FORMAT_IDENT 41
#define wxSTC_PL_FORMAT 42
#define wxSTC_PL_STRING_VAR 43
#define wxSTC_PL_XLAT 44
#define wxSTC_PL_REGEX_VAR 54
#define wxSTC_PL_REGSUBST_VAR 55
#define wxSTC_PL_BACKTICKS_VAR 57
#define wxSTC_PL_HERE_QQ_VAR 61
#define wxSTC_PL_HERE_QX_VAR 62
#define wxSTC_PL_STRING_QQ_VAR 64
#define wxSTC_PL_STRING_QX_VAR 65
#define wxSTC_PL_STRING_QR_VAR 66

/// Lexical states for SCLEX_RUBY
#define wxSTC_RB_DEFAULT 0
#define wxSTC_RB_ERROR 1
#define wxSTC_RB_COMMENTLINE 2
#define wxSTC_RB_POD 3
#define wxSTC_RB_NUMBER 4
#define wxSTC_RB_WORD 5
#define wxSTC_RB_STRING 6
#define wxSTC_RB_CHARACTER 7
#define wxSTC_RB_CLASSNAME 8
#define wxSTC_RB_DEFNAME 9
#define wxSTC_RB_OPERATOR 10
#define wxSTC_RB_IDENTIFIER 11
#define wxSTC_RB_REGEX 12
#define wxSTC_RB_GLOBAL 13
#define wxSTC_RB_SYMBOL 14
#define wxSTC_RB_MODULE_NAME 15
#define wxSTC_RB_INSTANCE_VAR 16
#define wxSTC_RB_CLASS_VAR 17
#define wxSTC_RB_BACKTICKS 18
#define wxSTC_RB_DATASECTION 19
#define wxSTC_RB_HERE_DELIM 20
#define wxSTC_RB_HERE_Q 21
#define wxSTC_RB_HERE_QQ 22
#define wxSTC_RB_HERE_QX 23
#define wxSTC_RB_STRING_Q 24
#define wxSTC_RB_STRING_QQ 25
#define wxSTC_RB_STRING_QX 26
#define wxSTC_RB_STRING_QR 27
#define wxSTC_RB_STRING_QW 28
#define wxSTC_RB_WORD_DEMOTED 29
#define wxSTC_RB_STDIN 30
#define wxSTC_RB_STDOUT 31
#define wxSTC_RB_STDERR 40
#define wxSTC_RB_UPPER_BOUND 41

/// Lexical states for SCLEX_VB, SCLEX_VBSCRIPT, SCLEX_POWERBASIC, SCLEX_BLITZBASIC, SCLEX_PUREBASIC, SCLEX_FREEBASIC
#define wxSTC_B_DEFAULT 0
#define wxSTC_B_COMMENT 1
#define wxSTC_B_NUMBER 2
#define wxSTC_B_KEYWORD 3
#define wxSTC_B_STRING 4
#define wxSTC_B_PREPROCESSOR 5
#define wxSTC_B_OPERATOR 6
#define wxSTC_B_IDENTIFIER 7
#define wxSTC_B_DATE 8
#define wxSTC_B_STRINGEOL 9
#define wxSTC_B_KEYWORD2 10
#define wxSTC_B_KEYWORD3 11
#define wxSTC_B_KEYWORD4 12
#define wxSTC_B_CONSTANT 13
#define wxSTC_B_ASM 14
#define wxSTC_B_LABEL 15
#define wxSTC_B_ERROR 16
#define wxSTC_B_HEXNUMBER 17
#define wxSTC_B_BINNUMBER 18
#define wxSTC_B_COMMENTBLOCK 19
#define wxSTC_B_DOCLINE 20
#define wxSTC_B_DOCBLOCK 21
#define wxSTC_B_DOCKEYWORD 22

/// Lexical states for SCLEX_PROPERTIES
#define wxSTC_PROPS_DEFAULT 0
#define wxSTC_PROPS_COMMENT 1
#define wxSTC_PROPS_SECTION 2
#define wxSTC_PROPS_ASSIGNMENT 3
#define wxSTC_PROPS_DEFVAL 4
#define wxSTC_PROPS_KEY 5

/// Lexical states for SCLEX_LATEX
#define wxSTC_L_DEFAULT 0
#define wxSTC_L_COMMAND 1
#define wxSTC_L_TAG 2
#define wxSTC_L_MATH 3
#define wxSTC_L_COMMENT 4
#define wxSTC_L_TAG2 5
#define wxSTC_L_MATH2 6
#define wxSTC_L_COMMENT2 7
#define wxSTC_L_VERBATIM 8
#define wxSTC_L_SHORTCMD 9
#define wxSTC_L_SPECIAL 10
#define wxSTC_L_CMDOPT 11
#define wxSTC_L_ERROR 12

/// Lexical states for SCLEX_LUA
#define wxSTC_LUA_DEFAULT 0
#define wxSTC_LUA_COMMENT 1
#define wxSTC_LUA_COMMENTLINE 2
#define wxSTC_LUA_COMMENTDOC 3
#define wxSTC_LUA_NUMBER 4
#define wxSTC_LUA_WORD 5
#define wxSTC_LUA_STRING 6
#define wxSTC_LUA_CHARACTER 7
#define wxSTC_LUA_LITERALSTRING 8
#define wxSTC_LUA_PREPROCESSOR 9
#define wxSTC_LUA_OPERATOR 10
#define wxSTC_LUA_IDENTIFIER 11
#define wxSTC_LUA_STRINGEOL 12
#define wxSTC_LUA_WORD2 13
#define wxSTC_LUA_WORD3 14
#define wxSTC_LUA_WORD4 15
#define wxSTC_LUA_WORD5 16
#define wxSTC_LUA_WORD6 17
#define wxSTC_LUA_WORD7 18
#define wxSTC_LUA_WORD8 19
#define wxSTC_LUA_LABEL 20

/// Lexical states for SCLEX_ERRORLIST
#define wxSTC_ERR_DEFAULT 0
#define wxSTC_ERR_PYTHON 1
#define wxSTC_ERR_GCC 2
#define wxSTC_ERR_MS 3
#define wxSTC_ERR_CMD 4
#define wxSTC_ERR_BORLAND 5
#define wxSTC_ERR_PERL 6
#define wxSTC_ERR_NET 7
#define wxSTC_ERR_LUA 8
#define wxSTC_ERR_CTAG 9
#define wxSTC_ERR_DIFF_CHANGED 10
#define wxSTC_ERR_DIFF_ADDITION 11
#define wxSTC_ERR_DIFF_DELETION 12
#define wxSTC_ERR_DIFF_MESSAGE 13
#define wxSTC_ERR_PHP 14
#define wxSTC_ERR_ELF 15
#define wxSTC_ERR_IFC 16
#define wxSTC_ERR_IFORT 17
#define wxSTC_ERR_ABSF 18
#define wxSTC_ERR_TIDY 19
#define wxSTC_ERR_JAVA_STACK 20
#define wxSTC_ERR_VALUE 21
#define wxSTC_ERR_GCC_INCLUDED_FROM 22
#define wxSTC_ERR_ESCSEQ 23
#define wxSTC_ERR_ESCSEQ_UNKNOWN 24
#define wxSTC_ERR_ES_BLACK 40
#define wxSTC_ERR_ES_RED 41
#define wxSTC_ERR_ES_GREEN 42
#define wxSTC_ERR_ES_BROWN 43
#define wxSTC_ERR_ES_BLUE 44
#define wxSTC_ERR_ES_MAGENTA 45
#define wxSTC_ERR_ES_CYAN 46
#define wxSTC_ERR_ES_GRAY 47
#define wxSTC_ERR_ES_DARK_GRAY 48
#define wxSTC_ERR_ES_BRIGHT_RED 49
#define wxSTC_ERR_ES_BRIGHT_GREEN 50
#define wxSTC_ERR_ES_YELLOW 51
#define wxSTC_ERR_ES_BRIGHT_BLUE 52
#define wxSTC_ERR_ES_BRIGHT_MAGENTA 53
#define wxSTC_ERR_ES_BRIGHT_CYAN 54
#define wxSTC_ERR_ES_WHITE 55

/// Lexical states for SCLEX_BATCH
#define wxSTC_BAT_DEFAULT 0
#define wxSTC_BAT_COMMENT 1
#define wxSTC_BAT_WORD 2
#define wxSTC_BAT_LABEL 3
#define wxSTC_BAT_HIDE 4
#define wxSTC_BAT_COMMAND 5
#define wxSTC_BAT_IDENTIFIER 6
#define wxSTC_BAT_OPERATOR 7

/// Lexical states for SCLEX_TCMD
#define wxSTC_TCMD_DEFAULT 0
#define wxSTC_TCMD_COMMENT 1
#define wxSTC_TCMD_WORD 2
#define wxSTC_TCMD_LABEL 3
#define wxSTC_TCMD_HIDE 4
#define wxSTC_TCMD_COMMAND 5
#define wxSTC_TCMD_IDENTIFIER 6
#define wxSTC_TCMD_OPERATOR 7
#define wxSTC_TCMD_ENVIRONMENT 8
#define wxSTC_TCMD_EXPANSION 9
#define wxSTC_TCMD_CLABEL 10

/// Lexical states for SCLEX_MAKEFILE
#define wxSTC_MAKE_DEFAULT 0
#define wxSTC_MAKE_COMMENT 1
#define wxSTC_MAKE_PREPROCESSOR 2
#define wxSTC_MAKE_IDENTIFIER 3
#define wxSTC_MAKE_OPERATOR 4
#define wxSTC_MAKE_TARGET 5
#define wxSTC_MAKE_IDEOL 9

/// Lexical states for SCLEX_DIFF
#define wxSTC_DIFF_DEFAULT 0
#define wxSTC_DIFF_COMMENT 1
#define wxSTC_DIFF_COMMAND 2
#define wxSTC_DIFF_HEADER 3
#define wxSTC_DIFF_POSITION 4
#define wxSTC_DIFF_DELETED 5
#define wxSTC_DIFF_ADDED 6
#define wxSTC_DIFF_CHANGED 7

/// Lexical states for SCLEX_CONF (Apache Configuration Files Lexer)
#define wxSTC_CONF_DEFAULT 0
#define wxSTC_CONF_COMMENT 1
#define wxSTC_CONF_NUMBER 2
#define wxSTC_CONF_IDENTIFIER 3
#define wxSTC_CONF_EXTENSION 4
#define wxSTC_CONF_PARAMETER 5
#define wxSTC_CONF_STRING 6
#define wxSTC_CONF_OPERATOR 7
#define wxSTC_CONF_IP 8
#define wxSTC_CONF_DIRECTIVE 9

/// Lexical states for SCLEX_AVE, Avenue
#define wxSTC_AVE_DEFAULT 0
#define wxSTC_AVE_COMMENT 1
#define wxSTC_AVE_NUMBER 2
#define wxSTC_AVE_WORD 3
#define wxSTC_AVE_STRING 6
#define wxSTC_AVE_ENUM 7
#define wxSTC_AVE_STRINGEOL 8
#define wxSTC_AVE_IDENTIFIER 9
#define wxSTC_AVE_OPERATOR 10
#define wxSTC_AVE_WORD1 11
#define wxSTC_AVE_WORD2 12
#define wxSTC_AVE_WORD3 13
#define wxSTC_AVE_WORD4 14
#define wxSTC_AVE_WORD5 15
#define wxSTC_AVE_WORD6 16

/// Lexical states for SCLEX_ADA
#define wxSTC_ADA_DEFAULT 0
#define wxSTC_ADA_WORD 1
#define wxSTC_ADA_IDENTIFIER 2
#define wxSTC_ADA_NUMBER 3
#define wxSTC_ADA_DELIMITER 4
#define wxSTC_ADA_CHARACTER 5
#define wxSTC_ADA_CHARACTEREOL 6
#define wxSTC_ADA_STRING 7
#define wxSTC_ADA_STRINGEOL 8
#define wxSTC_ADA_LABEL 9
#define wxSTC_ADA_COMMENTLINE 10
#define wxSTC_ADA_ILLEGAL 11

/// Lexical states for SCLEX_BAAN
#define wxSTC_BAAN_DEFAULT 0
#define wxSTC_BAAN_COMMENT 1
#define wxSTC_BAAN_COMMENTDOC 2
#define wxSTC_BAAN_NUMBER 3
#define wxSTC_BAAN_WORD 4
#define wxSTC_BAAN_STRING 5
#define wxSTC_BAAN_PREPROCESSOR 6
#define wxSTC_BAAN_OPERATOR 7
#define wxSTC_BAAN_IDENTIFIER 8
#define wxSTC_BAAN_STRINGEOL 9
#define wxSTC_BAAN_WORD2 10
#define wxSTC_BAAN_WORD3 11
#define wxSTC_BAAN_WORD4 12
#define wxSTC_BAAN_WORD5 13
#define wxSTC_BAAN_WORD6 14
#define wxSTC_BAAN_WORD7 15
#define wxSTC_BAAN_WORD8 16
#define wxSTC_BAAN_WORD9 17
#define wxSTC_BAAN_TABLEDEF 18
#define wxSTC_BAAN_TABLESQL 19
#define wxSTC_BAAN_FUNCTION 20
#define wxSTC_BAAN_DOMDEF 21
#define wxSTC_BAAN_FUNCDEF 22
#define wxSTC_BAAN_OBJECTDEF 23
#define wxSTC_BAAN_DEFINEDEF 24

/// Lexical states for SCLEX_LISP
#define wxSTC_LISP_DEFAULT 0
#define wxSTC_LISP_COMMENT 1
#define wxSTC_LISP_NUMBER 2
#define wxSTC_LISP_KEYWORD 3
#define wxSTC_LISP_KEYWORD_KW 4
#define wxSTC_LISP_SYMBOL 5
#define wxSTC_LISP_STRING 6
#define wxSTC_LISP_STRINGEOL 8
#define wxSTC_LISP_IDENTIFIER 9
#define wxSTC_LISP_OPERATOR 10
#define wxSTC_LISP_SPECIAL 11
#define wxSTC_LISP_MULTI_COMMENT 12

/// Lexical states for SCLEX_EIFFEL and SCLEX_EIFFELKW
#define wxSTC_EIFFEL_DEFAULT 0
#define wxSTC_EIFFEL_COMMENTLINE 1
#define wxSTC_EIFFEL_NUMBER 2
#define wxSTC_EIFFEL_WORD 3
#define wxSTC_EIFFEL_STRING 4
#define wxSTC_EIFFEL_CHARACTER 5
#define wxSTC_EIFFEL_OPERATOR 6
#define wxSTC_EIFFEL_IDENTIFIER 7
#define wxSTC_EIFFEL_STRINGEOL 8

/// Lexical states for SCLEX_NNCRONTAB (nnCron crontab Lexer)
#define wxSTC_NNCRONTAB_DEFAULT 0
#define wxSTC_NNCRONTAB_COMMENT 1
#define wxSTC_NNCRONTAB_TASK 2
#define wxSTC_NNCRONTAB_SECTION 3
#define wxSTC_NNCRONTAB_KEYWORD 4
#define wxSTC_NNCRONTAB_MODIFIER 5
#define wxSTC_NNCRONTAB_ASTERISK 6
#define wxSTC_NNCRONTAB_NUMBER 7
#define wxSTC_NNCRONTAB_STRING 8
#define wxSTC_NNCRONTAB_ENVIRONMENT 9
#define wxSTC_NNCRONTAB_IDENTIFIER 10

/// Lexical states for SCLEX_FORTH (Forth Lexer)
#define wxSTC_FORTH_DEFAULT 0
#define wxSTC_FORTH_COMMENT 1
#define wxSTC_FORTH_COMMENT_ML 2
#define wxSTC_FORTH_IDENTIFIER 3
#define wxSTC_FORTH_CONTROL 4
#define wxSTC_FORTH_KEYWORD 5
#define wxSTC_FORTH_DEFWORD 6
#define wxSTC_FORTH_PREWORD1 7
#define wxSTC_FORTH_PREWORD2 8
#define wxSTC_FORTH_NUMBER 9
#define wxSTC_FORTH_STRING 10
#define wxSTC_FORTH_LOCALE 11

/// Lexical states for SCLEX_MATLAB
#define wxSTC_MATLAB_DEFAULT 0
#define wxSTC_MATLAB_COMMENT 1
#define wxSTC_MATLAB_COMMAND 2
#define wxSTC_MATLAB_NUMBER 3
#define wxSTC_MATLAB_KEYWORD 4

/// single quoted string
#define wxSTC_MATLAB_STRING 5
#define wxSTC_MATLAB_OPERATOR 6
#define wxSTC_MATLAB_IDENTIFIER 7
#define wxSTC_MATLAB_DOUBLEQUOTESTRING 8

/// Lexical states for SCLEX_SCRIPTOL
#define wxSTC_SCRIPTOL_DEFAULT 0
#define wxSTC_SCRIPTOL_WHITE 1
#define wxSTC_SCRIPTOL_COMMENTLINE 2
#define wxSTC_SCRIPTOL_PERSISTENT 3
#define wxSTC_SCRIPTOL_CSTYLE 4
#define wxSTC_SCRIPTOL_COMMENTBLOCK 5
#define wxSTC_SCRIPTOL_NUMBER 6
#define wxSTC_SCRIPTOL_STRING 7
#define wxSTC_SCRIPTOL_CHARACTER 8
#define wxSTC_SCRIPTOL_STRINGEOL 9
#define wxSTC_SCRIPTOL_KEYWORD 10
#define wxSTC_SCRIPTOL_OPERATOR 11
#define wxSTC_SCRIPTOL_IDENTIFIER 12
#define wxSTC_SCRIPTOL_TRIPLE 13
#define wxSTC_SCRIPTOL_CLASSNAME 14
#define wxSTC_SCRIPTOL_PREPROCESSOR 15

/// Lexical states for SCLEX_ASM, SCLEX_AS
#define wxSTC_ASM_DEFAULT 0
#define wxSTC_ASM_COMMENT 1
#define wxSTC_ASM_NUMBER 2
#define wxSTC_ASM_STRING 3
#define wxSTC_ASM_OPERATOR 4
#define wxSTC_ASM_IDENTIFIER 5
#define wxSTC_ASM_CPUINSTRUCTION 6
#define wxSTC_ASM_MATHINSTRUCTION 7
#define wxSTC_ASM_REGISTER 8
#define wxSTC_ASM_DIRECTIVE 9
#define wxSTC_ASM_DIRECTIVEOPERAND 10
#define wxSTC_ASM_COMMENTBLOCK 11
#define wxSTC_ASM_CHARACTER 12
#define wxSTC_ASM_STRINGEOL 13
#define wxSTC_ASM_EXTINSTRUCTION 14
#define wxSTC_ASM_COMMENTDIRECTIVE 15

/// Lexical states for SCLEX_FORTRAN
#define wxSTC_F_DEFAULT 0
#define wxSTC_F_COMMENT 1
#define wxSTC_F_NUMBER 2
#define wxSTC_F_STRING1 3
#define wxSTC_F_STRING2 4
#define wxSTC_F_STRINGEOL 5
#define wxSTC_F_OPERATOR 6
#define wxSTC_F_IDENTIFIER 7
#define wxSTC_F_WORD 8
#define wxSTC_F_WORD2 9
#define wxSTC_F_WORD3 10
#define wxSTC_F_PREPROCESSOR 11
#define wxSTC_F_OPERATOR2 12
#define wxSTC_F_LABEL 13
#define wxSTC_F_CONTINUATION 14

/// Lexical states for SCLEX_CSS
#define wxSTC_CSS_DEFAULT 0
#define wxSTC_CSS_TAG 1
#define wxSTC_CSS_CLASS 2
#define wxSTC_CSS_PSEUDOCLASS 3
#define wxSTC_CSS_UNKNOWN_PSEUDOCLASS 4
#define wxSTC_CSS_OPERATOR 5
#define wxSTC_CSS_IDENTIFIER 6
#define wxSTC_CSS_UNKNOWN_IDENTIFIER 7
#define wxSTC_CSS_VALUE 8
#define wxSTC_CSS_COMMENT 9
#define wxSTC_CSS_ID 10
#define wxSTC_CSS_IMPORTANT 11
#define wxSTC_CSS_DIRECTIVE 12
#define wxSTC_CSS_DOUBLESTRING 13
#define wxSTC_CSS_SINGLESTRING 14
#define wxSTC_CSS_IDENTIFIER2 15
#define wxSTC_CSS_ATTRIBUTE 16
#define wxSTC_CSS_IDENTIFIER3 17
#define wxSTC_CSS_PSEUDOELEMENT 18
#define wxSTC_CSS_EXTENDED_IDENTIFIER 19
#define wxSTC_CSS_EXTENDED_PSEUDOCLASS 20
#define wxSTC_CSS_EXTENDED_PSEUDOELEMENT 21
#define wxSTC_CSS_MEDIA 22
#define wxSTC_CSS_VARIABLE 23

/// Lexical states for SCLEX_POV
#define wxSTC_POV_DEFAULT 0
#define wxSTC_POV_COMMENT 1
#define wxSTC_POV_COMMENTLINE 2
#define wxSTC_POV_NUMBER 3
#define wxSTC_POV_OPERATOR 4
#define wxSTC_POV_IDENTIFIER 5
#define wxSTC_POV_STRING 6
#define wxSTC_POV_STRINGEOL 7
#define wxSTC_POV_DIRECTIVE 8
#define wxSTC_POV_BADDIRECTIVE 9
#define wxSTC_POV_WORD2 10
#define wxSTC_POV_WORD3 11
#define wxSTC_POV_WORD4 12
#define wxSTC_POV_WORD5 13
#define wxSTC_POV_WORD6 14
#define wxSTC_POV_WORD7 15
#define wxSTC_POV_WORD8 16

/// Lexical states for SCLEX_LOUT
#define wxSTC_LOUT_DEFAULT 0
#define wxSTC_LOUT_COMMENT 1
#define wxSTC_LOUT_NUMBER 2
#define wxSTC_LOUT_WORD 3
#define wxSTC_LOUT_WORD2 4
#define wxSTC_LOUT_WORD3 5
#define wxSTC_LOUT_WORD4 6
#define wxSTC_LOUT_STRING 7
#define wxSTC_LOUT_OPERATOR 8
#define wxSTC_LOUT_IDENTIFIER 9
#define wxSTC_LOUT_STRINGEOL 10

/// Lexical states for SCLEX_ESCRIPT
#define wxSTC_ESCRIPT_DEFAULT 0
#define wxSTC_ESCRIPT_COMMENT 1
#define wxSTC_ESCRIPT_COMMENTLINE 2
#define wxSTC_ESCRIPT_COMMENTDOC 3
#define wxSTC_ESCRIPT_NUMBER 4
#define wxSTC_ESCRIPT_WORD 5
#define wxSTC_ESCRIPT_STRING 6
#define wxSTC_ESCRIPT_OPERATOR 7
#define wxSTC_ESCRIPT_IDENTIFIER 8
#define wxSTC_ESCRIPT_BRACE 9
#define wxSTC_ESCRIPT_WORD2 10
#define wxSTC_ESCRIPT_WORD3 11

/// Lexical states for SCLEX_PS
#define wxSTC_PS_DEFAULT 0
#define wxSTC_PS_COMMENT 1
#define wxSTC_PS_DSC_COMMENT 2
#define wxSTC_PS_DSC_VALUE 3
#define wxSTC_PS_NUMBER 4
#define wxSTC_PS_NAME 5
#define wxSTC_PS_KEYWORD 6
#define wxSTC_PS_LITERAL 7
#define wxSTC_PS_IMMEVAL 8
#define wxSTC_PS_PAREN_ARRAY 9
#define wxSTC_PS_PAREN_DICT 10
#define wxSTC_PS_PAREN_PROC 11
#define wxSTC_PS_TEXT 12
#define wxSTC_PS_HEXSTRING 13
#define wxSTC_PS_BASE85STRING 14
#define wxSTC_PS_BADSTRINGCHAR 15

/// Lexical states for SCLEX_NSIS
#define wxSTC_NSIS_DEFAULT 0
#define wxSTC_NSIS_COMMENT 1
#define wxSTC_NSIS_STRINGDQ 2
#define wxSTC_NSIS_STRINGLQ 3
#define wxSTC_NSIS_STRINGRQ 4
#define wxSTC_NSIS_FUNCTION 5
#define wxSTC_NSIS_VARIABLE 6
#define wxSTC_NSIS_LABEL 7
#define wxSTC_NSIS_USERDEFINED 8
#define wxSTC_NSIS_SECTIONDEF 9
#define wxSTC_NSIS_SUBSECTIONDEF 10
#define wxSTC_NSIS_IFDEFINEDEF 11
#define wxSTC_NSIS_MACRODEF 12
#define wxSTC_NSIS_STRINGVAR 13
#define wxSTC_NSIS_NUMBER 14
#define wxSTC_NSIS_SECTIONGROUP 15
#define wxSTC_NSIS_PAGEEX 16
#define wxSTC_NSIS_FUNCTIONDEF 17
#define wxSTC_NSIS_COMMENTBOX 18

/// Lexical states for SCLEX_MMIXAL
#define wxSTC_MMIXAL_LEADWS 0
#define wxSTC_MMIXAL_COMMENT 1
#define wxSTC_MMIXAL_LABEL 2
#define wxSTC_MMIXAL_OPCODE 3
#define wxSTC_MMIXAL_OPCODE_PRE 4
#define wxSTC_MMIXAL_OPCODE_VALID 5
#define wxSTC_MMIXAL_OPCODE_UNKNOWN 6
#define wxSTC_MMIXAL_OPCODE_POST 7
#define wxSTC_MMIXAL_OPERANDS 8
#define wxSTC_MMIXAL_NUMBER 9
#define wxSTC_MMIXAL_REF 10
#define wxSTC_MMIXAL_CHAR 11
#define wxSTC_MMIXAL_STRING 12
#define wxSTC_MMIXAL_REGISTER 13
#define wxSTC_MMIXAL_HEX 14
#define wxSTC_MMIXAL_OPERATOR 15
#define wxSTC_MMIXAL_SYMBOL 16
#define wxSTC_MMIXAL_INCLUDE 17

/// Lexical states for SCLEX_CLW
#define wxSTC_CLW_DEFAULT 0
#define wxSTC_CLW_LABEL 1
#define wxSTC_CLW_COMMENT 2
#define wxSTC_CLW_STRING 3
#define wxSTC_CLW_USER_IDENTIFIER 4
#define wxSTC_CLW_INTEGER_CONSTANT 5
#define wxSTC_CLW_REAL_CONSTANT 6
#define wxSTC_CLW_PICTURE_STRING 7
#define wxSTC_CLW_KEYWORD 8
#define wxSTC_CLW_COMPILER_DIRECTIVE 9
#define wxSTC_CLW_RUNTIME_EXPRESSIONS 10
#define wxSTC_CLW_BUILTIN_PROCEDURES_FUNCTION 11
#define wxSTC_CLW_STRUCTURE_DATA_TYPE 12
#define wxSTC_CLW_ATTRIBUTE 13
#define wxSTC_CLW_STANDARD_EQUATE 14
#define wxSTC_CLW_ERROR 15
#define wxSTC_CLW_DEPRECATED 16

/// Lexical states for SCLEX_LOT
#define wxSTC_LOT_DEFAULT 0
#define wxSTC_LOT_HEADER 1
#define wxSTC_LOT_BREAK 2
#define wxSTC_LOT_SET 3
#define wxSTC_LOT_PASS 4
#define wxSTC_LOT_FAIL 5
#define wxSTC_LOT_ABORT 6

/// Lexical states for SCLEX_YAML
#define wxSTC_YAML_DEFAULT 0
#define wxSTC_YAML_COMMENT 1
#define wxSTC_YAML_IDENTIFIER 2
#define wxSTC_YAML_KEYWORD 3
#define wxSTC_YAML_NUMBER 4
#define wxSTC_YAML_REFERENCE 5
#define wxSTC_YAML_DOCUMENT 6
#define wxSTC_YAML_TEXT 7
#define wxSTC_YAML_ERROR 8
#define wxSTC_YAML_OPERATOR 9

/// Lexical states for SCLEX_TEX
#define wxSTC_TEX_DEFAULT 0
#define wxSTC_TEX_SPECIAL 1
#define wxSTC_TEX_GROUP 2
#define wxSTC_TEX_SYMBOL 3
#define wxSTC_TEX_COMMAND 4
#define wxSTC_TEX_TEXT 5
#define wxSTC_METAPOST_DEFAULT 0
#define wxSTC_METAPOST_SPECIAL 1
#define wxSTC_METAPOST_GROUP 2
#define wxSTC_METAPOST_SYMBOL 3
#define wxSTC_METAPOST_COMMAND 4
#define wxSTC_METAPOST_TEXT 5
#define wxSTC_METAPOST_EXTRA 6

/// Lexical states for SCLEX_ERLANG
#define wxSTC_ERLANG_DEFAULT 0
#define wxSTC_ERLANG_COMMENT 1
#define wxSTC_ERLANG_VARIABLE 2
#define wxSTC_ERLANG_NUMBER 3
#define wxSTC_ERLANG_KEYWORD 4
#define wxSTC_ERLANG_STRING 5
#define wxSTC_ERLANG_OPERATOR 6
#define wxSTC_ERLANG_ATOM 7
#define wxSTC_ERLANG_FUNCTION_NAME 8
#define wxSTC_ERLANG_CHARACTER 9
#define wxSTC_ERLANG_MACRO 10
#define wxSTC_ERLANG_RECORD 11
#define wxSTC_ERLANG_PREPROC 12
#define wxSTC_ERLANG_NODE_NAME 13
#define wxSTC_ERLANG_COMMENT_FUNCTION 14
#define wxSTC_ERLANG_COMMENT_MODULE 15
#define wxSTC_ERLANG_COMMENT_DOC 16
#define wxSTC_ERLANG_COMMENT_DOC_MACRO 17
#define wxSTC_ERLANG_ATOM_QUOTED 18
#define wxSTC_ERLANG_MACRO_QUOTED 19
#define wxSTC_ERLANG_RECORD_QUOTED 20
#define wxSTC_ERLANG_NODE_NAME_QUOTED 21
#define wxSTC_ERLANG_BIFS 22
#define wxSTC_ERLANG_MODULES 23
#define wxSTC_ERLANG_MODULES_ATT 24
#define wxSTC_ERLANG_UNKNOWN 31

/// Lexical states for SCLEX_OCTAVE are identical to MatLab
/// Lexical states for SCLEX_MSSQL
#define wxSTC_MSSQL_DEFAULT 0
#define wxSTC_MSSQL_COMMENT 1
#define wxSTC_MSSQL_LINE_COMMENT 2
#define wxSTC_MSSQL_NUMBER 3
#define wxSTC_MSSQL_STRING 4
#define wxSTC_MSSQL_OPERATOR 5
#define wxSTC_MSSQL_IDENTIFIER 6
#define wxSTC_MSSQL_VARIABLE 7
#define wxSTC_MSSQL_COLUMN_NAME 8
#define wxSTC_MSSQL_STATEMENT 9
#define wxSTC_MSSQL_DATATYPE 10
#define wxSTC_MSSQL_SYSTABLE 11
#define wxSTC_MSSQL_GLOBAL_VARIABLE 12
#define wxSTC_MSSQL_FUNCTION 13
#define wxSTC_MSSQL_STORED_PROCEDURE 14
#define wxSTC_MSSQL_DEFAULT_PREF_DATATYPE 15
#define wxSTC_MSSQL_COLUMN_NAME_2 16

/// Lexical states for SCLEX_VERILOG
#define wxSTC_V_DEFAULT 0
#define wxSTC_V_COMMENT 1
#define wxSTC_V_COMMENTLINE 2
#define wxSTC_V_COMMENTLINEBANG 3
#define wxSTC_V_NUMBER 4
#define wxSTC_V_WORD 5
#define wxSTC_V_STRING 6
#define wxSTC_V_WORD2 7
#define wxSTC_V_WORD3 8
#define wxSTC_V_PREPROCESSOR 9
#define wxSTC_V_OPERATOR 10
#define wxSTC_V_IDENTIFIER 11
#define wxSTC_V_STRINGEOL 12
#define wxSTC_V_USER 19
#define wxSTC_V_COMMENT_WORD 20
#define wxSTC_V_INPUT 21
#define wxSTC_V_OUTPUT 22
#define wxSTC_V_INOUT 23
#define wxSTC_V_PORT_CONNECT 24

/// Lexical states for SCLEX_KIX
#define wxSTC_KIX_DEFAULT 0
#define wxSTC_KIX_COMMENT 1
#define wxSTC_KIX_STRING1 2
#define wxSTC_KIX_STRING2 3
#define wxSTC_KIX_NUMBER 4
#define wxSTC_KIX_VAR 5
#define wxSTC_KIX_MACRO 6
#define wxSTC_KIX_KEYWORD 7
#define wxSTC_KIX_FUNCTIONS 8
#define wxSTC_KIX_OPERATOR 9
#define wxSTC_KIX_COMMENTSTREAM 10
#define wxSTC_KIX_IDENTIFIER 31

/// Lexical states for SCLEX_GUI4CLI
#define wxSTC_GC_DEFAULT 0
#define wxSTC_GC_COMMENTLINE 1
#define wxSTC_GC_COMMENTBLOCK 2
#define wxSTC_GC_GLOBAL 3
#define wxSTC_GC_EVENT 4
#define wxSTC_GC_ATTRIBUTE 5
#define wxSTC_GC_CONTROL 6
#define wxSTC_GC_COMMAND 7
#define wxSTC_GC_STRING 8
#define wxSTC_GC_OPERATOR 9

/// Lexical states for SCLEX_SPECMAN
#define wxSTC_SN_DEFAULT 0
#define wxSTC_SN_CODE 1
#define wxSTC_SN_COMMENTLINE 2
#define wxSTC_SN_COMMENTLINEBANG 3
#define wxSTC_SN_NUMBER 4
#define wxSTC_SN_WORD 5
#define wxSTC_SN_STRING 6
#define wxSTC_SN_WORD2 7
#define wxSTC_SN_WORD3 8
#define wxSTC_SN_PREPROCESSOR 9
#define wxSTC_SN_OPERATOR 10
#define wxSTC_SN_IDENTIFIER 11
#define wxSTC_SN_STRINGEOL 12
#define wxSTC_SN_REGEXTAG 13
#define wxSTC_SN_SIGNAL 14
#define wxSTC_SN_USER 19

/// Lexical states for SCLEX_AU3
#define wxSTC_AU3_DEFAULT 0
#define wxSTC_AU3_COMMENT 1
#define wxSTC_AU3_COMMENTBLOCK 2
#define wxSTC_AU3_NUMBER 3
#define wxSTC_AU3_FUNCTION 4
#define wxSTC_AU3_KEYWORD 5
#define wxSTC_AU3_MACRO 6
#define wxSTC_AU3_STRING 7
#define wxSTC_AU3_OPERATOR 8
#define wxSTC_AU3_VARIABLE 9
#define wxSTC_AU3_SENT 10
#define wxSTC_AU3_PREPROCESSOR 11
#define wxSTC_AU3_SPECIAL 12
#define wxSTC_AU3_EXPAND 13
#define wxSTC_AU3_COMOBJ 14
#define wxSTC_AU3_UDF 15

/// Lexical states for SCLEX_APDL
#define wxSTC_APDL_DEFAULT 0
#define wxSTC_APDL_COMMENT 1
#define wxSTC_APDL_COMMENTBLOCK 2
#define wxSTC_APDL_NUMBER 3
#define wxSTC_APDL_STRING 4
#define wxSTC_APDL_OPERATOR 5
#define wxSTC_APDL_WORD 6
#define wxSTC_APDL_PROCESSOR 7
#define wxSTC_APDL_COMMAND 8
#define wxSTC_APDL_SLASHCOMMAND 9
#define wxSTC_APDL_STARCOMMAND 10
#define wxSTC_APDL_ARGUMENT 11
#define wxSTC_APDL_FUNCTION 12

/// Lexical states for SCLEX_BASH
#define wxSTC_SH_DEFAULT 0
#define wxSTC_SH_ERROR 1
#define wxSTC_SH_COMMENTLINE 2
#define wxSTC_SH_NUMBER 3
#define wxSTC_SH_WORD 4
#define wxSTC_SH_STRING 5
#define wxSTC_SH_CHARACTER 6
#define wxSTC_SH_OPERATOR 7
#define wxSTC_SH_IDENTIFIER 8
#define wxSTC_SH_SCALAR 9
#define wxSTC_SH_PARAM 10
#define wxSTC_SH_BACKTICKS 11
#define wxSTC_SH_HERE_DELIM 12
#define wxSTC_SH_HERE_Q 13

/// Lexical states for SCLEX_ASN1
#define wxSTC_ASN1_DEFAULT 0
#define wxSTC_ASN1_COMMENT 1
#define wxSTC_ASN1_IDENTIFIER 2
#define wxSTC_ASN1_STRING 3
#define wxSTC_ASN1_OID 4
#define wxSTC_ASN1_SCALAR 5
#define wxSTC_ASN1_KEYWORD 6
#define wxSTC_ASN1_ATTRIBUTE 7
#define wxSTC_ASN1_DESCRIPTOR 8
#define wxSTC_ASN1_TYPE 9
#define wxSTC_ASN1_OPERATOR 10

/// Lexical states for SCLEX_VHDL
#define wxSTC_VHDL_DEFAULT 0
#define wxSTC_VHDL_COMMENT 1
#define wxSTC_VHDL_COMMENTLINEBANG 2
#define wxSTC_VHDL_NUMBER 3
#define wxSTC_VHDL_STRING 4
#define wxSTC_VHDL_OPERATOR 5
#define wxSTC_VHDL_IDENTIFIER 6
#define wxSTC_VHDL_STRINGEOL 7
#define wxSTC_VHDL_KEYWORD 8
#define wxSTC_VHDL_STDOPERATOR 9
#define wxSTC_VHDL_ATTRIBUTE 10
#define wxSTC_VHDL_STDFUNCTION 11
#define wxSTC_VHDL_STDPACKAGE 12
#define wxSTC_VHDL_STDTYPE 13
#define wxSTC_VHDL_USERWORD 14
#define wxSTC_VHDL_BLOCK_COMMENT 15

/// Lexical states for SCLEX_CAML
#define wxSTC_CAML_DEFAULT 0
#define wxSTC_CAML_IDENTIFIER 1
#define wxSTC_CAML_TAGNAME 2
#define wxSTC_CAML_KEYWORD 3
#define wxSTC_CAML_KEYWORD2 4
#define wxSTC_CAML_KEYWORD3 5
#define wxSTC_CAML_LINENUM 6
#define wxSTC_CAML_OPERATOR 7
#define wxSTC_CAML_NUMBER 8
#define wxSTC_CAML_CHAR 9
#define wxSTC_CAML_WHITE 10
#define wxSTC_CAML_STRING 11
#define wxSTC_CAML_COMMENT 12
#define wxSTC_CAML_COMMENT1 13
#define wxSTC_CAML_COMMENT2 14
#define wxSTC_CAML_COMMENT3 15

/// Lexical states for SCLEX_HASKELL
#define wxSTC_HA_DEFAULT 0
#define wxSTC_HA_IDENTIFIER 1
#define wxSTC_HA_KEYWORD 2
#define wxSTC_HA_NUMBER 3
#define wxSTC_HA_STRING 4
#define wxSTC_HA_CHARACTER 5
#define wxSTC_HA_CLASS 6
#define wxSTC_HA_MODULE 7
#define wxSTC_HA_CAPITAL 8
#define wxSTC_HA_DATA 9
#define wxSTC_HA_IMPORT 10
#define wxSTC_HA_OPERATOR 11
#define wxSTC_HA_INSTANCE 12
#define wxSTC_HA_COMMENTLINE 13
#define wxSTC_HA_COMMENTBLOCK 14
#define wxSTC_HA_COMMENTBLOCK2 15
#define wxSTC_HA_COMMENTBLOCK3 16
#define wxSTC_HA_PRAGMA 17
#define wxSTC_HA_PREPROCESSOR 18
#define wxSTC_HA_STRINGEOL 19
#define wxSTC_HA_RESERVED_OPERATOR 20
#define wxSTC_HA_LITERATE_COMMENT 21
#define wxSTC_HA_LITERATE_CODEDELIM 22

/// Lexical states of SCLEX_TADS3
#define wxSTC_T3_DEFAULT 0
#define wxSTC_T3_X_DEFAULT 1
#define wxSTC_T3_PREPROCESSOR 2
#define wxSTC_T3_BLOCK_COMMENT 3
#define wxSTC_T3_LINE_COMMENT 4
#define wxSTC_T3_OPERATOR 5
#define wxSTC_T3_KEYWORD 6
#define wxSTC_T3_NUMBER 7
#define wxSTC_T3_IDENTIFIER 8
#define wxSTC_T3_S_STRING 9
#define wxSTC_T3_D_STRING 10
#define wxSTC_T3_X_STRING 11
#define wxSTC_T3_LIB_DIRECTIVE 12
#define wxSTC_T3_MSG_PARAM 13
#define wxSTC_T3_HTML_TAG 14
#define wxSTC_T3_HTML_DEFAULT 15
#define wxSTC_T3_HTML_STRING 16
#define wxSTC_T3_USER1 17
#define wxSTC_T3_USER2 18
#define wxSTC_T3_USER3 19
#define wxSTC_T3_BRACE 20

/// Lexical states for SCLEX_REBOL
#define wxSTC_REBOL_DEFAULT 0
#define wxSTC_REBOL_COMMENTLINE 1
#define wxSTC_REBOL_COMMENTBLOCK 2
#define wxSTC_REBOL_PREFACE 3
#define wxSTC_REBOL_OPERATOR 4
#define wxSTC_REBOL_CHARACTER 5
#define wxSTC_REBOL_QUOTEDSTRING 6
#define wxSTC_REBOL_BRACEDSTRING 7
#define wxSTC_REBOL_NUMBER 8
#define wxSTC_REBOL_PAIR 9
#define wxSTC_REBOL_TUPLE 10
#define wxSTC_REBOL_BINARY 11
#define wxSTC_REBOL_MONEY 12
#define wxSTC_REBOL_ISSUE 13
#define wxSTC_REBOL_TAG 14
#define wxSTC_REBOL_FILE 15
#define wxSTC_REBOL_EMAIL 16
#define wxSTC_REBOL_URL 17
#define wxSTC_REBOL_DATE 18
#define wxSTC_REBOL_TIME 19
#define wxSTC_REBOL_IDENTIFIER 20
#define wxSTC_REBOL_WORD 21
#define wxSTC_REBOL_WORD2 22
#define wxSTC_REBOL_WORD3 23
#define wxSTC_REBOL_WORD4 24
#define wxSTC_REBOL_WORD5 25
#define wxSTC_REBOL_WORD6 26
#define wxSTC_REBOL_WORD7 27
#define wxSTC_REBOL_WORD8 28

/// Lexical states for SCLEX_SQL
#define wxSTC_SQL_DEFAULT 0
#define wxSTC_SQL_COMMENT 1
#define wxSTC_SQL_COMMENTLINE 2
#define wxSTC_SQL_COMMENTDOC 3
#define wxSTC_SQL_NUMBER 4
#define wxSTC_SQL_WORD 5
#define wxSTC_SQL_STRING 6
#define wxSTC_SQL_CHARACTER 7
#define wxSTC_SQL_SQLPLUS 8
#define wxSTC_SQL_SQLPLUS_PROMPT 9
#define wxSTC_SQL_OPERATOR 10
#define wxSTC_SQL_IDENTIFIER 11
#define wxSTC_SQL_SQLPLUS_COMMENT 13
#define wxSTC_SQL_COMMENTLINEDOC 15
#define wxSTC_SQL_WORD2 16
#define wxSTC_SQL_COMMENTDOCKEYWORD 17
#define wxSTC_SQL_COMMENTDOCKEYWORDERROR 18
#define wxSTC_SQL_USER1 19
#define wxSTC_SQL_USER2 20
#define wxSTC_SQL_USER3 21
#define wxSTC_SQL_USER4 22
#define wxSTC_SQL_QUOTEDIDENTIFIER 23
#define wxSTC_SQL_QOPERATOR 24

/// Lexical states for SCLEX_SMALLTALK
#define wxSTC_ST_DEFAULT 0
#define wxSTC_ST_STRING 1
#define wxSTC_ST_NUMBER 2
#define wxSTC_ST_COMMENT 3
#define wxSTC_ST_SYMBOL 4
#define wxSTC_ST_BINARY 5
#define wxSTC_ST_BOOL 6
#define wxSTC_ST_SELF 7
#define wxSTC_ST_SUPER 8
#define wxSTC_ST_NIL 9
#define wxSTC_ST_GLOBAL 10
#define wxSTC_ST_RETURN 11
#define wxSTC_ST_SPECIAL 12
#define wxSTC_ST_KWSEND 13
#define wxSTC_ST_ASSIGN 14
#define wxSTC_ST_CHARACTER 15
#define wxSTC_ST_SPEC_SEL 16

/// Lexical states for SCLEX_FLAGSHIP (clipper)
#define wxSTC_FS_DEFAULT 0
#define wxSTC_FS_COMMENT 1
#define wxSTC_FS_COMMENTLINE 2
#define wxSTC_FS_COMMENTDOC 3
#define wxSTC_FS_COMMENTLINEDOC 4
#define wxSTC_FS_COMMENTDOCKEYWORD 5
#define wxSTC_FS_COMMENTDOCKEYWORDERROR 6
#define wxSTC_FS_KEYWORD 7
#define wxSTC_FS_KEYWORD2 8
#define wxSTC_FS_KEYWORD3 9
#define wxSTC_FS_KEYWORD4 10
#define wxSTC_FS_NUMBER 11
#define wxSTC_FS_STRING 12
#define wxSTC_FS_PREPROCESSOR 13
#define wxSTC_FS_OPERATOR 14
#define wxSTC_FS_IDENTIFIER 15
#define wxSTC_FS_DATE 16
#define wxSTC_FS_STRINGEOL 17
#define wxSTC_FS_CONSTANT 18
#define wxSTC_FS_WORDOPERATOR 19
#define wxSTC_FS_DISABLEDCODE 20
#define wxSTC_FS_DEFAULT_C 21
#define wxSTC_FS_COMMENTDOC_C 22
#define wxSTC_FS_COMMENTLINEDOC_C 23
#define wxSTC_FS_KEYWORD_C 24
#define wxSTC_FS_KEYWORD2_C 25
#define wxSTC_FS_NUMBER_C 26
#define wxSTC_FS_STRING_C 27
#define wxSTC_FS_PREPROCESSOR_C 28
#define wxSTC_FS_OPERATOR_C 29
#define wxSTC_FS_IDENTIFIER_C 30
#define wxSTC_FS_STRINGEOL_C 31

/// Lexical states for SCLEX_CSOUND
#define wxSTC_CSOUND_DEFAULT 0
#define wxSTC_CSOUND_COMMENT 1
#define wxSTC_CSOUND_NUMBER 2
#define wxSTC_CSOUND_OPERATOR 3
#define wxSTC_CSOUND_INSTR 4
#define wxSTC_CSOUND_IDENTIFIER 5
#define wxSTC_CSOUND_OPCODE 6
#define wxSTC_CSOUND_HEADERSTMT 7
#define wxSTC_CSOUND_USERKEYWORD 8
#define wxSTC_CSOUND_COMMENTBLOCK 9
#define wxSTC_CSOUND_PARAM 10
#define wxSTC_CSOUND_ARATE_VAR 11
#define wxSTC_CSOUND_KRATE_VAR 12
#define wxSTC_CSOUND_IRATE_VAR 13
#define wxSTC_CSOUND_GLOBAL_VAR 14
#define wxSTC_CSOUND_STRINGEOL 15

/// Lexical states for SCLEX_INNOSETUP
#define wxSTC_INNO_DEFAULT 0
#define wxSTC_INNO_COMMENT 1
#define wxSTC_INNO_KEYWORD 2
#define wxSTC_INNO_PARAMETER 3
#define wxSTC_INNO_SECTION 4
#define wxSTC_INNO_PREPROC 5
#define wxSTC_INNO_INLINE_EXPANSION 6
#define wxSTC_INNO_COMMENT_PASCAL 7
#define wxSTC_INNO_KEYWORD_PASCAL 8
#define wxSTC_INNO_KEYWORD_USER 9
#define wxSTC_INNO_STRING_DOUBLE 10
#define wxSTC_INNO_STRING_SINGLE 11
#define wxSTC_INNO_IDENTIFIER 12

/// Lexical states for SCLEX_OPAL
#define wxSTC_OPAL_SPACE 0
#define wxSTC_OPAL_COMMENT_BLOCK 1
#define wxSTC_OPAL_COMMENT_LINE 2
#define wxSTC_OPAL_INTEGER 3
#define wxSTC_OPAL_KEYWORD 4
#define wxSTC_OPAL_SORT 5
#define wxSTC_OPAL_STRING 6
#define wxSTC_OPAL_PAR 7
#define wxSTC_OPAL_BOOL_CONST 8
#define wxSTC_OPAL_DEFAULT 32

/// Lexical states for SCLEX_SPICE
#define wxSTC_SPICE_DEFAULT 0
#define wxSTC_SPICE_IDENTIFIER 1
#define wxSTC_SPICE_KEYWORD 2
#define wxSTC_SPICE_KEYWORD2 3
#define wxSTC_SPICE_KEYWORD3 4
#define wxSTC_SPICE_NUMBER 5
#define wxSTC_SPICE_DELIMITER 6
#define wxSTC_SPICE_VALUE 7
#define wxSTC_SPICE_COMMENTLINE 8

/// Lexical states for SCLEX_CMAKE
#define wxSTC_CMAKE_DEFAULT 0
#define wxSTC_CMAKE_COMMENT 1
#define wxSTC_CMAKE_STRINGDQ 2
#define wxSTC_CMAKE_STRINGLQ 3
#define wxSTC_CMAKE_STRINGRQ 4
#define wxSTC_CMAKE_COMMANDS 5
#define wxSTC_CMAKE_PARAMETERS 6
#define wxSTC_CMAKE_VARIABLE 7
#define wxSTC_CMAKE_USERDEFINED 8
#define wxSTC_CMAKE_WHILEDEF 9
#define wxSTC_CMAKE_FOREACHDEF 10
#define wxSTC_CMAKE_IFDEFINEDEF 11
#define wxSTC_CMAKE_MACRODEF 12
#define wxSTC_CMAKE_STRINGVAR 13
#define wxSTC_CMAKE_NUMBER 14

/// Lexical states for SCLEX_GAP
#define wxSTC_GAP_DEFAULT 0
#define wxSTC_GAP_IDENTIFIER 1
#define wxSTC_GAP_KEYWORD 2
#define wxSTC_GAP_KEYWORD2 3
#define wxSTC_GAP_KEYWORD3 4
#define wxSTC_GAP_KEYWORD4 5
#define wxSTC_GAP_STRING 6
#define wxSTC_GAP_CHAR 7
#define wxSTC_GAP_OPERATOR 8
#define wxSTC_GAP_COMMENT 9
#define wxSTC_GAP_NUMBER 10
#define wxSTC_GAP_STRINGEOL 11

/// Lexical state for SCLEX_PLM
#define wxSTC_PLM_DEFAULT 0
#define wxSTC_PLM_COMMENT 1
#define wxSTC_PLM_STRING 2
#define wxSTC_PLM_NUMBER 3
#define wxSTC_PLM_IDENTIFIER 4
#define wxSTC_PLM_OPERATOR 5
#define wxSTC_PLM_CONTROL 6
#define wxSTC_PLM_KEYWORD 7

/// Lexical state for SCLEX_PROGRESS
#define wxSTC_ABL_DEFAULT 0
#define wxSTC_ABL_NUMBER 1
#define wxSTC_ABL_WORD 2
#define wxSTC_ABL_STRING 3
#define wxSTC_ABL_CHARACTER 4
#define wxSTC_ABL_PREPROCESSOR 5
#define wxSTC_ABL_OPERATOR 6
#define wxSTC_ABL_IDENTIFIER 7
#define wxSTC_ABL_BLOCK 8
#define wxSTC_ABL_END 9
#define wxSTC_ABL_COMMENT 10
#define wxSTC_ABL_TASKMARKER 11
#define wxSTC_ABL_LINECOMMENT 12

/// Lexical states for SCLEX_ABAQUS
#define wxSTC_ABAQUS_DEFAULT 0
#define wxSTC_ABAQUS_COMMENT 1
#define wxSTC_ABAQUS_COMMENTBLOCK 2
#define wxSTC_ABAQUS_NUMBER 3
#define wxSTC_ABAQUS_STRING 4
#define wxSTC_ABAQUS_OPERATOR 5
#define wxSTC_ABAQUS_WORD 6
#define wxSTC_ABAQUS_PROCESSOR 7
#define wxSTC_ABAQUS_COMMAND 8
#define wxSTC_ABAQUS_SLASHCOMMAND 9
#define wxSTC_ABAQUS_STARCOMMAND 10
#define wxSTC_ABAQUS_ARGUMENT 11
#define wxSTC_ABAQUS_FUNCTION 12

/// Lexical states for SCLEX_ASYMPTOTE
#define wxSTC_ASY_DEFAULT 0
#define wxSTC_ASY_COMMENT 1
#define wxSTC_ASY_COMMENTLINE 2
#define wxSTC_ASY_NUMBER 3
#define wxSTC_ASY_WORD 4
#define wxSTC_ASY_STRING 5
#define wxSTC_ASY_CHARACTER 6
#define wxSTC_ASY_OPERATOR 7
#define wxSTC_ASY_IDENTIFIER 8
#define wxSTC_ASY_STRINGEOL 9
#define wxSTC_ASY_COMMENTLINEDOC 10
#define wxSTC_ASY_WORD2 11

/// Lexical states for SCLEX_R
#define wxSTC_R_DEFAULT 0
#define wxSTC_R_COMMENT 1
#define wxSTC_R_KWORD 2
#define wxSTC_R_BASEKWORD 3
#define wxSTC_R_OTHERKWORD 4
#define wxSTC_R_NUMBER 5
#define wxSTC_R_STRING 6
#define wxSTC_R_STRING2 7
#define wxSTC_R_OPERATOR 8
#define wxSTC_R_IDENTIFIER 9
#define wxSTC_R_INFIX 10
#define wxSTC_R_INFIXEOL 11

/// Lexical state for SCLEX_MAGIK
#define wxSTC_MAGIK_DEFAULT 0
#define wxSTC_MAGIK_COMMENT 1
#define wxSTC_MAGIK_HYPER_COMMENT 16
#define wxSTC_MAGIK_STRING 2
#define wxSTC_MAGIK_CHARACTER 3
#define wxSTC_MAGIK_NUMBER 4
#define wxSTC_MAGIK_IDENTIFIER 5
#define wxSTC_MAGIK_OPERATOR 6
#define wxSTC_MAGIK_FLOW 7
#define wxSTC_MAGIK_CONTAINER 8
#define wxSTC_MAGIK_BRACKET_BLOCK 9
#define wxSTC_MAGIK_BRACE_BLOCK 10
#define wxSTC_MAGIK_SQBRACKET_BLOCK 11
#define wxSTC_MAGIK_UNKNOWN_KEYWORD 12
#define wxSTC_MAGIK_KEYWORD 13
#define wxSTC_MAGIK_PRAGMA 14
#define wxSTC_MAGIK_SYMBOL 15

/// Lexical state for SCLEX_POWERSHELL
#define wxSTC_POWERSHELL_DEFAULT 0
#define wxSTC_POWERSHELL_COMMENT 1
#define wxSTC_POWERSHELL_STRING 2
#define wxSTC_POWERSHELL_CHARACTER 3
#define wxSTC_POWERSHELL_NUMBER 4
#define wxSTC_POWERSHELL_VARIABLE 5
#define wxSTC_POWERSHELL_OPERATOR 6
#define wxSTC_POWERSHELL_IDENTIFIER 7
#define wxSTC_POWERSHELL_KEYWORD 8
#define wxSTC_POWERSHELL_CMDLET 9
#define wxSTC_POWERSHELL_ALIAS 10
#define wxSTC_POWERSHELL_FUNCTION 11
#define wxSTC_POWERSHELL_USER1 12
#define wxSTC_POWERSHELL_COMMENTSTREAM 13
#define wxSTC_POWERSHELL_HERE_STRING 14
#define wxSTC_POWERSHELL_HERE_CHARACTER 15
#define wxSTC_POWERSHELL_COMMENTDOCKEYWORD 16

/// Lexical state for SCLEX_MYSQL
#define wxSTC_MYSQL_DEFAULT 0
#define wxSTC_MYSQL_COMMENT 1
#define wxSTC_MYSQL_COMMENTLINE 2
#define wxSTC_MYSQL_VARIABLE 3
#define wxSTC_MYSQL_SYSTEMVARIABLE 4
#define wxSTC_MYSQL_KNOWNSYSTEMVARIABLE 5
#define wxSTC_MYSQL_NUMBER 6
#define wxSTC_MYSQL_MAJORKEYWORD 7
#define wxSTC_MYSQL_KEYWORD 8
#define wxSTC_MYSQL_DATABASEOBJECT 9
#define wxSTC_MYSQL_PROCEDUREKEYWORD 10
#define wxSTC_MYSQL_STRING 11
#define wxSTC_MYSQL_SQSTRING 12
#define wxSTC_MYSQL_DQSTRING 13
#define wxSTC_MYSQL_OPERATOR 14
#define wxSTC_MYSQL_FUNCTION 15
#define wxSTC_MYSQL_IDENTIFIER 16
#define wxSTC_MYSQL_QUOTEDIDENTIFIER 17
#define wxSTC_MYSQL_USER1 18
#define wxSTC_MYSQL_USER2 19
#define wxSTC_MYSQL_USER3 20
#define wxSTC_MYSQL_HIDDENCOMMAND 21
#define wxSTC_MYSQL_PLACEHOLDER 22

/// Lexical state for SCLEX_PO
#define wxSTC_PO_DEFAULT 0
#define wxSTC_PO_COMMENT 1
#define wxSTC_PO_MSGID 2
#define wxSTC_PO_MSGID_TEXT 3
#define wxSTC_PO_MSGSTR 4
#define wxSTC_PO_MSGSTR_TEXT 5
#define wxSTC_PO_MSGCTXT 6
#define wxSTC_PO_MSGCTXT_TEXT 7
#define wxSTC_PO_FUZZY 8
#define wxSTC_PO_PROGRAMMER_COMMENT 9
#define wxSTC_PO_REFERENCE 10
#define wxSTC_PO_FLAGS 11
#define wxSTC_PO_MSGID_TEXT_EOL 12
#define wxSTC_PO_MSGSTR_TEXT_EOL 13
#define wxSTC_PO_MSGCTXT_TEXT_EOL 14
#define wxSTC_PO_ERROR 15

/// Lexical states for SCLEX_PASCAL
#define wxSTC_PAS_DEFAULT 0
#define wxSTC_PAS_IDENTIFIER 1
#define wxSTC_PAS_COMMENT 2
#define wxSTC_PAS_COMMENT2 3
#define wxSTC_PAS_COMMENTLINE 4
#define wxSTC_PAS_PREPROCESSOR 5
#define wxSTC_PAS_PREPROCESSOR2 6
#define wxSTC_PAS_NUMBER 7
#define wxSTC_PAS_HEXNUMBER 8
#define wxSTC_PAS_WORD 9
#define wxSTC_PAS_STRING 10
#define wxSTC_PAS_STRINGEOL 11
#define wxSTC_PAS_CHARACTER 12
#define wxSTC_PAS_OPERATOR 13
#define wxSTC_PAS_ASM 14

/// Lexical state for SCLEX_SORCUS
#define wxSTC_SORCUS_DEFAULT 0
#define wxSTC_SORCUS_COMMAND 1
#define wxSTC_SORCUS_PARAMETER 2
#define wxSTC_SORCUS_COMMENTLINE 3
#define wxSTC_SORCUS_STRING 4
#define wxSTC_SORCUS_STRINGEOL 5
#define wxSTC_SORCUS_IDENTIFIER 6
#define wxSTC_SORCUS_OPERATOR 7
#define wxSTC_SORCUS_NUMBER 8
#define wxSTC_SORCUS_CONSTANT 9

/// Lexical state for SCLEX_POWERPRO
#define wxSTC_POWERPRO_DEFAULT 0
#define wxSTC_POWERPRO_COMMENTBLOCK 1
#define wxSTC_POWERPRO_COMMENTLINE 2
#define wxSTC_POWERPRO_NUMBER 3
#define wxSTC_POWERPRO_WORD 4
#define wxSTC_POWERPRO_WORD2 5
#define wxSTC_POWERPRO_WORD3 6
#define wxSTC_POWERPRO_WORD4 7
#define wxSTC_POWERPRO_DOUBLEQUOTEDSTRING 8
#define wxSTC_POWERPRO_SINGLEQUOTEDSTRING 9
#define wxSTC_POWERPRO_LINECONTINUE 10
#define wxSTC_POWERPRO_OPERATOR 11
#define wxSTC_POWERPRO_IDENTIFIER 12
#define wxSTC_POWERPRO_STRINGEOL 13
#define wxSTC_POWERPRO_VERBATIM 14
#define wxSTC_POWERPRO_ALTQUOTE 15
#define wxSTC_POWERPRO_FUNCTION 16

/// Lexical states for SCLEX_SML
#define wxSTC_SML_DEFAULT 0
#define wxSTC_SML_IDENTIFIER 1
#define wxSTC_SML_TAGNAME 2
#define wxSTC_SML_KEYWORD 3
#define wxSTC_SML_KEYWORD2 4
#define wxSTC_SML_KEYWORD3 5
#define wxSTC_SML_LINENUM 6
#define wxSTC_SML_OPERATOR 7
#define wxSTC_SML_NUMBER 8
#define wxSTC_SML_CHAR 9
#define wxSTC_SML_STRING 11
#define wxSTC_SML_COMMENT 12
#define wxSTC_SML_COMMENT1 13
#define wxSTC_SML_COMMENT2 14
#define wxSTC_SML_COMMENT3 15

/// Lexical state for SCLEX_MARKDOWN
#define wxSTC_MARKDOWN_DEFAULT 0
#define wxSTC_MARKDOWN_LINE_BEGIN 1
#define wxSTC_MARKDOWN_STRONG1 2
#define wxSTC_MARKDOWN_STRONG2 3
#define wxSTC_MARKDOWN_EM1 4
#define wxSTC_MARKDOWN_EM2 5
#define wxSTC_MARKDOWN_HEADER1 6
#define wxSTC_MARKDOWN_HEADER2 7
#define wxSTC_MARKDOWN_HEADER3 8
#define wxSTC_MARKDOWN_HEADER4 9
#define wxSTC_MARKDOWN_HEADER5 10
#define wxSTC_MARKDOWN_HEADER6 11
#define wxSTC_MARKDOWN_PRECHAR 12
#define wxSTC_MARKDOWN_ULIST_ITEM 13
#define wxSTC_MARKDOWN_OLIST_ITEM 14
#define wxSTC_MARKDOWN_BLOCKQUOTE 15
#define wxSTC_MARKDOWN_STRIKEOUT 16
#define wxSTC_MARKDOWN_HRULE 17
#define wxSTC_MARKDOWN_LINK 18
#define wxSTC_MARKDOWN_CODE 19
#define wxSTC_MARKDOWN_CODE2 20
#define wxSTC_MARKDOWN_CODEBK 21

/// Lexical state for SCLEX_TXT2TAGS
#define wxSTC_TXT2TAGS_DEFAULT 0
#define wxSTC_TXT2TAGS_LINE_BEGIN 1
#define wxSTC_TXT2TAGS_STRONG1 2
#define wxSTC_TXT2TAGS_STRONG2 3
#define wxSTC_TXT2TAGS_EM1 4
#define wxSTC_TXT2TAGS_EM2 5
#define wxSTC_TXT2TAGS_HEADER1 6
#define wxSTC_TXT2TAGS_HEADER2 7
#define wxSTC_TXT2TAGS_HEADER3 8
#define wxSTC_TXT2TAGS_HEADER4 9
#define wxSTC_TXT2TAGS_HEADER5 10
#define wxSTC_TXT2TAGS_HEADER6 11
#define wxSTC_TXT2TAGS_PRECHAR 12
#define wxSTC_TXT2TAGS_ULIST_ITEM 13
#define wxSTC_TXT2TAGS_OLIST_ITEM 14
#define wxSTC_TXT2TAGS_BLOCKQUOTE 15
#define wxSTC_TXT2TAGS_STRIKEOUT 16
#define wxSTC_TXT2TAGS_HRULE 17
#define wxSTC_TXT2TAGS_LINK 18
#define wxSTC_TXT2TAGS_CODE 19
#define wxSTC_TXT2TAGS_CODE2 20
#define wxSTC_TXT2TAGS_CODEBK 21
#define wxSTC_TXT2TAGS_COMMENT 22
#define wxSTC_TXT2TAGS_OPTION 23
#define wxSTC_TXT2TAGS_PREPROC 24
#define wxSTC_TXT2TAGS_POSTPROC 25

/// Lexical states for SCLEX_A68K
#define wxSTC_A68K_DEFAULT 0
#define wxSTC_A68K_COMMENT 1
#define wxSTC_A68K_NUMBER_DEC 2
#define wxSTC_A68K_NUMBER_BIN 3
#define wxSTC_A68K_NUMBER_HEX 4
#define wxSTC_A68K_STRING1 5
#define wxSTC_A68K_OPERATOR 6
#define wxSTC_A68K_CPUINSTRUCTION 7
#define wxSTC_A68K_EXTINSTRUCTION 8
#define wxSTC_A68K_REGISTER 9
#define wxSTC_A68K_DIRECTIVE 10
#define wxSTC_A68K_MACRO_ARG 11
#define wxSTC_A68K_LABEL 12
#define wxSTC_A68K_STRING2 13
#define wxSTC_A68K_IDENTIFIER 14
#define wxSTC_A68K_MACRO_DECLARATION 15
#define wxSTC_A68K_COMMENT_WORD 16
#define wxSTC_A68K_COMMENT_SPECIAL 17
#define wxSTC_A68K_COMMENT_DOXYGEN 18

/// Lexical states for SCLEX_MODULA
#define wxSTC_MODULA_DEFAULT 0
#define wxSTC_MODULA_COMMENT 1
#define wxSTC_MODULA_DOXYCOMM 2
#define wxSTC_MODULA_DOXYKEY 3
#define wxSTC_MODULA_KEYWORD 4
#define wxSTC_MODULA_RESERVED 5
#define wxSTC_MODULA_NUMBER 6
#define wxSTC_MODULA_BASENUM 7
#define wxSTC_MODULA_FLOAT 8
#define wxSTC_MODULA_STRING 9
#define wxSTC_MODULA_STRSPEC 10
#define wxSTC_MODULA_CHAR 11
#define wxSTC_MODULA_CHARSPEC 12
#define wxSTC_MODULA_PROC 13
#define wxSTC_MODULA_PRAGMA 14
#define wxSTC_MODULA_PRGKEY 15
#define wxSTC_MODULA_OPERATOR 16
#define wxSTC_MODULA_BADSTR 17

/// Lexical states for SCLEX_COFFEESCRIPT
#define wxSTC_COFFEESCRIPT_DEFAULT 0
#define wxSTC_COFFEESCRIPT_COMMENT 1
#define wxSTC_COFFEESCRIPT_COMMENTLINE 2
#define wxSTC_COFFEESCRIPT_COMMENTDOC 3
#define wxSTC_COFFEESCRIPT_NUMBER 4
#define wxSTC_COFFEESCRIPT_WORD 5
#define wxSTC_COFFEESCRIPT_STRING 6
#define wxSTC_COFFEESCRIPT_CHARACTER 7
#define wxSTC_COFFEESCRIPT_UUID 8
#define wxSTC_COFFEESCRIPT_PREPROCESSOR 9
#define wxSTC_COFFEESCRIPT_OPERATOR 10
#define wxSTC_COFFEESCRIPT_IDENTIFIER 11
#define wxSTC_COFFEESCRIPT_STRINGEOL 12
#define wxSTC_COFFEESCRIPT_VERBATIM 13
#define wxSTC_COFFEESCRIPT_REGEX 14
#define wxSTC_COFFEESCRIPT_COMMENTLINEDOC 15
#define wxSTC_COFFEESCRIPT_WORD2 16
#define wxSTC_COFFEESCRIPT_COMMENTDOCKEYWORD 17
#define wxSTC_COFFEESCRIPT_COMMENTDOCKEYWORDERROR 18
#define wxSTC_COFFEESCRIPT_GLOBALCLASS 19
#define wxSTC_COFFEESCRIPT_STRINGRAW 20
#define wxSTC_COFFEESCRIPT_TRIPLEVERBATIM 21
#define wxSTC_COFFEESCRIPT_COMMENTBLOCK 22
#define wxSTC_COFFEESCRIPT_VERBOSE_REGEX 23
#define wxSTC_COFFEESCRIPT_VERBOSE_REGEX_COMMENT 24
#define wxSTC_COFFEESCRIPT_INSTANCEPROPERTY 25

/// Lexical states for SCLEX_AVS
#define wxSTC_AVS_DEFAULT 0
#define wxSTC_AVS_COMMENTBLOCK 1
#define wxSTC_AVS_COMMENTBLOCKN 2
#define wxSTC_AVS_COMMENTLINE 3
#define wxSTC_AVS_NUMBER 4
#define wxSTC_AVS_OPERATOR 5
#define wxSTC_AVS_IDENTIFIER 6
#define wxSTC_AVS_STRING 7
#define wxSTC_AVS_TRIPLESTRING 8
#define wxSTC_AVS_KEYWORD 9
#define wxSTC_AVS_FILTER 10
#define wxSTC_AVS_PLUGIN 11
#define wxSTC_AVS_FUNCTION 12
#define wxSTC_AVS_CLIPPROP 13
#define wxSTC_AVS_USERDFN 14

/// Lexical states for SCLEX_ECL
#define wxSTC_ECL_DEFAULT 0
#define wxSTC_ECL_COMMENT 1
#define wxSTC_ECL_COMMENTLINE 2
#define wxSTC_ECL_NUMBER 3
#define wxSTC_ECL_STRING 4
#define wxSTC_ECL_WORD0 5
#define wxSTC_ECL_OPERATOR 6
#define wxSTC_ECL_CHARACTER 7
#define wxSTC_ECL_UUID 8
#define wxSTC_ECL_PREPROCESSOR 9
#define wxSTC_ECL_UNKNOWN 10
#define wxSTC_ECL_IDENTIFIER 11
#define wxSTC_ECL_STRINGEOL 12
#define wxSTC_ECL_VERBATIM 13
#define wxSTC_ECL_REGEX 14
#define wxSTC_ECL_COMMENTLINEDOC 15
#define wxSTC_ECL_WORD1 16
#define wxSTC_ECL_COMMENTDOCKEYWORD 17
#define wxSTC_ECL_COMMENTDOCKEYWORDERROR 18
#define wxSTC_ECL_WORD2 19
#define wxSTC_ECL_WORD3 20
#define wxSTC_ECL_WORD4 21
#define wxSTC_ECL_WORD5 22
#define wxSTC_ECL_COMMENTDOC 23
#define wxSTC_ECL_ADDED 24
#define wxSTC_ECL_DELETED 25
#define wxSTC_ECL_CHANGED 26
#define wxSTC_ECL_MOVED 27

/// Lexical states for SCLEX_OSCRIPT
#define wxSTC_OSCRIPT_DEFAULT 0
#define wxSTC_OSCRIPT_LINE_COMMENT 1
#define wxSTC_OSCRIPT_BLOCK_COMMENT 2
#define wxSTC_OSCRIPT_DOC_COMMENT 3
#define wxSTC_OSCRIPT_PREPROCESSOR 4
#define wxSTC_OSCRIPT_NUMBER 5
#define wxSTC_OSCRIPT_SINGLEQUOTE_STRING 6
#define wxSTC_OSCRIPT_DOUBLEQUOTE_STRING 7
#define wxSTC_OSCRIPT_CONSTANT 8
#define wxSTC_OSCRIPT_IDENTIFIER 9
#define wxSTC_OSCRIPT_GLOBAL 10
#define wxSTC_OSCRIPT_KEYWORD 11
#define wxSTC_OSCRIPT_OPERATOR 12
#define wxSTC_OSCRIPT_LABEL 13
#define wxSTC_OSCRIPT_TYPE 14
#define wxSTC_OSCRIPT_FUNCTION 15
#define wxSTC_OSCRIPT_OBJECT 16
#define wxSTC_OSCRIPT_PROPERTY 17
#define wxSTC_OSCRIPT_METHOD 18

/// Lexical states for SCLEX_VISUALPROLOG
#define wxSTC_VISUALPROLOG_DEFAULT 0
#define wxSTC_VISUALPROLOG_KEY_MAJOR 1
#define wxSTC_VISUALPROLOG_KEY_MINOR 2
#define wxSTC_VISUALPROLOG_KEY_DIRECTIVE 3
#define wxSTC_VISUALPROLOG_COMMENT_BLOCK 4
#define wxSTC_VISUALPROLOG_COMMENT_LINE 5
#define wxSTC_VISUALPROLOG_COMMENT_KEY 6
#define wxSTC_VISUALPROLOG_COMMENT_KEY_ERROR 7
#define wxSTC_VISUALPROLOG_IDENTIFIER 8
#define wxSTC_VISUALPROLOG_VARIABLE 9
#define wxSTC_VISUALPROLOG_ANONYMOUS 10
#define wxSTC_VISUALPROLOG_NUMBER 11
#define wxSTC_VISUALPROLOG_OPERATOR 12
#define wxSTC_VISUALPROLOG_CHARACTER 13
#define wxSTC_VISUALPROLOG_CHARACTER_TOO_MANY 14
#define wxSTC_VISUALPROLOG_CHARACTER_ESCAPE_ERROR 15
#define wxSTC_VISUALPROLOG_STRING 16
#define wxSTC_VISUALPROLOG_STRING_ESCAPE 17
#define wxSTC_VISUALPROLOG_STRING_ESCAPE_ERROR 18
#define wxSTC_VISUALPROLOG_STRING_EOL_OPEN 19
#define wxSTC_VISUALPROLOG_STRING_VERBATIM 20
#define wxSTC_VISUALPROLOG_STRING_VERBATIM_SPECIAL 21
#define wxSTC_VISUALPROLOG_STRING_VERBATIM_EOL 22

/// Lexical states for SCLEX_STTXT
#define wxSTC_STTXT_DEFAULT 0
#define wxSTC_STTXT_COMMENT 1
#define wxSTC_STTXT_COMMENTLINE 2
#define wxSTC_STTXT_KEYWORD 3
#define wxSTC_STTXT_TYPE 4
#define wxSTC_STTXT_FUNCTION 5
#define wxSTC_STTXT_FB 6
#define wxSTC_STTXT_NUMBER 7
#define wxSTC_STTXT_HEXNUMBER 8
#define wxSTC_STTXT_PRAGMA 9
#define wxSTC_STTXT_OPERATOR 10
#define wxSTC_STTXT_CHARACTER 11
#define wxSTC_STTXT_STRING1 12
#define wxSTC_STTXT_STRING2 13
#define wxSTC_STTXT_STRINGEOL 14
#define wxSTC_STTXT_IDENTIFIER 15
#define wxSTC_STTXT_DATETIME 16
#define wxSTC_STTXT_VARS 17
#define wxSTC_STTXT_PRAGMAS 18

/// Lexical states for SCLEX_KVIRC
#define wxSTC_KVIRC_DEFAULT 0
#define wxSTC_KVIRC_COMMENT 1
#define wxSTC_KVIRC_COMMENTBLOCK 2
#define wxSTC_KVIRC_STRING 3
#define wxSTC_KVIRC_WORD 4
#define wxSTC_KVIRC_KEYWORD 5
#define wxSTC_KVIRC_FUNCTION_KEYWORD 6
#define wxSTC_KVIRC_FUNCTION 7
#define wxSTC_KVIRC_VARIABLE 8
#define wxSTC_KVIRC_NUMBER 9
#define wxSTC_KVIRC_OPERATOR 10
#define wxSTC_KVIRC_STRING_FUNCTION 11
#define wxSTC_KVIRC_STRING_VARIABLE 12

/// Lexical states for SCLEX_RUST
#define wxSTC_RUST_DEFAULT 0
#define wxSTC_RUST_COMMENTBLOCK 1
#define wxSTC_RUST_COMMENTLINE 2
#define wxSTC_RUST_COMMENTBLOCKDOC 3
#define wxSTC_RUST_COMMENTLINEDOC 4
#define wxSTC_RUST_NUMBER 5
#define wxSTC_RUST_WORD 6
#define wxSTC_RUST_WORD2 7
#define wxSTC_RUST_WORD3 8
#define wxSTC_RUST_WORD4 9
#define wxSTC_RUST_WORD5 10
#define wxSTC_RUST_WORD6 11
#define wxSTC_RUST_WORD7 12
#define wxSTC_RUST_STRING 13
#define wxSTC_RUST_STRINGR 14
#define wxSTC_RUST_CHARACTER 15
#define wxSTC_RUST_OPERATOR 16
#define wxSTC_RUST_IDENTIFIER 17
#define wxSTC_RUST_LIFETIME 18
#define wxSTC_RUST_MACRO 19
#define wxSTC_RUST_LEXERROR 20
#define wxSTC_RUST_BYTESTRING 21
#define wxSTC_RUST_BYTESTRINGR 22
#define wxSTC_RUST_BYTECHARACTER 23

/// Lexical states for SCLEX_DMAP
#define wxSTC_DMAP_DEFAULT 0
#define wxSTC_DMAP_COMMENT 1
#define wxSTC_DMAP_NUMBER 2
#define wxSTC_DMAP_STRING1 3
#define wxSTC_DMAP_STRING2 4
#define wxSTC_DMAP_STRINGEOL 5
#define wxSTC_DMAP_OPERATOR 6
#define wxSTC_DMAP_IDENTIFIER 7
#define wxSTC_DMAP_WORD 8
#define wxSTC_DMAP_WORD2 9
#define wxSTC_DMAP_WORD3 10

/// Lexical states for SCLEX_DMIS
#define wxSTC_DMIS_DEFAULT 0
#define wxSTC_DMIS_COMMENT 1
#define wxSTC_DMIS_STRING 2
#define wxSTC_DMIS_NUMBER 3
#define wxSTC_DMIS_KEYWORD 4
#define wxSTC_DMIS_MAJORWORD 5
#define wxSTC_DMIS_MINORWORD 6
#define wxSTC_DMIS_UNSUPPORTED_MAJOR 7
#define wxSTC_DMIS_UNSUPPORTED_MINOR 8
#define wxSTC_DMIS_LABEL 9

/// Lexical states for SCLEX_REGISTRY
#define wxSTC_REG_DEFAULT 0
#define wxSTC_REG_COMMENT 1
#define wxSTC_REG_VALUENAME 2
#define wxSTC_REG_STRING 3
#define wxSTC_REG_HEXDIGIT 4
#define wxSTC_REG_VALUETYPE 5
#define wxSTC_REG_ADDEDKEY 6
#define wxSTC_REG_DELETEDKEY 7
#define wxSTC_REG_ESCAPED 8
#define wxSTC_REG_KEYPATH_GUID 9
#define wxSTC_REG_STRING_GUID 10
#define wxSTC_REG_PARAMETER 11
#define wxSTC_REG_OPERATOR 12

/// Lexical state for SCLEX_BIBTEX
#define wxSTC_BIBTEX_DEFAULT 0
#define wxSTC_BIBTEX_ENTRY 1
#define wxSTC_BIBTEX_UNKNOWN_ENTRY 2
#define wxSTC_BIBTEX_KEY 3
#define wxSTC_BIBTEX_PARAMETER 4
#define wxSTC_BIBTEX_VALUE 5
#define wxSTC_BIBTEX_COMMENT 6

/// Lexical state for SCLEX_SREC
#define wxSTC_HEX_DEFAULT 0
#define wxSTC_HEX_RECSTART 1
#define wxSTC_HEX_RECTYPE 2
#define wxSTC_HEX_RECTYPE_UNKNOWN 3
#define wxSTC_HEX_BYTECOUNT 4
#define wxSTC_HEX_BYTECOUNT_WRONG 5
#define wxSTC_HEX_NOADDRESS 6
#define wxSTC_HEX_DATAADDRESS 7
#define wxSTC_HEX_RECCOUNT 8
#define wxSTC_HEX_STARTADDRESS 9
#define wxSTC_HEX_ADDRESSFIELD_UNKNOWN 10
#define wxSTC_HEX_EXTENDEDADDRESS 11
#define wxSTC_HEX_DATA_ODD 12
#define wxSTC_HEX_DATA_EVEN 13
#define wxSTC_HEX_DATA_UNKNOWN 14
#define wxSTC_HEX_DATA_EMPTY 15
#define wxSTC_HEX_CHECKSUM 16
#define wxSTC_HEX_CHECKSUM_WRONG 17
#define wxSTC_HEX_GARBAGE 18

/// Lexical state for SCLEX_IHEX (shared with Srec)
/// Lexical state for SCLEX_TEHEX (shared with Srec)
/// Lexical states for SCLEX_JSON
#define wxSTC_JSON_DEFAULT 0
#define wxSTC_JSON_NUMBER 1
#define wxSTC_JSON_STRING 2
#define wxSTC_JSON_STRINGEOL 3
#define wxSTC_JSON_PROPERTYNAME 4
#define wxSTC_JSON_ESCAPESEQUENCE 5
#define wxSTC_JSON_LINECOMMENT 6
#define wxSTC_JSON_BLOCKCOMMENT 7
#define wxSTC_JSON_OPERATOR 8
#define wxSTC_JSON_URI 9
#define wxSTC_JSON_COMPACTIRI 10
#define wxSTC_JSON_KEYWORD 11
#define wxSTC_JSON_LDKEYWORD 12
#define wxSTC_JSON_ERROR 13
#define wxSTC_EDI_DEFAULT 0
#define wxSTC_EDI_SEGMENTSTART 1
#define wxSTC_EDI_SEGMENTEND 2
#define wxSTC_EDI_SEP_ELEMENT 3
#define wxSTC_EDI_SEP_COMPOSITE 4
#define wxSTC_EDI_SEP_RELEASE 5
#define wxSTC_EDI_UNA 6
#define wxSTC_EDI_UNH 7
#define wxSTC_EDI_BADSEGMENT 8

//}}}


//The following values are deprecated in the Scintilla library

///@deprecated
#define wxSTC_INDIC0_MASK 0x20

///@deprecated
#define wxSTC_INDIC1_MASK 0x40

///@deprecated
#define wxSTC_INDIC2_MASK 0x80

///@deprecated
#define wxSTC_INDICS_MASK 0xE0


// Commands that can be bound to keystrokes {{{


/// Redoes the next action on the undo history.
#define wxSTC_CMD_REDO 2011

/// Select all the text in the document.
#define wxSTC_CMD_SELECTALL 2013

/// Undo one action in the undo history.
#define wxSTC_CMD_UNDO 2176

/// Cut the selection to the clipboard.
#define wxSTC_CMD_CUT 2177

/// Copy the selection to the clipboard.
#define wxSTC_CMD_COPY 2178

/// Paste the contents of the clipboard into the document replacing the selection.
#define wxSTC_CMD_PASTE 2179

/// Clear the selection.
#define wxSTC_CMD_CLEAR 2180

/// Move caret down one line.
#define wxSTC_CMD_LINEDOWN 2300

/// Move caret down one line extending selection to new caret position.
#define wxSTC_CMD_LINEDOWNEXTEND 2301

/// Move caret up one line.
#define wxSTC_CMD_LINEUP 2302

/// Move caret up one line extending selection to new caret position.
#define wxSTC_CMD_LINEUPEXTEND 2303

/// Move caret left one character.
#define wxSTC_CMD_CHARLEFT 2304

/// Move caret left one character extending selection to new caret position.
#define wxSTC_CMD_CHARLEFTEXTEND 2305

/// Move caret right one character.
#define wxSTC_CMD_CHARRIGHT 2306

/// Move caret right one character extending selection to new caret position.
#define wxSTC_CMD_CHARRIGHTEXTEND 2307

/// Move caret left one word.
#define wxSTC_CMD_WORDLEFT 2308

/// Move caret left one word extending selection to new caret position.
#define wxSTC_CMD_WORDLEFTEXTEND 2309

/// Move caret right one word.
#define wxSTC_CMD_WORDRIGHT 2310

/// Move caret right one word extending selection to new caret position.
#define wxSTC_CMD_WORDRIGHTEXTEND 2311

/// Move caret to first position on line.
#define wxSTC_CMD_HOME 2312

/// Move caret to first position on line extending selection to new caret position.
#define wxSTC_CMD_HOMEEXTEND 2313

/// Move caret to last position on line.
#define wxSTC_CMD_LINEEND 2314

/// Move caret to last position on line extending selection to new caret position.
#define wxSTC_CMD_LINEENDEXTEND 2315

/// Move caret to first position in document.
#define wxSTC_CMD_DOCUMENTSTART 2316

/// Move caret to first position in document extending selection to new caret position.
#define wxSTC_CMD_DOCUMENTSTARTEXTEND 2317

/// Move caret to last position in document.
#define wxSTC_CMD_DOCUMENTEND 2318

/// Move caret to last position in document extending selection to new caret position.
#define wxSTC_CMD_DOCUMENTENDEXTEND 2319

/// Move caret one page up.
#define wxSTC_CMD_PAGEUP 2320

/// Move caret one page up extending selection to new caret position.
#define wxSTC_CMD_PAGEUPEXTEND 2321

/// Move caret one page down.
#define wxSTC_CMD_PAGEDOWN 2322

/// Move caret one page down extending selection to new caret position.
#define wxSTC_CMD_PAGEDOWNEXTEND 2323

/// Switch from insert to overtype mode or the reverse.
#define wxSTC_CMD_EDITTOGGLEOVERTYPE 2324

/// Cancel any modes such as call tip or auto-completion list display.
#define wxSTC_CMD_CANCEL 2325

/// Delete the selection or if no selection, the character before the caret.
#define wxSTC_CMD_DELETEBACK 2326

/// If selection is empty or all on one line replace the selection with a tab character.
/// If more than one line selected, indent the lines.
#define wxSTC_CMD_TAB 2327

/// Dedent the selected lines.
#define wxSTC_CMD_BACKTAB 2328

/// Insert a new line, may use a CRLF, CR or LF depending on EOL mode.
#define wxSTC_CMD_NEWLINE 2329

/// Insert a Form Feed character.
#define wxSTC_CMD_FORMFEED 2330

/// Move caret to before first visible character on line.
/// If already there move to first character on line.
#define wxSTC_CMD_VCHOME 2331

/// Like VCHome but extending selection to new caret position.
#define wxSTC_CMD_VCHOMEEXTEND 2332

/// Magnify the displayed text by increasing the sizes by 1 point.
#define wxSTC_CMD_ZOOMIN 2333

/// Make the displayed text smaller by decreasing the sizes by 1 point.
#define wxSTC_CMD_ZOOMOUT 2334

/// Delete the word to the left of the caret.
#define wxSTC_CMD_DELWORDLEFT 2335

/// Delete the word to the right of the caret.
#define wxSTC_CMD_DELWORDRIGHT 2336

/// Delete the word to the right of the caret, but not the trailing non-word characters.
#define wxSTC_CMD_DELWORDRIGHTEND 2518

/// Cut the line containing the caret.
#define wxSTC_CMD_LINECUT 2337

/// Delete the line containing the caret.
#define wxSTC_CMD_LINEDELETE 2338

/// Switch the current line with the previous.
#define wxSTC_CMD_LINETRANSPOSE 2339

/// Duplicate the current line.
#define wxSTC_CMD_LINEDUPLICATE 2404

/// Transform the selection to lower case.
#define wxSTC_CMD_LOWERCASE 2340

/// Transform the selection to upper case.
#define wxSTC_CMD_UPPERCASE 2341

/// Scroll the document down, keeping the caret visible.
#define wxSTC_CMD_LINESCROLLDOWN 2342

/// Scroll the document up, keeping the caret visible.
#define wxSTC_CMD_LINESCROLLUP 2343

/// Delete the selection or if no selection, the character before the caret.
/// Will not delete the character before at the start of a line.
#define wxSTC_CMD_DELETEBACKNOTLINE 2344

/// Move caret to first position on display line.
#define wxSTC_CMD_HOMEDISPLAY 2345

/// Move caret to first position on display line extending selection to
/// new caret position.
#define wxSTC_CMD_HOMEDISPLAYEXTEND 2346

/// Move caret to last position on display line.
#define wxSTC_CMD_LINEENDDISPLAY 2347

/// Move caret to last position on display line extending selection to new
/// caret position.
#define wxSTC_CMD_LINEENDDISPLAYEXTEND 2348

/// Like Home but when word-wrap is enabled goes first to start of display line
/// HomeDisplay, then to start of document line Home.
#define wxSTC_CMD_HOMEWRAP 2349

/// Like HomeExtend but when word-wrap is enabled extends first to start of display line
/// HomeDisplayExtend, then to start of document line HomeExtend.
#define wxSTC_CMD_HOMEWRAPEXTEND 2450

/// Like LineEnd but when word-wrap is enabled goes first to end of display line
/// LineEndDisplay, then to start of document line LineEnd.
#define wxSTC_CMD_LINEENDWRAP 2451

/// Like LineEndExtend but when word-wrap is enabled extends first to end of display line
/// LineEndDisplayExtend, then to start of document line LineEndExtend.
#define wxSTC_CMD_LINEENDWRAPEXTEND 2452

/// Like VCHome but when word-wrap is enabled goes first to start of display line
/// VCHomeDisplay, then behaves like VCHome.
#define wxSTC_CMD_VCHOMEWRAP 2453

/// Like VCHomeExtend but when word-wrap is enabled extends first to start of display line
/// VCHomeDisplayExtend, then behaves like VCHomeExtend.
#define wxSTC_CMD_VCHOMEWRAPEXTEND 2454

/// Copy the line containing the caret.
#define wxSTC_CMD_LINECOPY 2455

/// Move to the previous change in capitalisation.
#define wxSTC_CMD_WORDPARTLEFT 2390

/// Move to the previous change in capitalisation extending selection
/// to new caret position.
#define wxSTC_CMD_WORDPARTLEFTEXTEND 2391

/// Move to the change next in capitalisation.
#define wxSTC_CMD_WORDPARTRIGHT 2392

/// Move to the next change in capitalisation extending selection
/// to new caret position.
#define wxSTC_CMD_WORDPARTRIGHTEXTEND 2393

/// Delete back from the current position to the start of the line.
#define wxSTC_CMD_DELLINELEFT 2395

/// Delete forwards from the current position to the end of the line.
#define wxSTC_CMD_DELLINERIGHT 2396

/// Move caret down one paragraph (delimited by empty lines).
#define wxSTC_CMD_PARADOWN 2413

/// Extend selection down one paragraph (delimited by empty lines).
#define wxSTC_CMD_PARADOWNEXTEND 2414

/// Move caret up one paragraph (delimited by empty lines).
#define wxSTC_CMD_PARAUP 2415

/// Extend selection up one paragraph (delimited by empty lines).
#define wxSTC_CMD_PARAUPEXTEND 2416

/// Move caret down one line, extending rectangular selection to new caret position.
#define wxSTC_CMD_LINEDOWNRECTEXTEND 2426

/// Move caret up one line, extending rectangular selection to new caret position.
#define wxSTC_CMD_LINEUPRECTEXTEND 2427

/// Move caret left one character, extending rectangular selection to new caret position.
#define wxSTC_CMD_CHARLEFTRECTEXTEND 2428

/// Move caret right one character, extending rectangular selection to new caret position.
#define wxSTC_CMD_CHARRIGHTRECTEXTEND 2429

/// Move caret to first position on line, extending rectangular selection to new caret position.
#define wxSTC_CMD_HOMERECTEXTEND 2430

/// Move caret to before first visible character on line.
/// If already there move to first character on line.
/// In either case, extend rectangular selection to new caret position.
#define wxSTC_CMD_VCHOMERECTEXTEND 2431

/// Move caret to last position on line, extending rectangular selection to new caret position.
#define wxSTC_CMD_LINEENDRECTEXTEND 2432

/// Move caret one page up, extending rectangular selection to new caret position.
#define wxSTC_CMD_PAGEUPRECTEXTEND 2433

/// Move caret one page down, extending rectangular selection to new caret position.
#define wxSTC_CMD_PAGEDOWNRECTEXTEND 2434

/// Move caret to top of page, or one page up if already at top of page.
#define wxSTC_CMD_STUTTEREDPAGEUP 2435

/// Move caret to top of page, or one page up if already at top of page, extending selection to new caret position.
#define wxSTC_CMD_STUTTEREDPAGEUPEXTEND 2436

/// Move caret to bottom of page, or one page down if already at bottom of page.
#define wxSTC_CMD_STUTTEREDPAGEDOWN 2437

/// Move caret to bottom of page, or one page down if already at bottom of page, extending selection to new caret position.
#define wxSTC_CMD_STUTTEREDPAGEDOWNEXTEND 2438

/// Move caret left one word, position cursor at end of word.
#define wxSTC_CMD_WORDLEFTEND 2439

/// Move caret left one word, position cursor at end of word, extending selection to new caret position.
#define wxSTC_CMD_WORDLEFTENDEXTEND 2440

/// Move caret right one word, position cursor at end of word.
#define wxSTC_CMD_WORDRIGHTEND 2441

/// Move caret right one word, position cursor at end of word, extending selection to new caret position.
#define wxSTC_CMD_WORDRIGHTENDEXTEND 2442

/// Centre current line in window.
#define wxSTC_CMD_VERTICALCENTRECARET 2619

/// Move the selected lines up one line, shifting the line above after the selection
#define wxSTC_CMD_MOVESELECTEDLINESUP 2620

/// Move the selected lines down one line, shifting the line below before the selection
#define wxSTC_CMD_MOVESELECTEDLINESDOWN 2621

/// Scroll to start of document.
#define wxSTC_CMD_SCROLLTOSTART 2628

/// Scroll to end of document.
#define wxSTC_CMD_SCROLLTOEND 2629

/// Move caret to before first visible character on display line.
/// If already there move to first character on display line.
#define wxSTC_CMD_VCHOMEDISPLAY 2652

/// Like VCHomeDisplay but extending selection to new caret position.
#define wxSTC_CMD_VCHOMEDISPLAYEXTEND 2653

//}}}




/**
    @class wxStyledTextCtrl

    A wxWidgets implementation of the Scintilla source code editing component.

    As well as features found in standard text editing components, Scintilla
    includes features especially useful when editing and debugging source code.
    These include support for syntax styling, error indicators, code completion
    and call tips.

    The selection margin can contain markers like those used in debuggers to indicate
    breakpoints and the current line. Styling choices are more open than with many
    editors, allowing the use of proportional fonts, bold and italics, multiple
    foreground and background colours and multiple fonts.

    wxStyledTextCtrl is a 1 to 1 mapping of "raw" scintilla interface, whose
    documentation can be found in the Scintilla website (http://www.scintilla.org/).

    Please see wxStyledTextEvent for the documentation of all event types you
    can use with wxStyledTextCtrl.


    @section stc_index Index of the member groups

    Links for quick access to the various categories of wxStyledTextCtrl functions:
    - @ref_member_group{ctor, Constructors and related methods}
    - @ref_member_group{TextRetrievalAndModification, Text retrieval and modification}
    - @ref_member_group{Searching, Searching and replacing}
    - @ref_member_group{Overtype, Overtype}
    - @ref_member_group{CutCopyAndPaste, Cut copy and paste}
    - @ref_member_group{ErrorHandling, Error handling}
    - @ref_member_group{UndoAndRedo, Undo and Redo}
    - @ref_member_group{SelectionAndInformation, Selection and information}
    - @ref_member_group{MultipleSelectionAndVirtualSpace, Multiple Selection and Virtual Space}
    - @ref_member_group{ScrollingAndAutomaticScrolling, Scrolling and automatic scrolling}
    - @ref_member_group{WhiteSpace, White space}
    - @ref_member_group{Cursor, Cursor}
    - @ref_member_group{MouseCapture, Mouse capture}
    - @ref_member_group{LineEndings, Line endings}
    - @ref_member_group{Words, Words}
    - @ref_member_group{Styling, Styling}
    - @ref_member_group{StyleDefinition, Style definition}
    - @ref_member_group{CaretAndSelectionStyles, Caret selection and hotspot styles}
    - @ref_member_group{CharacterRepresentations, Character representations}
    - @ref_member_group{Margins, Margins}
    - @ref_member_group{Annotations, Annotations}
    - @ref_member_group{OtherSettings, Other settings}
    - @ref_member_group{BraceHighlighting, Brace highlighting}
    - @ref_member_group{TabsAndIndentationGuides, Tabs and Indentation Guides}
    - @ref_member_group{Markers, Markers}
    - @ref_member_group{Indicators, Indicators}
    - @ref_member_group{Autocompletion, Autocompletion}
    - @ref_member_group{UserLists, User lists}
    - @ref_member_group{CallTips, Call tips}
    - @ref_member_group{KeyboardCommands, Keyboard commands}
    - @ref_member_group{KeyBindings, Key bindings}
    - @ref_member_group{PopupEditMenu, Popup edit menu}
    - @ref_member_group{MacroRecording, Macro recording}
    - @ref_member_group{Printing, Printing}
    - @ref_member_group{DirectAccess, Direct access}
    - @ref_member_group{MultipleViews, Multiple views}
    - @ref_member_group{BackgroundLoadSave, Background loading and saving}
    - @ref_member_group{Folding, Folding}
    - @ref_member_group{LineWrapping, Line wrapping}
    - @ref_member_group{Zooming, Zooming}
    - @ref_member_group{LongLines, Long lines}
    - @ref_member_group{Lexer, Lexer}
    - @ref_member_group{Notifications, Event related items}
    - @ref_member_group{DeprecatedMessages, Deprecated items}
    - @ref_member_group{additional_methods, Additional wxStyledTextCtrl methods}
    - @ref_member_group{raw_variants , Raw variants}
    - @ref_member_group{text_entry, Text entry methods}
    - @ref_member_group{text_area, Text area methods}

    @library{wxstc}
    @category{stc}

    @see wxStyledTextEvent
*/

class wxStyledTextCtrl : public wxControl, public wxTextEntry
{
public:

    // Ctor, etc
    // ----------------------------------------------
    ///@member_group_name{ctor, Constructors and related methods}
    //@{

    /**
        Ctor.
    */
    wxStyledTextCtrl(wxWindow *parent, wxWindowID id=wxID_ANY,
                     const wxPoint& pos = wxDefaultPosition,
                     const wxSize& size = wxDefaultSize, long style = 0,
                     const wxString& name = wxSTCNameStr);
    /**
        Default ctor.
    */
    wxStyledTextCtrl();

    /**
        Destructor.
    */
    ~wxStyledTextCtrl();

    /**
        Create the UI elements for a STC that was created with the default ctor. (For 2-phase create.)
    */
    bool Create(wxWindow *parent, wxWindowID id=wxID_ANY,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize, long style = 0,
                const wxString& name = wxSTCNameStr);

    //@}


    // Scintilla methods (generated by gen_iface.py)
    // ----------------------------------------------

    // **** Generated methods {{{


    /**
        @member_group_name{TextRetrievalAndModification, Text retrieval and modification}
    */
    //@{

    /**
        Add text to the document at current position.
    */
    void AddText(const wxString& text);

    /**
        Add array of cells to document.
    */
    void AddStyledText(const wxMemoryBuffer& data);

    /**
        Insert string at a position.
    */
    void InsertText(int pos, const wxString& text);

    /**
        Change the text that is being inserted in response to wxSTC_MOD_INSERTCHECK

        @since 3.1.0
    */
    void ChangeInsertion(int length, const wxString& text);

    /**
        Delete all text in the document.
    */
    void ClearAll();

    /**
        Delete a range of text in the document.
    */
    void DeleteRange(int start, int lengthDelete);

    /**
        Set all style bytes to 0, remove all folding information.
    */
    void ClearDocumentStyle();

    /**
        Returns the character byte at the position.
    */
    int GetCharAt(int pos) const;

    /**
        Returns the style byte at the position.
    */
    int GetStyleAt(int pos) const;

    /**
        Remember the current position in the undo history as the position
        at which the document was saved.
    */
    void SetSavePoint();

    /**
        Retrieve a buffer of cells.
    */
    wxMemoryBuffer GetStyledText(int startPos, int endPos);

    /**
        In read-only mode?
    */
    bool GetReadOnly() const;

    /**
        Retrieve the contents of a line.
    */
    wxString GetLine(int line) const;

    /**
        Retrieve a range of text.
    */
    wxString GetTextRange(int startPos, int endPos);

    /**
        Replace the selected text with the argument text.
    */
    void ReplaceSelection(const wxString& text);

    /**
        Set to read only or read write.
    */
    void SetReadOnly(bool readOnly);

    /**
        Replace the contents of the document with the argument text.
    */
    void SetText(const wxString& text);

    /**
        Retrieve all the text in the document.
    */
    wxString GetText() const;

    /**
        Append a string to the end of the document without changing the selection.
    */
    void AppendText(const wxString& text);

    /**
        Enlarge the document to a particular size of text bytes.
    */
    void Allocate(int bytes);

    /**
        Release all extended (>255) style numbers

        @since 3.1.0
    */
    void ReleaseAllExtendedStyles();

    /**
        Allocate some extended (>255) style numbers and return the start of the range

        @since 3.1.0
    */
    int AllocateExtendedStyles(int numberStyles);

    //@}

    /**
        @member_group_name{Searching, Searching and replacing}
    */
    //@{

    /**
        Find some text in the document.

        @param minPos
            The position (starting from zero) in the document at which to begin
            the search
        @param maxPos
            The last position (starting from zero) in the document to which
            the search will be restricted.
        @param text
            The text to search for.
        @param flags
            (Optional)  The search flags.  This should be a bit list containing
             one or more of the @link wxStyledTextCtrl::wxSTC_FIND_WHOLEWORD
            wxSTC_FIND_* @endlink constants.
        @param findEnd
            (Optional)  This parameter can optionally be used to receive the
            end position (starting from zero) of the found text.  This is
            primarily needed when searching using regular expressions.
            This parameter is available since wxWidgets 3.1.1.
        @return
            The position (starting from zero) in the document at which the text
            was found or wxSTC_INVALID_POSITION if the search fails.
        @remarks
            A backwards search can be performed by setting minPos to be greater
            than maxPos.
    */
    int FindText(int minPos, int maxPos, const wxString& text, int flags=0,
                 int* findEnd=NULL);

    /**
        Sets the position that starts the target which is used for updating the
        document without affecting the scroll position.
    */
    void SetTargetStart(int start);

    /**
        Get the position that starts the target.
    */
    int GetTargetStart() const;

    /**
        Sets the position that ends the target which is used for updating the
        document without affecting the scroll position.
    */
    void SetTargetEnd(int end);

    /**
        Get the position that ends the target.
    */
    int GetTargetEnd() const;

    /**
        Sets both the start and end of the target in one call.

        @since 3.1.0
    */
    void SetTargetRange(int start, int end);

    /**
        Retrieve the text in the target.

        @since 3.1.0
    */
    wxString GetTargetText() const;

    /**
        Make the target range start and end be the same as the selection range start and end.
    */
    void TargetFromSelection();

    /**
        Sets the target to the whole document.

        @since 3.1.1
    */
    void TargetWholeDocument();

    /**
        Replace the target text with the argument text.
        Text is counted so it can contain NULs.
        Returns the length of the replacement text.
    */
    int ReplaceTarget(const wxString& text);

    /**
        Replace the target text with the argument text after \\d processing.
        Text is counted so it can contain NULs.
        Looks for \\d where d is between 1 and 9 and replaces these with the strings
        matched in the last search operation which were surrounded by \\( and \\).
        Returns the length of the replacement text including any change
        caused by processing the \\d patterns.
    */
    int ReplaceTargetRE(const wxString& text);

    /**
        Search for a counted string in the target and set the target to the found
        range. Text is counted so it can contain NULs.
        Returns length of range or -1 for failure in which case target is not moved.
    */
    int SearchInTarget(const wxString& text);

    /**
        Set the search flags used by SearchInTarget.

        The input should be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_FIND_WHOLEWORD wxSTC_FIND_* @endlink constants.
    */
    void SetSearchFlags(int searchFlags);

    /**
        Get the search flags used by SearchInTarget.

        The return value will be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_FIND_WHOLEWORD wxSTC_FIND_* @endlink constants.
    */
    int GetSearchFlags() const;

    /**
        Retrieve the value of a tag from a regular expression search.
    */
    wxString GetTag(int tagNumber) const;

    /**
        Sets the current caret position to be the search anchor.
    */
    void SearchAnchor();

    /**
        Find some text starting at the search anchor.
        Does not ensure the selection is visible.
    */
    int SearchNext(int searchFlags, const wxString& text);

    /**
        Find some text starting at the search anchor and moving backwards.
        Does not ensure the selection is visible.
    */
    int SearchPrev(int searchFlags, const wxString& text);

    //@}

    /**
        @member_group_name{Overtype, Overtype}
    */
    //@{

    /**
        Set to overtype (true) or insert mode.
    */
    void SetOvertype(bool overType);

    /**
        Returns true if overtype mode is active otherwise false is returned.
    */
    bool GetOvertype() const;

    //@}

    /**
        @member_group_name{CutCopyAndPaste, Cut copy and paste}
    */
    //@{

    /**
        Will a paste succeed?
    */
    bool CanPaste() const;

    /**
        Cut the selection to the clipboard.
    */
    void Cut();

    /**
        Copy the selection to the clipboard.
    */
    void Copy();

    /**
        Paste the contents of the clipboard into the document replacing the selection.
    */
    void Paste();

    /**
        Clear the selection.
    */
    void Clear();

    /**
        Copy a range of text to the clipboard. Positions are clipped into the document.
    */
    void CopyRange(int start, int end);

    /**
        Copy argument text to the clipboard.
    */
    void CopyText(int length, const wxString& text);

    /**
        Enable/Disable convert-on-paste for line endings
    */
    void SetPasteConvertEndings(bool convert);

    /**
        Get convert-on-paste setting
    */
    bool GetPasteConvertEndings() const;

    /**
        Copy the selection, if selection empty copy the line with the caret
    */
    void CopyAllowLine();

    //@}

    /**
        @member_group_name{ErrorHandling, Error handling}
    */
    //@{

    /**
        Change error status - 0 = OK.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_STATUS_OK wxSTC_STATUS_* @endlink constants.
    */
    void SetStatus(int status);

    /**
        Get error status.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_STATUS_OK wxSTC_STATUS_* @endlink constants.
    */
    int GetStatus() const;

    //@}

    /**
        @member_group_name{UndoAndRedo, Undo and Redo}
    */
    //@{

    /**
        Redoes the next action on the undo history.
    */
    void Redo();

    /**
        Choose between collecting actions into the undo
        history and discarding them.
    */
    void SetUndoCollection(bool collectUndo);

    /**
        Are there any redoable actions in the undo history?
    */
    bool CanRedo() const;

    /**
        Is undo history being collected?
    */
    bool GetUndoCollection() const;

    /**
        Start a sequence of actions that is undone and redone as a unit.
        May be nested.
    */
    void BeginUndoAction();

    /**
        End a sequence of actions that is undone and redone as a unit.
    */
    void EndUndoAction();

    /**
        Are there any undoable actions in the undo history?
    */
    bool CanUndo() const;

    /**
        Delete the undo history.
    */
    void EmptyUndoBuffer();

    /**
        Undo one action in the undo history.
    */
    void Undo();

    /**
        Add a container action to the undo stack

        The flags argument can be either 0 or wxSTC_UNDO_MAY_COALESCE.
    */
    void AddUndoAction(int token, int flags);

    //@}

    /**
        @member_group_name{SelectionAndInformation, Selection and information}
    */
    //@{

    /**
        Returns the number of bytes in the document.
    */
    int GetLength() const;

    /**
        Returns the position of the caret.
    */
    int GetCurrentPos() const;

    /**
        Returns the position of the opposite end of the selection to the caret.
    */
    int GetAnchor() const;

    /**
        Select all the text in the document.
    */
    void SelectAll();

    /**
        Find the position from a point within the window.
    */
    int PositionFromPoint(wxPoint pt) const;

    /**
        Find the position from a point within the window but return
        wxSTC_INVALID_POSITION if not close to text.
    */
    int PositionFromPointClose(int x, int y);

    /**
        Set caret to start of a line and ensure it is visible.
    */
    void GotoLine(int line);

    /**
        Set caret to a position and ensure it is visible.
    */
    void GotoPos(int caret);

    /**
        Set the selection anchor to a position. The anchor is the opposite
        end of the selection from the caret.
    */
    void SetAnchor(int anchor);

    /**
        Retrieve the text of the line containing the caret.

        linePos can optionally be passed in to receive the index of the
        caret on the line.
    */
    wxString GetCurLine(int* linePos=NULL);

    /**
        Retrieve the column number of a position, taking tab width into account.
    */
    int GetColumn(int pos) const;

    /**
        Count characters between two positions.
    */
    int CountCharacters(int start, int end);

    /**
        Get the position after the last visible characters on a line.
    */
    int GetLineEndPosition(int line) const;

    /**
        Sets the position of the caret.
    */
    void SetCurrentPos(int caret);

    /**
        Sets the position that starts the selection - this becomes the anchor.
    */
    void SetSelectionStart(int anchor);

    /**
        Returns the position at the start of the selection.
    */
    int GetSelectionStart() const;

    /**
        Sets the position that ends the selection - this becomes the caret.
    */
    void SetSelectionEnd(int caret);

    /**
        Returns the position at the end of the selection.
    */
    int GetSelectionEnd() const;

    /**
        Set caret to a position, while removing any existing selection.
    */
    void SetEmptySelection(int caret);

    /**
        Returns the number of lines in the document. There is always at least one.
    */
    int GetLineCount() const;

    /**
        Is the document different from when it was last saved?
    */
    bool GetModify() const;

    /**
        Retrieve the selected text.
    */
    wxString GetSelectedText();

    /**
        Draw the selection in normal style or with selection highlighted.
    */
    void HideSelection(bool hide);

    /**
        Retrieve the point in the window where a position is displayed.
    */
    wxPoint PointFromPosition(int pos);

    /**
        Retrieve the line containing a position.
    */
    int LineFromPosition(int pos) const;

    /**
        Retrieve the position at the start of a line.
    */
    int PositionFromLine(int line) const;

    /**
        Retrieve the number of characters in the document.
    */
    int GetTextLength() const;

    /**
        Measure the pixel width of some text in a particular style.
        Does not handle tab or control characters.
    */
    int TextWidth(int style, const wxString& text);

    /**
        Retrieve the height of a particular line of text in pixels.
    */
    int TextHeight(int line);

    /**
        Move the caret inside current view if it's not there already.
    */
    void MoveCaretInsideView();

    /**
        How many characters are on a line, including end of line characters?
    */
    int LineLength(int line) const;

    /**
        Retrieves the number of lines completely visible.
    */
    int LinesOnScreen() const;

    /**
        Is the selection rectangular? The alternative is the more common stream selection.
    */
    bool SelectionIsRectangle() const;

    /**
        Set the last x chosen value to be the caret x position.
    */
    void ChooseCaretX();

    /**
        Given a valid document position, return the previous position taking code
        page into account. Returns 0 if passed 0.
    */
    int PositionBefore(int pos);

    /**
        Given a valid document position, return the next position taking code
        page into account. Maximum value returned is the last position in the document.
    */
    int PositionAfter(int pos);

    /**
        Given a valid document position, return a position that differs in a number
        of characters. Returned value is always between 0 and last position in document.

        @since 3.1.0
    */
    int PositionRelative(int pos, int relative);

    /**
        Set the selection mode to stream (wxSTC_SEL_STREAM) or rectangular (wxSTC_SEL_RECTANGLE/wxSTC_SEL_THIN) or
        by lines (wxSTC_SEL_LINES).
    */
    void SetSelectionMode(int selectionMode);

    /**
        Get the mode of the current selection.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_SEL_STREAM wxSTC_SEL_* @endlink constants.
    */
    int GetSelectionMode() const;

    /**
        Retrieve the position of the start of the selection at the given line (wxSTC_INVALID_POSITION if no selection on this line).
    */
    int GetLineSelStartPosition(int line);

    /**
        Retrieve the position of the end of the selection at the given line (wxSTC_INVALID_POSITION if no selection on this line).
    */
    int GetLineSelEndPosition(int line);

    /**
        Find the position of a column on a line taking into account tabs and
        multi-byte characters. If beyond end of line, return line end position.
    */
    int FindColumn(int line, int column);

    /**
        Find the position of a character from a point within the window.
    */
    int CharPositionFromPoint(int x, int y);

    /**
        Find the position of a character from a point within the window.
        Return wxSTC_INVALID_POSITION if not close to text.
    */
    int CharPositionFromPointClose(int x, int y);

    /**
        Set whether switching to rectangular mode while selecting with the mouse is allowed.

        @since 3.1.0
    */
    void SetMouseSelectionRectangularSwitch(bool mouseSelectionRectangularSwitch);

    /**
        Whether switching to rectangular mode while selecting with the mouse is allowed.

        @since 3.1.0
    */
    bool GetMouseSelectionRectangularSwitch() const;

    /**
        Move the selected lines up one line, shifting the line above after the selection
    */
    void MoveSelectedLinesUp();

    /**
        Move the selected lines down one line, shifting the line below before the selection
    */
    void MoveSelectedLinesDown();

    //@}

    /**
        @member_group_name{MultipleSelectionAndVirtualSpace, Multiple Selection and Virtual Space}
    */
    //@{

    /**
        Change the effect of pasting when there are multiple selections.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_MULTIPASTE_ONCE wxSTC_MULTIPASTE_* @endlink constants.
    */
    void SetMultiPaste(int multiPaste);

    /**
        Retrieve the effect of pasting when there are multiple selections.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_MULTIPASTE_ONCE wxSTC_MULTIPASTE_* @endlink constants.
    */
    int GetMultiPaste() const;

    /**
        Set whether multiple selections can be made
    */
    void SetMultipleSelection(bool multipleSelection);

    /**
        Whether multiple selections can be made
    */
    bool GetMultipleSelection() const;

    /**
        Set whether typing can be performed into multiple selections
    */
    void SetAdditionalSelectionTyping(bool additionalSelectionTyping);

    /**
        Whether typing can be performed into multiple selections
    */
    bool GetAdditionalSelectionTyping() const;

    /**
        Set whether additional carets will blink
    */
    void SetAdditionalCaretsBlink(bool additionalCaretsBlink);

    /**
        Whether additional carets will blink
    */
    bool GetAdditionalCaretsBlink() const;

    /**
        Set whether additional carets are visible
    */
    void SetAdditionalCaretsVisible(bool additionalCaretsVisible);

    /**
        Whether additional carets are visible
    */
    bool GetAdditionalCaretsVisible() const;

    /**
        How many selections are there?
    */
    int GetSelections() const;

    /**
        Is every selected range empty?

        @since 3.1.0
    */
    bool GetSelectionEmpty() const;

    /**
        Clear selections to a single empty stream selection
    */
    void ClearSelections();

    /**
        Add a selection
    */
    int AddSelection(int caret, int anchor);

    /**
        Drop one selection

        @since 3.1.0
    */
    void DropSelectionN(int selection);

    /**
        Set the main selection
    */
    void SetMainSelection(int selection);

    /**
        Which selection is the main selection
    */
    int GetMainSelection() const;

    /**
        Set the caret position of the nth selection.
    */
    void SetSelectionNCaret(int selection, int caret);

    /**
        Return the caret position of the nth selection.
    */
    int GetSelectionNCaret(int selection) const;

    /**
        Set the anchor position of the nth selection.
    */
    void SetSelectionNAnchor(int selection, int anchor);

    /**
        Return the anchor position of the nth selection.
    */
    int GetSelectionNAnchor(int selection) const;

    /**
        Set the virtual space of the caret of the nth selection.
    */
    void SetSelectionNCaretVirtualSpace(int selection, int space);

    /**
        Return the virtual space of the caret of the nth selection.
    */
    int GetSelectionNCaretVirtualSpace(int selection) const;

    /**
        Set the virtual space of the anchor of the nth selection.
    */
    void SetSelectionNAnchorVirtualSpace(int selection, int space);

    /**
        Return the virtual space of the anchor of the nth selection.
    */
    int GetSelectionNAnchorVirtualSpace(int selection) const;

    /**
        Sets the position that starts the selection - this becomes the anchor.
    */
    void SetSelectionNStart(int selection, int anchor);

    /**
        Returns the position at the start of the selection.
    */
    int GetSelectionNStart(int selection) const;

    /**
        Sets the position that ends the selection - this becomes the currentPosition.
    */
    void SetSelectionNEnd(int selection, int caret);

    /**
        Returns the position at the end of the selection.
    */
    int GetSelectionNEnd(int selection) const;

    /**
        Set the caret position of the rectangular selection.
    */
    void SetRectangularSelectionCaret(int caret);

    /**
        Return the caret position of the rectangular selection.
    */
    int GetRectangularSelectionCaret() const;

    /**
        Set the anchor position of the rectangular selection.
    */
    void SetRectangularSelectionAnchor(int anchor);

    /**
        Return the anchor position of the rectangular selection.
    */
    int GetRectangularSelectionAnchor() const;

    /**
        Set the virtual space of the caret of the rectangular selection.
    */
    void SetRectangularSelectionCaretVirtualSpace(int space);

    /**
        Return the virtual space of the caret of the rectangular selection.
    */
    int GetRectangularSelectionCaretVirtualSpace() const;

    /**
        Set the virtual space of the anchor of the rectangular selection.
    */
    void SetRectangularSelectionAnchorVirtualSpace(int space);

    /**
        Return the virtual space of the anchor of the rectangular selection.
    */
    int GetRectangularSelectionAnchorVirtualSpace() const;

    /**
        Set options for virtual space behaviour.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_VS_NONE wxSTC_VS_* @endlink constants.
    */
    void SetVirtualSpaceOptions(int virtualSpaceOptions);

    /**
        Return options for virtual space behaviour.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_VS_NONE wxSTC_VS_* @endlink constants.
    */
    int GetVirtualSpaceOptions() const;

    /**
        On GTK+, allow selecting the modifier key to use for mouse-based
        rectangular selection. Often the window manager requires Alt+Mouse Drag
        for moving windows.
        Valid values are wxSTC_KEYMOD_CTRL (default), wxSTC_KEYMOD_ALT, or wxSTC_KEYMOD_SUPER.
    */
    void SetRectangularSelectionModifier(int modifier);

    /**
        Get the modifier key used for rectangular selection.

        The return value will be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_KEYMOD_NORM wxSTC_KEYMOD_* @endlink constants.
    */
    int GetRectangularSelectionModifier() const;

    /**
        Set the foreground colour of additional selections.
        Must have previously called SetSelFore with non-zero first argument for this to have an effect.
    */
    void SetAdditionalSelForeground(const wxColour& fore);

    /**
        Set the background colour of additional selections.
        Must have previously called SetSelBack with non-zero first argument for this to have an effect.
    */
    void SetAdditionalSelBackground(const wxColour& back);

    /**
        Set the alpha of the selection.
    */
    void SetAdditionalSelAlpha(int alpha);

    /**
        Get the alpha of the selection.
    */
    int GetAdditionalSelAlpha() const;

    /**
        Set the foreground colour of additional carets.
    */
    void SetAdditionalCaretForeground(const wxColour& fore);

    /**
        Get the foreground colour of additional carets.
    */
    wxColour GetAdditionalCaretForeground() const;

    /**
        Set the main selection to the next selection.
    */
    void RotateSelection();

    /**
        Swap that caret and anchor of the main selection.
    */
    void SwapMainAnchorCaret();

    /**
        Add the next occurrence of the main selection to the set of selections as main.
        If the current selection is empty then select word around caret.

        @since 3.1.1
    */
    void MultipleSelectAddNext();

    /**
        Add each occurrence of the main selection in the target to the set of selections.
        If the current selection is empty then select word around caret.

        @since 3.1.1
    */
    void MultipleSelectAddEach();

    //@}

    /**
        @member_group_name{ScrollingAndAutomaticScrolling, Scrolling and automatic scrolling}
    */
    //@{

    /**
        Show or hide the horizontal scroll bar.
    */
    void SetUseHorizontalScrollBar(bool visible);

    /**
        Is the horizontal scroll bar visible?
    */
    bool GetUseHorizontalScrollBar() const;

    /**
        Retrieve the display line at the top of the display.
    */
    int GetFirstVisibleLine() const;

    /**
        Scroll horizontally and vertically.
    */
    void LineScroll(int columns, int lines);

    /**
        Ensure the caret is visible.
    */
    void EnsureCaretVisible();

    /**
        Scroll the argument positions and the range between them into view giving
        priority to the primary position then the secondary position.
        This may be used to make a search match visible.

        @since 3.1.0
    */
    void ScrollRange(int secondary, int primary);

    /**
        Sets the document width assumed for scrolling.
    */
    void SetScrollWidth(int pixelWidth);

    /**
        Retrieve the document width assumed for scrolling.
    */
    int GetScrollWidth() const;

    /**
        Sets whether the maximum width line displayed is used to set scroll width.
    */
    void SetScrollWidthTracking(bool tracking);

    /**
        Retrieve whether the scroll width tracks wide lines.
    */
    bool GetScrollWidthTracking() const;

    /**
        Sets the scroll range so that maximum scroll position has
        the last line at the bottom of the view (default).
        Setting this to false allows scrolling one page below the last line.
    */
    void SetEndAtLastLine(bool endAtLastLine);

    /**
        Retrieve whether the maximum scroll position has the last
        line at the bottom of the view.
    */
    bool GetEndAtLastLine() const;

    /**
        Show or hide the vertical scroll bar.
    */
    void SetUseVerticalScrollBar(bool visible);

    /**
        Is the vertical scroll bar visible?
    */
    bool GetUseVerticalScrollBar() const;

    /**
        Scroll so that a display line is at the top of the display.
    */
    void SetFirstVisibleLine(int displayLine);

    /**
        Set the way the display area is determined when a particular line
        is to be moved to by Find, FindNext, GotoLine, etc.

        The first argument should be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_VISIBLE_SLOP wxSTC_VISIBLE_* @endlink constants.
    */
    void SetVisiblePolicy(int visiblePolicy, int visibleSlop);

    /**
        Set the xOffset (ie, horizontal scroll position).
    */
    void SetXOffset(int xOffset);

    /**
        Get the xOffset (ie, horizontal scroll position).
    */
    int GetXOffset() const;

    /**
        Set the way the caret is kept visible when going sideways.
        The exclusion zone is given in pixels.

        The first argument should be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_CARET_SLOP wxSTC_CARET_* @endlink constants.
    */
    void SetXCaretPolicy(int caretPolicy, int caretSlop);

    /**
        Set the way the line the caret is on is kept visible.
        The exclusion zone is given in lines.

        The first argument should be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_CARET_SLOP wxSTC_CARET_* @endlink constants.
    */
    void SetYCaretPolicy(int caretPolicy, int caretSlop);

    //@}

    /**
        @member_group_name{WhiteSpace, White space}
    */
    //@{

    /**
        Are white space characters currently visible?
        Returns one of wxSTC_WS_* constants.
    */
    int GetViewWhiteSpace() const;

    /**
        Make white space characters invisible, always visible or visible outside indentation.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_WS_INVISIBLE wxSTC_WS_* @endlink  constants.
    */
    void SetViewWhiteSpace(int viewWS);

    /**
        Retrieve the current tab draw mode.
        Returns one of wxSTC_TD_* constants.

        @since 3.1.1
    */
    int GetTabDrawMode() const;

    /**
        Set how tabs are drawn when visible.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_TD_LONGARROW wxSTC_TD_* @endlink constants.
        @since 3.1.1
    */
    void SetTabDrawMode(int tabDrawMode);

    /**
        Set the foreground colour of all whitespace and whether to use this setting.
    */
    void SetWhitespaceForeground(bool useSetting, const wxColour& fore);

    /**
        Set the background colour of all whitespace and whether to use this setting.
    */
    void SetWhitespaceBackground(bool useSetting, const wxColour& back);

    /**
        Set the size of the dots used to mark space characters.
    */
    void SetWhitespaceSize(int size);

    /**
        Get the size of the dots used to mark space characters.
    */
    int GetWhitespaceSize() const;

    /**
        Set extra ascent for each line
    */
    void SetExtraAscent(int extraAscent);

    /**
        Get extra ascent for each line
    */
    int GetExtraAscent() const;

    /**
        Set extra descent for each line
    */
    void SetExtraDescent(int extraDescent);

    /**
        Get extra descent for each line
    */
    int GetExtraDescent() const;

    //@}

    /**
        @member_group_name{Cursor, Cursor}
    */
    //@{

    /**
        Sets the cursor to one of the wxSTC_CURSOR* values.
    */
    void SetSTCCursor(int cursorType);

    /**
        Get cursor type.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_CURSORNORMAL wxSTC_CURSOR* @endlink constants.
    */
    int GetSTCCursor() const;

    //@}

    /**
        @member_group_name{MouseCapture, Mouse capture}
    */
    //@{

    /**
        Set whether the mouse is captured when its button is pressed.
    */
    void SetMouseDownCaptures(bool captures);

    /**
        Get whether mouse gets captured.
    */
    bool GetMouseDownCaptures() const;

    /**
        Set whether the mouse wheel can be active outside the window.

        @since 3.1.1
    */
    void SetMouseWheelCaptures(bool captures);

    /**
        Get whether mouse wheel can be active outside the window.

        @since 3.1.1
    */
    bool GetMouseWheelCaptures() const;

    //@}

    /**
        @member_group_name{LineEndings, Line endings}
    */
    //@{

    /**
        Convert all line endings in the document to one mode.
    */
    void ConvertEOLs(int eolMode);

    /**
        Retrieve the current end of line mode - one of wxSTC_EOL_CRLF, wxSTC_EOL_CR, or wxSTC_EOL_LF.
    */
    int GetEOLMode() const;

    /**
        Set the current end of line mode.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_EOL_CRLF wxSTC_EOL_* @endlink  constants.
    */
    void SetEOLMode(int eolMode);

    /**
        Are the end of line characters visible?
    */
    bool GetViewEOL() const;

    /**
        Make the end of line characters visible or invisible.
    */
    void SetViewEOL(bool visible);

    /**
        Set the line end types that the application wants to use. May not be used if incompatible with lexer or encoding.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_LINE_END_TYPE_DEFAULT wxSTC_LINE_END_TYPE_* @endlink constants.
        @since 3.1.0
    */
    void SetLineEndTypesAllowed(int lineEndBitSet);

    /**
        Get the line end types currently allowed.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_LINE_END_TYPE_DEFAULT wxSTC_LINE_END_TYPE_* @endlink constants.
        @since 3.1.0
    */
    int GetLineEndTypesAllowed() const;

    /**
        Get the line end types currently recognised. May be a subset of the allowed types due to lexer limitation.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_LINE_END_TYPE_DEFAULT wxSTC_LINE_END_TYPE_* @endlink constants.
        @since 3.1.0
    */
    int GetLineEndTypesActive() const;

    /**
        Bit set of LineEndType enumertion for which line ends beyond the standard
        LF, CR, and CRLF are supported by the lexer.

        The return value will be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_LINE_END_TYPE_DEFAULT wxSTC_LINE_END_TYPE_* @endlink constants.
        @since 3.1.0
    */
    int GetLineEndTypesSupported() const;

    //@}

    /**
        @member_group_name{Words, Words}
    */
    //@{

    /**
        Set the set of characters making up words for when moving or selecting by word.
        First sets defaults like SetCharsDefault.
    */
    void SetWordChars(const wxString& characters);

    /**
        Get the set of characters making up words for when moving or selecting by word.
    */
    wxString GetWordChars() const;

    /**
        Get position of start of word.
    */
    int WordStartPosition(int pos, bool onlyWordCharacters);

    /**
        Get position of end of word.
    */
    int WordEndPosition(int pos, bool onlyWordCharacters);

    /**
        Is the range start..end considered a word?

        @since 3.1.1
    */
    bool IsRangeWord(int start, int end);

    /**
        Set the set of characters making up whitespace for when moving or selecting by word.
        Should be called after SetWordChars.
    */
    void SetWhitespaceChars(const wxString& characters);

    /**
        Get the set of characters making up whitespace for when moving or selecting by word.
    */
    wxString GetWhitespaceChars() const;

    /**
        Set the set of characters making up punctuation characters
        Should be called after SetWordChars.
    */
    void SetPunctuationChars(const wxString& characters);

    /**
        Get the set of characters making up punctuation characters
    */
    wxString GetPunctuationChars() const;

    /**
        Reset the set of characters for whitespace and word characters to the defaults.
    */
    void SetCharsDefault();

    //@}

    /**
        @member_group_name{Styling, Styling}
    */
    //@{

    /**
        Retrieve the position of the last correctly styled character.
    */
    int GetEndStyled() const;

    /**
        Set the current styling position to start.
    */
    void StartStyling(int start);

    /**
        Change style from current styling position for length characters to a style
        and move the current styling position to after this newly styled segment.
    */
    void SetStyling(int length, int style);

    /**
        Set the styles for a segment of the document.
    */
    void SetStyleBytes(int length, char* styleBytes);

    /**
        Used to hold extra styling information for each line.
    */
    void SetLineState(int line, int state);

    /**
        Retrieve the extra styling information for a line.
    */
    int GetLineState(int line) const;

    /**
        Retrieve the last line number that has line state.
    */
    int GetMaxLineState() const;

    /**
        Sets limits to idle styling.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_IDLESTYLING_NONE wxSTC_IDLESTYLING_* @endlink constants.
        @since 3.1.1
    */
    void SetIdleStyling(int idleStyling);

    /**
        Retrieve the limits to idle styling.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_IDLESTYLING_NONE wxSTC_IDLESTYLING_* @endlink constants.
        @since 3.1.1
    */
    int GetIdleStyling() const;

    //@}

    /**
        @member_group_name{StyleDefinition, Style definition}
    */
    //@{

    /**
        Clear all the styles and make equivalent to the global default style.
    */
    void StyleClearAll();

    /**
        Set the foreground colour of a style.
    */
    void StyleSetForeground(int style, const wxColour& fore);

    /**
        Set the background colour of a style.
    */
    void StyleSetBackground(int style, const wxColour& back);

    /**
        Set a style to be bold or not.
    */
    void StyleSetBold(int style, bool bold);

    /**
        Set a style to be italic or not.
    */
    void StyleSetItalic(int style, bool italic);

    /**
        Set the size of characters of a style.
    */
    void StyleSetSize(int style, int sizePoints);

    /**
        Set the font of a style.
    */
    void StyleSetFaceName(int style, const wxString& fontName);

    /**
        Set a style to have its end of line filled or not.
    */
    void StyleSetEOLFilled(int style, bool eolFilled);

    /**
        Reset the default style to its state at startup
    */
    void StyleResetDefault();

    /**
        Set a style to be underlined or not.
    */
    void StyleSetUnderline(int style, bool underline);

    /**
        Get the foreground colour of a style.
    */
    wxColour StyleGetForeground(int style) const;

    /**
        Get the background colour of a style.
    */
    wxColour StyleGetBackground(int style) const;

    /**
        Get is a style bold or not.
    */
    bool StyleGetBold(int style) const;

    /**
        Get is a style italic or not.
    */
    bool StyleGetItalic(int style) const;

    /**
        Get the size of characters of a style.
    */
    int StyleGetSize(int style) const;

    /**
        Get the font facename of a style
    */
    wxString StyleGetFaceName(int style);

    /**
        Get is a style to have its end of line filled or not.
    */
    bool StyleGetEOLFilled(int style) const;

    /**
        Get is a style underlined or not.
    */
    bool StyleGetUnderline(int style) const;

    /**
        Get is a style mixed case, or to force upper or lower case.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_CASE_MIXED wxSTC_CASE_* @endlink constants.
    */
    int StyleGetCase(int style) const;

    /**
        Get the character get of the font in a style.
    */
    int StyleGetCharacterSet(int style) const;

    /**
        Get is a style visible or not.
    */
    bool StyleGetVisible(int style) const;

    /**
        Get is a style changeable or not (read only).
        Experimental feature, currently buggy.
    */
    bool StyleGetChangeable(int style) const;

    /**
        Get is a style a hotspot or not.
    */
    bool StyleGetHotSpot(int style) const;

    /**
        Set a style to be mixed case, or to force upper or lower case.

        The second argument should be one of the
        @link wxStyledTextCtrl::wxSTC_CASE_MIXED wxSTC_CASE_* @endlink constants.
    */
    void StyleSetCase(int style, int caseVisible);

    /**
        Set the size of characters of a style. Size is in points multiplied by 100.
    */
    void StyleSetSizeFractional(int style, int sizeHundredthPoints);

    /**
        Get the size of characters of a style in points multiplied by 100
    */
    int StyleGetSizeFractional(int style) const;

    /**
        Set the weight of characters of a style.

        The second argument can be an integer or one of the
        @link wxStyledTextCtrl::wxSTC_WEIGHT_NORMAL wxSTC_WEIGHT_* @endlink constants.
    */
    void StyleSetWeight(int style, int weight);

    /**
        Get the weight of characters of a style.

        The return value will be an integer that is possibly one of the
        @link wxStyledTextCtrl::wxSTC_WEIGHT_NORMAL wxSTC_WEIGHT_* @endlink constants.
    */
    int StyleGetWeight(int style) const;

    /**
        Set the character set of the font in a style.

        Converts the Scintilla character set values to a wxFontEncoding.
    */
    void StyleSetCharacterSet(int style, int characterSet);

    /**
        Set a style to be a hotspot or not.
    */
    void StyleSetHotSpot(int style, bool hotspot);

    /**
        Set a style to be visible or not.
    */
    void StyleSetVisible(int style, bool visible);

    /**
        Set a style to be changeable or not (read only).
        Experimental feature, currently buggy.
    */
    void StyleSetChangeable(int style, bool changeable);

    //@}

    /**
        @member_group_name{CaretAndSelectionStyles, Caret selection and hotspot styles}
    */
    //@{

    /**
        Set the foreground colour of the main and additional selections and whether to use this setting.
    */
    void SetSelForeground(bool useSetting, const wxColour& fore);

    /**
        Set the background colour of the main and additional selections and whether to use this setting.
    */
    void SetSelBackground(bool useSetting, const wxColour& back);

    /**
        Get the alpha of the selection.
    */
    int GetSelAlpha() const;

    /**
        Set the alpha of the selection.
    */
    void SetSelAlpha(int alpha);

    /**
        Is the selection end of line filled?
    */
    bool GetSelEOLFilled() const;

    /**
        Set the selection to have its end of line filled or not.
    */
    void SetSelEOLFilled(bool filled);

    /**
        Set the foreground colour of the caret.
    */
    void SetCaretForeground(const wxColour& fore);

    /**
        Get the time in milliseconds that the caret is on and off.
    */
    int GetCaretPeriod() const;

    /**
        Get the time in milliseconds that the caret is on and off. 0 = steady on.
    */
    void SetCaretPeriod(int periodMilliseconds);

    /**
        Is the background of the line containing the caret in a different colour?
    */
    bool GetCaretLineVisible() const;

    /**
        Display the background of the line containing the caret in a different colour.
    */
    void SetCaretLineVisible(bool show);

    /**
        Get the colour of the background of the line containing the caret.
    */
    wxColour GetCaretLineBackground() const;

    /**
        Set the colour of the background of the line containing the caret.
    */
    void SetCaretLineBackground(const wxColour& back);

    /**
        Get the foreground colour of the caret.
    */
    wxColour GetCaretForeground() const;

    /**
        Set the width of the insert mode caret.
    */
    void SetCaretWidth(int pixelWidth);

    /**
        Returns the width of the insert mode caret.
    */
    int GetCaretWidth() const;

    /**
        Set a fore colour for active hotspots.
    */
    void SetHotspotActiveForeground(bool useSetting, const wxColour& fore);

    /**
        Get the fore colour for active hotspots.
    */
    wxColour GetHotspotActiveForeground() const;

    /**
        Set a back colour for active hotspots.
    */
    void SetHotspotActiveBackground(bool useSetting, const wxColour& back);

    /**
        Get the back colour for active hotspots.
    */
    wxColour GetHotspotActiveBackground() const;

    /**
        Enable / Disable underlining active hotspots.
    */
    void SetHotspotActiveUnderline(bool underline);

    /**
        Get whether underlining for active hotspots.
    */
    bool GetHotspotActiveUnderline() const;

    /**
        Limit hotspots to single line so hotspots on two lines don't merge.
    */
    void SetHotspotSingleLine(bool singleLine);

    /**
        Get the HotspotSingleLine property
    */
    bool GetHotspotSingleLine() const;

    /**
        Can the caret preferred x position only be changed by explicit movement commands?

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_CARETSTICKY_OFF wxSTC_CARETSTICKY_* @endlink constants.
    */
    int GetCaretSticky() const;

    /**
        Stop the caret preferred x position changing when the user types.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_CARETSTICKY_OFF wxSTC_CARETSTICKY_* @endlink constants.
    */
    void SetCaretSticky(int useCaretStickyBehaviour);

    /**
        Switch between sticky and non-sticky: meant to be bound to a key.
    */
    void ToggleCaretSticky();

    /**
        Set background alpha of the caret line.
    */
    void SetCaretLineBackAlpha(int alpha);

    /**
        Get the background alpha of the caret line.
    */
    int GetCaretLineBackAlpha() const;

    /**
        Set the style of the caret to be drawn.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_CARETSTYLE_INVISIBLE wxSTC_CARETSTYLE_* @endlink constants.
    */
    void SetCaretStyle(int caretStyle);

    /**
        Returns the current style of the caret.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_CARETSTYLE_INVISIBLE wxSTC_CARETSTYLE_* @endlink constants.
    */
    int GetCaretStyle() const;

    /**
        Is the caret line always visible?

        @since 3.1.0
    */
    bool GetCaretLineVisibleAlways() const;

    /**
        Sets the caret line to always visible.

        @since 3.1.0
    */
    void SetCaretLineVisibleAlways(bool alwaysVisible);

    //@}

    /**
        @member_group_name{CharacterRepresentations, Character representations}
    */
    //@{

    /**
        Change the way control characters are displayed:
        If symbol is < 32, keep the drawn way, else, use the given character.
    */
    void SetControlCharSymbol(int symbol);

    /**
        Get the way control characters are displayed.
    */
    int GetControlCharSymbol() const;

    /**
        Set the way a character is drawn.

        @since 3.1.0
    */
    void SetRepresentation(const wxString& encodedCharacter, const wxString& representation);

    /**
        Set the way a character is drawn.

        @since 3.1.0
    */
    wxString GetRepresentation(const wxString& encodedCharacter) const;

    /**
        Remove a character representation.

        @since 3.1.0
    */
    void ClearRepresentation(const wxString& encodedCharacter);

    //@}

    /**
        @member_group_name{Margins, Margins}
    */
    //@{

    /**
        Set a margin to be either numeric or symbolic.

        The second argument should be one of the
        @link wxStyledTextCtrl::wxSTC_MARGIN_SYMBOL wxSTC_MARGIN_* @endlink constants.
    */
    void SetMarginType(int margin, int marginType);

    /**
        Retrieve the type of a margin.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_MARGIN_SYMBOL wxSTC_MARGIN_* @endlink constants.
    */
    int GetMarginType(int margin) const;

    /**
        Set the width of a margin to a width expressed in pixels.
    */
    void SetMarginWidth(int margin, int pixelWidth);

    /**
        Retrieve the width of a margin in pixels.
    */
    int GetMarginWidth(int margin) const;

    /**
        Set a mask that determines which markers are displayed in a margin.
    */
    void SetMarginMask(int margin, int mask);

    /**
        Retrieve the marker mask of a margin.
    */
    int GetMarginMask(int margin) const;

    /**
        Make a margin sensitive or insensitive to mouse clicks.
    */
    void SetMarginSensitive(int margin, bool sensitive);

    /**
        Retrieve the mouse click sensitivity of a margin.
    */
    bool GetMarginSensitive(int margin) const;

    /**
        Set the cursor shown when the mouse is inside a margin.

        The second argument should be one of the
        @link wxStyledTextCtrl::wxSTC_CURSORNORMAL wxSTC_CURSOR* @endlink constants.
    */
    void SetMarginCursor(int margin, int cursor);

    /**
        Retrieve the cursor shown in a margin.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_CURSORNORMAL wxSTC_CURSOR* @endlink constants.
    */
    int GetMarginCursor(int margin) const;

    /**
        Set the background colour of a margin. Only visible for wxSTC_MARGIN_COLOUR.

        @since 3.1.1
    */
    void SetMarginBackground(int margin, const wxColour& back);

    /**
        Retrieve the background colour of a margin

        @since 3.1.1
    */
    wxColour GetMarginBackground(int margin) const;

    /**
        Allocate a non-standard number of margins.

        @since 3.1.1
    */
    void SetMarginCount(int margins);

    /**
        How many margins are there?.

        @since 3.1.1
    */
    int GetMarginCount() const;

    /**
        Sets the size in pixels of the left margin.
    */
    void SetMarginLeft(int pixelWidth);

    /**
        Returns the size in pixels of the left margin.
    */
    int GetMarginLeft() const;

    /**
        Sets the size in pixels of the right margin.
    */
    void SetMarginRight(int pixelWidth);

    /**
        Returns the size in pixels of the right margin.
    */
    int GetMarginRight() const;

    /**
        Set one of the colours used as a chequerboard pattern in the fold margin
    */
    void SetFoldMarginColour(bool useSetting, const wxColour& back);

    /**
        Set the other colour used as a chequerboard pattern in the fold margin
    */
    void SetFoldMarginHiColour(bool useSetting, const wxColour& fore);

    /**
        Set the text in the text margin for a line
    */
    void MarginSetText(int line, const wxString& text);

    /**
        Get the text in the text margin for a line
    */
    wxString MarginGetText(int line) const;

    /**
        Set the style number for the text margin for a line
    */
    void MarginSetStyle(int line, int style);

    /**
        Get the style number for the text margin for a line
    */
    int MarginGetStyle(int line) const;

    /**
        Set the style in the text margin for a line
    */
    void MarginSetStyles(int line, const wxString& styles);

    /**
        Get the styles in the text margin for a line
    */
    wxString MarginGetStyles(int line) const;

    /**
        Clear the margin text on all lines
    */
    void MarginTextClearAll();

    /**
        Get the start of the range of style numbers used for margin text
    */
    void MarginSetStyleOffset(int style);

    /**
        Get the start of the range of style numbers used for margin text
    */
    int MarginGetStyleOffset() const;

    /**
        Set the margin options.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_MARGINOPTION_NONE wxSTC_MARGINOPTION_* @endlink constants.
    */
    void SetMarginOptions(int marginOptions);

    /**
        Get the margin options.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_MARGINOPTION_NONE wxSTC_MARGINOPTION_* @endlink constants.
    */
    int GetMarginOptions() const;

    //@}

    /**
        @member_group_name{Annotations, Annotations}
    */
    //@{

    /**
        Set the annotation text for a line
    */
    void AnnotationSetText(int line, const wxString& text);

    /**
        Get the annotation text for a line
    */
    wxString AnnotationGetText(int line) const;

    /**
        Set the style number for the annotations for a line
    */
    void AnnotationSetStyle(int line, int style);

    /**
        Get the style number for the annotations for a line
    */
    int AnnotationGetStyle(int line) const;

    /**
        Set the annotation styles for a line
    */
    void AnnotationSetStyles(int line, const wxString& styles);

    /**
        Get the annotation styles for a line
    */
    wxString AnnotationGetStyles(int line) const;

    /**
        Get the number of annotation lines for a line
    */
    int AnnotationGetLines(int line) const;

    /**
        Clear the annotations from all lines
    */
    void AnnotationClearAll();

    /**
        Set the visibility for the annotations for a view

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_ANNOTATION_HIDDEN wxSTC_ANNOTATION_* @endlink constants.
    */
    void AnnotationSetVisible(int visible);

    /**
        Get the visibility for the annotations for a view

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_ANNOTATION_HIDDEN wxSTC_ANNOTATION_* @endlink constants.
    */
    int AnnotationGetVisible() const;

    /**
        Get the start of the range of style numbers used for annotations
    */
    void AnnotationSetStyleOffset(int style);

    /**
        Get the start of the range of style numbers used for annotations
    */
    int AnnotationGetStyleOffset() const;

    //@}

    /**
        @member_group_name{OtherSettings, Other settings}
    */
    //@{

    /**
        Is drawing done first into a buffer or direct to the screen?
    */
    bool GetBufferedDraw() const;

    /**
        If drawing is buffered then each line of text is drawn into a bitmap buffer
        before drawing it to the screen to avoid flicker.
    */
    void SetBufferedDraw(bool buffered);

    /**
        Set the code page used to interpret the bytes of the document as characters.
    */
    void SetCodePage(int codePage);

    /**
        Is the IME displayed in a window or inline?

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_IME_WINDOWED wxSTC_IME_* @endlink constants.
        @since 3.1.0
    */
    int GetIMEInteraction() const;

    /**
        Choose to display the the IME in a winow or inline.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_IME_WINDOWED wxSTC_IME_* @endlink constants.
        @since 3.1.0
    */
    void SetIMEInteraction(int imeInteraction);

    /**
        Get the code page used to interpret the bytes of the document as characters.
    */
    int GetCodePage() const;

    /**
        Sets the degree of caching of layout information.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_CACHE_NONE wxSTC_CACHE_* @endlink constants.
    */
    void SetLayoutCache(int cacheMode);

    /**
        Is drawing done in two phases with backgrounds drawn before foregrounds?
    */
    bool GetTwoPhaseDraw() const;

    /**
        In twoPhaseDraw mode, drawing is performed in two phases, first the background
        and then the foreground. This avoids chopping off characters that overlap the next run.
    */
    void SetTwoPhaseDraw(bool twoPhase);

    /**
        How many phases is drawing done in?

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_PHASES_ONE wxSTC_PHASES_* @endlink constants.
        @since 3.1.0
    */
    int GetPhasesDraw() const;

    /**
        In one phase draw, text is drawn in a series of rectangular blocks with no overlap.
        In two phase draw, text is drawn in a series of lines allowing runs to overlap horizontally.
        In multiple phase draw, each element is drawn over the whole drawing area, allowing text
        to overlap from one line to the next.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_PHASES_ONE wxSTC_PHASES_* @endlink constants.
        @since 3.1.0
    */
    void SetPhasesDraw(int phases);

    /**
        Choose the quality level for text.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_EFF_QUALITY_DEFAULT wxSTC_EFF_QUALITY_* @endlink constants.
        @remarks
        This method only has any effect with the wxMSW port and when
        technology has been set to wxSTC_TECHNOLOGY_DIRECTWRITE.
        @since 3.1.1
    */
    void SetFontQuality(int fontQuality);

    /**
        Retrieve the quality level for text.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_EFF_QUALITY_DEFAULT wxSTC_EFF_QUALITY_* @endlink constants.
        @since 3.1.1
    */
    int GetFontQuality() const;

    /**
        Change internal focus flag.
    */
    void SetSTCFocus(bool focus);

    /**
        Get internal focus flag.
    */
    bool GetSTCFocus() const;

    /**
        Set the technology used.

        @remarks
        For the wxMSW port, the input can be either wxSTC_TECHNOLOGY_DEFAULT
        or wxSTC_TECHNOLOGY_DIRECTWRITE.  With other ports, this method has
        no effect.
    */
    void SetTechnology(int technology);

    /**
        Get the tech.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_TECHNOLOGY_DEFAULT wxSTC_TECHNOLOGY_* @endlink constants.
    */
    int GetTechnology() const;

    //@}

    /**
        @member_group_name{BraceHighlighting, Brace highlighting}
    */
    //@{

    /**
        Highlight the characters at two positions.
    */
    void BraceHighlight(int posA, int posB);

    /**
        Use specified indicator to highlight matching braces instead of changing their style.
    */
    void BraceHighlightIndicator(bool useSetting, int indicator);

    /**
        Highlight the character at a position indicating there is no matching brace.
    */
    void BraceBadLight(int pos);

    /**
        Use specified indicator to highlight non matching brace instead of changing its style.
    */
    void BraceBadLightIndicator(bool useSetting, int indicator);

    /**
        Find the position of a matching brace or wxSTC_INVALID_POSITION if no match.
        The maxReStyle must be 0 for now. It may be defined in a future release.
    */
    int BraceMatch(int pos, int maxReStyle=0);

    //@}

    /**
        @member_group_name{TabsAndIndentationGuides, Tabs and Indentation Guides}
    */
    //@{

    /**
        Change the visible size of a tab to be a multiple of the width of a space character.
    */
    void SetTabWidth(int tabWidth);

    /**
        Retrieve the visible size of a tab.
    */
    int GetTabWidth() const;

    /**
        Clear explicit tabstops on a line.

        @since 3.1.0
    */
    void ClearTabStops(int line);

    /**
        Add an explicit tab stop for a line.

        @since 3.1.0
    */
    void AddTabStop(int line, int x);

    /**
        Find the next explicit tab stop position on a line after a position.

        @since 3.1.0
    */
    int GetNextTabStop(int line, int x);

    /**
        Set the number of spaces used for one level of indentation.
    */
    void SetIndent(int indentSize);

    /**
        Retrieve indentation size.
    */
    int GetIndent() const;

    /**
        Indentation will only use space characters if useTabs is false, otherwise
        it will use a combination of tabs and spaces.
    */
    void SetUseTabs(bool useTabs);

    /**
        Retrieve whether tabs will be used in indentation.
    */
    bool GetUseTabs() const;

    /**
        Change the indentation of a line to a number of columns.
    */
    void SetLineIndentation(int line, int indentation);

    /**
        Retrieve the number of columns that a line is indented.
    */
    int GetLineIndentation(int line) const;

    /**
        Retrieve the position before the first non indentation character on a line.
    */
    int GetLineIndentPosition(int line) const;

    /**
        Show or hide indentation guides.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_IV_NONE wxSTC_IV_* @endlink constants.
    */
    void SetIndentationGuides(int indentView);

    /**
        Are the indentation guides visible?

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_IV_NONE wxSTC_IV_* @endlink constants.
    */
    int GetIndentationGuides() const;

    /**
        Set the highlighted indentation guide column.
        0 = no highlighted guide.
    */
    void SetHighlightGuide(int column);

    /**
        Get the highlighted indentation guide column.
    */
    int GetHighlightGuide() const;

    /**
        Sets whether a tab pressed when caret is within indentation indents.
    */
    void SetTabIndents(bool tabIndents);

    /**
        Does a tab pressed when caret is within indentation indent?
    */
    bool GetTabIndents() const;

    /**
        Sets whether a backspace pressed when caret is within indentation unindents.
    */
    void SetBackSpaceUnIndents(bool bsUnIndents);

    /**
        Does a backspace pressed when caret is within indentation unindent?
    */
    bool GetBackSpaceUnIndents() const;

    //@}

    /**
        @member_group_name{Markers, Markers}

        @see MarkerDefineBitmap
    */
    //@{

    /**
        Retrieve the line number at which a particular marker is located.
    */
    int MarkerLineFromHandle(int markerHandle);

    /**
        Delete a marker.
    */
    void MarkerDeleteHandle(int markerHandle);

    /**
        Set the symbol used for a particular marker number,
        and optionally the fore and background colours.

        The second argument should be one of the
        @link wxStyledTextCtrl::wxSTC_MARK_CIRCLE wxSTC_MARK_* @endlink constants.
    */
    void MarkerDefine(int markerNumber, int markerSymbol,
                const wxColour& foreground = wxNullColour,
                const wxColour& background = wxNullColour);

    /**
        Set the foreground colour used for a particular marker number.
    */
    void MarkerSetForeground(int markerNumber, const wxColour& fore);

    /**
        Set the background colour used for a particular marker number.
    */
    void MarkerSetBackground(int markerNumber, const wxColour& back);

    /**
        Set the background colour used for a particular marker number when its folding block is selected.
    */
    void MarkerSetBackgroundSelected(int markerNumber, const wxColour& back);

    /**
        Enable/disable highlight for current folding block (smallest one that contains the caret)
    */
    void MarkerEnableHighlight(bool enabled);

    /**
        Add a marker to a line, returning an ID which can be used to find or delete the marker.
    */
    int MarkerAdd(int line, int markerNumber);

    /**
        Delete a marker from a line.
    */
    void MarkerDelete(int line, int markerNumber);

    /**
        Delete all markers with a particular number from all lines.
    */
    void MarkerDeleteAll(int markerNumber);

    /**
        Get a bit mask of all the markers set on a line.
    */
    int MarkerGet(int line);

    /**
        Find the next line at or after lineStart that includes a marker in mask.
        Return -1 when no more lines.
    */
    int MarkerNext(int lineStart, int markerMask);

    /**
        Find the previous line before lineStart that includes a marker in mask.
    */
    int MarkerPrevious(int lineStart, int markerMask);

    /**
        Define a marker from a bitmap

        @since 3.1.3
    */
    void MarkerDefinePixmap(int markerNumber, const char* const* xpmData);

    /**
        Add a set of markers to a line.
    */
    void MarkerAddSet(int line, int markerSet);

    /**
        Set the alpha used for a marker that is drawn in the text area, not the margin.
    */
    void MarkerSetAlpha(int markerNumber, int alpha);

    /**
        Which symbol was defined for markerNumber with MarkerDefine

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_MARK_CIRCLE wxSTC_MARK_* @endlink constants.
    */
    int GetMarkerSymbolDefined(int markerNumber);

    /**
        Set the width for future RGBA image data.
    */
    void RGBAImageSetWidth(int width);

    /**
        Set the height for future RGBA image data.
    */
    void RGBAImageSetHeight(int height);

    /**
        Set the scale factor in percent for future RGBA image data.

        @since 3.1.0
    */
    void RGBAImageSetScale(int scalePercent);

    /**
        Define a marker from RGBA data.
        It has the width and height from RGBAImageSetWidth/Height
    */
    void MarkerDefineRGBAImage(int markerNumber, const unsigned char* pixels);

    //@}

    /**
        @member_group_name{Indicators, Indicators}
    */
    //@{

    /**
        Set an indicator to plain, squiggle or TT.

        The second argument should be one of the
        @link wxStyledTextCtrl::wxSTC_INDIC_PLAIN wxSTC_INDIC_* @endlink constants.
    */
    void IndicatorSetStyle(int indicator, int indicatorStyle);

    /**
        Retrieve the style of an indicator.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_INDIC_PLAIN wxSTC_INDIC_* @endlink constants.
    */
    int IndicatorGetStyle(int indicator) const;

    /**
        Set the foreground colour of an indicator.
    */
    void IndicatorSetForeground(int indicator, const wxColour& fore);

    /**
        Retrieve the foreground colour of an indicator.
    */
    wxColour IndicatorGetForeground(int indicator) const;

    /**
        Set an indicator to draw under text or over(default).
    */
    void IndicatorSetUnder(int indicator, bool under);

    /**
        Retrieve whether indicator drawn under or over text.
    */
    bool IndicatorGetUnder(int indicator) const;

    /**
        Set a hover indicator to plain, squiggle or TT.

        @since 3.1.0
    */
    void IndicatorSetHoverStyle(int indicator, int indicatorStyle);

    /**
        Retrieve the hover style of an indicator.

        @since 3.1.0
    */
    int IndicatorGetHoverStyle(int indicator) const;

    /**
        Set the foreground hover colour of an indicator.

        @since 3.1.0
    */
    void IndicatorSetHoverForeground(int indicator, const wxColour& fore);

    /**
        Retrieve the foreground hover colour of an indicator.

        @since 3.1.0
    */
    wxColour IndicatorGetHoverForeground(int indicator) const;

    /**
        Set the attributes of an indicator.

        The second argument should be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_INDICFLAG_VALUEFORE wxSTC_INDICFLAG_* @endlink constants.
        @since 3.1.0
    */
    void IndicatorSetFlags(int indicator, int flags);

    /**
        Retrieve the attributes of an indicator.

        The return value will be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_INDICFLAG_VALUEFORE wxSTC_INDICFLAG_* @endlink constants.
        @since 3.1.0
    */
    int IndicatorGetFlags(int indicator) const;

    /**
        Set the indicator used for IndicatorFillRange and IndicatorClearRange
    */
    void SetIndicatorCurrent(int indicator);

    /**
        Get the current indicator
    */
    int GetIndicatorCurrent() const;

    /**
        Set the value used for IndicatorFillRange
    */
    void SetIndicatorValue(int value);

    /**
        Get the current indicator value
    */
    int GetIndicatorValue() const;

    /**
        Turn a indicator on over a range.
    */
    void IndicatorFillRange(int start, int lengthFill);

    /**
        Turn a indicator off over a range.
    */
    void IndicatorClearRange(int start, int lengthClear);

    /**
        Are any indicators present at pos?
    */
    int IndicatorAllOnFor(int pos);

    /**
        What value does a particular indicator have at a position?
    */
    int IndicatorValueAt(int indicator, int pos);

    /**
        Where does a particular indicator start?
    */
    int IndicatorStart(int indicator, int pos);

    /**
        Where does a particular indicator end?
    */
    int IndicatorEnd(int indicator, int pos);

    /**
        Set the alpha fill colour of the given indicator.
    */
    void IndicatorSetAlpha(int indicator, int alpha);

    /**
        Get the alpha fill colour of the given indicator.
    */
    int IndicatorGetAlpha(int indicator) const;

    /**
        Set the alpha outline colour of the given indicator.
    */
    void IndicatorSetOutlineAlpha(int indicator, int alpha);

    /**
        Get the alpha outline colour of the given indicator.
    */
    int IndicatorGetOutlineAlpha(int indicator) const;

    //@}

    /**
        @member_group_name{Autocompletion, Autocompletion}

        @see RegisterImage(int, const wxBitmap&)
    */
    //@{

    /**
        Display a auto-completion list.
        The lengthEntered parameter indicates how many characters before
        the caret should be used to provide context.
    */
    void AutoCompShow(int lengthEntered, const wxString& itemList);

    /**
        Remove the auto-completion list from the screen.
    */
    void AutoCompCancel();

    /**
        Is there an auto-completion list visible?
    */
    bool AutoCompActive();

    /**
        Retrieve the position of the caret when the auto-completion list was displayed.
    */
    int AutoCompPosStart();

    /**
        User has selected an item so remove the list and insert the selection.
    */
    void AutoCompComplete();

    /**
        Define a set of character that when typed cancel the auto-completion list.
    */
    void AutoCompStops(const wxString& characterSet);

    /**
        Change the separator character in the string setting up an auto-completion list.
        Default is space but can be changed if items contain space.
    */
    void AutoCompSetSeparator(int separatorCharacter);

    /**
        Retrieve the auto-completion list separator character.
    */
    int AutoCompGetSeparator() const;

    /**
        Select the item in the auto-completion list that starts with a string.
    */
    void AutoCompSelect(const wxString& select);

    /**
        Should the auto-completion list be cancelled if the user backspaces to a
        position before where the box was created.
    */
    void AutoCompSetCancelAtStart(bool cancel);

    /**
        Retrieve whether auto-completion cancelled by backspacing before start.
    */
    bool AutoCompGetCancelAtStart() const;

    /**
        Define a set of characters that when typed will cause the autocompletion to
        choose the selected item.
    */
    void AutoCompSetFillUps(const wxString& characterSet);

    /**
        Should a single item auto-completion list automatically choose the item.
    */
    void AutoCompSetChooseSingle(bool chooseSingle);

    /**
        Retrieve whether a single item auto-completion list automatically choose the item.
    */
    bool AutoCompGetChooseSingle() const;

    /**
        Set whether case is significant when performing auto-completion searches.
    */
    void AutoCompSetIgnoreCase(bool ignoreCase);

    /**
        Retrieve state of ignore case flag.
    */
    bool AutoCompGetIgnoreCase() const;

    /**
        Set whether or not autocompletion is hidden automatically when nothing matches.
    */
    void AutoCompSetAutoHide(bool autoHide);

    /**
        Retrieve whether or not autocompletion is hidden automatically when nothing matches.
    */
    bool AutoCompGetAutoHide() const;

    /**
        Set whether or not autocompletion deletes any word characters
        after the inserted text upon completion.
    */
    void AutoCompSetDropRestOfWord(bool dropRestOfWord);

    /**
        Retrieve whether or not autocompletion deletes any word characters
        after the inserted text upon completion.
    */
    bool AutoCompGetDropRestOfWord() const;

    /**
        Register an image for use in autocompletion lists.

        @since 3.1.3
    */
    void RegisterImage(int type, const char* const* xpmData);

    /**
        Clear all the registered images.
    */
    void ClearRegisteredImages();

    /**
        Retrieve the auto-completion list type-separator character.
    */
    int AutoCompGetTypeSeparator() const;

    /**
        Change the type-separator character in the string setting up an auto-completion list.
        Default is '?' but can be changed if items contain '?'.
    */
    void AutoCompSetTypeSeparator(int separatorCharacter);

    /**
        Set the maximum width, in characters, of auto-completion and user lists.
        Set to 0 to autosize to fit longest item, which is the default.
    */
    void AutoCompSetMaxWidth(int characterCount);

    /**
        Get the maximum width, in characters, of auto-completion and user lists.
    */
    int AutoCompGetMaxWidth() const;

    /**
        Set the maximum height, in rows, of auto-completion and user lists.
        The default is 5 rows.
    */
    void AutoCompSetMaxHeight(int rowCount);

    /**
        Set the maximum height, in rows, of auto-completion and user lists.
    */
    int AutoCompGetMaxHeight() const;

    /**
        Get currently selected item position in the auto-completion list
    */
    int AutoCompGetCurrent() const;

    /**
        Get currently selected item text in the auto-completion list

        @since 3.1.1
    */
    wxString AutoCompGetCurrentText() const;

    /**
        Set auto-completion case insensitive behaviour to either prefer case-sensitive matches or have no preference.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_CASEINSENSITIVEBEHAVIOUR_RESPECTCASE wxSTC_CASEINSENSITIVEBEHAVIOUR_* @endlink constants.
    */
    void AutoCompSetCaseInsensitiveBehaviour(int behaviour);

    /**
        Get auto-completion case insensitive behaviour.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_CASEINSENSITIVEBEHAVIOUR_RESPECTCASE wxSTC_CASEINSENSITIVEBEHAVIOUR_* @endlink constants.
    */
    int AutoCompGetCaseInsensitiveBehaviour() const;

    /**
        Change the effect of autocompleting when there are multiple selections.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_MULTIAUTOC_ONCE wxSTC_MULTIAUTOC_* @endlink constants.
        @since 3.1.0
    */
    void AutoCompSetMulti(int multi);

    /**
        Retrieve the effect of autocompleting when there are multiple selections.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_MULTIAUTOC_ONCE wxSTC_MULTIAUTOC_* @endlink constants.
        @since 3.1.0
    */
    int AutoCompGetMulti() const;

    /**
        Set the way autocompletion lists are ordered.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_ORDER_PRESORTED wxSTC_ORDER_* @endlink constants.
        @since 3.1.0
    */
    void AutoCompSetOrder(int order);

    /**
        Get the way autocompletion lists are ordered.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_ORDER_PRESORTED wxSTC_ORDER_* @endlink constants.
        @since 3.1.0
    */
    int AutoCompGetOrder() const;

    /**
        Register an RGBA image for use in autocompletion lists.
        It has the width and height from RGBAImageSetWidth/Height
    */
    void RegisterRGBAImage(int type, const unsigned char* pixels);

    //@}

    /**
        @member_group_name{UserLists, User lists}
    */
    //@{

    /**
        Display a list of strings and send notification when user chooses one.
    */
    void UserListShow(int listType, const wxString& itemList);

    //@}

    /**
        @member_group_name{CallTips, Call tips}
    */
    //@{

    /**
        Show a call tip containing a definition near position pos.
    */
    void CallTipShow(int pos, const wxString& definition);

    /**
        Remove the call tip from the screen.
    */
    void CallTipCancel();

    /**
        Is there an active call tip?
    */
    bool CallTipActive();

    /**
        Retrieve the position where the caret was before displaying the call tip.

        @since 3.1.0
    */
    int CallTipPosAtStart();

    /**
        Set the start position in order to change when backspacing removes the calltip.
    */
    void CallTipSetPosAtStart(int posStart);

    /**
        Highlight a segment of the definition.
    */
    void CallTipSetHighlight(int highlightStart, int highlightEnd);

    /**
        Set the background colour for the call tip.
    */
    void CallTipSetBackground(const wxColour& back);

    /**
        Set the foreground colour for the call tip.
    */
    void CallTipSetForeground(const wxColour& fore);

    /**
        Set the foreground colour for the highlighted part of the call tip.
    */
    void CallTipSetForegroundHighlight(const wxColour& fore);

    /**
        Enable use of wxSTC_STYLE_CALLTIP and set call tip tab size in pixels.
    */
    void CallTipUseStyle(int tabSize);

    /**
        Set position of calltip, above or below text.
    */
    void CallTipSetPosition(bool above);

    //@}

    /**
        @member_group_name{KeyboardCommands, Keyboard commands}
    */
    //@{

    /**
        Move caret down one line.
    */
    void LineDown();

    /**
        Move caret down one line extending selection to new caret position.
    */
    void LineDownExtend();

    /**
        Move caret up one line.
    */
    void LineUp();

    /**
        Move caret up one line extending selection to new caret position.
    */
    void LineUpExtend();

    /**
        Move caret left one character.
    */
    void CharLeft();

    /**
        Move caret left one character extending selection to new caret position.
    */
    void CharLeftExtend();

    /**
        Move caret right one character.
    */
    void CharRight();

    /**
        Move caret right one character extending selection to new caret position.
    */
    void CharRightExtend();

    /**
        Move caret left one word.
    */
    void WordLeft();

    /**
        Move caret left one word extending selection to new caret position.
    */
    void WordLeftExtend();

    /**
        Move caret right one word.
    */
    void WordRight();

    /**
        Move caret right one word extending selection to new caret position.
    */
    void WordRightExtend();

    /**
        Move caret to first position on line.
    */
    void Home();

    /**
        Move caret to first position on line extending selection to new caret position.
    */
    void HomeExtend();

    /**
        Move caret to last position on line.
    */
    void LineEnd();

    /**
        Move caret to last position on line extending selection to new caret position.
    */
    void LineEndExtend();

    /**
        Move caret to first position in document.
    */
    void DocumentStart();

    /**
        Move caret to first position in document extending selection to new caret position.
    */
    void DocumentStartExtend();

    /**
        Move caret to last position in document.
    */
    void DocumentEnd();

    /**
        Move caret to last position in document extending selection to new caret position.
    */
    void DocumentEndExtend();

    /**
        Move caret one page up.
    */
    void PageUp();

    /**
        Move caret one page up extending selection to new caret position.
    */
    void PageUpExtend();

    /**
        Move caret one page down.
    */
    void PageDown();

    /**
        Move caret one page down extending selection to new caret position.
    */
    void PageDownExtend();

    /**
        Switch from insert to overtype mode or the reverse.
    */
    void EditToggleOvertype();

    /**
        Cancel any modes such as call tip or auto-completion list display.
    */
    void Cancel();

    /**
        Delete the selection or if no selection, the character before the caret.
    */
    void DeleteBack();

    /**
        If selection is empty or all on one line replace the selection with a tab character.
        If more than one line selected, indent the lines.
    */
    void Tab();

    /**
        Dedent the selected lines.
    */
    void BackTab();

    /**
        Insert a new line, may use a CRLF, CR or LF depending on EOL mode.
    */
    void NewLine();

    /**
        Insert a Form Feed character.
    */
    void FormFeed();

    /**
        Move caret to before first visible character on line.
        If already there move to first character on line.
    */
    void VCHome();

    /**
        Like VCHome but extending selection to new caret position.
    */
    void VCHomeExtend();

    /**
        Delete the word to the left of the caret.
    */
    void DelWordLeft();

    /**
        Delete the word to the right of the caret.
    */
    void DelWordRight();

    /**
        Delete the word to the right of the caret, but not the trailing non-word characters.
    */
    void DelWordRightEnd();

    /**
        Cut the line containing the caret.
    */
    void LineCut();

    /**
        Delete the line containing the caret.
    */
    void LineDelete();

    /**
        Switch the current line with the previous.
    */
    void LineTranspose();

    /**
        Duplicate the current line.
    */
    void LineDuplicate();

    /**
        Transform the selection to lower case.
    */
    void LowerCase();

    /**
        Transform the selection to upper case.
    */
    void UpperCase();

    /**
        Scroll the document down, keeping the caret visible.
    */
    void LineScrollDown();

    /**
        Scroll the document up, keeping the caret visible.
    */
    void LineScrollUp();

    /**
        Delete the selection or if no selection, the character before the caret.
        Will not delete the character before at the start of a line.
    */
    void DeleteBackNotLine();

    /**
        Move caret to first position on display line.
    */
    void HomeDisplay();

    /**
        Move caret to first position on display line extending selection to
        new caret position.
    */
    void HomeDisplayExtend();

    /**
        Move caret to last position on display line.
    */
    void LineEndDisplay();

    /**
        Move caret to last position on display line extending selection to new
        caret position.
    */
    void LineEndDisplayExtend();

    /**
        Like Home but when word-wrap is enabled goes first to start of display line
        HomeDisplay, then to start of document line Home.
    */
    void HomeWrap();

    /**
        Like HomeExtend but when word-wrap is enabled extends first to start of display line
        HomeDisplayExtend, then to start of document line HomeExtend.
    */
    void HomeWrapExtend();

    /**
        Like LineEnd but when word-wrap is enabled goes first to end of display line
        LineEndDisplay, then to start of document line LineEnd.
    */
    void LineEndWrap();

    /**
        Like LineEndExtend but when word-wrap is enabled extends first to end of display line
        LineEndDisplayExtend, then to start of document line LineEndExtend.
    */
    void LineEndWrapExtend();

    /**
        Like VCHome but when word-wrap is enabled goes first to start of display line
        VCHomeDisplay, then behaves like VCHome.
    */
    void VCHomeWrap();

    /**
        Like VCHomeExtend but when word-wrap is enabled extends first to start of display line
        VCHomeDisplayExtend, then behaves like VCHomeExtend.
    */
    void VCHomeWrapExtend();

    /**
        Copy the line containing the caret.
    */
    void LineCopy();

    /**
        Move to the previous change in capitalisation.
    */
    void WordPartLeft();

    /**
        Move to the previous change in capitalisation extending selection
        to new caret position.
    */
    void WordPartLeftExtend();

    /**
        Move to the change next in capitalisation.
    */
    void WordPartRight();

    /**
        Move to the next change in capitalisation extending selection
        to new caret position.
    */
    void WordPartRightExtend();

    /**
        Delete back from the current position to the start of the line.
    */
    void DelLineLeft();

    /**
        Delete forwards from the current position to the end of the line.
    */
    void DelLineRight();

    /**
        Move caret down one paragraph (delimited by empty lines).
    */
    void ParaDown();

    /**
        Extend selection down one paragraph (delimited by empty lines).
    */
    void ParaDownExtend();

    /**
        Move caret up one paragraph (delimited by empty lines).
    */
    void ParaUp();

    /**
        Extend selection up one paragraph (delimited by empty lines).
    */
    void ParaUpExtend();

    /**
        Move caret down one line, extending rectangular selection to new caret position.
    */
    void LineDownRectExtend();

    /**
        Move caret up one line, extending rectangular selection to new caret position.
    */
    void LineUpRectExtend();

    /**
        Move caret left one character, extending rectangular selection to new caret position.
    */
    void CharLeftRectExtend();

    /**
        Move caret right one character, extending rectangular selection to new caret position.
    */
    void CharRightRectExtend();

    /**
        Move caret to first position on line, extending rectangular selection to new caret position.
    */
    void HomeRectExtend();

    /**
        Move caret to before first visible character on line.
        If already there move to first character on line.
        In either case, extend rectangular selection to new caret position.
    */
    void VCHomeRectExtend();

    /**
        Move caret to last position on line, extending rectangular selection to new caret position.
    */
    void LineEndRectExtend();

    /**
        Move caret one page up, extending rectangular selection to new caret position.
    */
    void PageUpRectExtend();

    /**
        Move caret one page down, extending rectangular selection to new caret position.
    */
    void PageDownRectExtend();

    /**
        Move caret to top of page, or one page up if already at top of page.
    */
    void StutteredPageUp();

    /**
        Move caret to top of page, or one page up if already at top of page, extending selection to new caret position.
    */
    void StutteredPageUpExtend();

    /**
        Move caret to bottom of page, or one page down if already at bottom of page.
    */
    void StutteredPageDown();

    /**
        Move caret to bottom of page, or one page down if already at bottom of page, extending selection to new caret position.
    */
    void StutteredPageDownExtend();

    /**
        Move caret left one word, position cursor at end of word.
    */
    void WordLeftEnd();

    /**
        Move caret left one word, position cursor at end of word, extending selection to new caret position.
    */
    void WordLeftEndExtend();

    /**
        Move caret right one word, position cursor at end of word.
    */
    void WordRightEnd();

    /**
        Move caret right one word, position cursor at end of word, extending selection to new caret position.
    */
    void WordRightEndExtend();

    /**
        Duplicate the selection. If selection empty duplicate the line containing the caret.
    */
    void SelectionDuplicate();

    /**
        Centre current line in window.
    */
    void VerticalCentreCaret();

    /**
        Scroll to start of document.
    */
    void ScrollToStart();

    /**
        Scroll to end of document.
    */
    void ScrollToEnd();

    /**
        Move caret to before first visible character on display line.
        If already there move to first character on display line.

        @since 3.1.0
    */
    void VCHomeDisplay();

    /**
        Like VCHomeDisplay but extending selection to new caret position.

        @since 3.1.0
    */
    void VCHomeDisplayExtend();

    //@}

    /**
        @member_group_name{KeyBindings, Key bindings}
    */
    //@{

    /**
        When key+modifier combination keyDefinition is pressed perform sciCommand.

        The second argument should be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_KEYMOD_NORM wxSTC_KEYMOD_* @endlink constants
        and the third argument should be one of the
        @link wxStyledTextCtrl::wxSTC_CMD_BACKTAB wxSTC_CMD_* @endlink constants.
    */
    void CmdKeyAssign(int key, int modifiers, int cmd);

    /**
        When key+modifier combination keyDefinition is pressed do nothing.

        The second argument should be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_KEYMOD_NORM wxSTC_KEYMOD_* @endlink constants.
    */
    void CmdKeyClear(int key, int modifiers);

    /**
        Drop all key mappings.
    */
    void CmdKeyClearAll();

    //@}

    /**
        @member_group_name{PopupEditMenu, Popup edit menu}
    */
    //@{

    /**
        Set whether a pop up menu is displayed automatically when the user presses
        the wrong mouse button on certain areas.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_POPUP_NEVER wxSTC_POPUP_* @endlink constants.
        @remarks
        When wxContextMenuEvent is used to create a custom popup menu,
        this function should be called with wxSTC_POPUP_NEVER.  Otherwise
        the default menu will be shown instead of the custom one.
    */
    void UsePopUp(int popUpMode);

    //@}

    /**
        @member_group_name{MacroRecording, Macro recording}
    */
    //@{

    /**
        Start notifying the container of all key presses and commands.
    */
    void StartRecord();

    /**
        Stop notifying the container of all key presses and commands.
    */
    void StopRecord();

    //@}

    /**
        @member_group_name{Printing, Printing}
    */
    //@{

    /**
        Sets the print magnification added to the point size of each style for printing.
    */
    void SetPrintMagnification(int magnification);

    /**
        Returns the print magnification.
    */
    int GetPrintMagnification() const;

    /**
        Modify colours when printing for clearer printed text.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_PRINT_NORMAL wxSTC_PRINT_* @endlink constants.
    */
    void SetPrintColourMode(int mode);

    /**
        Returns the print colour mode.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_PRINT_NORMAL wxSTC_PRINT_* @endlink constants.
    */
    int GetPrintColourMode() const;

    /**
        On Windows, will draw the document into a display context such as a printer.
    */
    int FormatRange(bool   doDraw,
               int    startPos,
               int    endPos,
               wxDC*  draw,
               wxDC*  target,
               wxRect renderRect,
               wxRect pageRect);

    /**
        Set printing to line wrapped (wxSTC_WRAP_WORD) or not line wrapped (wxSTC_WRAP_NONE).
    */
    void SetPrintWrapMode(int wrapMode);

    /**
        Is printing line wrapped?

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_WRAP_NONE wxSTC_WRAP_* @endlink constants.
    */
    int GetPrintWrapMode() const;

    //@}

    /**
        @member_group_name{DirectAccess, Direct access}
    */
    //@{

    /**
        Retrieve a pointer to a function that processes messages for this Scintilla.

        @since 3.1.1
    */
    void* GetDirectFunction() const;

    /**
        Retrieve a pointer value to use as the first argument when calling
        the function returned by GetDirectFunction.

        @since 3.1.1
    */
    void* GetDirectPointer() const;

    /**
        Compact the document buffer and return a read-only pointer to the
        characters in the document.
    */
    const char* GetCharacterPointer() const;

    /**
        Return a read-only pointer to a range of characters in the document.
        May move the gap so that the range is contiguous, but will only move up
        to lengthRange bytes.
    */
    const char* GetRangePointer(int position, int rangeLength) const;

    /**
        Return a position which, to avoid performance costs, should not be within
        the range of a call to GetRangePointer.
    */
    int GetGapPosition() const;

    //@}

    /**
        @member_group_name{MultipleViews, Multiple views}
    */
    //@{

    /**
        Retrieve a pointer to the document object.
    */
    void* GetDocPointer();

    /**
        Change the document object used.
    */
    void SetDocPointer(void* docPointer);

    /**
        Create a new document object.
        Starts with reference count of 1 and not selected into editor.
    */
    void* CreateDocument();

    /**
        Extend life of document.
    */
    void AddRefDocument(void* docPointer);

    /**
        Release a reference to the document, deleting document if it fades to black.
    */
    void ReleaseDocument(void* docPointer);

    //@}

    /**
        @member_group_name{BackgroundLoadSave, Background loading and saving}
    */
    //@{

    /**
        Create an ILoader*.
    */
    void* CreateLoader(int bytes) const;

    //@}

    /**
        @member_group_name{Folding, Folding}
    */
    //@{

    /**
        Find the display line of a document line taking hidden lines into account.
    */
    int VisibleFromDocLine(int docLine);

    /**
        Find the document line of a display line taking hidden lines into account.
    */
    int DocLineFromVisible(int displayLine);

    /**
        Set the fold level of a line.
        This encodes an integer level along with flags indicating whether the
        line is a header and whether it is effectively white space.
    */
    void SetFoldLevel(int line, int level);

    /**
        Retrieve the fold level of a line.
    */
    int GetFoldLevel(int line) const;

    /**
        Find the last child line of a header line.
    */
    int GetLastChild(int line, int level) const;

    /**
        Find the parent line of a child line.
    */
    int GetFoldParent(int line) const;

    /**
        Make a range of lines visible.
    */
    void ShowLines(int lineStart, int lineEnd);

    /**
        Make a range of lines invisible.
    */
    void HideLines(int lineStart, int lineEnd);

    /**
        Is a line visible?
    */
    bool GetLineVisible(int line) const;

    /**
        Are all lines visible?
    */
    bool GetAllLinesVisible() const;

    /**
        Show the children of a header line.
    */
    void SetFoldExpanded(int line, bool expanded);

    /**
        Is a header line expanded?
    */
    bool GetFoldExpanded(int line) const;

    /**
        Switch a header line between expanded and contracted.
    */
    void ToggleFold(int line);

    /**
        Switch a header line between expanded and contracted and show some text after the line.

        @since 3.1.1
    */
    void ToggleFoldShowText(int line, const wxString& text);

    /**
        Set the style of fold display text

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_FOLDDISPLAYTEXT_HIDDEN wxSTC_FOLDDISPLAYTEXT_* @endlink constants.
        @since 3.1.1
    */
    void FoldDisplayTextSetStyle(int style);

    /**
        Expand or contract a fold header.

        The second argument should be one of the
        @link wxStyledTextCtrl::wxSTC_FOLDACTION_CONTRACT wxSTC_FOLDACTION_* @endlink constants.
        @since 3.1.0
    */
    void FoldLine(int line, int action);

    /**
        Expand or contract a fold header and its children.

        The second argument should be one of the
        @link wxStyledTextCtrl::wxSTC_FOLDACTION_CONTRACT wxSTC_FOLDACTION_* @endlink constants.
        @since 3.1.0
    */
    void FoldChildren(int line, int action);

    /**
        Expand a fold header and all children. Use the level argument instead of the line's current level.

        @since 3.1.0
    */
    void ExpandChildren(int line, int level);

    /**
        Expand or contract all fold headers.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_FOLDACTION_CONTRACT wxSTC_FOLDACTION_* @endlink constants.
        @since 3.1.0
    */
    void FoldAll(int action);

    /**
        Ensure a particular line is visible by expanding any header line hiding it.
    */
    void EnsureVisible(int line);

    /**
        Set automatic folding behaviours.

        The input should be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_AUTOMATICFOLD_SHOW wxSTC_AUTOMATICFOLD_* @endlink constants.
        @since 3.1.0
    */
    void SetAutomaticFold(int automaticFold);

    /**
        Get automatic folding behaviours.

        The return value will be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_AUTOMATICFOLD_SHOW wxSTC_AUTOMATICFOLD_* @endlink constants.
        @since 3.1.0
    */
    int GetAutomaticFold() const;

    /**
        Set some style options for folding.

        The second argument should be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_FOLDFLAG_LINEBEFORE_EXPANDED wxSTC_FOLDFLAG_* @endlink constants.
    */
    void SetFoldFlags(int flags);

    /**
        Ensure a particular line is visible by expanding any header line hiding it.
        Use the currently set visibility policy to determine which range to display.
    */
    void EnsureVisibleEnforcePolicy(int line);

    /**
        Find the next line at or after lineStart that is a contracted fold header line.
        Return -1 when no more lines.
    */
    int ContractedFoldNext(int lineStart);

    //@}

    /**
        @member_group_name{LineWrapping, Line wrapping}
    */
    //@{

    /**
        The number of display lines needed to wrap a document line
    */
    int WrapCount(int docLine);

    /**
        Sets whether text is word wrapped.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_WRAP_NONE wxSTC_WRAP_* @endlink constants.
    */
    void SetWrapMode(int wrapMode);

    /**
        Retrieve whether text is word wrapped.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_WRAP_NONE wxSTC_WRAP_* @endlink constants.
    */
    int GetWrapMode() const;

    /**
        Set the display mode of visual flags for wrapped lines.

        The input should be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_WRAPVISUALFLAG_NONE wxSTC_WRAPVISUALFLAG_* @endlink constants.
    */
    void SetWrapVisualFlags(int wrapVisualFlags);

    /**
        Retrieve the display mode of visual flags for wrapped lines.

        The return value will be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_WRAPVISUALFLAG_NONE wxSTC_WRAPVISUALFLAG_* @endlink constants.
    */
    int GetWrapVisualFlags() const;

    /**
        Set the location of visual flags for wrapped lines.

        The input should be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_WRAPVISUALFLAGLOC_DEFAULT wxSTC_WRAPVISUALFLAGLOC_* @endlink constants.
    */
    void SetWrapVisualFlagsLocation(int wrapVisualFlagsLocation);

    /**
        Retrieve the location of visual flags for wrapped lines.

        The return value will be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_WRAPVISUALFLAGLOC_DEFAULT wxSTC_WRAPVISUALFLAGLOC_* @endlink constants.
    */
    int GetWrapVisualFlagsLocation() const;

    /**
        Set the start indent for wrapped lines.
    */
    void SetWrapStartIndent(int indent);

    /**
        Retrieve the start indent for wrapped lines.
    */
    int GetWrapStartIndent() const;

    /**
        Sets how wrapped sublines are placed. Default is wxSTC_WRAPINDENT_FIXED.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_WRAPINDENT_FIXED wxSTC_WRAPINDENT_* @endlink constants.
    */
    void SetWrapIndentMode(int wrapIndentMode);

    /**
        Retrieve how wrapped sublines are placed. Default is wxSTC_WRAPINDENT_FIXED.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_WRAPINDENT_FIXED wxSTC_WRAPINDENT_* @endlink constants.
    */
    int GetWrapIndentMode() const;

    /**
        Retrieve the degree of caching of layout information.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_CACHE_NONE wxSTC_CACHE_* @endlink constants.
    */
    int GetLayoutCache() const;

    /**
        Join the lines in the target.
    */
    void LinesJoin();

    /**
        Split the lines in the target into lines that are less wide than pixelWidth
        where possible.
    */
    void LinesSplit(int pixelWidth);

    /**
        Set number of entries in position cache
    */
    void SetPositionCacheSize(int size);

    /**
        How many entries are allocated to the position cache?
    */
    int GetPositionCacheSize() const;

    //@}

    /**
        @member_group_name{Zooming, Zooming}
    */
    //@{

    /**
        Magnify the displayed text by increasing the sizes by 1 point.
    */
    void ZoomIn();

    /**
        Make the displayed text smaller by decreasing the sizes by 1 point.
    */
    void ZoomOut();

    /**
        Set the zoom level. This number of points is added to the size of all fonts.
        It may be positive to magnify or negative to reduce.
    */
    void SetZoom(int zoomInPoints);

    /**
        Retrieve the zoom level.
    */
    int GetZoom() const;

    //@}

    /**
        @member_group_name{LongLines, Long lines}
    */
    //@{

    /**
        Retrieve the column number which text should be kept within.
    */
    int GetEdgeColumn() const;

    /**
        Set the column number of the edge.
        If text goes past the edge then it is highlighted.
    */
    void SetEdgeColumn(int column);

    /**
        Retrieve the edge highlight mode.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_EDGE_NONE wxSTC_EDGE_* @endlink constants.
    */
    int GetEdgeMode() const;

    /**
        The edge may be displayed by a line (wxSTC_EDGE_LINE/wxSTC_EDGE_MULTILINE) or by highlighting text that
        goes beyond it (wxSTC_EDGE_BACKGROUND) or not displayed at all (wxSTC_EDGE_NONE).

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_EDGE_NONE wxSTC_EDGE_* @endlink constants.
    */
    void SetEdgeMode(int edgeMode);

    /**
        Retrieve the colour used in edge indication.
    */
    wxColour GetEdgeColour() const;

    /**
        Change the colour used in edge indication.
    */
    void SetEdgeColour(const wxColour& edgeColour);

    /**
        Add a new vertical edge to the view.

        @since 3.1.1
    */
    void MultiEdgeAddLine(int column, const wxColour& edgeColour);

    /**
        Clear all vertical edges.

        @since 3.1.1
    */
    void MultiEdgeClearAll();

    //@}

    /**
        @member_group_name{Lexer, Lexer}
    */
    //@{

    /**
        Indicate that the internal state of a lexer has changed over a range and therefore
        there may be a need to redraw.
    */
    int ChangeLexerState(int start, int end);

    /**
        Set the lexing language of the document.

        The input should be one of the
        @link wxStyledTextCtrl::wxSTC_LEX_A68K wxSTC_LEX_* @endlink constants.
    */
    void SetLexer(int lexer);

    /**
        Retrieve the lexing language of the document.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_LEX_A68K wxSTC_LEX_* @endlink constants.
    */
    int GetLexer() const;

    /**
        Colourise a segment of the document using the current lexing language.
    */
    void Colourise(int start, int end);

    /**
        Set up a value that may be used by a lexer for some optional feature.
    */
    void SetProperty(const wxString& key, const wxString& value);

    /**
        Set up the key words used by the lexer.
    */
    void SetKeyWords(int keyWordSet, const wxString& keyWords);

    /**
        Set the lexing language of the document based on string name.
    */
    void SetLexerLanguage(const wxString& language);

    /**
        Load a lexer library (dll / so).

        @since 3.1.1
    */
    void LoadLexerLibrary(const wxString& path);

    /**
        Retrieve a "property" value previously set with SetProperty.
    */
    wxString GetProperty(const wxString& key);

    /**
        Retrieve a "property" value previously set with SetProperty,
        with "$()" variable replacement on returned buffer.
    */
    wxString GetPropertyExpanded(const wxString& key);

    /**
        Retrieve a "property" value previously set with SetProperty,
        interpreted as an int AFTER any "$()" variable replacement.
    */
    int GetPropertyInt(const wxString &key, int defaultValue=0) const;

    /**
        Retrieve the lexing language of the document.

        @since 3.1.1
    */
    wxString GetLexerLanguage() const;

    /**
        For private communication between an application and a known lexer.
    */
    void* PrivateLexerCall(int operation, void* pointer);

    /**
        Retrieve a '\\n' separated list of properties understood by the current lexer.
    */
    wxString PropertyNames() const;

    /**
        Retrieve the type of a property.

        The return value will be one of the
        @link wxStyledTextCtrl::wxSTC_TYPE_BOOLEAN wxSTC_TYPE_* @endlink constants.
    */
    int PropertyType(const wxString& name);

    /**
        Describe a property.
    */
    wxString DescribeProperty(const wxString& name) const;

    /**
        Retrieve a '\\n' separated list of descriptions of the keyword sets understood by the current lexer.
    */
    wxString DescribeKeyWordSets() const;

    /**
        Allocate a set of sub styles for a particular base style, returning start of range

        @since 3.1.0
    */
    int AllocateSubStyles(int styleBase, int numberStyles);

    /**
        The starting style number for the sub styles associated with a base style

        @since 3.1.0
    */
    int GetSubStylesStart(int styleBase) const;

    /**
        The number of sub styles associated with a base style

        @since 3.1.0
    */
    int GetSubStylesLength(int styleBase) const;

    /**
        For a sub style, return the base style, else return the argument.

        @since 3.1.0
    */
    int GetStyleFromSubStyle(int subStyle) const;

    /**
        For a secondary style, return the primary style, else return the argument.

        @since 3.1.0
    */
    int GetPrimaryStyleFromStyle(int style) const;

    /**
        Free allocated sub styles

        @since 3.1.0
    */
    void FreeSubStyles();

    /**
        Set the identifiers that are shown in a particular style

        @since 3.1.0
    */
    void SetIdentifiers(int style, const wxString& identifiers);

    /**
        Where styles are duplicated by a feature such as active/inactive code
        return the distance between the two types.

        @since 3.1.0
    */
    int DistanceToSecondaryStyles() const;

    /**
        Get the set of base styles that can be extended with sub styles

        @since 3.1.0
    */
    wxString GetSubStyleBases() const;

    //@}

    /**
        @member_group_name{Notifications, Event related items}
    */
    //@{

    /**
        Sets the time the mouse must sit still to generate a mouse dwell event.

        The input should be a time in milliseconds or wxSTC_TIME_FOREVER.
    */
    void SetMouseDwellTime(int periodMilliseconds);

    /**
        Retrieve the time the mouse must sit still to generate a mouse dwell event.

        The return value will be a time in milliseconds or wxSTC_TIME_FOREVER.
    */
    int GetMouseDwellTime() const;

    /**
        Set which document modification events are sent to the container.

        The input should be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_MOD_INSERTTEXT wxSTC_MOD_* @endlink constants,
        the @link wxStyledTextCtrl::wxSTC_PERFORMED_REDO wxSTC_PERFORMED_* @endlink constants,
        wxSTC_STARTACTION, wxSTC_MULTILINEUNDOREDO, wxSTC_MULTISTEPUNDOREDO, and wxSTC_LASTSTEPINUNDOREDO.
        The input can also be wxSTC_MODEVENTMASKALL to indicate that all changes
        should generate events.
    */
    void SetModEventMask(int eventMask);

    /**
        Get which document modification events are sent to the container.

        The return value will wxSTC_MODEVENTMASKALL if all changes generate
        events.  Otherwise it will be a bit list containing one or more of the
        @link wxStyledTextCtrl::wxSTC_MOD_INSERTTEXT wxSTC_MOD_* @endlink constants,
        the @link wxStyledTextCtrl::wxSTC_PERFORMED_REDO wxSTC_PERFORMED_* @endlink constants,
        wxSTC_STARTACTION, wxSTC_MULTILINEUNDOREDO, wxSTC_MULTISTEPUNDOREDO, and wxSTC_LASTSTEPINUNDOREDO.
    */
    int GetModEventMask() const;

    /**
        Set the identifier reported as idFrom in notification messages.
    */
    void SetIdentifier(int identifier);

    /**
        Get the identifier.
    */
    int GetIdentifier() const;

    //@}

    /**
        @member_group_name{DeprecatedMessages, Deprecated items}

        These methods should not be used in new code.
    */
    //@{

    /**
        Divide each styling byte into lexical class bits (default: 5) and indicator
        bits (default: 3). If a lexer requires more than 32 lexical states, then this
        is used to expand the possible states.

        @deprecated
    */
    void SetStyleBits(int bits);

    /**
        Retrieve number of bits in style bytes used to hold the lexical state.

        @deprecated
    */
    int GetStyleBits() const;

    /**
        Retrieve the number of bits the current lexer needs for styling.

        @deprecated
    */
    int GetStyleBitsNeeded() const;

    //@}

    //}}}


    // Manually declared methods
    // ----------------------------------------------
    /**
        @member_group_name{additional_methods, Additional wxStyledTextCtrl methods}

        In addition to the standard Scintilla functions, wxStyledTextCtrl
        includes the following functions to simplify some tasks.
    */
    //@{

    /**
       Returns the line number of the line with the caret.
    */
    int GetCurrentLine();

    /**
       Extract style settings from a spec-string which is composed of one or
       more of the following comma separated elements:

          bold                    turns on bold
          italic                  turns on italics
          fore:[name or \#RRGGBB]  sets the foreground colour
          back:[name or \#RRGGBB]  sets the background colour
          face:[facename]         sets the font face name to use
          size:[num]              sets the font size in points
          eol                     turns on eol filling
          underline               turns on underlining
    */
    void StyleSetSpec(int styleNum, const wxString& spec);

    /**
       Get the font of a style.
    */
    wxFont StyleGetFont(int style);

    /**
       Set style size, face, bold, italic, and underline attributes from
       a wxFont's attributes.
    */
    void StyleSetFont(int styleNum, wxFont& font);

    /**
       Set all font style attributes at once.
    */
    void StyleSetFontAttr(int styleNum, int size,
                          const wxString& faceName,
                          bool bold, bool italic,
                          bool underline,
                          wxFontEncoding encoding=wxFONTENCODING_DEFAULT);

    /**
       Set the font encoding to be used by a style.
    */
    void StyleSetFontEncoding(int style, wxFontEncoding encoding);

    /**
       Perform one of the operations defined by the wxSTC_CMD_* constants.
    */
    void CmdKeyExecute(int cmd);

    /**
       Set the left and right margin in the edit area, measured in pixels.
    */
    void SetMargins(int left, int right);

    /**
       Scroll enough to make the given line visible
    */
    void ScrollToLine(int line);

    /**
       Scroll enough to make the given column visible
    */
    void ScrollToColumn(int column);

    /**
       Scintilla API call.
    */
    wxIntPtr SendMsg(int msg, wxUIntPtr wp=0, wxIntPtr lp=0) const;

    /**
       Set the vertical scrollbar to use instead of the one that's built-in.
    */
    void SetVScrollBar(wxScrollBar* bar);

    /**
       Set the horizontal scrollbar to use instead of the one that's built-in.
    */
    void SetHScrollBar(wxScrollBar* bar);

    /**
       Can be used to prevent the EVT_CHAR handler from adding the char
    */
    bool GetLastKeydownProcessed();
    void SetLastKeydownProcessed(bool val);

    /**
       Write the contents of the editor to filename
    */
    bool SaveFile(const wxString& filename);

    /**
       Load the contents of filename into the editor
    */
    bool LoadFile(const wxString& filename);

    /**
       Allow for simulating a DnD DragEnter

       @since 3.1.0
    */
    wxDragResult DoDragEnter(wxCoord x, wxCoord y, wxDragResult defaultRes);

    /**
       Allow for simulating a DnD DragOver
    */
    wxDragResult DoDragOver(wxCoord x, wxCoord y, wxDragResult defaultRes);

    /**
       Allow for simulating a DnD DragLeave

       @since 3.1.0
    */
    void DoDragLeave();

    /**
       Allow for simulating a DnD DropText
    */
    bool DoDropText(long x, long y, const wxString& data);

    /**
       Specify whether anti-aliased fonts should be used.

      This will have no effect on some platforms, but on some (wxMac for
      example) can greatly improve performance.
    */
    void SetUseAntiAliasing(bool useAA);

    /**
       Returns the current UseAntiAliasing setting.
    */
    bool GetUseAntiAliasing();

    /**
       Clear annotations from the given line.
    */
    void AnnotationClearLine(int line);

    /**
       Define a marker with a wxBitmap.
    */
    void MarkerDefineBitmap(int markerNumber, const wxBitmap& bmp);

    /**
       Register an image for use in autocompletion lists.
    */
    void RegisterImage(int type, const wxBitmap& bmp);

    //@}


    // Raw versions
    // ----------------------------------------------
    /**
        @member_group_name{raw_variants , Raw variants  }

        These methods allow data to be sent to or received from the control
        using character buffers instead of using a wxString.
    */
    //@{

    /**
       Add text to the document at current position.
    */
    void AddTextRaw(const char* text, int length=-1);

    /**
       Insert string at a position.
    */
    void InsertTextRaw(int pos, const char* text);

    /**
       Retrieve the text of the line containing the caret.
       Returns the index of the caret on the line.
    */
    wxCharBuffer GetCurLineRaw(int* linePos=NULL);

    /**
       Retrieve the contents of a line.
    */
    wxCharBuffer GetLineRaw(int line);

    /**
       Retrieve the selected text.
    */
    wxCharBuffer GetSelectedTextRaw();

    /**
       Retrieve the target text.

       @since 3.1.1
    */
    wxCharBuffer GetTargetTextRaw();

    /**
       Retrieve a range of text.
    */
    wxCharBuffer GetTextRangeRaw(int startPos, int endPos);

    /**
       Replace the contents of the document with the argument text.
    */
    void SetTextRaw(const char* text);

    /**
       Retrieve all the text in the document.
    */
    wxCharBuffer GetTextRaw();

    /**
       Append a string to the end of the document without changing the selection.
    */
    void AppendTextRaw(const char* text, int length=-1);

    /**
       Replace the current selection with text. If there is no current
       selection, text is inserted at the current caret position.

        @param text
            The null terminated string used for the replacement.

       @since 3.1.3
    */
    void ReplaceSelectionRaw(const char* text);

    /**
       Replace the current target with text.

       @return
            The return value is the length of the replacement string.

       @remarks
            If length=-1, text must be null terminated.

       @since 3.1.3
    */
    int ReplaceTargetRaw(const char* text, int length=-1);

    /**
       Replace the current target with text using regular expressions.

       The replacement string will be formed from text with any occurrences '\1'
       through '\9' replaced by tagged matches from the most recent regular
       expression search. In addition, any occurrences of '\0' will be replaced
       with all the matched text from the most recent search. After replacement,
       the target range refers to the replacement text.

       @return
            The return value is the length of the replacement string.

       @remarks
            If length=-1, text must be null terminated.

       @see
            SearchInTarget()

       @since 3.1.3
    */
    int ReplaceTargetRERaw(const char* text, int length=-1);

    //@}


    // wxTextEntryBase pure virtual methods
    // ----------------------------------------------
    ///@member_group_name{text_entry, Text entry methods}
    //@{

    /**
        Writes the text into the text control at the current insertion position.

        @param text
            Text to write to the text control.

        @remarks
            Newlines in the text string are the only control characters
            allowed, and they will cause appropriate line breaks.
            See operator<<() and AppendText() for more convenient ways of
            writing to the window.
            After the write operation, the insertion point will be at the end
            of the inserted text, so subsequent write operations will be appended.
            To append text after the user may have interacted with the control,
            call wxTextCtrl::SetInsertionPointEnd() before writing.
    */
    virtual void WriteText(const wxString& text);

    /**
        Removes the text starting at the first given position up to
        (but not including) the character at the last position.

        This function puts the current insertion point position at @a to as a
        side effect.

        @param from
            The first position.
        @param to
            The last position.
    */
    virtual void Remove(long from, long to);

    /**
        Replaces the text starting at the first position up to
        (but not including) the character at the last position with the given text.

        This function puts the current insertion point position at @a to as a
        side effect.

        @param from
            The first position.
        @param to
            The last position.
        @param value
            The value to replace the existing text with.
    */
    virtual void Replace(long from, long to, const wxString& value);

    /**
        Sets the insertion point at the given position.

        @param pos
            Position to set, in the range from 0 to GetLastPosition() inclusive.
    */
    virtual void SetInsertionPoint(long pos);

    /**
        Returns the insertion point, or cursor, position.

        This is defined as the zero based index of the character position to
        the right of the insertion point. For example, if the insertion point
        is at the end of the single-line text control, it is equal to
        GetLastPosition().

        Notice that insertion position is, in general, different from the index
        of the character the cursor position at in the string returned by
        GetValue(). While this is always the case for the single line controls,
        multi-line controls can use two characters @c "\\r\\n" as line
        separator (this is notably the case under MSW) meaning that indices in
        the control and its string value are offset by 1 for every line.

        Hence to correctly get the character at the current cursor position,
        taking into account that there can be none if the cursor is at the end
        of the string, you could do the following:

        @code
        wxString GetCurrentChar(wxTextCtrl *tc)
        {
            long pos = tc->GetInsertionPoint();
            if ( pos == tc->GetLastPosition() )
                return wxString();

            return tc->GetRange(pos, pos + 1);
        }
        @endcode
    */
    virtual long GetInsertionPoint() const;

    /**
        Returns the zero based index of the last position in the text control,
        which is equal to the number of characters in the control.
    */
    virtual long GetLastPosition() const;

    /**
        Selects the text starting at the first position up to (but not
        including) the character at the last position.

        If both parameters are equal to -1 all text in the control is selected.

        Notice that the insertion point will be moved to @a from by this
        function.

        @param from
            The first position.
        @param to
            The last position.

        @see SelectAll()
    */
    virtual void SetSelection(long from, long to);

    /**
        Deselects selected text in the control.

        @since 2.9.5
    */
    virtual void SelectNone();

    /**
        Gets the current selection span.

        If the returned values are equal, there was no selection. Please note
        that the indices returned may be used with the other wxTextCtrl methods
        but don't necessarily represent the correct indices into the string
        returned by GetValue() for multiline controls under Windows (at least,)
        you should use GetStringSelection() to get the selected text.

        @param from
            The returned first position.
        @param to
            The returned last position.

        @beginWxPerlOnly
        In wxPerl this method takes no parameters and returns a
        2-element list (from, to).
        @endWxPerlOnly
    */
    virtual void GetSelection(long *from, long *to) const;

    /**
        Returns @true if the controls contents may be edited by user (note that
        it always can be changed by the program).

        In other words, this functions returns @true if the control hasn't been
        put in read-only mode by a previous call to SetEditable().
    */
    virtual bool IsEditable() const;

    /**
        Makes the text item editable or read-only, overriding the
        @b wxTE_READONLY flag.

        @param editable
            If @true, the control is editable. If @false, the control is
            read-only.

        @see IsEditable()
    */
    virtual void SetEditable(bool editable);

    //@}


    // wxTextAreaBase pure virtual methods
    // ---------------------------------------------
    ///@member_group_name{text_area, Text area methods}
    //@{

    /**
        Gets the length of the specified line, not including any trailing
        newline character(s).

        @param lineNo
            Line number (starting from zero).

        @return
            The length of the line, or -1 if @a lineNo was invalid.
    */
    virtual int GetLineLength(long lineNo) const;

    /**
        Returns the contents of a given line in the text control, not including
        any trailing newline character(s).

        @param lineNo
            The line number, starting from zero.

        @return
            The contents of the line.
    */
    virtual wxString GetLineText(long lineNo) const;

    /**
        Returns the number of lines in the text control buffer.

        The returned number is the number of logical lines, i.e. just the count
        of the number of newline characters in the control + 1, for wxGTK and
        wxOSX/Cocoa ports while it is the number of physical lines, i.e. the
        count of lines actually shown in the control, in wxMSW.
        Because of this discrepancy, it is not recommended to use this function.

        @remarks
            Note that even empty text controls have one line (where the
            insertion point is), so GetNumberOfLines() never returns 0.
    */
    virtual int GetNumberOfLines() const;

    /**
        Returns @true if the text has been modified by user.

        Note that calling SetValue() doesn't make the control modified.

        @see MarkDirty()
    */
    virtual bool IsModified() const;

    /**
        Mark text as modified (dirty).

        @see IsModified()
    */
    virtual void MarkDirty();

    /**
        Resets the internal modified flag as if the current changes had been
        saved.
    */
    virtual void DiscardEdits();

    /**
        This method is inherited from wxTextAreaBase but is not implemented
        in wxStyledTextCtrl.
    */
    virtual bool SetStyle(long start, long end, const wxTextAttr& style);

    /**
        This method is inherited from wxTextAreaBase but is not implemented
        in wxStyledTextCtrl.
    */
    virtual bool GetStyle(long position, wxTextAttr& style);

    /**
        This method is inherited from wxTextAreaBase but is not implemented
        in wxStyledTextCtrl.
    */
    virtual bool SetDefaultStyle(const wxTextAttr& style);

    /**
        Converts the given zero based column and line number to a position.

        @param x
            The column number.
        @param y
            The line number.

        @return
            The position value, or -1 if x or y was invalid.
    */
    virtual long XYToPosition(long x, long y) const;

    /**
        Converts given position to a zero-based column, line number pair.

        @param pos
            Position.
        @param x
            Receives zero based column number.
        @param y
            Receives zero based line number.

        @return
            @true on success, @false on failure (most likely due to a too large
            position parameter).

        @beginWxPerlOnly
        In wxPerl this function takes only the @a pos argument and
        returns a 2-element list (x, y).
        @endWxPerlOnly

        @see XYToPosition()
    */
    virtual bool PositionToXY(long pos, long *x, long *y) const;

    /**
        Makes the line containing the given position visible.

        @param pos
            The position that should be visible.
    */
    virtual void ShowPosition(long pos);

    /**
        Finds the position of the character at the specified point.

        If the return code is not @c wxTE_HT_UNKNOWN the row and column of the
        character closest to this position are returned, otherwise the output
        parameters are not modified.

        Please note that this function is currently only implemented in wxUniv,
        wxMSW and wxGTK2 ports and always returns @c wxTE_HT_UNKNOWN in the
        other ports.

        @beginWxPerlOnly
        In wxPerl this function takes only the @a pt argument and
        returns a 3-element list (result, col, row).
        @endWxPerlOnly

        @param pt
            The position of the point to check, in window device coordinates.
        @param pos
            Receives the position of the character at the given position. May
            be @NULL.

        @see PositionToXY(), XYToPosition()
    */
    virtual wxTextCtrlHitTestResult HitTest(const wxPoint& pt, long *pos) const;

    /**
        Finds the row and column of the character at the specified point.

        If the return code is not @c wxTE_HT_UNKNOWN the row and column of the
        character closest to this position are returned, otherwise the output
        parameters are not modified.

        Please note that this function is currently only implemented in wxUniv,
        wxMSW and wxGTK2 ports and always returns @c wxTE_HT_UNKNOWN in the
        other ports.

        @beginWxPerlOnly
        In wxPerl this function takes only the @a pt argument and
        returns a 3-element list (result, col, row).
        @endWxPerlOnly

        @param pt
            The position of the point to check, in window device coordinates.
        @param col
            Receives the column of the character at the given position. May be
            @NULL.
        @param row
            Receives the row of the character at the given position. May be
            @NULL.

        @see PositionToXY(), XYToPosition()
    */
    virtual wxTextCtrlHitTestResult HitTest(const wxPoint& pt,
                                            wxTextCoord *col,
                                            wxTextCoord *row) const;
    //@}


    // VersionInfo
    // ---------------------------------------------

    /**
        Returns the version of the Scintilla library used by this control.
    */
    static wxVersionInfo GetLibraryVersionInfo();

};

//----------------------------------------------------------------------

/**
    @class wxStyledTextEvent

    The type of events sent from wxStyledTextCtrl.

    @beginEventTable{wxStyledTextEvent}
    @event{EVT_STC_AUTOCOMP_CANCELLED(id, fn)}
        Process a @c wxEVT_STC_AUTOCOMP_CANCELLED event.
    @event{EVT_STC_AUTOCOMP_CHAR_DELETED(id, fn)}
        Process a @c wxEVT_STC_AUTOCOMP_CHAR_DELETED event.
    @event{EVT_STC_AUTOCOMP_COMPLETED(id, fn)}
        Process a @c wxEVT_STC_AUTOCOMP_COMPLETED event.
        @since 3.1.1

    @event{EVT_STC_AUTOCOMP_SELECTION(id, fn)}
        Process a @c wxEVT_STC_AUTOCOMP_SELECTION event.
    @event{EVT_STC_AUTOCOMP_SELECTION_CHANGE(id, fn)}
        Process a @c wxEVT_STC_AUTOCOMP_SELECTION_CHANGE event.
        @since 3.1.3

    @event{EVT_STC_CALLTIP_CLICK(id, fn)}
        Process a @c wxEVT_STC_CALLTIP_CLICK event.
    @event{EVT_STC_CHANGE(id, fn)}
        Process a @c wxEVT_STC_CHANGE event.
    @event{EVT_STC_CHARADDED(id, fn)}
        Process a @c wxEVT_STC_CHARADDED event.
    @event{EVT_STC_CLIPBOARD_COPY(id, fn)}
        Process a @c wxEVT_STC_CLIPBOARD_COPY event.
        @since 3.1.0

    @event{EVT_STC_CLIPBOARD_PASTE(id, fn)}
        Process a @c wxEVT_STC_CLIPBOARD_PASTE event.
        @since 3.1.0

    @event{EVT_STC_DO_DROP(id, fn)}
        Process a @c wxEVT_STC_DO_DROP event.
    @event{EVT_STC_DOUBLECLICK(id, fn)}
        Process a @c wxEVT_STC_DOUBLECLICK event.
    @event{EVT_STC_DRAG_OVER(id, fn)}
        Process a @c wxEVT_STC_DRAG_OVER event.
    @event{EVT_STC_DWELLEND(id, fn)}
        Process a @c wxEVT_STC_DWELLEND event.
    @event{EVT_STC_DWELLSTART(id, fn)}
        Process a @c wxEVT_STC_DWELLSTART event.
    @event{EVT_STC_HOTSPOT_CLICK(id, fn)}
        Process a @c wxEVT_STC_HOTSPOT_CLICK event.
    @event{EVT_STC_HOTSPOT_DCLICK(id, fn)}
        Process a @c wxEVT_STC_HOTSPOT_DCLICK event.
    @event{EVT_STC_HOTSPOT_RELEASE_CLICK(id, fn)}
        Process a @c wxEVT_STC_HOTSPOT_RELEASE_CLICK event.
    @event{EVT_STC_INDICATOR_CLICK(id, fn)}
        Process a @c wxEVT_STC_INDICATOR_CLICK event.
    @event{EVT_STC_INDICATOR_RELEASE(id, fn)}
        Process a @c wxEVT_STC_INDICATOR_RELEASE event.
    @event{EVT_STC_MACRORECORD(id, fn)}
        Process a @c wxEVT_STC_MACRORECORD event.
    @event{EVT_STC_MARGIN_RIGHT_CLICK(id, fn)}
        Process a @c wxEVT_STC_MARGIN_RIGHT_CLICK event.
        @since 3.1.1

    @event{EVT_STC_MARGINCLICK(id, fn)}
        Process a @c wxEVT_STC_MARGINCLICK event.
    @event{EVT_STC_MODIFIED(id, fn)}
        Process a @c wxEVT_STC_MODIFIED event.
    @event{EVT_STC_NEEDSHOWN(id, fn)}
        Process a @c wxEVT_STC_NEEDSHOWN event.
    @event{EVT_STC_PAINTED(id, fn)}
        Process a @c wxEVT_STC_PAINTED event.
    @event{EVT_STC_ROMODIFYATTEMPT(id, fn)}
        Process a @c wxEVT_STC_ROMODIFYATTEMPT event.
    @event{EVT_STC_SAVEPOINTLEFT(id, fn)}
        Process a @c wxEVT_STC_SAVEPOINTLEFT event.
    @event{EVT_STC_SAVEPOINTREACHED(id, fn)}
        Process a @c wxEVT_STC_SAVEPOINTREACHED event.
    @event{EVT_STC_START_DRAG(id, fn)}
        Process a @c wxEVT_STC_START_DRAG event.
    @event{EVT_STC_STYLENEEDED(id, fn)}
        Process a @c wxEVT_STC_STYLENEEDED event.
    @event{EVT_STC_UPDATEUI(id, fn)}
        Process a @c wxEVT_STC_UPDATEUI event.
    @event{EVT_STC_USERLISTSELECTION(id, fn)}
        Process a @c wxEVT_STC_USERLISTSELECTION event.
    @event{EVT_STC_ZOOM(id, fn)}
        Process a @c wxEVT_STC_ZOOM event.
    @endEventTable

    Most of the Scintilla notifications are mapped to a similarly named
    wxStyledTextEvent.  However a few of the notifications would only offer
    information available in other wxWidgets event types, and in those cases a
    corresponding wxStyledTextEvent is not defined. Currently, the
    @c wxEVT_KEY_DOWN event is used instead of the @c SCN_KEY notification.  The
    regular wxWidgets drag and drop functionality can be used instead of the
    @c SCN_URIDROPPED notification. The @c wxEVT_SET_FOCUS event is used instead
    of the @c SCN_FOCUSIN notification.  And the @c wxEVT_KILL_FOCUS event is
    used instead of the @c SCN_FOCUSOUT notification.

    @section event_types Event Types

    The following is a brief description of when the control generates these
    events and a list of which methods provide relevant information.  Additional
    details can be found in the Scintilla documentation
    (http://www.scintilla.org/ScintillaDoc.html#Notifications).

    @c wxEVT_STC_AUTOCOMP_CANCELLED

    - Generated when an autocompletion list has been canceled.

    - Valid event functions: none.

    @c wxEVT_STC_AUTOCOMP_CHAR_DELETED

    - Generated when a character has been deleted from an autocompletion list.

    - Valid event functions: none.

    @c wxEVT_STC_AUTOCOMP_COMPLETED

    - Generated after an autocompletion list has closed and inserted its text
    into the control.

    - Valid event functions:
    @link wxStyledTextEvent::GetKey GetKey@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetString GetString@endlink,
    @link wxStyledTextEvent::GetListCompletionMethod GetListCompletionMethod@endlink.

    @c wxEVT_STC_AUTOCOMP_SELECTION

    - Generated when an entry has been selected in an autocompletion list but
    before the text has been inserted.

    - To prevent the insertion, call @link wxStyledTextCtrl::AutoCompCancel
    wxStyledTextCtrl::AutoCompCancel@endlink in the event handler.

    - Valid event functions:
    @link wxStyledTextEvent::GetKey GetKey@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetString GetString@endlink,
    @link wxStyledTextEvent::GetListCompletionMethod GetListCompletionMethod@endlink.

    @c wxEVT_STC_AUTOCOMP_SELECTION_CHANGE

    - Generated when items are highlighted in an autocompletion or user list.

    - @link wxStyledTextEvent::GetPosition GetPosition@endlink will return the
    position at which the list is being shown.

    - For a user list, @link wxStyledTextEvent::GetListType GetListType@endlink
    will return the list type. The list type is a value input in to the
    @link wxStyledTextCtrl::UserListShow wxStyledTextCtrl::UserListShow@endlink
    method when a user list is created.

    - For an autocompletion list,
    @link wxStyledTextEvent::GetListType GetListType@endlink will always return
    zero.

    - Valid event functions:
    @link wxStyledTextEvent::GetListType GetListType@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetString GetString@endlink.

    @c wxEVT_STC_CALLTIP_CLICK

    - Generated when a calltip has been clicked.

    - @link wxStyledTextEvent::GetPosition GetPosition@endlink will return 1 if
    the up arrow has been clicked, 2 if the down arrow has been clicked, and 0
    for all other clicks.

    - Valid event functions:
    @link wxStyledTextEvent::GetPosition GetPosition@endlink.

    @c wxEVT_STC_CHANGE

    - Generated when the text of the document has changed.

    - This an older style event and should probably not be used in new code. Use
    @c wxEVT_STC_MODIFIED instead.

    - Valid event functions: none.

    @c wxEVT_STC_CHARADDED

    - Generated when a character has been added to the control.

    - Valid event functions: @link wxStyledTextEvent::GetKey GetKey@endlink.

    @c wxEVT_STC_CLIPBOARD_COPY

    - Generated when text is being cut or copied to the clipboard.

    - Use wxStyledTextEvent::SetString() to modify the text that will be placed
    on the clipboard.

    - Valid event functions:
    @link wxStyledTextEvent::GetString GetString@endlink,
    @link wxStyledTextEvent::SetString SetString@endlink.

    @c wxEVT_STC_CLIPBOARD_PASTE

    - Generated when text is being pasted from the clipboard.

    - Use wxStyledTextEvent::SetString() to modify the text that will be
    inserted into the control.

    - Valid event functions:
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetString GetString@endlink,
    @link wxStyledTextEvent::SetString SetString@endlink.

    @c wxEVT_STC_DO_DROP

    - Generated when text is being dropped into the control.

    - Details of the drag may be altered by changing the respective fields of
    the event.

    - Valid event functions:
    @link wxStyledTextEvent::GetDragResult GetDragResult@endlink,
    @link wxStyledTextEvent::SetDragResult SetDragResult@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::SetPosition SetPosition@endlink,
    @link wxStyledTextEvent::GetString GetString@endlink,
    @link wxStyledTextEvent::SetString SetString@endlink,
    @link wxStyledTextEvent::GetX GetX@endlink,
    @link wxStyledTextEvent::GetY GetY@endlink.

    @c wxEVT_STC_DOUBLECLICK

    - Generated when the control has been double-clicked.

    - Valid event functions: @link wxStyledTextEvent::GetLine GetLine@endlink,
    @link wxStyledTextEvent::GetModifiers GetModifiers@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetAlt GetAlt@endlink,
    @link wxStyledTextEvent::GetControl GetControl@endlink,
    @link wxStyledTextEvent::GetShift GetShift@endlink.

    @c wxEVT_STC_DRAG_OVER

    - Generated repeatedly as text is being dragged inside the control.

    - Valid event functions:
    @link wxStyledTextEvent::GetDragResult GetDragResult@endlink,
    @link wxStyledTextEvent::SetDragResult SetDragResult@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetX GetX@endlink,
    @link wxStyledTextEvent::GetY GetY@endlink.

    @c wxEVT_STC_DWELLEND

    - Generated when the mouse has been moved after a
    @c wxEVT_STC_DWELLSTART event.

    - Valid event functions:
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetX GetX@endlink,
    @link wxStyledTextEvent::GetY GetY@endlink.

    @c wxEVT_STC_DWELLSTART

    - Generated when the mouse has remained still for a certain amount of time.

    - The amount of time can be specified with
    @link wxStyledTextCtrl::SetMouseDwellTime
    wxStyledTextCtrl::SetMouseDwellTime@endlink.

    - Valid event functions:
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetX GetX@endlink,
    @link wxStyledTextEvent::GetY GetY@endlink.

    @c wxEVT_STC_HOTSPOT_CLICK

    - Generated when a hotspot has been clicked.

    - Valid event functions:
    @link wxStyledTextEvent::GetModifiers GetModifiers@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetAlt GetAlt@endlink,
    @link wxStyledTextEvent::GetControl GetControl@endlink,
    @link wxStyledTextEvent::GetShift GetShift@endlink.

    @c wxEVT_STC_HOTSPOT_DCLICK

    - Generated when a hotspot has been double-clicked.

    - Valid event functions:
    @link wxStyledTextEvent::GetModifiers GetModifiers@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetAlt GetAlt@endlink,
    @link wxStyledTextEvent::GetControl GetControl@endlink,
    @link wxStyledTextEvent::GetShift GetShift@endlink.

    @c wxEVT_STC_HOTSPOT_RELEASE_CLICK

    - Generated when a click over a hotspot has been released.

    - Valid event functions:
    @link wxStyledTextEvent::GetModifiers GetModifiers@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetAlt GetAlt@endlink,
    @link wxStyledTextEvent::GetControl GetControl@endlink,
    @link wxStyledTextEvent::GetShift GetShift@endlink.

    @c wxEVT_STC_INDICATOR_CLICK

    - Generated when a indicator has been clicked.

    - Valid event functions:
    @link wxStyledTextEvent::GetModifiers GetModifiers@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetAlt GetAlt@endlink,
    @link wxStyledTextEvent::GetControl GetControl@endlink,
    @link wxStyledTextEvent::GetShift GetShift@endlink.

    @c wxEVT_STC_INDICATOR_RELEASE

    - Generated when a click over a indicator has been released.

    - Valid event functions:
    @link wxStyledTextEvent::GetModifiers GetModifiers@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetAlt GetAlt@endlink,
    @link wxStyledTextEvent::GetControl GetControl@endlink,
    @link wxStyledTextEvent::GetShift GetShift@endlink.

    @c wxEVT_STC_MACRORECORD

    - Generated while macro recording is in progress.

    - Valid event functions:
    @link wxStyledTextEvent::GetMessage GetMessage@endlink,
    @link wxStyledTextEvent::GetLParam GetLParam@endlink,
    @link wxStyledTextEvent::GetWParam GetWParam@endlink.

    @c wxEVT_STC_MARGIN_RIGHT_CLICK

    - Generated when one of the margins is clicked with the right mouse button.

    - This event is only generated if @link wxStyledTextCtrl::SetMarginSensitive
    SetMarginSensitive@endlink has been called for one or more of the margins.

    - Valid event functions:
    @link wxStyledTextEvent::GetMargin GetMargin@endlink,
    @link wxStyledTextEvent::GetModifiers GetModifiers@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetAlt GetAlt@endlink,
    @link wxStyledTextEvent::GetControl GetControl@endlink,
    @link wxStyledTextEvent::GetShift GetShift@endlink.

    @c wxEVT_STC_MARGINCLICK

    - Generated when one of the margins is clicked.

    - This event is only generated if @link wxStyledTextCtrl::SetMarginSensitive
    SetMarginSensitive@endlink has been called for one or more of the margins.

    - Valid event functions:
    @link wxStyledTextEvent::GetMargin GetMargin@endlink,
    @link wxStyledTextEvent::GetModifiers GetModifiers@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetAlt GetAlt@endlink,
    @link wxStyledTextEvent::GetControl GetControl@endlink,
    @link wxStyledTextEvent::GetShift GetShift@endlink.

    @c wxEVT_STC_MODIFIED

    - Generated when the contents of the control have changed or are about to
    change.
    - You should not attempt to make any changes to the control inside a
    handler for this event.

    - Valid event functions:
    @link wxStyledTextEvent::GetAnnotationsLinesAdded GetAnnotationsLinesAdded@endlink,
    @link wxStyledTextEvent::GetFoldLevelNow GetFoldLevelNow@endlink,
    @link wxStyledTextEvent::GetFoldLevelPrev GetFoldLevelPrev@endlink,
    @link wxStyledTextEvent::GetLength GetLength@endlink,
    @link wxStyledTextEvent::GetLine GetLine@endlink,
    @link wxStyledTextEvent::GetLinesAdded GetLinesAdded@endlink,
    @link wxStyledTextEvent::GetModificationType GetModificationType@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetString GetString@endlink,
    @link wxStyledTextEvent::GetToken GetToken@endlink.

    @c wxEVT_STC_NEEDSHOWN

    - Generated when certain lines should be made visible by scrolling the text
    in the control.

    - Valid event functions:
    @link wxStyledTextEvent::GetLength GetLength@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink.

    @c wxEVT_STC_PAINTED

    - Generated when the control has been refreshed.

    - Valid event functions: none.

    @c wxEVT_STC_ROMODIFYATTEMPT

    - Generated when an attempt has been made to change the control's text after
    it has been set read-only.

    - Valid event functions: none.

    @c wxEVT_STC_SAVEPOINTREACHED

    - Generated when the undo history has been made empty.

    - Valid event functions: none.

    @c wxEVT_STC_SAVEPOINTLEFT

    - Generated when the undo history is no longer empty.

    - Valid event functions: none.

    @c wxEVT_STC_START_DRAG

    - Generated when text is being dragged from the control.

    - Details of the drag may be altered by changing the respective fields of
    the event; in particular, set an empty string to prohibit the drag entirely.

    - Valid event functions:
    @link wxStyledTextEvent::GetDragFlags GetDragFlags@endlink,
    @link wxStyledTextEvent::SetDragFlags SetDragFlags@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetString GetString@endlink,
    @link wxStyledTextEvent::SetString SetString@endlink.

    @c wxEVT_STC_STYLENEEDED

    - Generated when the control has determined that style bytes should be set
    for a portion of the document.
    - These events are only sent if the lexer is set to
    @link wxStyledTextEvent::wxSTC_LEX_CONTAINER wxSTC_LEX_CONTAINER@endlink.

    - Valid event functions: @link wxStyledTextEvent::GetPosition
    GetPosition@endlink.

    @c wxEVT_STC_UPDATEUI

    - Generated when the text, style, cursor position, selection, or scrolling
    of the control has changed.

    - Valid event functions:
    @link wxStyledTextEvent::GetUpdated GetUpdated@endlink.

    @c wxEVT_STC_USERLISTSELECTION

    - Generated when a selection has been made from a user list.

    - Valid event functions:
    @link wxStyledTextEvent::GetListType GetListType@endlink,
    @link wxStyledTextEvent::GetPosition GetPosition@endlink,
    @link wxStyledTextEvent::GetString GetString@endlink,
    @link wxStyledTextEvent::GetKey GetKey@endlink,
    @link wxStyledTextEvent::GetListCompletionMethod GetListCompletionMethod@endlink.

    @c wxEVT_STC_ZOOM

    - Generated when the zoom factor of the control has been changed either by
    the user or a call to @link wxStyledTextCtrl::ZoomIn
    wxStyledTextCtrl::ZoomIn@endlink/@link wxStyledTextCtrl::ZoomOut
    ZoomOut@endlink.

    - Valid event functions: none.

    @library{wxstc}
    @category{events,stc}
*/

class wxStyledTextEvent : public wxCommandEvent {
public:
    /**
        Constructor
    */
    wxStyledTextEvent(wxEventType commandType=0, int id=0);

    /**
        Copy constructor
    */
    wxStyledTextEvent(const wxStyledTextEvent& event);

    /**
        Destructor
    */
    ~wxStyledTextEvent();

    /**
        Returns true if the Alt key is pressed.

        This method is valid for the following event types:
        - @c wxEVT_STC_DOUBLECLICK
        - @c wxEVT_STC_MARGINCLICK
        - @c wxEVT_STC_HOTSPOT_CLICK
        - @c wxEVT_STC_HOTSPOT_DCLICK
        - @c wxEVT_STC_HOTSPOT_RELEASE_CLICK
        - @c wxEVT_STC_INDICATOR_CLICK
        - @c wxEVT_STC_INDICATOR_RELEASE
        - @c wxEVT_STC_MARGIN_RIGHT_CLICK
    */
    bool GetAlt() const;

    /**
        Returns the number of lines that have been added to or removed from an
        annotation.

        This method is valid for @c wxEVT_STC_MODIFIED events when the result of
        GetModificationType() includes
        @link wxStyledTextEvent::wxSTC_MOD_CHANGEANNOTATION
        wxSTC_MOD_CHANGEANNOTATION@endlink.
    */
    int  GetAnnotationsLinesAdded() const;

    /**
        Returns true if the Control key is pressed.

        This method is valid for the following event types:
        - @c wxEVT_STC_DOUBLECLICK
        - @c wxEVT_STC_MARGINCLICK
        - @c wxEVT_STC_HOTSPOT_CLICK
        - @c wxEVT_STC_HOTSPOT_DCLICK
        - @c wxEVT_STC_HOTSPOT_RELEASE_CLICK
        - @c wxEVT_STC_INDICATOR_CLICK
        - @c wxEVT_STC_INDICATOR_RELEASE
        - @c wxEVT_STC_MARGIN_RIGHT_CLICK
    */
    bool GetControl() const;

    /**
        Returns flags for the drag operation associated with this event.

        This method is valid for @c wxEVT_STC_START_DRAG events.
    */
    int GetDragFlags();

    /**
        Returns drag result for this event.

        This method is valid for @c wxEVT_STC_DRAG_OVER and
        @c wxEVT_STC_DO_DROP events.
    */
    wxDragResult GetDragResult();

    /**
        @deprecated Use GetString() instead.
     */
    wxString GetDragText();

    /**
        Returns the current fold level for the line.

        This method is valid for @c wxEVT_STC_MODIFIED events when the result of
        GetModificationType() includes @link
        wxStyledTextEvent::wxSTC_MOD_CHANGEFOLD wxSTC_MOD_CHANGEFOLD@endlink.
    */
    int  GetFoldLevelNow() const;

    /**
        Returns previous fold level for the line.

        This method is valid for @c wxEVT_STC_MODIFIED events when the result of
        GetModificationType() includes @link
        wxStyledTextEvent::wxSTC_MOD_CHANGEFOLD wxSTC_MOD_CHANGEFOLD@endlink.
    */
    int  GetFoldLevelPrev() const;

    /**
        Returns the key code of the key that generated this event.

        This method is valid for the following event types:
        - @c wxEVT_STC_CHARADDED
        - @c wxEVT_STC_USERLISTSELECTION
        - @c wxEVT_STC_AUTOCOMP_SELECTION
        - @c wxEVT_STC_AUTOCOMP_COMPLETED
    */
    int  GetKey()  const;

    /**
        Returns the length (number of characters) of this event.

        This method is valid for @c wxEVT_STC_MODIFIED and
        @c wxEVT_STC_NEEDSHOWN events.
    */
    int  GetLength() const;

    /**
        Returns zero-based line number for this event.

        This method is valid for @c wxEVT_STC_DOUBLECLICK and
        @c wxEVT_STC_MODIFIED events.
    */
    int  GetLine() const;

    /**
        Returns the number of lines added or deleted with this event.

        This method is valid for @c wxEVT_STC_MODIFIED events when the result of
        GetModificationType() includes @link
        wxStyledTextEvent::wxSTC_MOD_INSERTTEXT wxSTC_MOD_INSERTTEXT @endlink or
        @link wxStyledTextEvent::wxSTC_MOD_DELETETEXT
        wxSTC_MOD_DELETETEXT@endlink.
    */
    int  GetLinesAdded() const;

    /**
        Returns a value describing the action that closed the list.

        The returned value will be one of the following constants:

        <table>
          <tr>
             <td>@link wxStyledTextEvent::wxSTC_AC_FILLUP wxSTC_AC_FILLUP@endlink</td>
             <td>A fillup character caused the completion.</td>
          </tr>
          <tr>
             <td>@link wxStyledTextEvent::wxSTC_AC_DOUBLECLICK wxSTC_AC_DOUBLECLICK@endlink</td>
             <td>A double-click caused the completion.</td>
          </tr>
          <tr>
             <td>@link wxStyledTextEvent::wxSTC_AC_TAB wxSTC_AC_TAB@endlink</td>
             <td>The tab key caused the completion.</td>
          </tr>
          <tr>
             <td>@link wxStyledTextEvent::wxSTC_AC_NEWLINE wxSTC_AC_NEWLINE@endlink</td>
             <td>The enter key caused the completion.</td>
          </tr>
          <tr>
             <td>@link wxStyledTextEvent::wxSTC_AC_COMMAND wxSTC_AC_COMMAND@endlink</td>
             <td>The @link wxStyledTextCtrl::AutoCompComplete
                 wxStyledTextCtrl::AutoCompComplete@endlink method was called.</td>
          </tr>
        </table>

        This method is valid for @c wxEVT_STC_USERLISTSELECTION,
        @c wxEVT_STC_AUTOCOMP_SELECTION, and @c wxEVT_STC_AUTOCOMP_COMPLETED
        events.

        @since 3.1.1
    */
    int  GetListCompletionMethod() const;

    /**
        Returns the list type for this event.

        The list type is an integer passed to a list when it is created with
        the @link wxStyledTextCtrl::UserListShow
        wxStyledTextCtrl::UserListShow @endlink method and can be used to
        distinguish lists if more than one is used.

        This method is valid for @c wxEVT_STC_AUTOCOMP_SELECTION_CHANGE and
        @c wxEVT_STC_USERLISTSELECTION events.
    */
    int  GetListType() const;

    /**
        Returns the value of the LParam field for this event.

        This method is valid for @c wxEVT_STC_MACRORECORD events.
    */
    int  GetLParam() const;

    /**
        Returns the zero-based index of the margin that generated this event.

        This method is valid for @c wxEVT_STC_MARGINCLICK and
        @c wxEVT_STC_MARGIN_RIGHT_CLICK events.
    */
    int  GetMargin() const;

    /**
        Returns a message number while a macro is being recorded.

        Many of the wxStyledTextCtrl methods such as @link
        wxStyledTextCtrl::InsertText InsertText@endlink and @link
        wxStyledTextCtrl::Paste Paste@endlink have an event number associated
        with them.  This method returns that number while a macro is being
        recorded so that the macro can be played back later.

        This method is valid for @c wxEVT_STC_MACRORECORD events.
    */
    int  GetMessage() const;

    /**
        Returns the modification type for this event.

        The modification type is a bit list that describes the change that
        generated this event.  It may contain one or more of the following
        values:

        - @link wxStyledTextEvent::wxSTC_MOD_INSERTTEXT wxSTC_MOD_INSERTTEXT
          @endlink
        - @link wxStyledTextEvent::wxSTC_MOD_DELETETEXT wxSTC_MOD_DELETETEXT
          @endlink
        - @link wxStyledTextEvent::wxSTC_MOD_CHANGESTYLE wxSTC_MOD_CHANGESTYLE
          @endlink
        - @link wxStyledTextEvent::wxSTC_MOD_CHANGEFOLD wxSTC_MOD_CHANGEFOLD
          @endlink
        - @link wxStyledTextEvent::wxSTC_PERFORMED_USER wxSTC_PERFORMED_USER
          @endlink
        - @link wxStyledTextEvent::wxSTC_PERFORMED_UNDO wxSTC_PERFORMED_UNDO
          @endlink
        - @link wxStyledTextEvent::wxSTC_PERFORMED_REDO wxSTC_PERFORMED_REDO
          @endlink
        - @link wxStyledTextEvent::wxSTC_MULTISTEPUNDOREDO
          wxSTC_MULTISTEPUNDOREDO
          @endlink
        - @link wxStyledTextEvent::wxSTC_LASTSTEPINUNDOREDO
          wxSTC_LASTSTEPINUNDOREDO
          @endlink
        - @link wxStyledTextEvent::wxSTC_MOD_CHANGEMARKER
          wxSTC_MOD_CHANGEMARKER @endlink
        - @link wxStyledTextEvent::wxSTC_MOD_BEFOREINSERT
          wxSTC_MOD_BEFOREINSERT
          @endlink
        - @link wxStyledTextEvent::wxSTC_MOD_BEFOREDELETE
          wxSTC_MOD_BEFOREDELETE
          @endlink
        - @link wxStyledTextEvent::wxSTC_MULTILINEUNDOREDO
          wxSTC_MULTILINEUNDOREDO
          @endlink
        - @link wxStyledTextEvent::wxSTC_STARTACTION wxSTC_STARTACTION
          @endlink
        - @link wxStyledTextEvent::wxSTC_MOD_CHANGEINDICATOR
          wxSTC_MOD_CHANGEINDICATOR
          @endlink
        - @link wxStyledTextEvent::wxSTC_MOD_CHANGELINESTATE
          wxSTC_MOD_CHANGELINESTATE
          @endlink
        - @link wxStyledTextEvent::wxSTC_MOD_CHANGEMARGIN
          wxSTC_MOD_CHANGEMARGIN
          @endlink
        - @link wxStyledTextEvent::wxSTC_MOD_CHANGEANNOTATION
          wxSTC_MOD_CHANGEANNOTATION
          @endlink
        - @link wxStyledTextEvent::wxSTC_MOD_CONTAINER
          wxSTC_MOD_CONTAINER
          @endlink
        - @link wxStyledTextEvent::wxSTC_MOD_LEXERSTATE
          wxSTC_MOD_LEXERSTATE
          @endlink
        - @link wxStyledTextEvent::wxSTC_MOD_INSERTCHECK
          wxSTC_MOD_INSERTCHECK
          @endlink
        - @link wxStyledTextEvent::wxSTC_MOD_CHANGETABSTOPS
          wxSTC_MOD_CHANGETABSTOPS
          @endlink

        This method is valid for @c wxEVT_STC_MODIFIED events.
    */
    int  GetModificationType() const;

    /**
        Returns the modifiers of the key press or mouse click for this event.

        The returned value is a bit list that may contain one or more of the
        following values:

        - @link wxStyledTextEvent::wxSTC_KEYMOD_SHIFT wxSTC_KEYMOD_SHIFT @endlink
        - @link wxStyledTextEvent::wxSTC_KEYMOD_CTRL wxSTC_KEYMOD_CTRL @endlink
        - @link wxStyledTextEvent::wxSTC_KEYMOD_ALT wxSTC_KEYMOD_ALT @endlink
        - @link wxStyledTextEvent::wxSTC_KEYMOD_SUPER wxSTC_KEYMOD_SUPER @endlink
        - @link wxStyledTextEvent::wxSTC_KEYMOD_META wxSTC_KEYMOD_META @endlink

        In addition, the value can be checked for equality with @link
        wxStyledTextEvent::wxSTC_KEYMOD_NORM wxSTC_KEYMOD_NORM @endlink to test
        if no modifiers are present.

        This method is valid for the following event types:
        - @c wxEVT_STC_DOUBLECLICK
        - @c wxEVT_STC_MARGINCLICK
        - @c wxEVT_STC_HOTSPOT_CLICK
        - @c wxEVT_STC_HOTSPOT_DCLICK
        - @c wxEVT_STC_HOTSPOT_RELEASE_CLICK
        - @c wxEVT_STC_INDICATOR_CLICK
        - @c wxEVT_STC_INDICATOR_RELEASE
        - @c wxEVT_STC_MARGIN_RIGHT_CLICK
    */
    int  GetModifiers() const;

    /**
        Returns the zero-based text position associated this event.

        This method is valid for the following event types:
        - @c wxEVT_STC_STYLENEEDED
        - @c wxEVT_STC_DOUBLECLICK
        - @c wxEVT_STC_MODIFIED
        - @c wxEVT_STC_MARGINCLICK
        - @c wxEVT_STC_NEEDSHOWN
        - @c wxEVT_STC_USERLISTSELECTION
        - @c wxEVT_STC_DWELLSTART
        - @c wxEVT_STC_DWELLEND
        - @c wxEVT_STC_HOTSPOT_CLICK
        - @c wxEVT_STC_HOTSPOT_DCLICK
        - @c wxEVT_STC_HOTSPOT_RELEASE_CLICK
        - @c wxEVT_STC_INDICATOR_CLICK
        - @c wxEVT_STC_INDICATOR_RELEASE
        - @c wxEVT_STC_CALLTIP_CLICK
        - @c wxEVT_STC_AUTOCOMP_SELECTION
        - @c wxEVT_STC_AUTOCOMP_SELECTION_CHANGE
        - @c wxEVT_STC_AUTOCOMP_COMPLETED
        - @c wxEVT_STC_MARGIN_RIGHT_CLICK
    */
    int  GetPosition() const;

    /**
        Returns true if the Shift key is pressed.

        This method is valid for the following event types:
        - @c wxEVT_STC_DOUBLECLICK
        - @c wxEVT_STC_MARGINCLICK
        - @c wxEVT_STC_HOTSPOT_CLICK
        - @c wxEVT_STC_HOTSPOT_DCLICK
        - @c wxEVT_STC_HOTSPOT_RELEASE_CLICK
        - @c wxEVT_STC_INDICATOR_CLICK
        - @c wxEVT_STC_INDICATOR_RELEASE
        - @c wxEVT_STC_MARGIN_RIGHT_CLICK
    */
    bool GetShift() const;

    /**
        @deprecated Use GetString() instead.
     */
    wxString GetText() const;

    /**
        Returns the token value for this event.

        The token is an integer value that can be set with a call to the
        @link wxStyledTextCtrl::AddUndoAction
        wxStyledTextCtrl::AddUndoAction@endlink method.

        This method is valid for @c wxEVT_STC_MODIFIED events when the result of
        GetModificationType() includes  @link
        wxStyledTextEvent::wxSTC_MOD_CONTAINER wxSTC_MOD_CONTAINER@endlink.
    */
    int  GetToken() const;

    /**
        Returns the value of the updated field for this event.

        The value of this field is a bit list that describes the change that
        generated this event.  It may contain one or more of the following
        values:

        - @link wxStyledTextEvent::wxSTC_UPDATE_CONTENT wxSTC_UPDATE_CONTENT
        @endlink
        - @link wxStyledTextEvent::wxSTC_UPDATE_SELECTION wxSTC_UPDATE_SELECTION
        @endlink
        - @link wxStyledTextEvent::wxSTC_UPDATE_V_SCROLL wxSTC_UPDATE_V_SCROLL
        @endlink
        - @link wxStyledTextEvent::wxSTC_UPDATE_H_SCROLL wxSTC_UPDATE_H_SCROLL
        @endlink

        This method is valid for @c wxEVT_STC_UPDATEUI events.
    */
    int  GetUpdated() const;

    /**
        Returns value of the WParam field for this event.

        This method is valid for @c wxEVT_STC_MACRORECORD events.
    */
    int  GetWParam() const;

    /**
        Returns the X coordinate of the mouse for this event.

        This method is valid for the following event types:
        - @c wxEVT_STC_DWELLSTART
        - @c wxEVT_STC_DWELLEND
        - @c wxEVT_STC_START_DRAG
        - @c wxEVT_STC_DRAG_OVER
        - @c wxEVT_STC_DO_DROP
    */
    int  GetX() const;

    /**
        Returns the Y coordinate of the mouse for this event.

        This method is valid for the following event types:
        - @c wxEVT_STC_DWELLSTART
        - @c wxEVT_STC_DWELLEND
        - @c wxEVT_STC_START_DRAG
        - @c wxEVT_STC_DRAG_OVER
        - @c wxEVT_STC_DO_DROP
    */
    int  GetY() const;

    /**
        Sets the annotation lines added value for this event.
    */
    void SetAnnotationLinesAdded(int val);

    /**
        Sets the drag flags for this event.
    */
    void SetDragFlags(int flags);

    /**
        Sets the drag result for this event.
    */
    void SetDragResult(wxDragResult val);

    /**
        Sets the drag text for this event.

        @deprecated
    */
    void SetDragText(const wxString& val);

    /**
        Sets the current fold level for this event.
    */
    void SetFoldLevelNow(int val);

    /**
        Sets the previous fold level for this event.
    */
    void SetFoldLevelPrev(int val);

    /**
        Sets the key code for this event.
    */
    void SetKey(int k);

    /**
        Sets the length value for this event.
    */
    void SetLength(int len);

    /**
        Sets line number for this event.
    */
    void SetLine(int val);

    /**
        Sets the number of lines added for this event.
    */
    void SetLinesAdded(int num);

    /**
        Sets the list completion method for this event.

        @since 3.1.1
    */
    void SetListCompletionMethod(int val);

    /**
        Sets the list type for this event.
    */
    void SetListType(int val);

    /**
        Sets value of the LParam field for this event.
    */
    void SetLParam(int val);

    /**
        Sets margin number for this event.
    */
    void SetMargin(int val);

    /**
        Sets message number for this event.
    */
    void SetMessage(int val);

    /**
        Sets the modification type for this event.
    */
    void SetModificationType(int t);

    /**
        Sets the value of the modifiers field for this event.
    */
    void SetModifiers(int m);

    /**
        Sets file position for this event.
    */
    void SetPosition(int pos);

    /**
        Sets the text for this event.

        @deprecated
    */
    void SetText(const wxString& t);

    /**
        Sets the token for this event.
    */
    void SetToken(int val);

    /**
        Sets the value of the updated field for this event.
    */
    void SetUpdated(int val);

    /**
        Sets the value of the WParam field for this event.
    */
    void SetWParam(int val);

    /**
        Sets the X value for this event.
    */
    void SetX(int val);

    /**
        Sets the Y value for this event.
    */
    void SetY(int val);
};



const wxEventType wxEVT_STC_CHANGE;
const wxEventType wxEVT_STC_STYLENEEDED;
const wxEventType wxEVT_STC_CHARADDED;
const wxEventType wxEVT_STC_SAVEPOINTREACHED;
const wxEventType wxEVT_STC_SAVEPOINTLEFT;
const wxEventType wxEVT_STC_ROMODIFYATTEMPT;
const wxEventType wxEVT_STC_KEY;
const wxEventType wxEVT_STC_DOUBLECLICK;
const wxEventType wxEVT_STC_UPDATEUI;
const wxEventType wxEVT_STC_MODIFIED;
const wxEventType wxEVT_STC_MACRORECORD;
const wxEventType wxEVT_STC_MARGINCLICK;
const wxEventType wxEVT_STC_NEEDSHOWN;
const wxEventType wxEVT_STC_PAINTED;
const wxEventType wxEVT_STC_USERLISTSELECTION;
const wxEventType wxEVT_STC_URIDROPPED;
const wxEventType wxEVT_STC_DWELLSTART;
const wxEventType wxEVT_STC_DWELLEND;
const wxEventType wxEVT_STC_START_DRAG;
const wxEventType wxEVT_STC_DRAG_OVER;
const wxEventType wxEVT_STC_DO_DROP;
const wxEventType wxEVT_STC_ZOOM;
const wxEventType wxEVT_STC_HOTSPOT_CLICK;
const wxEventType wxEVT_STC_HOTSPOT_DCLICK;
const wxEventType wxEVT_STC_CALLTIP_CLICK;
const wxEventType wxEVT_STC_AUTOCOMP_SELECTION;
const wxEventType wxEVT_STC_INDICATOR_CLICK;
const wxEventType wxEVT_STC_INDICATOR_RELEASE;
const wxEventType wxEVT_STC_AUTOCOMP_CANCELLED;
const wxEventType wxEVT_STC_AUTOCOMP_CHAR_DELETED;
const wxEventType wxEVT_STC_HOTSPOT_RELEASE_CLICK;
const wxEventType wxEVT_STC_CLIPBOARD_COPY;
const wxEventType wxEVT_STC_CLIPBOARD_PASTE;
const wxEventType wxEVT_STC_AUTOCOMP_COMPLETED;
const wxEventType wxEVT_STC_MARGIN_RIGHT_CLICK;
const wxEventType wxEVT_STC_AUTOCOMP_SELECTION_CHANGE;
