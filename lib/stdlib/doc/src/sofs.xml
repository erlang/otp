<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>2001</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>

    <title>sofs</title>
    <prepared>Hans Bolinder</prepared>
    <responsible></responsible>
    <docno></docno>
    <approved></approved>
    <checked></checked>
    <date>2001-08-25</date>
    <rev>PA1</rev>
    <file>sofs.xml</file>
  </header>
  <module>sofs</module>
  <modulesummary>Functions for manipulating sets of sets.</modulesummary>
  <description>
    <p>This module provides operations on finite sets and
      relations represented as sets. Intuitively, a set is a
      collection of elements; every element belongs to the set, and
      the set contains every element.</p>

    <p>Given a set A and a sentence S(x), where x is a free variable,
      a new set B whose elements are exactly those elements of A for
      which S(x) holds can be formed, this is denoted B&nbsp;=
      {x&nbsp;in&nbsp;A&nbsp;: S(x)}. Sentences are expressed using
      the logical operators "for some" (or "there exists"), "for all",
      "and", "or", "not". If the existence of a set containing all the
      specified elements is known (as is always the case in this
      module), this is denoted B&nbsp;= {x&nbsp;: S(x)}.</p>

    <list type="bulleted">
      <item>
        <p>The <em>unordered set</em> containing the elements a, b, and c is
          denoted {a,&nbsp;b,&nbsp;c}. This notation is not to be confused with
          tuples.</p>
        <p>The <em>ordered pair</em> of a and b, with first <em>coordinate</em>
          a and second coordinate b, is denoted (a,&nbsp;b). An ordered pair
          is an <em>ordered set</em> of two elements. In this module, ordered
          sets can contain one, two, or more elements, and parentheses are
          used to enclose the elements.</p>
        <p>Unordered sets and ordered sets are orthogonal, again in this
          module; there is no unordered set equal to any ordered set.</p>
      </item>
      <item>
        <p>The <em>empty set</em> contains no elements.</p>
        <p>Set A is <marker id="equal"></marker><em>equal</em> to set B if they
          contain the same elements, which is denoted A&nbsp;=&nbsp;B. Two
          ordered sets are equal if they contain the same number of elements
          and have equal elements at each coordinate.</p>
        <p>Set B is a <marker id="subset"></marker><em>subset</em> of set A
          if A contains all elements that B contains.</p>
        <p>The <marker id="union"></marker><em>union</em> of two sets A and B
          is the smallest set that contains all elements of A and all elements
          of B.</p>
        <p>The <marker id="intersection"></marker><em>intersection</em> of two
          sets A and B is the set that contains all elements of A that belong
          to B.</p>
        <p>Two sets are <marker id="disjoint"></marker><em>disjoint</em> if
          their intersection is the empty set.</p>
        <p>The <marker id="difference"></marker><em>difference</em> of two sets
          A and B is the set that contains all elements of A that do not belong
          to B.</p>
        <p>The <marker id="symmetric_difference"></marker><em>symmetric 
          difference</em> of two sets is the set that contains those element
          that belong to either of the two sets, but not both.</p>
        <p>The <marker id="union_n"></marker><em>union</em> of a collection
          of sets is the smallest set that contains all the elements that
          belong to at least one set of the collection.</p>
        <p>The <marker id="intersection_n"></marker><em>intersection</em> of
          a non-empty collection of sets is the set that contains all elements
          that belong to every set of the collection.</p>
      </item>
      <item>
        <p>The <marker id="Cartesian_product"></marker><em>Cartesian
          product</em> of two sets X and Y, denoted X&nbsp;&times;&nbsp;Y, is
          the set {a&nbsp;: a&nbsp;= (x,&nbsp;y) for some x&nbsp;in&nbsp;X and
          for some y&nbsp;in&nbsp;Y}.</p>
        <p>A <marker id="relation"></marker><em>relation</em> is a subset of
          X&nbsp;&times;&nbsp;Y. Let R be a relation. The fact that (x,&nbsp;y)
          belongs to R is written as x&nbsp;R&nbsp;y. As relations are sets,
          the definitions of the last item (subset, union, and so on) apply to
          relations as well.</p>
        <p>The <marker id="domain"></marker><em>domain</em> of R is the set
          {x&nbsp;: x&nbsp;R&nbsp;y for some y&nbsp;in&nbsp;Y}.</p>
        <p>The <marker id="range"></marker><em>range</em> of R is the set
          {y&nbsp;: x&nbsp;R&nbsp;y for some x&nbsp;in&nbsp;X}.</p>
        <p>The <marker id="converse"></marker><em>converse</em> of R is the
          set {a&nbsp;: a&nbsp;= (y,&nbsp;x) for some
          (x,&nbsp;y)&nbsp;in&nbsp;R}.</p>
        <p>If A is a subset of X, the <marker id="image"></marker><em>image</em>
          of A under R is the set {y&nbsp;: x&nbsp;R&nbsp;y for some
          x&nbsp;in&nbsp;A}. If B is a subset of Y, the
          <marker id="inverse_image"></marker><em>inverse image</em> of B is the
          set {x&nbsp;: x&nbsp;R&nbsp;y for some y&nbsp;in&nbsp;B}.</p>
        <p>If R is a relation from X to Y, and S is a relation from Y to Z, the 
          <marker id="relative_product"></marker><em>relative product</em> of R
          and S is the relation T from X to Z defined so that x&nbsp;T&nbsp;z
          if and only if there exists an element y in Y such that
          x&nbsp;R&nbsp;y and y&nbsp;S&nbsp;z.</p>
        <p>The <marker id="restriction"></marker><em>restriction</em> of R to A
          is the set S defined so that x&nbsp;S&nbsp;y if and only if there
          exists an element x in A such that x&nbsp;R&nbsp;y.</p>
        <p>If S is a restriction of R to A, then R is an
          <marker id="extension"></marker><em>extension</em> of S to X.</p>
        <p>If X&nbsp;=&nbsp;Y, then R is called a relation <em>in</em> X.</p>
        <p>The <marker id="field"></marker><em>field</em> of a relation R in X
          is the union of the domain of R and the range of R.</p>
        <p>If R is a relation in X, and if S is defined so that x&nbsp;S&nbsp;y
          if x&nbsp;R&nbsp;y and not x&nbsp;=&nbsp;y, then S is the
          <marker id="strict_relation"></marker><em>strict</em> relation
          corresponding to R. Conversely, if S is a relation in X, and if R is
          defined so that x&nbsp;R&nbsp;y if x&nbsp;S&nbsp;y or x&nbsp;=&nbsp;y,
          then R is the <marker id="weak_relation"></marker><em>weak</em>
          relation corresponding to S.</p>
        <p>A relation R in X is <em>reflexive</em> if x&nbsp;R&nbsp;x for every
          element x of X, it is <em>symmetric</em> if x&nbsp;R&nbsp;y implies
          that y&nbsp;R&nbsp;x, and it is <em>transitive</em> if
          x&nbsp;R&nbsp;y and y&nbsp;R&nbsp;z imply that x&nbsp;R&nbsp;z.</p>
      </item>
      <item>
        <p>A <marker id="function"></marker><em>function</em> F is a relation,
          a subset of X&nbsp;&times;&nbsp;Y, such that the domain of F is equal
          to X and such that for every x in X there is a unique element y in Y
          with (x,&nbsp;y) in F. The latter condition can be formulated as
          follows: if x&nbsp;F&nbsp;y and x&nbsp;F&nbsp;z, then y&nbsp;=&nbsp;z.
          In this module, it is not required that the domain of F is equal to X
          for a relation to be considered a function.</p>
        <p>Instead of writing (x,&nbsp;y)&nbsp;in&nbsp;F or x&nbsp;F&nbsp;y, we
          write F(x)&nbsp;=&nbsp;y when F is a function, and say that F maps x
          onto y, or that the value of F at x is y.</p>
        <p>As functions are relations, the definitions of the last item (domain,
          range, and so on) apply to functions as well.</p>
        <p>If the converse of a function F is a function F', then F' is called 
          the <marker id="inverse"></marker><em>inverse</em> of F.</p>
        <p>The relative product of two functions F1 and F2 is called
          the <marker id="composite"></marker><em>composite</em> of F1 and F2
          if the range of F1 is a subset of the domain of F2.</p>
      </item>
      <item>
        <p>Sometimes, when the range of a function is more important than the
          function itself, the function is called a <em>family</em>.</p>
        <p>The domain of a family is called the <em>index set</em>, and the
          range is called the <em>indexed set</em>.</p>
        <p>If x is a family from I to X, then x[i] denotes the value of the
          function at index i. The notation "a family in X" is used for such a
          family.</p>
        <p>When the indexed set is a set of subsets of a set X, we call x a 
          <marker id="family"></marker><em>family of subsets</em> of X.</p>
        <p>If x is a family of subsets of X, the union of the range of x is
          called the <em>union of the family</em> x.</p>
        <p>If x is non-empty (the index set is non-empty), the <em>intersection
          of the family</em> x is the intersection of the range of x.</p>
        <p>In this module, the only families that are considered are families
          of subsets of some set X; in the following, the word "family" is
          used for such families of subsets.</p>
      </item>
      <item>
        <p>A <marker id="partition"></marker><em>partition</em> of a set X is a
          collection S of non-empty subsets of X whose union is X and whose
          elements are pairwise disjoint.</p>
        <p>A relation in a set is an <em>equivalence relation</em> if it is
          reflexive, symmetric, and transitive.</p>
        <p>If R is an equivalence relation in X, and x is an element of X, the 
          <marker id="equivalence_class"></marker><em>equivalence class</em> of
          x with respect to R is the set of all those elements y of X for which
          x&nbsp;R&nbsp;y holds. The equivalence classes constitute a
          partitioning of X. Conversely, if C is a partition of X, the relation
          that holds for any two elements of X if they belong to the same
          equivalence class, is an equivalence relation induced by the
          partition C.</p>
        <p>If R is an equivalence relation in X, the
          <marker id="canonical_map"></marker><em>canonical map</em> is the
          function that maps every element of X onto its equivalence class.</p>
      </item>
      <item>
        <p><marker id="binary_relation"></marker>Relations as defined above
          (as sets of ordered pairs) are from now on referred to as <em>binary
          relations</em>.</p>
        <p>We call a set of ordered sets (x[1],&nbsp;...,&nbsp;x[n]) an
          <marker id="n_ary_relation"></marker><em>(n-ary) relation</em>, and
          say that the relation is a subset of the
          <marker id="Cartesian_product_tuple"></marker>Cartesian product
          X[1]&nbsp;&times;&nbsp;...&nbsp;&times;&nbsp;X[n], where x[i] is
          an element of X[i], 1&nbsp;&lt;=&nbsp;i&nbsp;&lt;=&nbsp;n.</p>
        <p>The <marker id="projection"></marker><em>projection</em> of an n-ary
          relation R onto coordinate i is the set {x[i]&nbsp;:
          (x[1],&nbsp;...,&nbsp;x[i],&nbsp;...,&nbsp;x[n]) in R for some
          x[j]&nbsp;in&nbsp;X[j], 1&nbsp;&lt;=&nbsp;j&nbsp;&lt;=&nbsp;n and
          not i&nbsp;=&nbsp;j}. The projections of a binary relation R onto the
          first and second coordinates are the domain and the range of R,
          respectively.</p>
        <p>The relative product of binary relations can be generalized to n-ary
          relations as follows. Let TR be an ordered set
          (R[1],&nbsp;...,&nbsp;R[n]) of binary relations from X to Y[i]
          and S a binary relation from
          (Y[1]&nbsp;&times;&nbsp;...&nbsp;&times;&nbsp;Y[n]) to Z. The
          <marker id="tuple_relative_product"></marker><em>relative product</em>
          of TR and S is the binary relation T from X to Z defined so that
          x&nbsp;T&nbsp;z if and only if there exists an element y[i] in Y[i]
          for each 1&nbsp;&lt;=&nbsp;i&nbsp;&lt;=&nbsp;n such that
          x&nbsp;R[i]&nbsp;y[i] and
          (y[1],&nbsp;...,&nbsp;y[n])&nbsp;S&nbsp;z. Now let TR be a an
          ordered set (R[1],&nbsp;...,&nbsp;R[n]) of binary relations from
          X[i] to Y[i] and S a subset of
          X[1]&nbsp;&times;&nbsp;...&nbsp;&times;&nbsp;X[n].
          The <marker id="multiple_relative_product"></marker><em>multiple
          relative product</em> of TR and S is defined to be the set
          {z&nbsp;: z&nbsp;= ((x[1],&nbsp;...,&nbsp;x[n]), (y[1],...,y[n]))
          for some (x[1],&nbsp;...,&nbsp;x[n])&nbsp;in&nbsp;S and for some
          (x[i],&nbsp;y[i]) in R[i], 1&nbsp;&lt;=&nbsp;i&nbsp;&lt;=&nbsp;n}.</p>
        <p>The <marker id="natural_join"></marker><em>natural join</em> of an
          n-ary relation R and an m-ary relation S on coordinate i and j is
          defined to be the set
          {z&nbsp;: z&nbsp;= (x[1],&nbsp;...,&nbsp;x[n],&nbsp;
          y[1],&nbsp;...,&nbsp;y[j-1],&nbsp;y[j+1],&nbsp;...,&nbsp;y[m])
          for some (x[1],&nbsp;...,&nbsp;x[n])&nbsp;in&nbsp;R and for some
          (y[1],&nbsp;...,&nbsp;y[m])&nbsp;in&nbsp;S such that
          x[i]&nbsp;=&nbsp;y[j]}.</p>
      </item>
      <item>
        <p><marker id="sets_definition"></marker>The sets recognized by this
          module are represented by elements of the relation Sets, which is
          defined as the smallest set such that:</p>
        <list type="bulleted">
          <item>
            <p>For every atom T, except '_', and for every term X,
              (T,&nbsp;X) belongs to Sets (<em>atomic sets</em>).</p>
          </item>
          <item>
            <p>(['_'],&nbsp;[]) belongs to Sets (the <em>untyped empty
              set</em>).</p>
          </item>
          <item>
            <p>For every tuple T&nbsp;= {T[1],&nbsp;...,&nbsp;T[n]} and
              for every tuple X&nbsp;= {X[1],&nbsp;...,&nbsp;X[n]}, if
              (T[i],&nbsp;X[i]) belongs to Sets for every
              1&nbsp;&lt;=&nbsp;i&nbsp;&lt;=&nbsp;n, then (T,&nbsp;X) belongs
              to Sets (<em>ordered sets</em>).</p>
          </item>
          <item>
            <p>For every term T, if X is the empty list or a non-empty
              sorted list [X[1],&nbsp;...,&nbsp;X[n]] without duplicates
              such that (T,&nbsp;X[i]) belongs to Sets for every
              1&nbsp;&lt;=&nbsp;i&nbsp;&lt;=&nbsp;n, then ([T],&nbsp;X)
              belongs to Sets (<em>typed unordered sets</em>).</p>
          </item>
        </list>
        <p>An <marker id="external_set"></marker><em>external set</em> is an
          element of the range of Sets.</p>
        <p>A <marker id="type"></marker><em>type</em> is an element of the
          domain of Sets.</p>
        <p>If S is an element (T,&nbsp;X) of Sets, then T is a
          <marker id="valid_type"></marker><em>valid type</em> of X, T is the
          type of S, and X is the external set of S.
          <seealso marker="#from_term/2"><c>from_term/2</c></seealso> creates a
          set from a type and an Erlang term turned into an external set.</p>
        <p>The sets represented by Sets are the elements of the range of
          function Set from Sets to Erlang terms and sets of Erlang terms:</p>
          <list type="bulleted">
            <item>Set(T,Term)&nbsp;= Term, where T is an atom</item>
            <item>Set({T[1],&nbsp;...,&nbsp;T[n]},&nbsp;{X[1],&nbsp;...,
              &nbsp;X[n]})&nbsp;= (Set(T[1],&nbsp;X[1]),&nbsp;...,&nbsp;
	      Set(T[n],&nbsp;X[n]))</item>
            <item>Set([T],&nbsp;[X[1],&nbsp;...,&nbsp;X[n]])&nbsp;=
              {Set(T,&nbsp;X[1]),&nbsp;...,&nbsp;Set(T,&nbsp;X[n])}</item>
            <item>Set([T],&nbsp;[])&nbsp;= {}</item>
          </list>
        <p>When there is no risk of confusion, elements of Sets are identified
          with the sets they represent. For example, if U is the result of
          calling <seealso marker="#union/2"><c>union/2</c></seealso> with S1
          and S2 as arguments, then U is said to be the union of S1 and S2.
          A more precise formulation is that Set(U) is the union of Set(S1)
          and Set(S2).</p>
      </item>
    </list>

    <p>The types are used to implement the various conditions that
      sets must fulfill. As an example, consider the relative
      product of two sets R and S, and recall that the relative
      product of R and S is defined if R is a binary relation to Y and
      S is a binary relation from Y. The function that implements the
      relative product, <seealso marker="#relative_product/2">
      <c>relative_product/2</c></seealso>, checks
      that the arguments represent binary relations by matching [{A,B}]
      against the type of the first argument (Arg1 say), and [{C,D}]
      against the type of the second argument (Arg2 say). The fact
      that [{A,B}] matches the type of Arg1 is to be interpreted as
      Arg1 representing a binary relation from X to Y, where X is
      defined as all sets Set(x) for some element x in Sets the type
      of which is A, and similarly for Y. In the same way Arg2 is
      interpreted as representing a binary relation from W to Z.
      Finally it is checked that B matches C, which is sufficient to
      ensure that W is equal to Y. The untyped empty set is handled
      separately: its type, ['_'], matches the type of any unordered
      set.</p>

    <p>A few functions of this module
      (<seealso marker="#drestriction/3"><c>drestriction/3</c></seealso>,
      <seealso marker="#family_projection/2"><c>family_projection/2</c></seealso>,
      <seealso marker="#partition/2"><c>partition/2</c></seealso>,
      <seealso marker="#partition_family/2"><c>partition_family/2</c></seealso>,
      <seealso marker="#projection/2"><c>projection/2</c></seealso>,
      <seealso marker="#restriction/3"><c>restriction/3</c></seealso>,
      <seealso marker="#substitution/2"><c>substitution/2</c></seealso>)
      accept an Erlang
      function as a means to modify each element of a given unordered
      set. <marker id="set_fun"></marker>Such a function, called
      SetFun in the following, can be specified as a functional object (fun),
      a tuple <c>{external,&nbsp;Fun}</c>, or an integer:</p>

    <list type="bulleted">
      <item>
        <p>If SetFun is specified as a fun, the fun is applied to each element
          of the given set and the return value is assumed to be a set.</p>
      </item>
      <item>
        <p>If SetFun is specified as a tuple <c>{external, Fun}</c>, Fun is
          applied to the external set of each element of the given set and the
          return value is assumed to be an external set. Selecting the
          elements of an unordered set as external sets and assembling a
          new unordered set from a list of external sets is in the present
          implementation more efficient than modifying each element as a
          set. However, this optimization can only be used when the
          elements of the unordered set are atomic or ordered sets. It
          must also be the case that the type of the elements matches some
          clause of Fun (the type of the created set is the result of
          applying Fun to the type of the given set), and that Fun does
          nothing but selecting, duplicating, or rearranging parts of the
          elements.</p>
      </item>
      <item>
        <p>Specifying a SetFun as an integer I is equivalent to
          specifying <c>{external, fun(X)&nbsp;->
          element(I,&nbsp;X)&nbsp;end}</c>, but is to be preferred, as it
          makes it possible to handle this case even more efficiently.</p>
      </item>
    </list>

    <p>Examples of SetFuns:</p>

    <pre>
fun sofs:union/1
fun(S) -> sofs:partition(1, S) end
{external, fun(A) -> A end}
{external, fun({A,_,C}) -> {C,A} end}
{external, fun({_,{_,C}}) -> C end}
{external, fun({_,{_,{_,E}=C}}) -> {E,{E,C}} end}
2</pre>

    <p>The order in which a SetFun is applied to the elements of an
      unordered set is not specified, and can change in future
      versions of this module.</p>

    <p>The execution time of the functions of this module is dominated
      by the time it takes to sort lists. When no sorting is needed,
      the execution time is in the worst case proportional to the sum
      of the sizes of the input arguments and the returned value. A
      few functions execute in constant time:
      <seealso marker="#from_external/2"><c>from_external/2</c></seealso>,
      <seealso marker="#is_empty_set/1"><c>is_empty_set/1</c></seealso>,
      <seealso marker="#is_set/1"><c>is_set/1</c></seealso>,
      <seealso marker="#is_sofs_set/1"><c>is_sofs_set/1</c></seealso>,
      <seealso marker="#to_external/1"><c>to_external/1</c></seealso>
      <seealso marker="#type/1"><c>type/1</c></seealso>.</p>

    <p>The functions of this module exit the process with a
      <c>badarg</c>, <c>bad_function</c>, or <c>type_mismatch</c>
      message when given badly formed arguments or sets the types of
      which are not compatible.</p>

    <p>When comparing external sets, operator <c>==/2</c> is used.</p>
  </description>

  <datatypes>
    <datatype>
      <name name="anyset"></name>
      <desc><p>Any kind of set (also included are the atomic sets).</p></desc>
    </datatype>
    <datatype>
      <name name="binary_relation"></name>
      <desc><p>A <seealso marker="#binary_relation">binary
        relation</seealso>.</p></desc>
    </datatype>
    <datatype>
      <name name="external_set"></name>
      <desc><p>An <seealso marker="#external_set">external
        set</seealso>.</p></desc>
    </datatype>
    <datatype>
      <name name="family"></name>
      <desc><p>A <seealso marker="#family">family</seealso> (of subsets).</p>
      </desc>
    </datatype>
    <datatype>
      <name name="a_function"></name>
      <desc><p>A <seealso marker="#function">function</seealso>.</p></desc>
    </datatype>
    <datatype>
      <name name="ordset"></name>
      <desc><p>An <seealso marker="#sets_definition">ordered
        set</seealso>.</p></desc>
    </datatype>
    <datatype>
      <name name="relation"></name>
      <desc><p>An <seealso marker="#n_ary_relation">n-ary relation</seealso>.
      </p></desc>
    </datatype>
    <datatype>
      <name name="a_set"></name>
      <desc><p>An <seealso marker="#sets_definition">unordered
        set</seealso>.</p></desc>
    </datatype>
    <datatype>
      <name name="set_of_sets"></name>
      <desc><p>An <seealso marker="#sets_definition">unordered
        set</seealso> of unordered sets.</p></desc>
    </datatype>
    <datatype>
      <name name="set_fun"></name>
      <desc><p>A <seealso marker="#set_fun">SetFun</seealso>.</p></desc>
    </datatype>
    <datatype>
      <name name="spec_fun"></name>
    </datatype>
    <datatype>
      <name name="type"></name>
      <desc><p>A <seealso marker="#type">type</seealso>.</p></desc>
    </datatype>
    <datatype>
      <!-- Parameterized opaque types are NYI: -->
      <name>tuple_of(T)</name>
      <desc><p>A tuple where the elements are of type <c>T</c>.</p></desc>
    </datatype>
  </datatypes>

  <funcs>
    <func>
      <name name="a_function" arity="1"/>
      <name name="a_function" arity="2"/>
      <fsummary>Create a function.</fsummary>
      <desc>
        <p>Creates a <seealso marker="#function">function</seealso>.
          <c>a_function(F,&nbsp;T)</c> is equivalent to
          <c>from_term(F,&nbsp;T)</c> if the result is a function. If
          no <seealso marker="#type">type</seealso> is explicitly
          specified, <c>[{atom,&nbsp;atom}]</c> is used as the
          function type.</p>
      </desc>
    </func>

    <func>
      <name name="canonical_relation" arity="1"/>
      <fsummary>Return the canonical map.</fsummary>
      <desc>
        <p>Returns the binary relation containing the elements
          (E,&nbsp;Set) such that Set belongs to <c><anno>SetOfSets</anno></c>
          and E belongs to Set. If <c>SetOfSets</c> is
          a <seealso marker="#partition">partition</seealso> of a set X and
          R is the equivalence relation in X induced by <c>SetOfSets</c>,
          then the returned relation is
          the <seealso marker="#canonical_map">canonical map</seealso> from
          X onto the equivalence classes with respect to R.</p>
        <pre>
1> <input>Ss = sofs:from_term([[a,b],[b,c]]),</input>
<input>CR = sofs:canonical_relation(Ss),</input>
<input>sofs:to_external(CR).</input>
[{a,[a,b]},{b,[a,b]},{b,[b,c]},{c,[b,c]}]</pre>
      </desc>
    </func>

    <func>
      <name name="composite" arity="2"/>
      <fsummary>Return the composite of two functions.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#composite">composite</seealso> of 
          the functions <c><anno>Function1</anno></c> and
          <c><anno>Function2</anno></c>.</p>
        <pre>
1> <input>F1 = sofs:a_function([{a,1},{b,2},{c,2}]),</input>
<input>F2 = sofs:a_function([{1,x},{2,y},{3,z}]),</input>
<input>F = sofs:composite(F1, F2),</input>
<input>sofs:to_external(F).</input>
[{a,x},{b,y},{c,y}]</pre>
      </desc>
    </func>

    <func>
      <name name="constant_function" arity="2"/>
      <fsummary>Create the function that maps each element of a
        set onto another set.</fsummary>
      <desc>
        <p>Creates the <seealso marker="#function">function</seealso>
          that maps each element of set <c>Set</c> onto <c>AnySet</c>.</p>
        <pre>
1> <input>S = sofs:set([a,b]),</input>
<input>E = sofs:from_term(1),</input>
<input>R = sofs:constant_function(S, E),</input>
<input>sofs:to_external(R).</input>
[{a,1},{b,1}]</pre>
      </desc>
    </func>

    <func>
      <name name="converse" arity="1"/>
      <fsummary>Return the converse of a binary relation.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#converse">converse</seealso>
          of the binary relation <c><anno>BinRel1</anno></c>.</p>
        <pre>
1> <input>R1 = sofs:relation([{1,a},{2,b},{3,a}]),</input>
<input>R2 = sofs:converse(R1),</input>
<input>sofs:to_external(R2).</input>
[{a,1},{a,3},{b,2}]</pre>
      </desc>
    </func>

    <func>
      <name name="difference" arity="2"/>
      <fsummary>Return the difference of two sets.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#difference">difference</seealso> of
          the sets <c><anno>Set1</anno></c> and <c><anno>Set2</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="digraph_to_family" arity="1"/>
      <name name="digraph_to_family" arity="2"/>
      <fsummary>Create a family from a directed graph.</fsummary>
      <desc>
        <p>Creates a <seealso marker="#family">family</seealso> from
          the directed graph <c><anno>Graph</anno></c>. Each vertex a of
          <c><anno>Graph</anno></c> is
          represented by a pair (a,&nbsp;{b[1],&nbsp;...,&nbsp;b[n]}),
          where the b[i]:s are the out-neighbors of a. If no type is
          explicitly specified, [{atom,&nbsp;[atom]}] is used as type of
          the family. It is assumed that <c><anno>Type</anno></c> is
          a <seealso marker="#valid_type">valid type</seealso> of the 
          external set of the family.</p>
        <p>If G is a directed graph, it holds that the vertices and
          edges of G are the same as the vertices and edges of
          <c>family_to_digraph(digraph_to_family(G))</c>.</p>
      </desc>
    </func>

    <func>
      <name name="domain" arity="1"/>
      <fsummary>Return the domain of a binary relation.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#domain">domain</seealso> of
          the binary relation <c><anno>BinRel</anno></c>.</p>
        <pre>
1> <input>R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]),</input>
<input>S = sofs:domain(R),</input>
<input>sofs:to_external(S).</input>
[1,2]</pre>
      </desc>
    </func>

    <func>
      <name name="drestriction" arity="2"/>
      <fsummary>Return a restriction of a binary relation.</fsummary>
      <desc>
        <p>Returns the difference between the binary relation
          <c><anno>BinRel1</anno></c>
          and the <seealso marker="#restriction">restriction</seealso>
          of <c><anno>BinRel1</anno></c> to <c><anno>Set</anno></c>.</p>
        <pre>
1> <input>R1 = sofs:relation([{1,a},{2,b},{3,c}]),</input>
<input>S = sofs:set([2,4,6]),</input>
<input>R2 = sofs:drestriction(R1, S),</input>
<input>sofs:to_external(R2).</input>
[{1,a},{3,c}]</pre>
        <p><c>drestriction(R,&nbsp;S)</c> is equivalent to
          <c>difference(R,&nbsp;restriction(R,&nbsp;S))</c>.</p>
      </desc>
    </func>

    <func>
      <name name="drestriction" arity="3"/>
      <fsummary>Return a restriction of a relation.</fsummary>
      <desc>
        <p>Returns a subset of <c><anno>Set1</anno></c> containing those
          elements that do not give
          an element in <c><anno>Set2</anno></c> as the result of applying
          <c><anno>SetFun</anno></c>.</p>
        <pre>
1> <input>SetFun = {external, fun({_A,B,C}) -> {B,C} end},</input>
<input>R1 = sofs:relation([{a,aa,1},{b,bb,2},{c,cc,3}]),</input>
<input>R2 = sofs:relation([{bb,2},{cc,3},{dd,4}]),</input>
<input>R3 = sofs:drestriction(SetFun, R1, R2),</input>
<input>sofs:to_external(R3).</input>
[{a,aa,1}]</pre>
        <p><c>drestriction(F,&nbsp;S1,&nbsp;S2)</c> is equivalent to
          <c>difference(S1,&nbsp;restriction(F,&nbsp;S1,&nbsp;S2))</c>.</p>
      </desc>
    </func>

    <func>
      <name name="empty_set" arity="0"/>
      <fsummary>Return the untyped empty set.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#sets_definition">untyped empty
          set</seealso>. <c>empty_set()</c> is equivalent to
          <c>from_term([],&nbsp;['_'])</c>.</p>
      </desc>
    </func>

    <func>
      <name name="extension" arity="3"/>
      <fsummary>Extend the domain of a binary relation.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#extension">extension</seealso> of
          <c><anno>BinRel1</anno></c> such that for
          each element E in <c><anno>Set</anno></c> that does not belong to the
          <seealso marker="#domain">domain</seealso> of
          <c><anno>BinRel1</anno></c>, <c><anno>BinRel2</anno></c> contains the
          pair (E,&nbsp;<c>AnySet</c>).</p>
        <pre>
1> <input>S = sofs:set([b,c]),</input>
<input>A = sofs:empty_set(),</input>
<input>R = sofs:family([{a,[1,2]},{b,[3]}]),</input>
<input>X = sofs:extension(R, S, A),</input>
<input>sofs:to_external(X).</input>
[{a,[1,2]},{b,[3]},{c,[]}]</pre>
      </desc>
    </func>

    <func>
      <name name="family" arity="1"/>
      <name name="family" arity="2"/>
      <fsummary>Create a family of subsets.</fsummary>
      <desc>
        <p>Creates a <seealso marker="#family">family of subsets</seealso>.
          <c>family(F,&nbsp;T)</c> is equivalent to
          <c>from_term(F,&nbsp;T)</c> if the result is a family. If
          no <seealso marker="#type">type</seealso> is explicitly
          specified, <c>[{atom,&nbsp;[atom]}]</c> is used as the
          family type.</p>
      </desc>
    </func>

    <func>
      <name name="family_difference" arity="2"/>
      <fsummary>Return the difference of two families.</fsummary>
      <desc>
        <p>If <c><anno>Family1</anno></c> and <c><anno>Family2</anno></c>
          are <seealso marker="#family">families</seealso>, then
          <c><anno>Family3</anno></c> is the family
          such that the index set is equal to the index set of
          <c><anno>Family1</anno></c>, and <c><anno>Family3</anno></c>[i] is
          the difference between <c><anno>Family1</anno></c>[i]
          and <c><anno>Family2</anno></c>[i] if <c><anno>Family2</anno></c>
          maps i, otherwise <c><anno>Family1</anno>[i]</c>.</p>
        <pre>
1> <input>F1 = sofs:family([{a,[1,2]},{b,[3,4]}]),</input>
<input>F2 = sofs:family([{b,[4,5]},{c,[6,7]}]),</input>
<input>F3 = sofs:family_difference(F1, F2),</input>
<input>sofs:to_external(F3).</input>
[{a,[1,2]},{b,[3]}]</pre>
      </desc>
    </func>

    <func>
      <name name="family_domain" arity="1"/>
      <fsummary>Return a family of domains.</fsummary>
      <desc>
        <p>If <c><anno>Family1</anno></c> is
          a <seealso marker="#family">family</seealso>
          and <c><anno>Family1</anno></c>[i] is a binary relation for every i
          in the index set of <c><anno>Family1</anno></c>,
          then <c><anno>Family2</anno></c> is the family with the same index
          set as <c><anno>Family1</anno></c> such
          that <c><anno>Family2</anno></c>[i] is
          the <seealso marker="#domain">domain</seealso> of
          <c><anno>Family1</anno>[i]</c>.</p>
        <pre>
1> <input>FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]),</input>
<input>F = sofs:family_domain(FR),</input>
<input>sofs:to_external(F).</input>
[{a,[1,2,3]},{b,[]},{c,[4,5]}]</pre>
      </desc>
    </func>

    <func>
      <name name="family_field" arity="1"/>
      <fsummary>Return a family of fields.</fsummary>
      <desc>
        <p>If <c><anno>Family1</anno></c> is
          a <seealso marker="#family">family</seealso>
          and <c><anno>Family1</anno></c>[i] is a binary relation for every i
          in the index set of <c><anno>Family1</anno></c>,
          then <c><anno>Family2</anno></c> is the family with the same index
          set as <c><anno>Family1</anno></c> such
          that <c><anno>Family2</anno></c>[i] is
          the <seealso marker="#field">field</seealso> of
          <c><anno>Family1</anno></c>[i].</p>
        <pre>
1> <input>FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]),</input>
<input>F = sofs:family_field(FR),</input>
<input>sofs:to_external(F).</input>
[{a,[1,2,3,a,b,c]},{b,[]},{c,[4,5,d,e]}]</pre>
        <p><c>family_field(Family1)</c> is equivalent to
          <c>family_union(family_domain(Family1),
          family_range(Family1))</c>.</p>
      </desc>
    </func>

    <func>
      <name name="family_intersection" arity="1"/>
      <fsummary>Return the intersection of a family
         of sets of sets.</fsummary>
      <desc>
        <p>If <c><anno>Family1</anno></c> is
          a <seealso marker="#family">family</seealso>
          and <c><anno>Family1</anno></c>[i] is a set of sets for every i in
          the index set of <c><anno>Family1</anno></c>,
          then <c><anno>Family2</anno></c> is the family with the same index
          set as <c><anno>Family1</anno></c> such
          that <c><anno>Family2</anno></c>[i] is
          the <seealso marker="#intersection_n">intersection</seealso>
          of <c><anno>Family1</anno></c>[i].</p>
        <p>If <c><anno>Family1</anno></c>[i] is an empty set for some i,
          the process exits with a <c>badarg</c> message.</p>
        <pre>
1> <input>F1 = sofs:from_term([{a,[[1,2,3],[2,3,4]]},{b,[[x,y,z],[x,y]]}]),</input>
<input>F2 = sofs:family_intersection(F1),</input>
<input>sofs:to_external(F2).</input>
[{a,[2,3]},{b,[x,y]}]</pre>
      </desc>
    </func>

    <func>
      <name name="family_intersection" arity="2"/>
      <fsummary>Return the intersection of two families.</fsummary>
      <desc>
        <p>If <c><anno>Family1</anno></c> and <c><anno>Family2</anno></c>
          are <seealso marker="#family">families</seealso>,
          then <c><anno>Family3</anno></c> is the family such that the index
          set is the intersection of <c><anno>Family1</anno></c>:s and
          <c><anno>Family2</anno></c>:s index sets,
          and <c><anno>Family3</anno></c>[i] is the intersection of
          <c><anno>Family1</anno></c>[i] and <c><anno>Family2</anno></c>[i].</p>
        <pre>
1> <input>F1 = sofs:family([{a,[1,2]},{b,[3,4]},{c,[5,6]}]),</input>
<input>F2 = sofs:family([{b,[4,5]},{c,[7,8]},{d,[9,10]}]),</input>
<input>F3 = sofs:family_intersection(F1, F2),</input>
<input>sofs:to_external(F3).</input>
[{b,[4]},{c,[]}]</pre>
      </desc>
    </func>

    <func>
      <name name="family_projection" arity="2"/>
      <fsummary>Return a family of modified subsets.</fsummary>
      <desc>
        <p>If <c><anno>Family1</anno></c> is
          a <seealso marker="#family">family</seealso>,
          then <c><anno>Family2</anno></c> is the family with the same index
          set as <c><anno>Family1</anno></c> such
          that <c><anno>Family2</anno></c>[i] is the result of
          calling <c><anno>SetFun</anno></c> with <c><anno>Family1</anno></c>[i]
          as argument.</p>
        <pre>
1> <input>F1 = sofs:from_term([{a,[[1,2],[2,3]]},{b,[[]]}]),</input>
<input>F2 = sofs:family_projection(fun sofs:union/1, F1),</input>
<input>sofs:to_external(F2).</input>
[{a,[1,2,3]},{b,[]}]</pre>
      </desc>
    </func>

    <func>
      <name name="family_range" arity="1"/>
      <fsummary>Return a family of ranges.</fsummary>
      <desc>
        <p>If <c><anno>Family1</anno></c> is
          a <seealso marker="#family">family</seealso>
          and <c><anno>Family1</anno></c>[i] is a binary relation for every i
          in the index set of <c><anno>Family1</anno></c>,
          then <c><anno>Family2</anno></c> is the family with the same index
          set as <c><anno>Family1</anno></c> such
          that <c><anno>Family2</anno></c>[i] is
          the <seealso marker="#range">range</seealso> of
          <c><anno>Family1</anno></c>[i].</p>
        <pre>
1> <input>FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]),</input>
<input>F = sofs:family_range(FR),</input>
<input>sofs:to_external(F).</input>
[{a,[a,b,c]},{b,[]},{c,[d,e]}]</pre>
      </desc>
    </func>

    <func>
      <name name="family_specification" arity="2"/>
      <fsummary>Select a subset of a family using a predicate.</fsummary>
      <desc>
        <p>If <c><anno>Family1</anno></c> is
          a <seealso marker="#family">family</seealso>,
          then <c><anno>Family2</anno></c> is
          the <seealso marker="#restriction">restriction</seealso> of
          <c><anno>Family1</anno></c> to those elements i of the index set
          for which <c><anno>Fun</anno></c> applied
          to <c><anno>Family1</anno></c>[i] returns
          <c>true</c>. If <c><anno>Fun</anno></c> is a
          tuple <c>{external,&nbsp;Fun2}</c>, then <c>Fun2</c> is applied to
          the <seealso marker="#external_set">external set</seealso>
          of <c><anno>Family1</anno></c>[i], otherwise <c><anno>Fun</anno></c>
           is applied to <c><anno>Family1</anno></c>[i].</p>
        <pre>
1> <input>F1 = sofs:family([{a,[1,2,3]},{b,[1,2]},{c,[1]}]),</input>
<input>SpecFun = fun(S) -> sofs:no_elements(S) =:= 2 end,</input>
<input>F2 = sofs:family_specification(SpecFun, F1),</input>
<input>sofs:to_external(F2).</input>
[{b,[1,2]}]</pre>
      </desc>
    </func>

    <func>
      <name name="family_to_digraph" arity="1"/>
      <name name="family_to_digraph" arity="2"/>
      <fsummary>Create a directed graph from a family.</fsummary>
      <desc>
        <p>Creates a directed graph from
          <seealso marker="#family">family</seealso> <c><anno>Family</anno></c>.
          For each pair (a,&nbsp;{b[1],&nbsp;...,&nbsp;b[n]})
          of <c><anno>Family</anno></c>, vertex
          a and the edges (a,&nbsp;b[i]) for
          1&nbsp;&lt;=&nbsp;i&nbsp;&lt;=&nbsp;n are added to a newly
          created directed graph.</p>
        <p>If no graph type is specified, <seealso marker="digraph#new/0">
          <c>digraph:new/0</c></seealso> is used for
          creating the directed graph, otherwise argument
          <c><anno>GraphType</anno></c> is passed on as second argument to
          <seealso marker="digraph#new/1"><c>digraph:new/1</c></seealso>.</p>
        <p>It F is a family, it holds that F is a subset of
          <c>digraph_to_family(family_to_digraph(F),&nbsp;type(F))</c>.
          Equality holds if <c>union_of_family(F)</c> is a subset of
          <c>domain(F)</c>.</p>
        <p>Creating a cycle in an acyclic graph exits the process with
          a <c>cyclic</c> message.</p>
      </desc>
    </func>

    <func>
      <name name="family_to_relation" arity="1"/>
      <fsummary>Create a binary relation from a family.</fsummary>
      <desc>
        <p>If <c><anno>Family</anno></c> is
          a <seealso marker="#family">family</seealso>,
          then <c><anno>BinRel</anno></c> is the binary relation containing
          all pairs (i,&nbsp;x) such that i belongs to the index set
          of <c><anno>Family</anno></c> and x belongs
          to <c><anno>Family</anno></c>[i].</p>
        <pre>
1> <input>F = sofs:family([{a,[]}, {b,[1]}, {c,[2,3]}]),</input>
<input>R = sofs:family_to_relation(F),</input>
<input>sofs:to_external(R).</input>
[{b,1},{c,2},{c,3}]</pre>
      </desc>
    </func>

    <func>
      <name name="family_union" arity="1"/>
      <fsummary>Return the union of a family of sets of sets.</fsummary>
      <desc>
        <p>If <c><anno>Family1</anno></c> is
          a <seealso marker="#family">family</seealso>
          and <c><anno>Family1</anno></c>[i] is a set of sets for each i in
          the index set of <c><anno>Family1</anno></c>,
          then <c><anno>Family2</anno></c> is the family with the same index
          set as <c><anno>Family1</anno></c> such
          that <c><anno>Family2</anno></c>[i] is
          the <seealso marker="#union_n">union</seealso> of
          <c><anno>Family1</anno></c>[i].</p>
        <pre>
1> <input>F1 = sofs:from_term([{a,[[1,2],[2,3]]},{b,[[]]}]),</input>
<input>F2 = sofs:family_union(F1),</input>
<input>sofs:to_external(F2).</input>
[{a,[1,2,3]},{b,[]}]</pre>
        <p><c>family_union(F)</c> is equivalent to
          <c>family_projection(fun sofs:union/1,&nbsp;F)</c>.</p>
      </desc>
    </func>

    <func>
      <name name="family_union" arity="2"/>
      <fsummary>Return the union of two families.</fsummary>
      <desc>
        <p>If <c><anno>Family1</anno></c> and <c><anno>Family2</anno></c>
          are <seealso marker="#family">families</seealso>,
          then <c><anno>Family3</anno></c> is the family such that the index
          set is the union of <c><anno>Family1</anno></c>:s
          and <c><anno>Family2</anno></c>:s index sets,
          and <c><anno>Family3</anno></c>[i] is the union
          of <c><anno>Family1</anno></c>[i] and <c><anno>Family2</anno></c>[i]
          if both map i, otherwise <c><anno>Family1</anno></c>[i]
          or <c><anno>Family2</anno></c>[i].</p>
        <pre>
1> <input>F1 = sofs:family([{a,[1,2]},{b,[3,4]},{c,[5,6]}]),</input>
<input>F2 = sofs:family([{b,[4,5]},{c,[7,8]},{d,[9,10]}]),</input>
<input>F3 = sofs:family_union(F1, F2),</input>
<input>sofs:to_external(F3).</input>
[{a,[1,2]},{b,[3,4,5]},{c,[5,6,7,8]},{d,[9,10]}]</pre>
      </desc>
    </func>

    <func>
      <name name="field" arity="1"/>
      <fsummary>Return the field of a binary relation.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#field">field</seealso> of the
          binary relation <c><anno>BinRel</anno></c>.</p>
        <pre>
1> <input>R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]),</input>
<input>S = sofs:field(R),</input>
<input>sofs:to_external(S).</input>
[1,2,a,b,c]</pre>
        <p><c>field(R)</c> is equivalent
          to <c>union(domain(R), range(R))</c>.</p>
      </desc>
    </func>

    <func>
      <name name="from_external" arity="2"/>
      <fsummary>Create a set.</fsummary>
      <desc>
        <p>Creates a set from the <seealso marker="#external_set">external 
          set</seealso> <c><anno>ExternalSet</anno></c> and
          the <seealso marker="#type">type</seealso> <c><anno>Type</anno></c>.
          It is assumed that <c><anno>Type</anno></c> is
          a <seealso marker="#valid_type">valid
          type</seealso> of <c><anno>ExternalSet</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="from_sets" arity="1" clause_i="1"/>
      <fsummary>Create a set out of a list of sets.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#sets_definition">unordered
          set</seealso> containing the sets of list
          <c><anno>ListOfSets</anno></c>.</p>
        <pre>
1> <input>S1 = sofs:relation([{a,1},{b,2}]),</input>
<input>S2 = sofs:relation([{x,3},{y,4}]),</input>
<input>S = sofs:from_sets([S1,S2]),</input>
<input>sofs:to_external(S).</input>
[[{a,1},{b,2}],[{x,3},{y,4}]]</pre>
      </desc>
    </func>

    <func>
      <name name="from_sets" arity="1" clause_i="2"/>
      <fsummary>Create an ordered set out of a tuple of sets.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#sets_definition">ordered
          set</seealso> containing the sets of the non-empty tuple
          <c><anno>TupleOfSets</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="from_term" arity="1"/>
      <name name="from_term" arity="2"/>
      <fsummary>Create a set.</fsummary>
      <desc>
        <p><marker id="from_term"></marker>Creates an element
          of <seealso marker="#sets_definition">Sets</seealso> by
          traversing term <c><anno>Term</anno></c>, sorting lists,
          removing duplicates, and
          deriving or verifying a <seealso marker="#valid_type">valid
          type</seealso> for the so obtained external set. An
          explicitly specified <seealso marker="#type">type</seealso>
          <c><anno>Type</anno></c>
          can be used to limit the depth of the traversal; an atomic
          type stops the traversal, as shown by the following example
          where <c>"foo"</c> and <c>{"foo"}</c> are left unmodified:</p>
        <pre>
1> <input>S = sofs:from_term([{{"foo"},[1,1]},{"foo",[2,2]}],
[{atom,[atom]}]),</input>
<input>sofs:to_external(S).</input>
[{{"foo"},[1]},{"foo",[2]}]</pre>
        <p><c>from_term</c> can be used for creating atomic or ordered
          sets. The only purpose of such a set is that of later
          building unordered sets, as all functions in this module
          that <em>do</em> anything operate on unordered sets.
          Creating unordered sets from a collection of ordered sets
          can be the way to go if the ordered sets are big and one
          does not want to waste heap by rebuilding the elements of
          the unordered set. The following example shows that a set can be
          built "layer by layer":</p>
        <pre>
1> <input>A = sofs:from_term(a),</input>
<input>S = sofs:set([1,2,3]),</input>
<input>P1 = sofs:from_sets({A,S}),</input>
<input>P2 = sofs:from_term({b,[6,5,4]}),</input>
<input>Ss = sofs:from_sets([P1,P2]),</input>
<input>sofs:to_external(Ss).</input>
[{a,[1,2,3]},{b,[4,5,6]}]</pre>
        <p>Other functions that create sets are
          <seealso marker="#from_external/2"><c>from_external/2</c></seealso>
          and <seealso marker="#from_sets/1"><c>from_sets/1</c></seealso>.
          Special cases of <c>from_term/2</c> are
          <seealso marker="#a_function/1"><c>a_function/1,2</c></seealso>,
          <seealso marker="#empty_set/0"><c>empty_set/0</c></seealso>,
          <seealso marker="#family/1"><c>family/1,2</c></seealso>,
          <seealso marker="#relation/1"><c>relation/1,2</c></seealso>, and
          <seealso marker="#set/1"><c>set/1,2</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="image" arity="2"/>
      <fsummary>Return the image of a set under a binary relation.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#image">image</seealso> of
          set <c><anno>Set1</anno></c> under the binary
          relation <c><anno>BinRel</anno></c>.</p>
        <pre>
1> <input>R = sofs:relation([{1,a},{2,b},{2,c},{3,d}]),</input>
<input>S1 = sofs:set([1,2]),</input>
<input>S2 = sofs:image(R, S1),</input>
<input>sofs:to_external(S2).</input>
[a,b,c]</pre>
      </desc>
    </func>

    <func>
      <name name="intersection" arity="1"/>
      <fsummary>Return the intersection of a set of sets.</fsummary>
      <desc>
        <p>Returns
          the <seealso marker="#intersection_n">intersection</seealso> of
          the set of sets <c><anno>SetOfSets</anno></c>.</p>
        <p>Intersecting an empty set of sets exits the process with a
          <c>badarg</c> message.</p>
      </desc>
    </func>

    <func>
      <name name="intersection" arity="2"/>
      <fsummary>Return the intersection of two sets.</fsummary>
      <desc>
        <p>Returns
          the <seealso marker="#intersection">intersection</seealso> of
          <c><anno>Set1</anno></c> and <c><anno>Set2</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="intersection_of_family" arity="1"/>
      <fsummary>Return the intersection of a family.</fsummary>
      <desc>
        <p>Returns the intersection of
          <seealso marker="#family">family</seealso> <c><anno>Family</anno></c>.
        </p>
        <p>Intersecting an empty family exits the process with a
          <c>badarg</c> message.</p>
        <pre>
1> <input>F = sofs:family([{a,[0,2,4]},{b,[0,1,2]},{c,[2,3]}]),</input>
<input>S = sofs:intersection_of_family(F),</input>
<input>sofs:to_external(S).</input>
[2]</pre>
      </desc>
    </func>

    <func>
      <name name="inverse" arity="1"/>
      <fsummary>Return the inverse of a function.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#inverse">inverse</seealso>
          of function <c><anno>Function1</anno></c>.</p>
        <pre>
1> <input>R1 = sofs:relation([{1,a},{2,b},{3,c}]),</input>
<input>R2 = sofs:inverse(R1),</input>
<input>sofs:to_external(R2).</input>
[{a,1},{b,2},{c,3}]</pre>
      </desc>
    </func>

    <func>
      <name name="inverse_image" arity="2"/>
      <fsummary>Return the inverse image of a set under
        a binary relation.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#inverse_image">inverse
          image</seealso> of <c><anno>Set1</anno></c> under the binary
          relation <c><anno>BinRel</anno></c>.</p>
        <pre>
1> <input>R = sofs:relation([{1,a},{2,b},{2,c},{3,d}]),</input>
<input>S1 = sofs:set([c,d,e]),</input>
<input>S2 = sofs:inverse_image(R, S1),</input>
<input>sofs:to_external(S2).</input>
[2,3]</pre>
      </desc>
    </func>

    <func>
      <name name="is_a_function" arity="1"/>
      <fsummary>Test for a function.</fsummary>
      <desc>
        <p>Returns <c>true</c> if the binary relation <c><anno>BinRel</anno></c>
          is a <seealso marker="#function">function</seealso> or the
          untyped empty set, otherwise <c>false</c>.</p>
      </desc>
    </func>

    <func>
      <name name="is_disjoint" arity="2"/>
      <fsummary>Test for disjoint sets.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Set1</anno></c>
          and <c><anno>Set2</anno></c>
          are <seealso marker="#disjoint">disjoint</seealso>, otherwise
          <c>false</c>.</p>
      </desc>
    </func>

    <func>
      <name name="is_empty_set" arity="1"/>
      <fsummary>Test for an empty set.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>AnySet</anno></c> is an empty
          unordered set, otherwise <c>false</c>.</p>
      </desc>
    </func>

    <func>
      <name name="is_equal" arity="2"/>
      <fsummary>Test two sets for equality.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>AnySet1</anno></c>
          and <c><anno>AnySet2</anno></c>
          are <seealso marker="#equal">equal</seealso>, otherwise
          <c>false</c>. The following  example shows that <c>==/2</c> is
          used when comparing sets for equality:</p>
        <pre>
1> <input>S1 = sofs:set([1.0]),</input>
<input>S2 = sofs:set([1]),</input>
<input>sofs:is_equal(S1, S2).</input>
true</pre>
      </desc>
    </func>

    <func>
      <name name="is_set" arity="1"/>
      <fsummary>Test for an unordered set.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>AnySet</anno></c> is
          an <seealso marker="#sets_definition">unordered set</seealso>, and
          <c>false</c> if <c><anno>AnySet</anno></c> is an ordered set or an
          atomic set.</p>
      </desc>
    </func>

    <func>
      <name name="is_sofs_set" arity="1"/>
      <fsummary>Test for an unordered set.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is
          an <seealso marker="#sets_definition">unordered set</seealso>, an
          ordered set, or an atomic set, otherwise <c>false</c>.</p>
      </desc>
    </func>

    <func>
      <name name="is_subset" arity="2"/>
      <fsummary>Test two sets for subset.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Set1</anno></c> is
          a <seealso marker="#subset">subset</seealso>
          of <c><anno>Set2</anno></c>, otherwise <c>false</c>.</p>
      </desc>
    </func>

    <func>
      <name name="is_type" arity="1"/>
      <fsummary>Test for a type.</fsummary>
      <desc>
        <p>Returns <c>true</c> if term <c><anno>Term</anno></c> is
          a <seealso marker="#type">type</seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="join" arity="4"/>
      <fsummary>Return the join of two relations.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#natural_join">natural
          join</seealso> of the relations <c><anno>Relation1</anno></c>
          and <c><anno>Relation2</anno></c> on coordinates <c><anno>I</anno></c>
          and <c><anno>J</anno></c>.</p>
        <pre>
1> <input>R1 = sofs:relation([{a,x,1},{b,y,2}]),</input>
<input>R2 = sofs:relation([{1,f,g},{1,h,i},{2,3,4}]),</input>
<input>J = sofs:join(R1, 3, R2, 1),</input>
<input>sofs:to_external(J).</input>
[{a,x,1,f,g},{a,x,1,h,i},{b,y,2,3,4}]</pre>
      </desc>
    </func>

    <func>
      <name name="multiple_relative_product" arity="2"/>
      <fsummary>Return the multiple relative product of a tuple of binary
        relations and a relation.</fsummary>
      <desc>
        <p>If <c><anno>TupleOfBinRels</anno></c> is a non-empty tuple
          {R[1],&nbsp;...,&nbsp;R[n]} of binary relations
          and <c><anno>BinRel1</anno></c> is a binary relation,
          then <c><anno>BinRel2</anno></c> is
          the <seealso marker="#multiple_relative_product">multiple relative
          product</seealso> of the ordered set
          (R[i],&nbsp;...,&nbsp;R[n]) and <c><anno>BinRel1</anno></c>.</p>
        <pre>
1> <input>Ri = sofs:relation([{a,1},{b,2},{c,3}]),</input>
<input>R = sofs:relation([{a,b},{b,c},{c,a}]),</input>
<input>MP = sofs:multiple_relative_product({Ri, Ri}, R),</input>
<input>sofs:to_external(sofs:range(MP)).</input>
[{1,2},{2,3},{3,1}]</pre>
      </desc>
    </func>

    <func>
      <name name="no_elements" arity="1"/>
      <fsummary>Return the number of elements of a set.</fsummary>
      <desc>
        <p>Returns the number of elements of the ordered or unordered
          set <c><anno>ASet</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="partition" arity="1"/>
      <fsummary>Return the coarsest partition given a set of sets.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#partition">partition</seealso> of
          the union of the set of sets <c><anno>SetOfSets</anno></c> such that
          two elements are considered equal if they belong to the same
          elements of <c><anno>SetOfSets</anno></c>.</p>
        <pre>
1> <input>Sets1 = sofs:from_term([[a,b,c],[d,e,f],[g,h,i]]),</input>
<input>Sets2 = sofs:from_term([[b,c,d],[e,f,g],[h,i,j]]),</input>
<input>P = sofs:partition(sofs:union(Sets1, Sets2)),</input>
<input>sofs:to_external(P).</input>
[[a],[b,c],[d],[e,f],[g],[h,i],[j]]</pre>
      </desc>
    </func>

    <func>
      <name name="partition" arity="2"/>
      <fsummary>Return a partition of a set.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#partition">partition</seealso> of
          <c><anno>Set</anno></c> such that two elements are considered equal
          if the results of applying <c><anno>SetFun</anno></c> are equal.</p>
        <pre>
1> <input>Ss = sofs:from_term([[a],[b],[c,d],[e,f]]),</input>
<input>SetFun = fun(S) -> sofs:from_term(sofs:no_elements(S)) end,</input>
<input>P = sofs:partition(SetFun, Ss),</input>
<input>sofs:to_external(P).</input>
[[[a],[b]],[[c,d],[e,f]]]</pre>
      </desc>
    </func>

    <func>
      <name name="partition" arity="3"/>
      <fsummary>Return a partition of a set.</fsummary>
      <desc>
        <p>Returns a pair of sets that, regarded as constituting a
          set, forms a <seealso marker="#partition">partition</seealso> of
          <c><anno>Set1</anno></c>. If the
          result of applying <c><anno>SetFun</anno></c> to an element of
          <c><anno>Set1</anno></c> gives an element in <c><anno>Set2</anno></c>,
          the element belongs to <c><anno>Set3</anno></c>, otherwise the
          element belongs to <c><anno>Set4</anno></c>.</p>
        <pre>
1> <input>R1 = sofs:relation([{1,a},{2,b},{3,c}]),</input>
<input>S = sofs:set([2,4,6]),</input>
<input>{R2,R3} = sofs:partition(1, R1, S),</input>
<input>{sofs:to_external(R2),sofs:to_external(R3)}.</input>
{[{2,b}],[{1,a},{3,c}]}</pre>
        <p><c>partition(F,&nbsp;S1,&nbsp;S2)</c> is equivalent to
          <c>{restriction(F,&nbsp;S1,&nbsp;S2),
          drestriction(F,&nbsp;S1,&nbsp;S2)}</c>.</p>
      </desc>
    </func>

    <func>
      <name name="partition_family" arity="2"/>
      <fsummary>Return a family indexing a partition.</fsummary>
      <desc>
        <p>Returns <seealso marker="#family">family</seealso>
          <c><anno>Family</anno></c> where the indexed set is
          a <seealso marker="#partition">partition</seealso>
          of <c><anno>Set</anno></c> such that two elements are considered
          equal if the results of applying <c><anno>SetFun</anno></c> are the
          same value i. This i is the index that <c><anno>Family</anno></c>
          maps onto the <seealso marker="#equivalence_class">equivalence
          class</seealso>.</p>
        <pre>
1> <input>S = sofs:relation([{a,a,a,a},{a,a,b,b},{a,b,b,b}]),</input>
<input>SetFun = {external, fun({A,_,C,_}) -> {A,C} end},</input>
<input>F = sofs:partition_family(SetFun, S),</input>
<input>sofs:to_external(F).</input>
[{{a,a},[{a,a,a,a}]},{{a,b},[{a,a,b,b},{a,b,b,b}]}]</pre>
      </desc>
    </func>

    <func>
      <name name="product" arity="1"/>
      <fsummary>Return the Cartesian product of a tuple of sets.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#Cartesian_product_tuple">Cartesian
          product</seealso> of the non-empty tuple of sets
          <c><anno>TupleOfSets</anno></c>. If (x[1],&nbsp;...,&nbsp;x[n]) is
          an element of the n-ary relation <c><anno>Relation</anno></c>, then
          x[i] is drawn from element i of <c><anno>TupleOfSets</anno></c>.</p>
        <pre>
1> <input>S1 = sofs:set([a,b]),</input>
<input>S2 = sofs:set([1,2]),</input>
<input>S3 = sofs:set([x,y]),</input>
<input>P3 = sofs:product({S1,S2,S3}),</input>
<input>sofs:to_external(P3).</input>
[{a,1,x},{a,1,y},{a,2,x},{a,2,y},{b,1,x},{b,1,y},{b,2,x},{b,2,y}]</pre>
      </desc>
    </func>

    <func>
      <name name="product" arity="2"/>
      <fsummary>Return the Cartesian product of two sets.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#Cartesian_product">Cartesian
          product</seealso> of <c><anno>Set1</anno></c>
          and <c><anno>Set2</anno></c>.</p>
        <pre>
1> <input>S1 = sofs:set([1,2]),</input>
<input>S2 = sofs:set([a,b]),</input>
<input>R = sofs:product(S1, S2),</input>
<input>sofs:to_external(R).</input>
[{1,a},{1,b},{2,a},{2,b}]</pre>
        <p><c>product(S1,&nbsp;S2)</c> is equivalent to
          <c>product({S1,&nbsp;S2})</c>.</p>
      </desc>
    </func>

    <func>
      <name name="projection" arity="2"/>
      <fsummary>Return a set of substituted elements.</fsummary>
      <desc>
        <p>Returns the set created by substituting each element of
          <c><anno>Set1</anno></c> by the result of
          applying <c><anno>SetFun</anno></c> to the element.</p>
        <p>If <c><anno>SetFun</anno></c> is a number i&nbsp;&gt;=&nbsp;1 and
          <c><anno>Set1</anno></c> is a relation, then the returned set is
          the <seealso marker="#projection">projection</seealso> of
          <c><anno>Set1</anno></c> onto coordinate i.</p>
        <pre>
1> <input>S1 = sofs:from_term([{1,a},{2,b},{3,a}]),</input>
<input>S2 = sofs:projection(2, S1),</input>
<input>sofs:to_external(S2).</input>
[a,b]</pre>
      </desc>
    </func>

    <func>
      <name name="range" arity="1"/>
      <fsummary>Return the range of a binary relation.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#range">range</seealso> of the
          binary relation <c><anno>BinRel</anno></c>.</p>
        <pre>
1> <input>R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]),</input>
<input>S = sofs:range(R),</input>
<input>sofs:to_external(S).</input>
[a,b,c]</pre>
      </desc>
    </func>

    <func>
      <name name="relation" arity="1"/>
      <name name="relation" arity="2"/>
      <fsummary>Create a relation.</fsummary>
      <desc>
        <p>Creates a <seealso marker="#relation">relation</seealso>.
          <c>relation(R,&nbsp;T)</c> is equivalent to
          <c>from_term(R,&nbsp;T)</c>, if T is
          a <seealso marker="#type">type</seealso> and the result is a
          relation. If <c><anno>Type</anno></c> is an integer N, then
          <c>[{atom,&nbsp;...,&nbsp;atom}])</c>, where the tuple size
          is N, is used as type of the relation. If no type is
          explicitly specified, the size of the first tuple of
          <c><anno>Tuples</anno></c> is
          used if there is such a tuple. <c>relation([])</c> is
          equivalent to <c>relation([],&nbsp;2)</c>.</p>
      </desc>
    </func>

    <func>
      <name name="relation_to_family" arity="1"/>
      <fsummary>Create a family from a binary relation.</fsummary>
      <desc>
        <p>Returns <seealso marker="#family">family</seealso>
          <c><anno>Family</anno></c> such that the index set is equal to
          the <seealso marker="#domain">domain</seealso> of the binary
          relation <c><anno>BinRel</anno></c>, and <c><anno>Family</anno></c>[i]
          is the <seealso marker="#image">image</seealso> of the set of i
          under <c><anno>BinRel</anno></c>.</p>
        <pre>
1> <input>R = sofs:relation([{b,1},{c,2},{c,3}]),</input>
<input>F = sofs:relation_to_family(R),</input>
<input>sofs:to_external(F).</input>
[{b,[1]},{c,[2,3]}]</pre>
      </desc>
    </func>

    <func>
      <name name="relative_product" arity="1"/>
      <name name="relative_product" arity="2" clause_i="1"/>
      <fsummary>Return the relative product of a list of binary relations
        and a binary relation.</fsummary>
      <desc>
        <p>If <c><anno>ListOfBinRels</anno></c> is a non-empty list
          [R[1],&nbsp;...,&nbsp;R[n]] of binary relations and
          <c><anno>BinRel1</anno></c>
          is a binary relation, then <c><anno>BinRel2</anno></c> is the
          <seealso marker="#tuple_relative_product">relative product</seealso>
          of the ordered set (R[i],&nbsp;...,&nbsp;R[n]) and
          <c><anno>BinRel1</anno></c>.</p>
        <p>If <c><anno>BinRel1</anno></c> is omitted, the relation of equality
          between the elements of
          the <seealso marker="#Cartesian_product_tuple">Cartesian
          product</seealso> of the ranges of R[i],
          range&nbsp;R[1]&nbsp;&times;&nbsp;...&nbsp;&times;&nbsp;range&nbsp;R[n],
          is used instead (intuitively, nothing is "lost").</p>
        <pre>
1> <input>TR = sofs:relation([{1,a},{1,aa},{2,b}]),</input>
<input>R1 = sofs:relation([{1,u},{2,v},{3,c}]),</input>
<input>R2 = sofs:relative_product([TR, R1]),</input>
<input>sofs:to_external(R2).</input>
[{1,{a,u}},{1,{aa,u}},{2,{b,v}}]</pre>
        <p>Notice that <c>relative_product([R1],&nbsp;R2)</c> is
          different from <c>relative_product(R1,&nbsp;R2)</c>; the
          list of one element is not identified with the element itself.</p>
      </desc>
    </func>

    <func>
      <name name="relative_product" arity="2" clause_i="2"/>
      <fsummary>Return the relative product of
        two binary relations.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#relative_product">relative
          product</seealso> of the binary relations <c><anno>BinRel1</anno></c>
          and <c><anno>BinRel2</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="relative_product1" arity="2"/>
      <fsummary>Return the relative_product of
        two binary relations.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#relative_product">relative
          product</seealso> of
          the <seealso marker="#converse">converse</seealso> of the
          binary relation <c><anno>BinRel1</anno></c> and the binary
          relation <c><anno>BinRel2</anno></c>.</p>
        <pre>
1> <input>R1 = sofs:relation([{1,a},{1,aa},{2,b}]),</input>
<input>R2 = sofs:relation([{1,u},{2,v},{3,c}]),</input>
<input>R3 = sofs:relative_product1(R1, R2),</input>
<input>sofs:to_external(R3).</input>
[{a,u},{aa,u},{b,v}]</pre>
        <p><c>relative_product1(R1,&nbsp;R2)</c> is equivalent to
          <c>relative_product(converse(R1),&nbsp;R2)</c>.</p>
      </desc>
    </func>

    <func>
      <name name="restriction" arity="2"/>
      <fsummary>Return a restriction of a binary relation.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#restriction">restriction</seealso> of
          the binary relation <c><anno>BinRel1</anno></c>
          to <c><anno>Set</anno></c>.</p>
        <pre>
1> <input>R1 = sofs:relation([{1,a},{2,b},{3,c}]),</input>
<input>S = sofs:set([1,2,4]),</input>
<input>R2 = sofs:restriction(R1, S),</input>
<input>sofs:to_external(R2).</input>
[{1,a},{2,b}]</pre>
      </desc>
    </func>

    <func>
      <name name="restriction" arity="3"/>
      <fsummary>Return a restriction of a set.</fsummary>
      <desc>
        <p>Returns a subset of <c><anno>Set1</anno></c> containing those
          elements that gives an element in <c><anno>Set2</anno></c> as the
          result of applying <c><anno>SetFun</anno></c>.</p>
        <pre>
1> <input>S1 = sofs:relation([{1,a},{2,b},{3,c}]),</input>
<input>S2 = sofs:set([b,c,d]),</input>
<input>S3 = sofs:restriction(2, S1, S2),</input>
<input>sofs:to_external(S3).</input>
[{2,b},{3,c}]</pre>
      </desc>
    </func>

    <func>
      <name name="set" arity="1"/>
      <name name="set" arity="2"/>
      <fsummary>Create a set of atoms or any type of sets.</fsummary>
      <desc>
        <p>Creates an <seealso marker="#sets_definition">unordered
          set</seealso>. <c>set(L,&nbsp;T)</c> is equivalent to
          <c>from_term(L,&nbsp;T)</c>, if the result is an unordered
          set. If no <seealso marker="#type">type</seealso> is
          explicitly specified, <c>[atom]</c> is used as the set type.</p>
      </desc>
    </func>

    <func>
      <name name="specification" arity="2"/>
      <fsummary>Select a subset using a predicate.</fsummary>
      <desc>
        <p>Returns the set containing every element
          of <c><anno>Set1</anno></c> for which <c><anno>Fun</anno></c>
          returns <c>true</c>. If <c><anno>Fun</anno></c> is a tuple
          <c>{external,&nbsp;Fun2}</c>, <c>Fun2</c> is applied to the
          <seealso marker="#external_set">external set</seealso> of
          each element, otherwise <c><anno>Fun</anno></c> is applied to each
          element.</p>
        <pre>
1> <input>R1 = sofs:relation([{a,1},{b,2}]),</input>
<input>R2 = sofs:relation([{x,1},{x,2},{y,3}]),</input>
<input>S1 = sofs:from_sets([R1,R2]),</input>
<input>S2 = sofs:specification(fun sofs:is_a_function/1, S1),</input>
<input>sofs:to_external(S2).</input>
[[{a,1},{b,2}]]</pre>
      </desc>
    </func>

    <func>
      <name name="strict_relation" arity="1"/>
      <fsummary>Return the strict relation corresponding to
        a given relation.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#strict_relation">strict
          relation</seealso> corresponding to the binary
          relation <c><anno>BinRel1</anno></c>.</p>
        <pre>
1> <input>R1 = sofs:relation([{1,1},{1,2},{2,1},{2,2}]),</input>
<input>R2 = sofs:strict_relation(R1),</input>
<input>sofs:to_external(R2).</input>
[{1,2},{2,1}]</pre>
      </desc>
    </func>

    <func>
      <name name="substitution" arity="2"/>
      <fsummary>Return a function with a given set as domain.</fsummary>
      <desc>
        <p>Returns a function, the domain of which
          is <c><anno>Set1</anno></c>. The value of an element of the domain
          is the result of applying <c><anno>SetFun</anno></c> to the
          element.</p>
        <pre>
1> <input>L = [{a,1},{b,2}].</input>
[{a,1},{b,2}]
2> <input>sofs:to_external(sofs:projection(1,sofs:relation(L))).</input>
[a,b]
3> <input>sofs:to_external(sofs:substitution(1,sofs:relation(L))).</input>
[{{a,1},a},{{b,2},b}]
4> <input>SetFun = {external, fun({A,_}=E) -> {E,A} end},</input>
<input>sofs:to_external(sofs:projection(SetFun,sofs:relation(L))).</input>
[{{a,1},a},{{b,2},b}]</pre>
        <p>The relation of equality between the elements of {a,b,c}:</p>
        <pre>
1> <input>I = sofs:substitution(fun(A) -> A end, sofs:set([a,b,c])),</input>
<input>sofs:to_external(I).</input>
[{a,a},{b,b},{c,c}]</pre>
        <p>Let <c>SetOfSets</c> be a set of sets and <c>BinRel</c> a binary
          relation. The function that maps each element <c>Set</c> of
          <c>SetOfSets</c> onto the <seealso marker="#image">image</seealso>
          of <c>Set</c> under <c>BinRel</c> is returned by the following
          function:</p>
        <pre>
images(SetOfSets, BinRel) ->
   Fun = fun(Set) -> sofs:image(BinRel, Set) end,
   sofs:substitution(Fun, SetOfSets).</pre>
        <p>External unordered sets are represented as sorted lists. So,
          creating the image of a set under a relation R can traverse all
          elements of R (to that comes the sorting of results, the
          image). In <seealso marker="#image/2"><c>image/2</c></seealso>,
          <c>BinRel</c> is traversed once
          for each element of <c>SetOfSets</c>, which can take too long. The
          following efficient function can be used instead under the
          assumption that the image of each element of <c>SetOfSets</c> under
          <c>BinRel</c> is non-empty:</p>
        <pre>
images2(SetOfSets, BinRel) ->
   CR = sofs:canonical_relation(SetOfSets),
   R = sofs:relative_product1(CR, BinRel),
   sofs:relation_to_family(R).</pre>
      </desc>
    </func>

    <func>
      <name name="symdiff" arity="2"/>
      <fsummary>Return the symmetric difference of two sets.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#symmetric_difference">symmetric
          difference</seealso> (or the Boolean sum)
          of <c><anno>Set1</anno></c> and <c><anno>Set2</anno></c>.</p>
        <pre>
1> <input>S1 = sofs:set([1,2,3]),</input>
<input>S2 = sofs:set([2,3,4]),</input>
<input>P = sofs:symdiff(S1, S2),</input>
<input>sofs:to_external(P).</input>
[1,4]</pre>
      </desc>
    </func>

    <func>
      <name name="symmetric_partition" arity="2"/>
      <fsummary>Return a partition of two sets.</fsummary>
      <desc>
        <p>Returns a triple of sets:</p>
        <list type="bulleted">
          <item><c><anno>Set3</anno></c> contains the elements of
            <c><anno>Set1</anno></c> that do not belong to
            <c><anno>Set2</anno></c>.
          </item>
          <item><c><anno>Set4</anno></c> contains the elements of
            <c><anno>Set1</anno></c> that belong to <c><anno>Set2</anno></c>.
          </item>
          <item><c><anno>Set5</anno></c> contains the elements of
            <c><anno>Set2</anno></c> that do not belong to
            <c><anno>Set1</anno></c>.
          </item>
        </list>
      </desc>
    </func>

    <func>
      <name name="to_external" arity="1"/>
      <fsummary>Return the elements of a set.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#external_set">external
          set</seealso> of an atomic, ordered, or unordered set.</p>
      </desc>
    </func>

    <func>
      <name name="to_sets" arity="1"/>
      <fsummary>Return a list or a tuple of the elements of a set.</fsummary>
      <desc>
        <p>Returns the elements of the ordered set <c><anno>ASet</anno></c>
          as a tuple of sets, and the elements of the unordered set
          <c><anno>ASet</anno></c> as a sorted list of sets without
          duplicates.</p>
      </desc>
    </func>

    <func>
      <name name="type" arity="1"/>
      <fsummary>Return the type of a set.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#type">type</seealso> of an
          atomic, ordered, or unordered set.</p>
      </desc>
    </func>

    <func>
      <name name="union" arity="1"/>
      <fsummary>Return the union of a set of sets.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#union_n">union</seealso> of the
          set of sets <c><anno>SetOfSets</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="union" arity="2"/>
      <fsummary>Return the union of two sets.</fsummary>
      <desc>
        <p>Returns the <seealso marker="#union">union</seealso> of
          <c><anno>Set1</anno></c> and <c><anno>Set2</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="union_of_family" arity="1"/>
      <fsummary>Return the union of a family.</fsummary>
      <desc>
        <p>Returns the union of <seealso marker="#family">family</seealso>
          <c><anno>Family</anno></c>.</p>
        <pre>
1> <input>F = sofs:family([{a,[0,2,4]},{b,[0,1,2]},{c,[2,3]}]),</input>
<input>S = sofs:union_of_family(F),</input>
<input>sofs:to_external(S).</input>
[0,1,2,3,4]</pre>
      </desc>
    </func>

    <func>
      <name name="weak_relation" arity="1"/>
      <fsummary>Return the weak relation corresponding to
        a given relation.</fsummary>
      <desc>
        <p>Returns a subset S of the <seealso marker="#weak_relation">weak
          relation</seealso> W
          corresponding to the binary relation <c><anno>BinRel1</anno></c>.
          Let F be the <seealso marker="#field">field</seealso> of
          <c><anno>BinRel1</anno></c>. The
          subset S is defined so that x S y if x W y for some x in F
          and for some y in F.</p>
        <pre>
1> <input>R1 = sofs:relation([{1,1},{1,2},{3,1}]),</input>
<input>R2 = sofs:weak_relation(R1),</input>
<input>sofs:to_external(R2).</input>
[{1,1},{1,2},{2,2},{3,1},{3,3}]</pre>
      </desc>
    </func>
  </funcs>

  <section>
    <title>See Also</title>
    <p><seealso marker="dict"><c>dict(3)</c></seealso>,
      <seealso marker="digraph"><c>digraph(3)</c></seealso>,
      <seealso marker="orddict"><c>orddict(3)</c></seealso>,
      <seealso marker="ordsets"><c>ordsets(3)</c></seealso>,
      <seealso marker="sets"><c>sets(3)</c></seealso></p>
  </section>
</erlref>

