<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>1996</year><year>2023</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>

    <title>gen_event</title>
    <prepared></prepared>
    <docno></docno>
    <date></date>
    <rev></rev>
  </header>
  <module since="">gen_event</module>
  <modulesummary>Generic event handling behavior.</modulesummary>
  <description>
    <p>This behavior module provides event handling functionality. It
      consists of a generic event manager process with any number of
      event handlers that are added and deleted dynamically.</p>

    <p>An event manager implemented using this module has a standard
      set of interface functions and includes functionality for tracing and
      error reporting. It also fits into an OTP supervision tree. For more
      information, see
      <seeguide marker="system/design_principles:events">OTP Design Principles</seeguide>.
    </p>

    <p>Each event handler is implemented as a callback module exporting
      a predefined set of functions. The relationship between the behavior
      functions and the callback functions is as follows:</p>

    <pre>
gen_event module                   Callback module
----------------                   ---------------
gen_event:start
gen_event:start_monitor
gen_event:start_link       ----->  -

gen_event:add_handler
gen_event:add_sup_handler  ----->  Module:init/1

gen_event:notify
gen_event:sync_notify      ----->  Module:handle_event/2

gen_event:send_request
gen_event:call             ----->  Module:handle_call/2

-                          ----->  Module:handle_info/2

gen_event:delete_handler   ----->  Module:terminate/2

gen_event:swap_handler
gen_event:swap_sup_handler ----->  Module1:terminate/2
                                   Module2:init/1

gen_event:which_handlers   ----->  -

gen_event:stop             ----->  Module:terminate/2

-                          ----->  Module:code_change/3</pre>

    <p>As each event handler is one callback module, an event manager
      has many callback modules that are added and deleted
      dynamically. <c>gen_event</c> is therefore more tolerant of callback
      module errors than the other behaviors. If a callback function for
      an installed event handler fails with <c>Reason</c>, or returns a
      bad value <c>Term</c>, the event manager does not fail. It deletes
      the event handler by calling callback function
      <seemfa marker="#Module:terminate/2"><c>Module:terminate/2</c></seemfa>,
      giving as argument
      <c>{error,{'EXIT',Reason}}</c> or <c>{error,Term}</c>, respectively.
      No other event handler is affected.</p>

    <p>A <c>gen_event</c> process handles system messages as described in
       <seeerl marker="sys"><c>sys(3)</c></seeerl>. The <c>sys</c> module
       can be used for debugging an event manager.</p>

    <p>Notice that an event manager <em>does</em> trap exit signals
      automatically.</p>

    <p>The <c>gen_event</c> process can go into hibernation 
      (see <seemfa marker="erts:erlang#hibernate/3">
      <c>erlang:hibernate/3</c></seemfa>) if a callback function in
      a handler module specifies <c>hibernate</c> in its return value.
      This can be useful if the server is expected to be idle for a long
      time. However, use this feature with care, as hibernation
      implies at least two garbage collections (when hibernating and
      shortly after waking up) and is not something you want to do
      between each event handled by a busy event manager.</p>

    <p>Notice that when multiple event handlers are
      invoked, it is sufficient that one single event handler returns a
      <c>hibernate</c> request for the whole event manager to go into
      hibernation.</p>

    <p>Unless otherwise stated, all functions in this module fail if
      the specified event manager does not exist or if bad arguments are
      specified.</p>

    <note><p>
      For some important information about distributed signals, see the
      <seeguide marker="system/reference_manual:processes#blocking-signaling-over-distribution">
        <i>Blocking Signaling Over Distribution</i></seeguide> section in the
      <i>Processes</i> chapter of the <i>Erlang Reference Manual</i>.
      Blocking signaling can, for example, cause call timeouts in
      <c>gen_event</c> to be significantly delayed.
    </p></note>
  </description>

  <datatypes>
    <datatype>
      <name name="handler"/>
    </datatype>

    <datatype>
      <name name="handler_args"/>
    </datatype>

    <datatype>
      <name name="add_handler_ret"/>
    </datatype>

    <datatype>
      <name name="del_handler_ret"/>
    </datatype>

    <datatype>
      <name name="emgr_ref"/>
    </datatype>    
    
    <datatype>
      <name name="request_id"/>
      <desc>
	<p>
	  An opaque request identifier. See
          <seemfa marker="#send_request/3"><c>send_request/3</c></seemfa>
	  for details.
	</p>
      </desc>
    </datatype>

    <datatype>
      <name name="request_id_collection"/>
      <desc>
        <p>
	  An opaque collection of request identifiers
          (<seetype marker="#request_id"><c>request_id()</c></seetype>)
	  where each request identifier can be associated with a label
          chosen by the user. For more information see
          <seemfa marker="#reqids_new/0"><c>reqids_new/0</c></seemfa>.
	</p>
      </desc>
    </datatype>

    <datatype>
      <name name="response_timeout"/>
      <desc>
        <p>
          Used to set a time limit on how long to wait for a response using
          either 
          <seemfa marker="#receive_response/2"><c>receive_response/2</c></seemfa>,
          <seemfa marker="#receive_response/3"><c>receive_response/3</c></seemfa>,
          <seemfa marker="#wait_response/2"><c>wait_response/2</c></seemfa>,
          or
          <seemfa marker="#wait_response/3"><c>wait_response/3</c></seemfa>.
          The time unit used is <c>millisecond</c>. Currently valid values:
        </p>
        <taglist>
          <tag><c>0..4294967295</c></tag>
          <item><p>
            Timeout relative to current time in milliseconds.
          </p></item>
          <tag><c>infinity</c></tag>
          <item><p>
            Infinite timeout. That is, the operation will never time out.
          </p></item>
          <tag><c>{abs, Timeout}</c></tag>
          <item><p>
            An absolute
            <seemfa marker="erts:erlang#monotonic_time/1">Erlang monotonic time</seemfa>
            timeout in milliseconds. That is, the operation will time out when
            <seemfa marker="erts:erlang#monotonic_time/1"><c>erlang:monotonic_time(millisecond)</c></seemfa>
            returns a value larger than or equal to <c>Timeout</c>. <c>Timeout</c>
            is not allowed to identify a time further into the future than <c>4294967295</c>
            milliseconds. Identifying the timeout using an absolute timeout value
            is especially handy when you have a deadline for responses corresponding
            to a complete collection of requests
            (<seetype marker="#request_id_collection"><c>request_id_collection()</c></seetype>)
,
            since you do not have to recalculate the relative time until the deadline
            over and over again.
	  </p></item>
        </taglist>
      </desc>
    </datatype>

    <datatype>
      <name name="format_status"/>
      <desc>
        <p>
          A map that describes the <c>gen_event</c> process status.
          The keys are:
        </p>
        <taglist>
          <tag><c>state</c></tag>
          <item>The internal state of the event handler.</item>
          <tag><c>message</c></tag>
          <item>The message that caused the event handler to terminate.</item>
          <tag><c>reason</c></tag>
          <item>The reason that caused the event handler to terminate.</item>
          <tag><c>log</c></tag>
          <item>
            The <seemfa marker="sys#log/2">sys log</seemfa> of the server.
          </item>
        </taglist>
        <p>
          New associations may be added into the status map
          without prior notice.
        </p>
      </desc>
    </datatype>
  </datatypes>

  <funcs>
    <func>
      <name since="">add_handler(EventMgrRef, Handler, Args) -> Result</name>
      <fsummary>Add an event handler to a generic event manager.</fsummary>
      <type>
        <v>EventMgrRef = Name | {Name,Node} | {global,GlobalName}
	| {via,Module,ViaName} | pid()</v>
        <v>&nbsp;Name = Node = atom()</v>
        <v>&nbsp;GlobalName = ViaName = term()</v>
        <v>Handler = Module | {Module,Id}</v>
        <v>&nbsp;Module = atom()</v>
        <v>&nbsp;Id = term()</v>
        <v>Args = term()</v>
        <v>Result = ok | {'EXIT',Reason} | term()</v>
        <v>&nbsp;Reason = term()</v>
      </type>
      <desc>
        <p>Adds a new event handler to event manager <c>EventMgrRef</c>.
          The event manager calls
          <seemfa marker="#Module:init/1"><c>Module:init/1</c></seemfa>
          to initiate the event handler and its internal state.</p>
        <p><c>EventMgrRef</c> can be any of the following:</p>
        <list type="bulleted">
          <item>The pid</item>
          <item><c>Name</c>, if the event manager is locally registered</item>
          <item><c>{Name,Node}</c>, if the event manager is locally
            registered at another node</item>
          <item><c>{global,GlobalName}</c>, if the event manager is globally
            registered</item>
          <item><c>{via,Module,ViaName}</c>, if the event manager is registered
            through an alternative process registry</item>
        </list>
        <p><c>Handler</c> is the name of the callback module <c>Module</c> or
          a tuple <c>{Module,Id}</c>, where <c>Id</c> is any term.
          The <c>{Module,Id}</c> representation makes it possible to
          identify a specific event handler when many event handlers
          use the same callback module.</p>
        <p><c>Args</c> is any term that is passed as the argument
          to <c>Module:init/1</c>.</p>
        <p>If <c>Module:init/1</c> returns a correct value indicating
          successful completion, the event manager adds the event
          handler and this function returns
          <c>ok</c>. If <c>Module:init/1</c> fails with <c>Reason</c> or
          returns <c>{error,Reason}</c>, the event handler is
          ignored and this function returns <c>{'EXIT',Reason}</c> or
          <c>{error,Reason}</c>, respectively.</p>
      </desc>
    </func>

    <func>
      <name since="">add_sup_handler(EventMgrRef, Handler, Args) -> Result</name>
      <fsummary>Add a supervised event handler to a generic event manager.
      </fsummary>
      <type>
        <v>EventMgrRef = Name | {Name,Node} | {global,GlobalName}
	| {via,Module,ViaName} | pid()</v>
        <v>&nbsp;Name = Node = atom()</v>
        <v>&nbsp;GlobalName = ViaName = term()</v>
        <v>Handler = Module | {Module,Id}</v>
        <v>&nbsp;Module = atom()</v>
        <v>&nbsp;Id = term()</v>
        <v>Args = term()</v>
        <v>Result = ok | {'EXIT',Reason} | term()</v>
        <v>&nbsp;Reason = term()</v>
      </type>
      <desc>
        <p>Adds a new event handler in the same way as
          <seemfa marker="#add_handler/3"><c>add_handler/3</c></seemfa>,
          but also supervises the connection by linking the event handler
          and the calling process.</p>
        <list type="bulleted">
          <item>If the calling process later terminates with <c>Reason</c>,
           the event manager deletes any supervised event handlers by calling
           <seemfa marker="#Module:terminate/2">
           <c>Module:terminate/2</c></seemfa>,
           then calls
           <seemfa marker="#Module:handle_info/2">
           <c>Module:handle_info/2</c></seemfa>
           for each remaining handler.
          </item>
          <item>
            <p>If the event handler is deleted later, the event manager
              sends a message <c>{gen_event_EXIT,Handler,Reason}</c> to
              the calling process. <c>Reason</c> is one of the following:</p>
            <list type="bulleted">
              <item>
                <p><c>normal</c>, if the event handler has been removed
                  because of a
                  call to <c>delete_handler/3</c>, or <c>remove_handler</c>
                  has been returned by a callback function (see below).</p>
              </item>
              <item>
                <p><c>shutdown</c>, if the event handler has been removed
                  because the event manager is terminating.</p>
              </item>
              <item>
                <p><c>{swapped,NewHandler,Pid}</c>, if the process <c>Pid</c>
                  has replaced the event handler with another event handler
                  <c>NewHandler</c> using a call to
                  <seemfa marker="#swap_handler/3">
                  <c>swap_handler/3</c></seemfa> or
                  <seemfa marker="#swap_sup_handler/3">
                  <c>swap_sup_handler/3</c></seemfa>.</p>
              </item>
              <item>
                <p>A term, if the event handler is removed because of an error.
                  Which term depends on the error.</p></item>
            </list>
          </item>
        </list>
        <p>For a description of the arguments and return values, see
          <seemfa marker="#add_handler/3"><c>add_handler/3</c></seemfa>.</p>
      </desc>
    </func>

    <func>
      <name since="">call(EventMgrRef, Handler, Request) -> Result</name>
      <name since="">call(EventMgrRef, Handler, Request, Timeout) -> Result</name>
      <fsummary>Make a synchronous call to a generic event manager.</fsummary>
      <type>
        <v>EventMgrRef = Name | {Name,Node} | {global,GlobalName}
	| {via,Module,ViaName} | pid()</v>
        <v>&nbsp;Name = Node = atom()</v>
        <v>&nbsp;GlobalName = ViaName = term()</v>
        <v>Handler = Module | {Module,Id}</v>
        <v>&nbsp;Module = atom()</v>
        <v>&nbsp;Id = term()</v>
        <v>Request = term()</v>
        <v>Timeout = int()>0 | infinity</v>
        <v>Result = Reply | {error,Error}</v>
        <v>&nbsp;Reply = term()</v>
        <v>&nbsp;Error = bad_module | {'EXIT',Reason} | term()</v>
        <v>&nbsp;&nbsp;Reason = term()</v>
      </type>
      <desc>
        <p>Makes a synchronous call to event handler <c>Handler</c>
          installed in event manager <c>EventMgrRef</c> by sending a
          request and waiting until a reply arrives or a time-out occurs.
          The event manager calls <seemfa marker="#Module:handle_call/2">
          <c>Module:handle_call/2</c></seemfa> to handle the request.</p>
        <p>For a description of <c>EventMgrRef</c> and <c>Handler</c>, see
          <seemfa marker="#add_handler/3"><c>add_handler/3</c></seemfa>.</p>
        <p><c>Request</c> is any term that is passed as one of
          the arguments to <c>Module:handle_call/2</c>.</p>
        <p><c>Timeout</c> is an integer greater than zero that specifies
          how many milliseconds to wait for a reply, or the atom
          <c>infinity</c> to wait indefinitely. Defaults to 5000.
          If no reply is received within the specified time, the function
          call fails.</p>
        <p>The return value <c>Reply</c> is defined in the return value of
          <c>Module:handle_call/2</c>. If the specified event handler is not
          installed, the function returns <c>{error,bad_module}</c>. If
          the callback function fails with <c>Reason</c> or returns an
          unexpected value <c>Term</c>, this function returns
          <c>{error,{'EXIT',Reason}}</c> or <c>{error,Term}</c>,
          respectively.</p>
        <p>
          When this call fails it
          <seemfa marker="erts:erlang#exit/1">exits</seemfa>
          the calling process.
          The exit term is on the form
          <c>{Reason,&nbsp;Location}</c> where
          <c>Location&nbsp;=&nbsp;{gen_event,call,ArgList}</c>.
          See
          <seemfa marker="gen_server#call/3">
            <c>gen_server:call/3</c>
          </seemfa>
          that has a description of relevant
          values for the <c>Reason</c> in the exit term.
        </p>
      </desc>
    </func>

    <func>
      <name name="check_response" arity="2" since="OTP 23.0"/>
      <fsummary>Check if a message is a response to an asynchronous call request
      to a generic event manager.</fsummary>
      <desc>
	<p>
	  Check if <c><anno>Msg</anno></c> is a response corresponding
          to the request identifier <c><anno>ReqId</anno></c>. The request
          must have been made by
	  <seemfa marker="#send_request/3"><c>send_request/3</c></seemfa>.
	</p>
        <p>
          If <c><anno>Msg</anno></c> is a response corresponding to
          <c><anno>ReqId</anno></c> the response is returned; otherwise,
          <c>no_reply</c> is returned and no cleanup is done, and
	  thus the function must be invoked repeatedly until a response
	  is returned.
        </p>
	<p>
	  If the specified event handler is not
          installed, the function returns <c>{error,bad_module}</c>. If
          the callback function fails with <c>Reason</c> or returns an
          unexpected value <c>Term</c>, this function returns
          <c>{error,{'EXIT',Reason}}</c> or <c>{error,Term}</c>,
          respectively. If the event manager dies before or during the
	  request this function returns <c>{error,{Reason, EventMgrRef}}</c>.
	</p>
      </desc>
    </func>

    <func>
      <name name="check_response" arity="3" since="OTP 25.0"/>
      <fsummary>Check if a message is a response to an asynchronous call request
      to a generic event manager.</fsummary>
      <desc>
	<p>
	  Check if <c><anno>Msg</anno></c> is a response corresponding
          to a request identifier saved in <c><anno>ReqIdCollection</anno></c>.
          All request identifiers of <c><anno>ReqIdCollection</anno></c>
          must correspond to requests that have been made using
	  <seemfa marker="#send_request/3"><c>send_request/3</c></seemfa> or
          <seemfa marker="#send_request/5"><c>send_request/5</c></seemfa>,
          and all request must have been made by the process calling this
          function.
	</p>
        <p>
          The <c><anno>Label</anno></c> in the response equals the
          <c><anno>Label</anno></c> associated with the request identifier
          that the response corresponds to. The <c><anno>Label</anno></c>
          of a request identifier is associated when
          <seemfa marker="#reqids_add/3">saving the request id</seemfa>
          in a request identifier collection, or when sending the request using
          <seemfa marker="#send_request/5"><c>send_request/5</c></seemfa>.
        </p>
        <p>
          Compared to
          <seemfa marker="#check_response/2"><c>check_response/2</c></seemfa>,
          the returned result associated with a specific request identifier
          or an exception associated with a specific request identifier will
          be wrapped in a 3-tuple. The first element of this tuple equals the
          value that would have been produced by <c>check_response/2</c>,
          the second element equals the <c><anno>Label</anno></c> associated
          with the specific request identifier, and the third element
          <c><anno>NewReqIdCollection</anno></c> is a possibly  modified
          request identifier collection.
        </p>
        <p>
          If <c><anno>ReqIdCollection</anno></c> is empty, the atom
          <c>no_request</c> will be returned. If <c><anno>Msg</anno></c>
          does not correspond to any of the request identifiers in
          <c><anno>ReqIdCollection</anno></c>, the atom
          <c>no_reply</c> is returned.
        </p>
        <p>
          If <c><anno>Delete</anno></c> equals <c>true</c>, the association
          with <c><anno>Label</anno></c> will have been deleted from
          <c><anno>ReqIdCollection</anno></c> in the resulting
          <c><anno>NewReqIdCollection</anno></c>. If
          <c><anno>Delete</anno></c> equals <c>false</c>,
          <c><anno>NewReqIdCollection</anno></c> will equal
          <c><anno>ReqIdCollection</anno></c>. Note that deleting an
          association is not for free and that a collection containing
          already handled requests can still be used by subsequent calls to
          <c>check_response/3</c>,
 	  <seemfa marker="#receive_response/3"><c>receive_response/3</c></seemfa>,
          and
	  <seemfa marker="#wait_response/3"><c>wait_response/3</c></seemfa>.
          However, without deleting handled associations, the above calls will
          not be able to detect when there are no more outstanding requests to
          handle, so you will have to keep track of this some other way than
          relying on a <c>no_request</c> return. Note that if you pass a
          collection only containing associations of already handled or
          abandoned requests to <c>check_response/3</c>, it will always
          return <c>no_reply</c>.
        </p>
      </desc>
    </func>

    <func> 
      <name since="">delete_handler(EventMgrRef, Handler, Args) -> Result</name>
      <fsummary>Delete an event handler from a generic event manager.</fsummary>
      <type>
        <v>EventMgrRef = Name | {Name,Node} | {global,GlobalName}
	| {via,Module,ViaName} | pid()</v>
        <v>&nbsp;Name = Node = atom()</v>
        <v>&nbsp;GlobalName = ViaName = term()</v>
        <v>Handler = Module | {Module,Id}</v>
        <v>&nbsp;Module = atom()</v>
        <v>&nbsp;Id = term()</v>
        <v>Args = term()</v>
        <v>Result = term() | {error,module_not_found} | {'EXIT',Reason}</v>
        <v>&nbsp;Reason = term()</v>
      </type>
      <desc>
        <p>Deletes an event handler from event manager
          <c>EventMgrRef</c>. The event manager calls
          <seemfa marker="#Module:terminate/2">
          <c>Module:terminate/2</c></seemfa> to terminate the event
          handler.</p>
         <p>For a description of <c>EventMgrRef</c> and <c>Handler</c>, see
          <seemfa marker="#add_handler/3"><c>add_handler/3</c></seemfa>.</p>
        <p><c>Args</c> is any term that is passed as one of
          the arguments to <c>Module:terminate/2</c>.</p>
        <p>The return value is the return value of <c>Module:terminate/2</c>.
          If the specified event handler is not installed, the function
          returns <c>{error,module_not_found}</c>. If the callback function
          fails with <c>Reason</c>, the function returns
          <c>{'EXIT',Reason}</c>.</p>
      </desc>
    </func>

    <func>
      <name since="">notify(EventMgrRef, Event) -> ok</name>
      <name since="">sync_notify(EventMgrRef, Event) -> ok</name>
      <fsummary>Notify an event manager about an event.</fsummary>
      <type>
        <v>EventMgrRef = Name | {Name,Node} | {global,GlobalName}
	| {via,Module,ViaName} | pid()</v>
        <v>&nbsp;Name = Node = atom()</v>
        <v>&nbsp;GlobalName = ViaName = term()</v>
        <v>Event = term()</v>
      </type>
      <desc>
        <p>Sends an event notification to event manager
          <c>EventMgrRef</c>. The event manager calls
          <seemfa marker="#Module:handle_event/2">
          <c>Module:handle_event/2</c></seemfa>
          for each installed event handler to handle the event.</p>
        <p><c>notify/2</c> is asynchronous and returns immediately after
          the event notification has been sent. <c>sync_notify/2</c> is
          synchronous in the sense that it returns <c>ok</c> after
          the event has been handled by all event handlers.</p>
        <p>For a description of <c>EventMgrRef</c>, see
          <seemfa marker="#add_handler/3"><c>add_handler/3</c></seemfa>.</p>
        <p><c>Event</c> is any term that is passed as one of
          the arguments to <seemfa marker="#Module:handle_event/2">
          <c>Module:handle_event/2</c></seemfa>.</p>
        <p><c>notify/1</c> does not fail even if the specified event manager
          does not exist, unless it is specified as <c>Name</c>.</p>
      </desc>
    </func>
    
    <func>
      <name name="receive_response" arity="2" clause_i="1" since="OTP 24.0"/>
      <fsummary>Receive a response to an asynchronous call request
      to a generic event manager.</fsummary>
      <desc>
	<p>
	  Receive a response corresponding to the request identifier
          <c><anno>ReqId</anno></c>- The request must have been made by
	  <seemfa marker="#send_request/3"><c>send_request/3</c></seemfa>
	  to the <c>gen_statem</c> process. This function must be called
	  from the same process from which
	  <seemfa marker="#send_request/3"><c>send_request/3</c></seemfa>
	  was made.
	</p>
	<p>
	  <c><anno>Timeout</anno></c> specifies how long to wait for
          a response. If no response is received within the specified time,
          the function returns <c>timeout</c>. Assuming that the
	  server executes on a node supporting aliases (introduced in
	  OTP 24) the request will also be abandoned. That is, no
          response will be received after a timeout. Otherwise, a
          stray response might be received at a later time.
	</p>
	<p>
	  The return value <c>Reply</c> is defined in the return value
	  of <c>Module:handle_call/3</c>.
	</p>
	<p>
	  If the specified event handler is not
          installed, the function returns <c>{error,bad_module}</c>. If
          the callback function fails with <c>Reason</c> or returns an
          unexpected value <c>Term</c>, this function returns
          <c>{error,{'EXIT',Reason}}</c> or <c>{error,Term}</c>,
          respectively. If the event manager dies before or during the
	  request this function returns <c>{error,{Reason, EventMgrRef}}</c>.
	</p>
	<p>
	  The difference between
	  <seemfa marker="#wait_response/2"><c>wait_response/2</c></seemfa>
	  and <c>receive_response/2</c> is that <c>receive_response/2</c>
	  abandons the request at timeout so that a potential future
	  response is ignored, while <c>wait_response/2</c> does not.
	</p>
      </desc>
    </func>

    <func>
      <name name="receive_response" arity="3" since="OTP 25.0"/>
      <fsummary>Receive a response to an asynchronous call request
      to a generic event manager.</fsummary>
      <desc>
	<p>
	  Receive a response corresponding to a request identifier saved
          in <c><anno>ReqIdCollection</anno></c>. All request identifiers
          of <c><anno>ReqIdCollection</anno></c> must correspond to requests
          that have been made using
	  <seemfa marker="#send_request/3"><c>send_request/3</c></seemfa> or
          <seemfa marker="#send_request/5"><c>send_request/5</c></seemfa>,
          and all request must have been made by the process calling this
          function.
	</p>
        <p>
          The <c><anno>Label</anno></c> in the response equals the
          <c><anno>Label</anno></c> associated with the request identifier
          that the response corresponds to. The <c><anno>Label</anno></c>
          of a request identifier is associated when
          <seemfa marker="#reqids_add/3">adding the request id</seemfa>
          in a request identifier collection, or when sending the request using
          <seemfa marker="#send_request/5"><c>send_request/5</c></seemfa>.
        </p>
        <p>
          Compared to
          <seemfa marker="#receive_response/2"><c>receive_response/2</c></seemfa>,
          the returned result associated with a specific request identifier
          will be wrapped in a 3-tuple. The first element of this tuple equals
          the value that would have been produced by <c>receive_response/2</c>,
          the second element equals the <c><anno>Label</anno></c> associated
          with the specific request identifier, and the third element
          <c><anno>NewReqIdCollection</anno></c> is a possibly modified
          request identifier collection.
        </p>
        <p>
          If <c><anno>ReqIdCollection</anno></c> is empty, the atom
          <c>no_request</c> will be returned.
        </p>
	<p>
	  <c><anno>Timeout</anno></c> specifies how long to wait for
          a response. If no response is received within the specified time,
          the function returns <c>timeout</c>. Assuming that the
	  server executes on a node supporting aliases (introduced in
	  OTP 24) all requests identified by <c><anno>ReqIdCollection</anno></c>
          will also be abandoned. That is, no responses will be received
          after a timeout. Otherwise, stray responses might be received
          at a later time.
	</p>
	<p>
	  The difference between <c>receive_response/3</c> and
          <seemfa marker="#wait_response/3"><c>wait_response/3</c></seemfa>
          is that <c>receive_response/3</c> abandons the requests at timeout
          so that potential future responses are ignored, while
          <c>wait_response/3</c> does not.
	</p>
        <p>
          If <c><anno>Delete</anno></c> equals <c>true</c>, the association
          with <c><anno>Label</anno></c> will have been deleted from
          <c><anno>ReqIdCollection</anno></c> in the resulting
          <c><anno>NewReqIdCollection</anno></c>. If
          <c><anno>Delete</anno></c> equals <c>false</c>,
          <c><anno>NewReqIdCollection</anno></c> will equal
          <c><anno>ReqIdCollection</anno></c>. Note that deleting an
          association is not for free and that a collection containing
          already handled requests can still be used by subsequent calls to
          <c>receive_response/3</c>,
 	  <seemfa marker="#check_response/3"><c>check_response/3</c></seemfa>,
          and
	  <seemfa marker="#wait_response/3"><c>wait_response/3</c></seemfa>.
          However, without deleting handled associations, the above calls will
          not be able to detect when there are no more outstanding requests to
          handle, so you will have to keep track of this some other way than
          relying on a <c>no_request</c> return. Note that if you pass a
          collection only containing associations of already handled or
          abandoned requests to <c>receive_response/3</c>, it will always block
          until a timeout determined by <c><anno>Timeout</anno></c> is
          triggered.
        </p>
      </desc>
    </func>
    
    <func>
      <name name="reqids_add" arity="3" since="OTP 25.0"/>
      <fsummary>Save a request identifier.</fsummary>
      <desc>
	<p>
          Saves <c><anno>ReqId</anno></c> and associates a <c><anno>Label</anno></c>
          with the request identifier by adding this information to
          <c><anno>ReqIdCollection</anno></c> and returning the
          resulting request identifier collection.
        </p>
      </desc>
    </func>

    <func>
      <name name="reqids_new" arity="0" since="OTP 25.0"/>
      <fsummary>Create a new empty request identifier collection.</fsummary>
      <desc>
	<p>
          Returns a new empty request identifier collection. A 
          request identifier collection can be utilized in order
          the handle multiple outstanding requests.
        </p>
        <p>
          Request identifiers of requests made by
	  <seemfa marker="#send_request/3"><c>send_request/3</c></seemfa>
          can be saved in a request identifier collection using 
	  <seemfa marker="#reqids_add/3"><c>reqids_add/3</c></seemfa>.
          Such a collection of request identifiers can later be used in
          order to get one response corresponding to a request in the
          collection by passing the collection as argument to
          <seemfa marker="#receive_response/3"><c>receive_response/3</c></seemfa>,
	  <seemfa marker="#wait_response/3"><c>wait_response/3</c></seemfa>,
	  or,
	  <seemfa marker="#check_response/3"><c>check_response/3</c></seemfa>.
        </p>
        <p>
          <seemfa marker="#reqids_size/1"><c>reqids_size/1</c></seemfa>
          can be used to determine the amount of request identifiers in a
          request identifier collection.
        </p>
      </desc>
    </func>
    
    <func>
      <name name="reqids_size" arity="1" since="OTP 25.0"/>
      <fsummary>Get size of a request identifier collection.</fsummary>
      <desc>
	<p>
          Returns the amount of request identifiers saved in
          <c><anno>ReqIdCollection</anno></c>.
        </p>
      </desc>
    </func>

    <func>
      <name name="reqids_to_list" arity="1" since="OTP 25.0"/>
      <fsummary>List a request identifiers.</fsummary>
      <desc>
	<p>
          Returns a list of <c>{<anno>ReqId</anno>, <anno>Label</anno>}</c>
          tuples which corresponds to all request identifiers with their
          associated labels present in the <c><anno>ReqIdCollection</anno></c>
          collection.
        </p>
      </desc>
    </func>

    <func>
      <name name="send_request" arity="3" since="OTP 23.0"/>
      <fsummary>Send an asyncronous call request to a generic event manager.</fsummary>
      <desc>
        <p>
          Sends an asynchronous <c>call</c> request <c><anno>Request</anno></c> to
          event handler <c><anno>Handler</anno></c> installed in the event manager
          identified by <c><anno>EventMgrRef</anno></c> and returns a request
          identifier <c>ReqId</c>. The return value <c><anno>ReqId</anno></c>
          shall later be used with
          <seemfa marker="#receive_response/2"><c>receive_response/2</c></seemfa>,
          <seemfa marker="#wait_response/2"><c>wait_response/2</c></seemfa>, or
	  <seemfa marker="#check_response/2"><c>check_response/2</c></seemfa>
	  to fetch the actual result of the request. Besides passing
          the request identifier directly to these functions, it can also be
          saved in a request identifier collection using 
	  <seemfa marker="#reqids_add/3"><c>reqids_add/3</c></seemfa>.
          Such a collection of request identifiers can later be used in
          order to get one response corresponding to a request in the
          collection by passing the collection as argument to
          <seemfa marker="#receive_response/3"><c>receive_response/3</c></seemfa>,
	  <seemfa marker="#wait_response/3"><c>wait_response/3</c></seemfa>, or
	  <seemfa marker="#check_response/3"><c>check_response/3</c></seemfa>.
          If you are about to save the request identifier in a request identifier
          collection, you may want to consider using
          <seemfa marker="#send_request/5"><c>send_request/5</c></seemfa>
          instead.
	</p>
	<p>
	  The call <c>gen_event:receive_response(gen_event:send_request(<anno>EventMgrRef</anno>,
          <anno>Handler</anno>, <anno>Request</anno>), Timeout)</c>
	  can be seen as equivalent to
	  <seemfa marker="#call/3"><c>gen_event:call(<anno>EventMgrRef</anno>,
          <anno>Handler</anno>, <anno>Request</anno>, Timeout)</c></seemfa>,
	  ignoring the error handling.
	</p>
	<p>
	  The event manager calls <seemfa marker="#Module:handle_call/2">
          <c>Module:handle_call/2</c></seemfa> to handle the request.
	</p>
        <p>
	  <c>Request</c> is any term that is passed as one of
          the arguments to <c>Module:handle_call/3</c>.
	</p>
      </desc>
    </func>


    <func>
      <name name="send_request" arity="5" since="OTP 25.0"/>
      <fsummary>Sends a request to a generic server.</fsummary>
      <desc>
	<p>
          Sends an asynchronous <c>call</c> request <c><anno>Request</anno></c> to
          event handler <c><anno>Handler</anno></c> installed in the event manager
          identified by <c><anno>EventMgrRef</anno></c>.
          The <c><anno>Label</anno></c> will be associated with the request
          identifier of the operation and added to the returned request
          identifier collection <c><anno>NewReqIdCollection</anno></c>.
          The collection can later be used in order to get one response
          corresponding to a request in the collection by passing the
          collection as argument to
	  <seemfa marker="#receive_response/3"><c>receive_response/3</c></seemfa>,
	  <seemfa marker="#wait_response/3"><c>wait_response/3</c></seemfa>,
	  or,
	  <seemfa marker="#check_response/3"><c>check_response/3</c></seemfa>.
        </p>

        <p>
          The same as calling
          <seemfa marker="#reqids_add/3"><c>gen_event:reqids_add</c></seemfa>(<seemfa
          marker="#send_request/3"><c>gen_event:send_request</c></seemfa><c>(<anno>EventMgrRef</anno>,
          <anno>Handler</anno>, <anno>Request</anno>), <anno>Label</anno>,
          <anno>ReqIdCollection</anno>)</c>, but calling <c>send_request/5</c>
          is slightly more efficient.
        </p>
      </desc>
    </func>

    <func>
      <name since="">start() -> Result</name>
      <name since="">start(EventMgrName | Options) -> Result</name>
      <name since="OTP 20.0">start(EventMgrName, Options) -> Result</name>
      <fsummary>Create a stand-alone event manager process.</fsummary>
      <type>
        <v>EventMgrName = {local,Name} | {global,GlobalName} | {via,Module,ViaName}</v>
        <v>&nbsp;Name = atom()</v>
        <v>&nbsp;GlobalName = ViaName = term()</v>
        <v>Options = [Option]</v>
        <v>&nbsp;Option = {debug,Dbgs} | {timeout,Time} | {hibernate_after,HibernateAfterTimeout} | {spawn_opt,SOpts}</v>
        <v>&nbsp;&nbsp;Dbgs = [Dbg]</v>
        <v>&nbsp;&nbsp;&nbsp;Dbg = trace | log | statistics | {log_to_file,FileName} | {install,{Func,FuncState}}</v>
        <v>&nbsp;&nbsp;SOpts = [term()]</v>
        <v>Result = {ok,Pid} | {error,{already_started,Pid}}</v>
        <v>&nbsp;Pid = pid()</v>
      </type>
      <desc>
        <p>Creates a stand-alone event manager process, that is, an event
          manager that is not part of a supervision tree and thus has
          no supervisor.</p>
        <p>For a description of the arguments and return values, see
          <seemfa marker="#start_link/0"><c>start_link/0,1</c></seemfa>.</p>
      </desc>
    </func>

    <func>
      <name since="">start_link() -> Result</name>
      <name since="">start_link(EventMgrName | Options) -> Result</name>
      <name since="OTP 20.0">start_link(EventMgrName, Options) -> Result</name>
      <fsummary>Create a generic event manager process in a supervision tree.
      </fsummary>
      <type>
        <v>EventMgrName = {local,Name} | {global,GlobalName} | {via,Module,ViaName}</v>
        <v>&nbsp;Name = atom()</v>
        <v>&nbsp;GlobalName = ViaName = term()</v>
        <v>Options = [Option]</v>
        <v>&nbsp;Option = {debug,Dbgs} | {timeout,Time} | {hibernate_after,HibernateAfterTimeout} | {spawn_opt,SOpts}</v>
        <v>&nbsp;&nbsp;Dbgs = [Dbg]</v>
        <v>&nbsp;&nbsp;&nbsp;Dbg = trace | log | statistics | {log_to_file,FileName} | {install,{Func,FuncState}}</v>
        <v>&nbsp;&nbsp;SOpts = [term()]</v>
        <v>Result = {ok,Pid} | {error,{already_started,Pid}}</v>
        <v>&nbsp;Pid = pid()</v>
      </type>
      <desc>
        <p>Creates an event manager process as part of a supervision
          tree. The function is to be called, directly or indirectly,
          by the supervisor. For example, it ensures that
          the event manager is linked to the supervisor.</p>
        <list type="bulleted">
          <item>
            <p>If <c>EventMgrName={local,Name}</c>, the event manager is
              registered locally as <c>Name</c> using <c>register/2</c>.</p>
          </item>
          <item>
            <p>If <c>EventMgrName={global,GlobalName}</c>, the event manager is
              registered globally as <c>GlobalName</c> using
              <seemfa marker="kernel:global#register_name/2">
              <c>global:register_name/2</c></seemfa>.
              If no name is provided, the event manager is not registered.</p>
          </item>
          <item>
            <p>If <c>EventMgrName={via,Module,ViaName}</c>, the event manager
              registers with the registry represented by <c>Module</c>.
              The <c>Module</c> callback is to export the functions
              <c>register_name/2</c>, <c>unregister_name/1</c>,
              <c>whereis_name/1</c>, and <c>send/2</c>, which are to behave
              as the corresponding functions in
              <seeerl marker="kernel:global"><c>global</c></seeerl>.
              Thus, <c>{via,global,GlobalName}</c> is a valid reference.</p>
          </item>
          <item>
            <p>If option <c>{hibernate_after,HibernateAfterTimeout}</c> is present, the <c>gen_event</c>
              process awaits any message for <c>HibernateAfterTimeout</c> milliseconds and
              if no message is received, the process goes into hibernation automatically
              (by calling <seemfa marker="proc_lib#hibernate/3"><c>proc_lib:hibernate/3</c></seemfa>).</p>
          </item>
        </list>
        <p>If the event manager is successfully created, the function
          returns <c>{ok,Pid}</c>, where <c>Pid</c> is the pid of
          the event manager. If a process with the specified
          <c>EventMgrName</c> exists already, the function returns
          <c>{error,{already_started,Pid}}</c>, where <c>Pid</c> is
          the pid of that process.</p>
      </desc>
    </func>

    <func>
      <name since="OTP 23.0">start_monitor() -> Result</name>
      <name since="OTP 23.0">start_monitor(EventMgrName | Options) -> Result</name>
      <name since="OTP 23.0">start_monitor(EventMgrName, Options) -> Result</name>
      <fsummary>Create a stand-alone event manager process.</fsummary>
      <type>
        <v>EventMgrName = {local,Name} | {global,GlobalName} | {via,Module,ViaName}</v>
        <v>&nbsp;Name = atom()</v>
        <v>&nbsp;GlobalName = ViaName = term()</v>
        <v>Options = [Option]</v>
        <v>&nbsp;Option = {debug,Dbgs} | {timeout,Time} | {hibernate_after,HibernateAfterTimeout} | {spawn_opt,SOpts}</v>
        <v>&nbsp;&nbsp;Dbgs = [Dbg]</v>
        <v>&nbsp;&nbsp;&nbsp;Dbg = trace | log | statistics | {log_to_file,FileName} | {install,{Func,FuncState}}</v>
        <v>&nbsp;&nbsp;SOpts = [term()]</v>
        <v>Result = {ok,{Pid,Mon}} | {error,{already_started,Pid}}</v>
        <v>&nbsp;Pid = pid()</v>
      </type>
      <desc>
        <p>Creates a stand-alone event manager process, that is, an event
          manager that is not part of a supervision tree (and thus has
          no supervisor) and atomically sets up a monitor to
	  the newly created process.</p>
        <p>For a description of the arguments and return values, see
          <seemfa marker="#start_link/0"><c>start_link/0,1</c></seemfa>.
	Note that the return value on successful start differs from
	<c>start_link/3,4</c>. <c>start_monitor/3,4</c> will return
	<c>{ok,{Pid,Mon}}</c> where <c>Pid</c> is the process identifier
	of the process, and <c>Mon</c> is a reference to the monitor
	set up to monitor the process. If the start is not successful,
	the caller will be blocked until the <c>DOWN</c> message has
	been received and removed from the message queue.</p>
      </desc>
    </func>

    <func>
      <name since="">stop(EventMgrRef) -> ok</name>
      <name since="OTP 18.0">stop(EventMgrRef, Reason, Timeout) -> ok</name>
      <fsummary>Terminate a generic event manager.</fsummary>
      <type>
        <v>EventMgrRef = Name | {Name,Node} | {global,GlobalName}
	| {via,Module,ViaName} | pid()</v>
        <v>Name = Node = atom()</v>
        <v>GlobalName = ViaName = term()</v>
        <v>Reason = term()</v>
        <v>Timeout = int()>0 | infinity</v>
      </type>
      <desc>
        <p>Orders event manager <c>EventMgrRef</c> to exit with
          the specifies <c>Reason</c> and waits for it to
          terminate. Before terminating, <c>gen_event</c> calls
          <seemfa marker="#Module:terminate/2">
          <c>Module:terminate(stop,...)</c></seemfa>
          for each installed event handler.</p>
        <p>The function returns <c>ok</c> if the event manager terminates
          with the expected reason. Any other reason than <c>normal</c>,
          <c>shutdown</c>, or <c>{shutdown,Term}</c> causes an
          error report to be issued using
          <seeerl marker="kernel:logger"><c>logger(3)</c></seeerl>.
          The default <c>Reason</c> is <c>normal</c>.</p>
        <p><c>Timeout</c> is an integer greater than zero that
          specifies how many milliseconds to wait for the event manager to
          terminate, or the atom <c>infinity</c> to wait
          indefinitely. Defaults to <c>infinity</c>. If the
          event manager has not terminated within the specified time,
          the call exits the calling process
          with reason <c>timeout</c>.</p>
        <p>
          If the process does not exist, the call exits
          the calling process with reason <c>noproc</c>,
          and with reason <c>{nodedown,Node}</c>
          if the connection fails to the remote <c>Node</c>
          where the server runs.
        </p>
        <p>For a description of <c>EventMgrRef</c>, see
          <seemfa marker="#add_handler/3"><c>add_handler/3</c></seemfa>.</p>
      </desc>
    </func>

    <func>
      <name since="">swap_handler(EventMgrRef, {Handler1,Args1}, {Handler2,Args2}) -> Result</name>
      <fsummary>Replace an event handler in a generic event manager.</fsummary>
      <type>
        <v>EventMgrRef = Name | {Name,Node} | {global,GlobalName}
	| {via,Module,ViaName} | pid()</v>
        <v>&nbsp;Name = Node = atom()</v>
        <v>&nbsp;GlobalName = ViaName = term()</v>
        <v>Handler1 = Handler2 = Module | {Module,Id}</v>
        <v>&nbsp;Module = atom()</v>
        <v>&nbsp;Id = term()</v>
        <v>Args1 = Args2 = term()</v>
        <v>Result = ok | {error,Error}</v>
        <v>&nbsp;Error = {'EXIT',Reason} | term()</v>
        <v>&nbsp;&nbsp;Reason = term()</v>
      </type>
      <desc>
        <p>Replaces an old event handler with a new event handler in
          event manager <c>EventMgrRef</c>.</p>
        <p>For a description of the arguments, see
          <seemfa marker="#add_handler/3"><c>add_handler/3</c></seemfa>.</p>
        <p>First the old event handler <c>Handler1</c> is deleted.
          The event manager calls <c>Module1:terminate(Args1, ...)</c>,
          where <c>Module1</c> is the callback module of <c>Handler1</c>,
          and collects the return value.</p>
        <p>Then the new event handler <c>Handler2</c> is added and initiated
          by calling <c>Module2:init({Args2,Term})</c>, where <c>Module2</c>
          is the callback module of <c>Handler2</c> and <c>Term</c> is
          the return value of <c>Module1:terminate/2</c>. This makes it
          possible to transfer information from <c>Handler1</c> to
          <c>Handler2</c>.</p>
        <p>The new handler is added even if the the specified old event
          handler is not installed, in which case <c>Term=error</c>, or if
          <c>Module1:terminate/2</c> fails with <c>Reason</c>,
          in which case <c>Term={'EXIT',Reason}</c>.
          The old handler is deleted even if <c>Module2:init/1</c> fails.</p>
        <p>If there was a supervised connection between <c>Handler1</c> and
          a process <c>Pid</c>, there is a supervised connection
          between <c>Handler2</c> and <c>Pid</c> instead.</p>
        <p>If <c>Module2:init/1</c> returns a correct value, this function
          returns <c>ok</c>. If <c>Module2:init/1</c> fails with
          <c>Reason</c> or returns an unexpected value <c>Term</c>,
          this function returns <c>{error,{'EXIT',Reason}}</c> or
          <c>{error,Term}</c>, respectively.</p>
      </desc>
    </func>

    <func>
      <name since="">swap_sup_handler(EventMgrRef, {Handler1,Args1}, {Handler2,Args2}) -> Result</name>
      <fsummary>Replace an event handler in a generic event manager.</fsummary>
      <type>
        <v>EventMgrRef = Name | {Name,Node} | {global,GlobalName}
	| {via,Module,ViaName} | pid()</v>
        <v>&nbsp;Name = Node = atom()</v>
        <v>&nbsp;GlobalName = ViaName = term()</v>
        <v>Handler1 = Handler 2 = Module | {Module,Id}</v>
        <v>&nbsp;Module = atom()</v>
        <v>&nbsp;Id = term()</v>
        <v>Args1 = Args2 = term()</v>
        <v>Result = ok | {error,Error}</v>
        <v>&nbsp;Error = {'EXIT',Reason} | term()</v>
        <v>&nbsp;&nbsp;Reason = term()</v>
      </type>
      <desc>
        <p>Replaces an event handler in event manager <c>EventMgrRef</c>
          in the same way as <c>swap_handler/3</c>, but also supervises
          the connection between <c>Handler2</c> and the calling process.</p>
        <p>For a description of the arguments and return values, see 
          <seemfa marker="#swap_handler/3"><c>swap_handler/3</c></seemfa>.</p>
      </desc>
    </func>

    <func>
      <name name="wait_response" arity="2" since="OTP 23.0"/>
      <fsummary>Wait or poll for a response to an asynchronous call request
      to a generic event manager.</fsummary>
      <desc>
	<p>
	  Wait for a response corresponding to the request identifier
          <c><anno>ReqId</anno></c>. The request must have been made by
	  <seemfa marker="#send_request/3"><c>send_request/3</c></seemfa>
	  to the <c>gen_statem</c> process. This function must be called
	  from the same process from which
	  <seemfa marker="#send_request/3"><c>send_request/3</c></seemfa>
	  was made.
	</p>
	<p>
	  <c><anno>WaitTime</anno></c> specifies how long to wait for
          a response. If no response is received within the specified
	  time, the function returns <c>timeout</c> and no cleanup is
	  done, and thus the function can be invoked repeatedly until a
	  reply is returned.
	</p>
	<p>
	  The return value <c>Reply</c> is defined in the return value
	  of <c>Module:handle_call/3</c>.
	</p>
	<p>
	  If the specified event handler is not
          installed, the function returns <c>{error,bad_module}</c>. If
          the callback function fails with <c>Reason</c> or returns an
          unexpected value <c>Term</c>, this function returns
          <c>{error,{'EXIT',Reason}}</c> or <c>{error,Term}</c>,
          respectively. If the event manager dies before or during the
	  request this function returns <c>{error,{Reason, EventMgrRef}}</c>.
	</p>
	<p>
	  The difference between
	  <seemfa marker="#receive_response/2"><c>receive_response/2</c></seemfa>
	  and <c>wait_response/2</c> is that <c>receive_response/2</c>
	  abandons the request at timeout so that a potential future
	  response is ignored, while <c>wait_response/2</c> does not.
	</p>
      </desc>
    </func>

    <func>
      <name name="wait_response" arity="3" since="OTP 25.0"/>
      <fsummary>Wait or poll for a response to an asynchronous call request
      to a generic event manager.</fsummary>
      <desc>
	<p>
	  Wait for a response corresponding to a request identifier saved
          in <c><anno>ReqIdCollection</anno></c>. All request identifiers
          of <c><anno>ReqIdCollection</anno></c> must correspond to requests
          that have been made using
	  <seemfa marker="#send_request/3"><c>send_request/3</c></seemfa> or
          <seemfa marker="#send_request/5"><c>send_request/5</c></seemfa>,
          and all request must have been made by the process calling this
          function.
	</p>
        <p>
          The <c><anno>Label</anno></c> in the response equals the
          <c><anno>Label</anno></c> associated with the request identifier
          that the response corresponds to. The <c><anno>Label</anno></c>
          of a request identifier is associated when
          <seemfa marker="#reqids_add/3">saving the request id</seemfa> in
          a request identifier collection, or when sending the request using
          <seemfa marker="#send_request/5"><c>send_request/5</c></seemfa>.
        </p>
        <p>
          Compared to
          <seemfa marker="#wait_response/2"><c>wait_response/2</c></seemfa>,
          the returned result associated with a specific request identifier
          or an exception associated with a specific request identifier will
          be wrapped in a 3-tuple. The first element of this tuple equals the
          value that would have been produced by <c>wait_response/2</c>,
          the second element equals the <c><anno>Label</anno></c> associated
          with the specific request identifier, and the third element
          <c><anno>NewReqIdCollection</anno></c> is a possibly  modified
          request identifier collection.
        </p>
        <p>
          If <c><anno>ReqIdCollection</anno></c> is empty, <c>no_request</c>
          will be returned. If no response is received before the
          <c><anno>WaitTime</anno></c> timeout has triggered, the atom
          <c>timeout</c> is returned. It is valid to continue waiting for a
          response as many times as needed up until a response has been received
          and completed by <c>check_response()</c>, <c>receive_response()</c>,
          or <c>wait_response()</c>.
        </p>
	<p>
	  The difference between
          <seemfa marker="#receive_response/3"><c>receive_response/3</c></seemfa>
	  and <c>wait_response/3</c> is that <c>receive_response/3</c>
	  abandons requests at timeout so that a potential future
	  responses are ignored, while <c>wait_response/3</c> does not.
	</p>
        <p>
          If <c><anno>Delete</anno></c> equals <c>true</c>, the association
          with <c><anno>Label</anno></c> will have been deleted from
          <c><anno>ReqIdCollection</anno></c> in the resulting
          <c><anno>NewReqIdCollection</anno></c>. If
          <c><anno>Delete</anno></c> equals <c>false</c>,
          <c><anno>NewReqIdCollection</anno></c> will equal
          <c><anno>ReqIdCollection</anno></c>. Note that deleting an
          association is not for free and that a collection containing
          already handled requests can still be used by subsequent calls to
          <c>wait_response/3</c>,
 	  <seemfa marker="#check_response/3"><c>check_response/3</c></seemfa>,
          and
	  <seemfa marker="#receive_response/3"><c>receive_response/3</c></seemfa>.
          However, without deleting handled associations, the above calls will
          not be able to detect when there are no more outstanding requests to
          handle, so you will have to keep track of this some other way than
          relying on a <c>no_request</c> return. Note that if you pass a
          collection only containing associations of already handled or
          abandoned requests to <c>wait_response/3</c>, it will always block
          until a timeout determined by <c><anno>WaitTime</anno></c> is
          triggered and then return <c>no_reply</c>.
        </p>
      </desc>
    </func>

    <func>
      <name since="">which_handlers(EventMgrRef) -> [Handler]</name>
      <fsummary>Return all event handlers installed in a generic event manager.
      </fsummary>
      <type>
        <v>EventMgrRef = Name | {Name,Node} | {global,GlobalName}
	| {via,Module,ViaName} | pid()</v>
        <v>&nbsp;Name = Node = atom()</v>
        <v>&nbsp;GlobalName = ViaName = term()</v>
        <v>Handler = Module | {Module,Id}</v>
        <v>&nbsp;Module = atom()</v>
        <v>&nbsp;Id = term()</v>
      </type>
      <desc>
        <p>Returns a list of all event handlers installed in event
          manager <c>EventMgrRef</c>.</p>
        <p>For a description of <c>EventMgrRef</c> and <c>Handler</c>, see
          <seemfa marker="#add_handler/3"><c>add_handler/3</c></seemfa>.</p>
      </desc>
    </func>
  </funcs>

 

  <funcs>
    <fsdescription>
      <title>Callback Functions</title>
      <p>The following functions are to be exported from a <c>gen_event</c>
        callback module.</p>
    </fsdescription>
    <func>
      <name since="">Module:code_change(OldVsn, State, Extra) -> {ok, NewState}</name>
      <fsummary>Update the internal state during upgrade/downgrade.</fsummary>
      <type>
        <v>OldVsn = Vsn | {down, Vsn}</v>
        <v>&nbsp;&nbsp;Vsn = term()</v>
        <v>State = NewState = term()</v>
        <v>Extra = term()</v>
      </type>
      <desc>
        <note>
          <p>This callback is optional, so callback modules need not export it.
            If a release upgrade/downgrade with <c>Change={advanced,Extra}</c>
            specified in the <c>.appup</c> file is made when <c>code_change/3</c>
            isn't implemented the event handler will crash with an <c>undef</c> error
            reason.</p>
        </note>
        <p>This function is called for an installed event handler that
          is to update its internal state during a release
          upgrade/downgrade, that is, when the instruction
          <c>{update,Module,Change,...}</c>, where
          <c>Change={advanced,Extra}</c>, is specified in the <c>.appup</c>
          file. For more information, see <seeguide
          marker="system/design_principles:index">OTP Design Principles</seeguide>.</p>
        <p>For an upgrade, <c>OldVsn</c> is <c>Vsn</c>, and for a downgrade,
          <c>OldVsn</c> is <c>{down,Vsn}</c>. <c>Vsn</c> is defined by the
          <c>vsn</c> attribute(s) of the old version of the callback module
          <c>Module</c>. If no such attribute is defined, the version
          is the checksum of the Beam file.</p>
        <p><c>State</c> is the internal state of the event handler.</p>
        <p><c>Extra</c> is passed "as is" from the <c>{advanced,Extra}</c>
          part of the update instruction.</p>
        <p>The function is to return the updated internal state.</p>
      </desc>
    </func>

    <func>
      <name since="OTP 25.0">Module:format_status(Status) -> NewStatus</name>
      <fsummary>Optional function for providing a term describing the
        current event handler state.</fsummary>
      <type>
        <v>Status = <seetype marker="#format_status">format_status()</seetype></v>
        <v>NewStatus = <seetype marker="#format_status">format_status()</seetype></v>
      </type>
      <desc>
        <note>
          <p>This callback is optional, so event handler modules need
            not export it. If a handler does not export this function,
            the <c>gen_event</c> module uses the handler state directly for
            the purposes described below.</p>
          <p>
	    If this callback is exported but fails, to hide possibly sensitive
            data, the default function will instead return the fact that
	    <c>format_status/1</c> has crashed.</p>
        </note>
        <p>This function is called by a <c>gen_event</c> process in the
          following situations:</p>
        <list type="bulleted">
          <item>One of <seemfa marker="sys#get_status/1">
            <c>sys:get_status/1,2</c></seemfa>
            is invoked to get the <c>gen_event</c> status.</item>
          <item>The event handler terminates abnormally and <c>gen_event</c>
            logs an error.</item>
        </list>
        <p>
          This callback is used to limit the status of the event handler
          returned by
          <seemfa marker="sys#get_status/1"><c>sys:get_status/1,2</c></seemfa>
          or sent to <seeerl marker="kernel:logger"><c>logger</c></seeerl>.
        </p>
        <p>
          The callback gets a map <c>Status</c>
          describing the current status and shall return a map
          <c>NewStatus</c> with the same keys,
          but it may transform some values.
        </p>
        <p>
          Two possible use cases for this callback is to
          remove sensitive information from the state
          to prevent it from being printed in log files,
          or to compact large irrelevant status items
          that would only clutter the logs.
        </p>
        <code type="erl"><![CDATA[
format_status(Status) ->
  maps:map(
    fun(state,State) ->
            maps:remove(private_key, State);
       (message,{password, _Pass}) ->
            {password, removed};
       (_,Value) ->
            Value
    end, Status).
]]></code>
      </desc>
    </func>
    
    <func>
      <name since="OTP R14B">Module:format_status(Opt, [PDict, State]) -> Status</name>
      <fsummary>Optional function for providing a term describing the
        current event handler state.</fsummary>
      <type>
        <v>Opt = normal | terminate</v>
        <v>PDict = [{Key, Value}]</v>
        <v>State = term()</v>
        <v>Status = term()</v>
      </type>
      <desc>
        <warning>
          <p>This callback is deprecated, in new code use <seemfa marker="#Module:format_status/1">
          format_status/1</seemfa>. If a <seemfa marker="#Module:format_status/1">format_status/1</seemfa>
            callback exists, then this function will never be called.</p>
        </warning>
        <note>
          <p>This callback is optional, so event handler modules need
            not export it. If a handler does not export this function,
            the <c>gen_event</c> module uses the handler state directly for
            the purposes described below.</p>
        </note>
        <p>This function is called by a <c>gen_event</c> process in the
          following situations:</p>
        <list type="bulleted">
          <item>One of <seemfa marker="sys#get_status/1">
            <c>sys:get_status/1,2</c></seemfa>
            is invoked to get the <c>gen_event</c> status. <c>Opt</c> is set
            to the atom <c>normal</c> for this case.</item>
          <item>The event handler terminates abnormally and <c>gen_event</c>
            logs an error. <c>Opt</c> is set to the
            atom <c>terminate</c> for this case.</item>
        </list>
        <p>This function is useful for changing the form and
          appearance of the event handler state for these cases. An
          event handler callback module wishing to change the
          the <c>sys:get_status/1,2</c> return value as well as how
          its state appears in termination error logs, exports an
          instance of <c>format_status/2</c> that returns a term
          describing the current state of the event handler.</p>
        <p><c>PDict</c> is the current value of the
          process dictionary of <c>gen_event</c>.</p>
        <p><c>State</c> is the internal state of the event handler.</p>
        <p>The function is to return <c>Status</c>, a term that
          change the details of the current state of the event
          handler. Any term is allowed for <c>Status</c>. The
          <c>gen_event</c> module uses <c>Status</c> as follows:</p>
        <list type="bulleted">
          <item><p>When <c>sys:get_status/1,2</c> is called, <c>gen_event</c>
            ensures that its return value contains <c>Status</c> in
            place of the state term of the event handler.</p></item>
          <item><p>When an event handler terminates abnormally, <c>gen_event</c>
            logs <c>Status</c> in place of the state term of the
            event handler.</p></item>
        </list>
        <p>One use for this function is to return compact alternative
          state representations to avoid that large state terms
          are printed in log files.</p>
      </desc>
    </func>

    <func>
      <name since="">Module:handle_call(Request, State) -> Result</name>
      <fsummary>Handle a synchronous request.</fsummary>
      <type>
        <v>Request = term()</v>
        <v>State = term()</v>
        <v>Result = {ok,Reply,NewState} | {ok,Reply,NewState,hibernate}</v>
        <v>&nbsp;| {swap_handler,Reply,Args1,NewState,Handler2,Args2}</v>
        <v>&nbsp;| {remove_handler, Reply}</v>
        <v>&nbsp;Reply = term()</v>
        <v>&nbsp;NewState = term()</v>
        <v>&nbsp;Args1 = Args2 = term()</v>
        <v>&nbsp;Handler2 = Module2 | {Module2,Id}</v>
        <v>&nbsp;&nbsp;Module2 = atom()</v>
        <v>&nbsp;&nbsp;Id = term()</v>
      </type>
      <desc>
        <p>Whenever an event manager receives a request sent using
          <seemfa marker="#call/3"><c>call/3,4</c></seemfa>,
          this function is called for
          the specified event handler to handle the request.</p>
        <p><c>Request</c> is the <c>Request</c> argument of <c>call/3,4</c>.</p>
        <p><c>State</c> is the internal state of the event handler.</p>
        <p>The return values are the same as for
          <seemfa marker="#Module:handle_event/2">
          <c>Module:handle_event/2</c></seemfa>
          except that they also contain a term <c>Reply</c>, which is the reply
          to the client as the return value of <c>call/3,4</c>.</p>
      </desc>
    </func>

    <func>
      <name since="">Module:handle_event(Event, State) -> Result</name>
      <fsummary>Handle an event.</fsummary>
      <type>
        <v>Event = term()</v>
        <v>State = term()</v>
        <v>Result = {ok,NewState} | {ok,NewState,hibernate} </v>
        <v>&nbsp;&nbsp;| {swap_handler,Args1,NewState,Handler2,Args2}
        | remove_handler</v>
        <v>&nbsp;NewState = term()</v>
        <v>&nbsp;Args1 = Args2 = term()</v>
        <v>&nbsp;Handler2 = Module2 | {Module2,Id}</v>
        <v>&nbsp;&nbsp;Module2 = atom()</v>
        <v>&nbsp;&nbsp;Id = term()</v>
      </type>
      <desc>
        <p>Whenever an event manager receives an event sent using
          <seemfa marker="#notify/2"><c>notify/2</c></seemfa> or
          <seemfa marker="#sync_notify/2"><c>sync_notify/2</c></seemfa>,
          this function is called for each installed event handler to handle
          the event.</p>
        <p><c>Event</c> is the <c>Event</c> argument of
          <c>notify/2</c>/<c>sync_notify/2</c>.</p>
        <p><c>State</c> is the internal state of the event handler.</p>
        <list type="bulleted">
          <item>
            <p>If <c>{ok,NewState}</c> or <c>{ok,NewState,hibernate}</c>
              is returned, the event handler
              remains in the event manager with the possible updated
              internal state <c>NewState</c>.</p>
          </item>
          <item>
            <p>If <c>{ok,NewState,hibernate}</c> is returned, the event
              manager also goes into hibernation (by calling
              <seemfa marker="proc_lib#hibernate/3">
              <c>proc_lib:hibernate/3</c></seemfa>), waiting for the next
              event to occur. It is sufficient that one of the
              event handlers return <c>{ok,NewState,hibernate}</c> for the
              whole event manager process to hibernate.</p>
          </item>
          <item>
            <p>If <c>{swap_handler,Args1,NewState,Handler2,Args2}</c> is
              returned, the event handler is replaced by <c>Handler2</c> by
              first calling <c>Module:terminate(Args1,NewState)</c> and then
              <c>Module2:init({Args2,Term})</c>, where <c>Term</c> is the return
              value of <c>Module:terminate/2</c>. For more information, see
              <seemfa marker="#swap_handler/3"><c>swap_handler/3</c></seemfa>.
            </p>
          </item>
          <item>
            <p>If <c>remove_handler</c> is returned, the event handler is
              deleted by calling
              <c>Module:terminate(remove_handler,State)</c>.</p>
          </item>
        </list>
      </desc>
    </func>

    <func>
      <name since="">Module:handle_info(Info, State) -> Result</name>
      <fsummary>Handle an incoming message.</fsummary>
      <type>
        <v>Info = term()</v>
        <v>State = term()</v>
        <v>Result = {ok,NewState} | {ok,NewState,hibernate}</v>
        <v>&nbsp;| {swap_handler,Args1,NewState,Handler2,Args2}
        | remove_handler</v>
        <v>&nbsp;NewState = term()</v>
        <v>&nbsp;Args1 = Args2 = term()</v>
        <v>&nbsp;Handler2 = Module2 | {Module2,Id}</v>
        <v>&nbsp;&nbsp;Module2 = atom()</v>
        <v>&nbsp;&nbsp;Id = term()</v>
      </type>
      <desc>
        <note>
          <p>This callback is optional, so callback modules need not
            export it. The <c>gen_event</c> module provides a default
            implementation of this function that logs about the unexpected
            <c>Info</c> message, drops it and returns <c>{ok, State}</c>.</p>
        </note>
        <p>This function is called for each installed event handler when
          an event manager receives any other message than an event or
          a synchronous request (or a system message).</p>
        <p><c>Info</c> is the received message.</p>
        <p>In particular, this callback will be made when a process terminated
          after calling
          <seemfa marker="#add_sup_handler/3">
          <c>add_sup_handler/3</c></seemfa>. Any event handler
          attached to an event manager which in turn has a supervised handler
          should expect callbacks of the shape
          <seemfa marker="#Module:handle_info/2">
          <c>Module:handle_info({'EXIT', Pid, Reason}, State)</c></seemfa>.</p>
        <p>For a description of <c>State</c> and possible return values, see
          <seemfa marker="#Module:handle_event/2">
          <c>Module:handle_event/2</c></seemfa>.</p>
      </desc>
    </func>

    <func>
      <name since="">Module:init(InitArgs) -> {ok,State} | {ok,State,hibernate} | {error,Reason}</name>
      <fsummary>Initialize an event handler.</fsummary>
      <type>
        <v>InitArgs = Args | {Args,Term}</v>
        <v>&nbsp;Args = Term = term()</v>
        <v>State = term()</v>
	<v>Reason = term()</v>
      </type>
      <desc>
        <p>Whenever a new event handler is added to an event manager,
          this function is called to initialize the event handler.</p>
        <p>If the event handler is added because of a call to
          <seemfa marker="#add_handler/3"><c>add_handler/3</c></seemfa> or
          <seemfa marker="#add_sup_handler/3">
          <c>add_sup_handler/3</c></seemfa>, <c>InitArgs</c> is
          the <c>Args</c> argument of these functions.</p>
        <p>If the event handler replaces another event handler because of
          a call to
          <seemfa marker="#swap_handler/3"><c>swap_handler/3</c></seemfa> or
          <seemfa marker="#swap_sup_handler/3">
          <c>swap_sup_handler/3</c></seemfa>, or because of a <c>swap</c>
          return tuple from one of the other callback functions,
          <c>InitArgs</c> is a tuple <c>{Args,Term}</c>, where <c>Args</c> is
          the argument provided in the function call/return tuple and
          <c>Term</c> is the result of terminating the old event handler, see
          <seemfa marker="#swap_handler/3"><c>swap_handler/3</c></seemfa>.</p>
        <p>If successful, the function returns <c>{ok,State}</c>
          or <c>{ok,State,hibernate}</c>, where <c>State</c> is the
          initial internal state of the event handler.</p>
        <p>If <c>{ok,State,hibernate}</c> is returned, the event
          manager goes into hibernation (by calling <seemfa
          marker="proc_lib#hibernate/3"><c>proc_lib:hibernate/3</c></seemfa>),
          waiting for the next event to occur.</p>
      </desc>
    </func>

    <func>
      <name since="">Module:terminate(Arg, State) -> term()</name>
      <fsummary>Clean up before deletion.</fsummary>
      <type>
        <v>Arg = Args | {stop,Reason} | stop | remove_handler</v>
        <v>&nbsp;| {error,{'EXIT',Reason}} | {error,Term}</v>
        <v>&nbsp;Args = Reason = Term = term()</v>
      </type>
      <desc>
        <note>
          <p>This callback is optional, so callback modules need not
            export it. The <c>gen_event</c> module provides a default
            implementation without cleanup.</p>
        </note>
        <p>Whenever an event handler is deleted from an event manager,
          this function is called. It is to be the opposite of
          <seemfa marker="#Module:init/1"><c>Module:init/1</c></seemfa>
          and do any necessary cleaning up.</p>
        <p>If the event handler is deleted because of a call to
          <seemfa marker="#delete_handler/3"><c>delete_handler/3</c></seemfa>,
          <seemfa marker="#swap_handler/3"><c>swap_handler/3</c></seemfa>, or
          <seemfa marker="#swap_sup_handler/3">
          <c>swap_sup_handler/3</c></seemfa>, <c>Arg</c> is
          the <c>Args</c> argument of this function call.</p>
        <p><c>Arg={stop,Reason}</c> if the event handler has a supervised
          connection to a process that has terminated with reason
          <c>Reason</c>.</p>
        <p><c>Arg=stop</c> if the event handler is deleted because
          the event manager is terminating.</p>
        <p>The event manager terminates if it is part of a supervision
          tree and it is ordered by its supervisor to terminate.
          Even if it is <em>not</em> part of a supervision tree, it
          terminates if it receives an <c>'EXIT'</c> message from
          its parent.</p>
        <p><c>Arg=remove_handler</c> if the event handler is deleted because
          another callback function has returned <c>remove_handler</c> or
          <c>{remove_handler,Reply}</c>.</p>
        <p><c>Arg={error,Term}</c> if the event handler is deleted because
          a callback function returned an unexpected value <c>Term</c>,
          or <c>Arg={error,{'EXIT',Reason}}</c> if a callback function
          failed.</p>
        <p><c>State</c> is the internal state of the event handler.</p>
        <p>The function can return any term. If the event handler is
          deleted because of a call to <c>gen_event:delete_handler/3</c>,
          the return value of that function becomes the return value of this
          function. If the event handler is to be replaced with another event
          handler because of a swap, the return value is passed to
          the <c>init</c> function of the new event handler. Otherwise
          the return value is ignored.</p>
      </desc>
    </func>
  </funcs>

  <section>
    <title>See Also</title>
    <p><seeerl marker="supervisor"><c>supervisor(3)</c></seeerl>,
      <seeerl marker="sys"><c>sys(3)</c></seeerl></p>
  </section>
</erlref>
