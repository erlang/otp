<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>1996</year><year>2023</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>

    <title>ets</title>
    <prepared></prepared>
    <docno></docno>
    <date></date>
    <rev></rev>
  </header>
  <module since="">ets</module>
  <modulesummary>Built-in term storage.</modulesummary>
  <description>
    <p>This module is an interface to the Erlang built-in term storage
      BIFs. These provide the ability to store very large quantities of
      data in an Erlang runtime system, and to have constant access
      time to the data. (In the case of <c>ordered_set</c>, see below,
      access time is proportional to the logarithm of the number of
      stored objects.)</p>

    <p>Data is organized as a set of dynamic tables, which can store
      tuples. Each table is created by a process. When the process
      terminates, the table is automatically destroyed. Every table has
      access rights set at creation.</p>

    <p>Tables are divided into four different types, <c>set</c>,
      <c>ordered_set</c>, <c>bag</c>, and <c>duplicate_bag</c>.
      A <c>set</c> or <c>ordered_set</c> table can only have one object
      associated with each key. A <c>bag</c> or <c>duplicate_bag</c> table can
      have many objects associated with each key.</p>
    <p>
      Insert and lookup times in tables of type <c>set</c> are constant,
      regardless of the table size. For table types <c>bag</c> and
      <c>duplicate_bag</c> time is proportional to the number of objects with the
      same key. Even seemingly unrelated keys may inflict linear search to be
      skipped past while looking for the key of interest (due to hash collision).
    </p>
    <warning>
      <p>
	For tables of type <c>bag</c> and <c>duplicate_bag</c>, avoid inserting
	an extensive amount of objects with the same key. It will hurt insert and
	lookup performance as well as real time characteristics of the runtime
	environment (hash bucket linear search do not yield).
      </p>
    </warning>
    <p>
      The <c>ordered_set</c> table type uses a binary search tree. Insert and
      lookup times are proportional to the logarithm of the number of objects in
      the table.
    </p>
   <marker id="max_ets_tables"></marker>
   <note>
     <p>
       The number of tables stored at one Erlang node <em>used</em> to
       be limited. This is no longer the case (except by memory usage).
       The previous default limit was about 1400 tables and
       could be increased by setting the environment variable
       <c>ERL_MAX_ETS_TABLES</c> or the command line option
       <seecom marker="erts:erl#+e"><c>+e</c></seecom> before starting the
       Erlang runtime system. This hard limit has been removed, but it is currently
       useful to set the <c>ERL_MAX_ETS_TABLES</c> anyway. It should be
       set to an approximate of the maximum amount of tables used since
       an internal table for named tables is sized using this value. If
       large amounts of named tables are used and <c>ERL_MAX_ETS_TABLES</c>
       hasn't been increased, the performance of named table lookup will
       degrade.
    </p>
   </note>

    <p>Notice that there is no automatic garbage collection for tables.
      Even if there are no references to a table from any process, it
      is not automatically destroyed unless the owner process
      terminates. To destroy a table explicitly, use function
      <seemfa marker="#delete/1"><c>delete/1</c></seemfa>.
      The default owner is the process that created the
      table. To transfer table ownership at process termination, use
      option <seeerl marker="#heir"><c>heir</c></seeerl> or call
      <seemfa marker="#give_away/3"><c>give_away/3</c></seemfa>.</p>

    <p>Some implementation details:</p>

    <list type="bulleted">
      <item><p>In the current implementation, every object insert and
       look-up operation results in a copy of the object.</p></item>
      <item><p><c>'$end_of_table'</c> is not to be used as a key, as
       this atom is used to mark the end of the table when using functions
       <seemfa marker="#first/1"><c>first/1</c></seemfa> and
       <seemfa marker="#next/2"><c>next/2</c></seemfa>.</p></item>
    </list>

    <p>Notice the subtle difference between
      <em>matching</em> and <em>comparing equal</em>, which is
      demonstrated by table types <c>set</c> and <c>ordered_set</c>:</p>

    <list type="bulleted">
      <item>
        <p>Two Erlang terms <c>match</c> if they are of
          the same type and have the same value, so that <c>1</c> matches
          <c>1</c>, but not <c>1.0</c> (as <c>1.0</c> is a <c>float()</c>
          and not an <c>integer()</c>).</p>
      </item>
      <item>
        <p>Two Erlang terms <em>compare equal</em>
          if they either are of the same type and value, or if
          both are numeric types and extend to the same value, so that
          <c>1</c> compares equal to both <c>1</c> and <c>1.0</c>.</p>
      </item>
      <item>
        <p>The <c>ordered_set</c> works on the <em>Erlang term order</em> and
          no defined order exists between an <c>integer()</c> and a
          <c>float()</c> that extends to the same value. Hence the key
          <c>1</c> and the key <c>1.0</c> are regarded as equal in an
          <c>ordered_set</c> table.</p>
      </item>
    </list>
  </description>

  <section><marker id="ets_failures"></marker>
    <title>Failures</title>
    <p>Functions in this module fail by raising an error exception
    with error reason:</p>
    <taglist>
      <tag><c>badarg</c></tag>
      <item><p>
	If any argument has the wrong format.
      </p></item>
      <tag><c>badarg</c></tag>
      <item><p>
	If the table identifier is invalid.
      </p></item>
      <tag><c>badarg</c></tag>
      <item><p>
	If the operation is denied because of
	table access rights (<seeerl marker="#protected">protected</seeerl>
	or <seeerl marker="#private">private</seeerl>).
      </p></item>
      <tag><c>system_limit</c></tag>
      <item><p>
	Modification of a value causes it to not be representable
	internally in the VM. For example, incrementation of a
	counter past the largest integer representable.
      </p></item>
      <tag><c>system_limit</c></tag>
      <item><p>
	If a match specification passed as argument has excessive
	nesting which causes scheduler stack exhaustion for the
	scheduler that the calling process is executing on.
	<seecom marker="erts:erl#sched_thread_stack_size">Scheduler
	stack size</seecom> can be configured when starting the
	runtime system.
      </p></item>
    </taglist>
  </section>

  <section><marker id="concurrency"></marker>
    <title>Concurrency</title>
      <p>This module provides some limited support for concurrent access.
       All updates to single objects are guaranteed to be both <em>atomic</em>
       and <em>isolated</em>. This means that an updating operation to
       a single object either succeeds or fails completely without any
       effect (atomicity) and that
       no intermediate results of the update can be seen by other
       processes (isolation). Some functions that update many objects
       state that they even guarantee atomicity and isolation for the entire
       operation. In database terms the isolation level can be seen as
       "serializable", as if all isolated operations are carried out serially,
       one after the other in a strict order.</p>
  </section>

  <section><marker id="traversal"></marker>
    <title>Table traversal</title>
    <p>There are different ways to traverse through the objects of a table.</p>
    <list type="bulleted">
      <item><p><em>Single-step</em> traversal one key at at time, using
	<seemfa marker="#first/1"><c>first/1</c></seemfa>,
	<seemfa marker="#next/2"><c>next/2</c></seemfa>,
	<seemfa marker="#last/1"><c>last/1</c></seemfa> and
	<seemfa marker="#prev/2"><c>prev/2</c></seemfa>.</p>
      </item>
      <item><p>Search with simple <em>match patterns</em>, using
	<seemfa marker="#match/1"><c>match/1/2/3</c></seemfa>,
	<seemfa marker="#match_delete/2"><c>match_delete/2</c></seemfa> and
	<seemfa marker="#match_object/1"><c>match_object/1/2/3</c></seemfa>.</p>
      </item>
      <item><p>Search with more powerful <em>match specifications</em>, using
	<seemfa marker="#select/1"><c>select/1/2/3</c></seemfa>,
	<seemfa marker="#select_count/2"><c>select_count/2</c></seemfa>,
	<seemfa marker="#select_delete/2"><c>select_delete/2</c></seemfa>,
	<seemfa marker="#select_replace/2"><c>select_replace/2</c></seemfa> and
	<seemfa marker="#select_reverse/1"><c>select_reverse/1/2/3</c></seemfa>.</p>
      </item>
      <item><p><em>Table conversions</em>, using
	<seemfa marker="#tab2file/2"><c>tab2file/2/3</c></seemfa> and
        <seemfa marker="#tab2list/1"><c>tab2list/1</c></seemfa>.</p>
      </item>
    </list>
    <p>
      No table traversal will guarantee a consistent snapshot of the entire
      table if the table is also updated by concurrent processes during the
      traversal. The result of each concurrently updated object may be seen (or
      not) depending on if it has happened when the traversal visits that part
      of the table. The only way to guarantee a full consistent table snapshot
      (if you really need that) is to disallow concurrent updates during the
      entire traversal.
    </p>
    <p>
      Moreover, traversals not done in a <em>safe</em> way, on tables where
      keys are inserted or deleted during the traversal, may yield the
      following undesired effects:
    </p>
    <list type="bulleted">
      <item><p>Any key may be missed.</p></item>
      <item><p>Any key may be found more than once.</p></item>
      <item><p>The traversal may fail with <c>badarg</c> exception if keys are deleted.</p>
      </item>
    </list>
    <p>A table traversal is <em>safe</em> if either</p>
    <list type="bulleted">
      <item><p>the table is of type <c>ordered_set</c>.</p>
      </item>
      <item><p>the entire table traversal is done within one ETS function
        call.</p>
      </item>
      <item><p>function <seemfa marker="#safe_fixtable/2"><c>safe_fixtable/2</c></seemfa>
        is used to keep the table fixated during the entire traversal.</p>
      </item>
    </list>
    <note>
      <p>Even though the access of a single object is always guaranteed to be
      <seeerl marker="#concurrency">atomic and isolated</seeerl>, each traversal
      through a table to find the next key is not done with such guarantees. This is often
      not a problem, but may cause rare subtle "unexpected" effects if a concurrent
      process inserts objects during a traversal. For example, consider one
      process doing</p>
<pre>
ets:new(t, [ordered_set, named_table]),
ets:insert(t, {1}),
ets:insert(t, {2}),
ets:insert(t, {3}),
</pre>
      <p>A concurrent call to <c>ets:first(t)</c>, done by another
      process, may then in rare cases return <c>2</c> even though
      <c>2</c> has never existed in the table ordered as the first key. In
      the same way, a concurrent call to <c>ets:next(t, 1)</c> may return
      <c>3</c> even though <c>3</c> never existed in the table
      ordered directly after <c>1</c>.</p>
      <p>Effects like this are improbable but possible. The probability will
      further be reduced (if not vanish) if table option
      <seeerl marker="#new_2_write_concurrency"><c>write_concurrency</c></seeerl>
      is not enabled. This can also only be a potential concern for
      <c>ordered_set</c> where the traversal order is defined.</p>
    </note>
    <p>Traversals using <c>match</c> and <c>select</c> functions may not need to
    scan the entire table depending on how the key is specified. A match
    pattern with a <em>fully bound key</em> (without any match variables) will
    optimize the operation to a single key lookup without any table traversal
    at all. For <c>ordered_set</c> a <em>partially bound key</em> will limit the
    traversal to only scan a subset of the table based on term order. A
    partially bound key is either a list or a tuple with a prefix that is fully
    bound. Example:</p>
<pre>
1> <input>T = ets:new(t,[ordered_set]), ets:insert(T, {"555-1234", "John Smith"}).</input>
true
2> <input>%% Efficient search of all with area code 555</input>
2> <input>ets:match(T,{[$5,$5,$5,$- |'$1'],'$2'}).</input>
[["1234","John Smith"]]
</pre>
  </section>

  <section>
    <marker id="match_spec"></marker>
    <title>Match Specifications</title>
    <p>Some of the functions use a <em>match specification</em>,
      <c>match_spec</c>. For a brief explanation, see
      <seemfa marker="#select/2"><c>select/2</c></seemfa>. For a detailed
      description, see section <seeguide marker="erts:match_spec">
      Match Specifications in Erlang</seeguide> in ERTS User's Guide.</p>
    <p>A match specifications with excessive nesting will cause a
      <seeerl marker="#ets_failures"><c>system_limit</c></seeerl> error
      exception to be raised.</p>
  </section>

  <datatypes>
    <datatype>
      <name name="table_access"/>
    </datatype>
    <datatype>
      <name>continuation()</name>
      <desc>
        <p>Opaque continuation used by <seemfa marker="#select/1">
          <c>select/1,3</c></seemfa>, <seemfa marker="#select_reverse/1">
          <c>select_reverse/1,3</c></seemfa>, <seemfa marker="#match/1">
          <c>match/1,3</c></seemfa>, and <seemfa marker="#match_object/1">
          <c>match_object/1,3</c></seemfa>.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="match_spec"/>
      <desc><p>A match specification, see <seeerl marker="#match_spec">Match Specifications</seeerl>.</p></desc>
    </datatype>
    <datatype>
      <name name="compiled_match_spec"/>
      <desc><p>A compiled match specification.</p></desc>
    </datatype>
    <datatype>
      <name name="match_pattern"/>
    </datatype>
    <datatype>
      <name name="table"/>
    </datatype>
    <datatype>
      <name name="tid"/>
      <desc><p>A table identifier, as returned by
      <seemfa marker="#new/2"><c>new/2</c></seemfa>.</p></desc>
    </datatype>
    <datatype>
      <name name="table_type"/>
    </datatype>
  </datatypes>

  <funcs>
    <func>
      <name name="all" arity="0" since=""/>
      <fsummary>Return a list of all ETS tables.</fsummary>
      <desc>
        <p>Returns a list of all tables at the node. Named tables are
          specified by their names, unnamed tables are specified by their
          table identifiers.</p>
        <p>There is no guarantee of consistency in the returned list. Tables
          created or deleted by other processes "during" the <c>ets:all()</c>
          call either are or are not included in the list. Only tables
          created/deleted <em>before</em> <c>ets:all()</c> is called are
          guaranteed to be included/excluded.</p>
      </desc>
    </func>

    <func>
      <name name="delete" arity="1" since=""/>
      <fsummary>Delete an entire ETS table.</fsummary>
      <desc>
        <p>Deletes the entire table <c><anno>Table</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="delete" arity="2" since=""/>
      <fsummary>Delete all objects with a specified key from an ETS
        table.</fsummary>
      <desc>
        <p>Deletes all objects with key <c><anno>Key</anno></c> from table
        <c><anno>Table</anno></c>. This function succeeds even if
	no objects with key <c><anno>Key</anno></c> exist.</p>
      </desc>
    </func>

    <func>
      <name name="delete_all_objects" arity="1" since=""/>
      <fsummary>Delete all objects in an ETS table.</fsummary>
      <desc>
        <p>Delete all objects in the ETS table <c><anno>Table</anno></c>.
          The operation is guaranteed to be
          <seeerl marker="#concurrency">atomic and isolated</seeerl>.</p>
      </desc>
    </func>

    <func>
      <name name="delete_object" arity="2" since=""/>
      <fsummary>Deletes a specific from an ETS table.</fsummary>
      <desc>
        <p>Delete the exact object <c><anno>Object</anno></c> from the
          ETS table,
          leaving objects with the same key but other differences
          (useful for type <c>bag</c>). In a <c>duplicate_bag</c> table, all
          instances of the object are deleted.</p>
      </desc>
    </func>

    <func>
      <name name="file2tab" arity="1" since=""/>
      <fsummary>Read an ETS table from a file.</fsummary>
      <desc>
        <p>Reads a file produced by <seemfa marker="#tab2file/2">
          <c>tab2file/2</c></seemfa> or 
          <seemfa marker="#tab2file/3"><c>tab2file/3</c></seemfa> and
          creates the corresponding table <c><anno>Table</anno></c>.</p>
        <p>Equivalent to <c>file2tab(<anno>Filename</anno>, [])</c>.</p>
      </desc>
    </func>

    <func>
      <name name="file2tab" arity="2" since=""/>
      <fsummary>Read an ETS table from a file.</fsummary>
      <desc>
        <p>Reads a file produced by <seemfa marker="#tab2file/2">
          <c>tab2file/2</c></seemfa> or <seemfa marker="#tab2file/3">
          <c>tab2file/3</c></seemfa> and creates the
          corresponding table <c><anno>Table</anno></c>.</p>
        <p>The only supported option is <c>{verify,boolean()}</c>.
          If verification is turned on (by specifying <c>{verify,true}</c>),
          the function uses whatever information is present in the file to
          assert that the information is not damaged. How this is done depends
          on which <c>extended_info</c> was written using 
          <seemfa marker="#tab2file/3"><c>tab2file/3</c></seemfa>.</p>
        <p>If no <c>extended_info</c> is present in the file and
          <c>{verify,true}</c> is specified, the number of objects
          written is compared to the size of the original table when the
          dump was started. This can make verification fail if the table was
          <c>public</c> and objects were added or removed while the
          table was dumped to file. To avoid this problem,
          either do not verify files dumped while updated simultaneously
          or use option <c>{extended_info, [object_count]}</c> to
          <seemfa marker="#tab2file/3"><c>tab2file/3</c></seemfa>, which
          extends the information in the file with the number of objects
          written.</p>
        <p>If verification is turned on and the file was written with
          option <c>{extended_info, [md5sum]}</c>, reading the file
          is slower and consumes radically more CPU time than otherwise.</p>
        <p><c>{verify,false}</c> is the default.</p>
      </desc>
    </func>

    <func>
      <name name="first" arity="1" since=""/>
      <fsummary>Return the first key in an ETS table.</fsummary>
      <desc>
        <p>Returns the first key <c><anno>Key</anno></c> in table
          <c><anno>Table</anno></c>. For an <c>ordered_set</c> table, the first
          key in Erlang term order is returned. For other
          table types, the first key according to the internal
          order of the table is returned. If the table is empty,
          <c>'$end_of_table'</c> is returned.</p>
        <p>To find subsequent keys in the table, use
          <seemfa marker="#next/2"><c>next/2</c></seemfa>.</p>
      </desc>
    </func>

    <func>
      <name name="foldl" arity="3" since=""/>
      <fsummary>Fold a function over an ETS table.</fsummary>
      <desc>
        <p><c><anno>Acc0</anno></c> is returned if the table is empty.
          This function is similar to
          <seemfa marker="lists#foldl/3"><c>lists:foldl/3</c></seemfa>.
          The table elements are traversed in an unspecified order, except for
          <c>ordered_set</c> tables, where they are traversed first to last.</p>
        <p>If <c><anno>Function</anno></c> inserts objects into the table,
          or another
          process inserts objects into the table, those objects <em>can</em>
          (depending on key ordering) be included in the traversal.</p>
      </desc>
    </func>

    <func>
      <name name="foldr" arity="3" since=""/>
      <fsummary>Fold a function over an ETS table.</fsummary>
      <desc>
        <p><c><anno>Acc0</anno></c> is returned if the table is empty.
          This function is similar to
          <seemfa marker="lists#foldr/3"><c>lists:foldr/3</c></seemfa>.
          The table elements are traversed in an unspecified order, except for
          <c>ordered_set</c> tables, where they are traversed last to first.</p>
        <p>If <c><anno>Function</anno></c> inserts objects into the table,
          or another
          process inserts objects into the table, those objects <em>can</em>
          (depending on key ordering) be included in the traversal.</p>
      </desc>
    </func>

    <func>
      <name name="from_dets" arity="2" since=""/>
      <fsummary>Fill an ETS table with objects from a Dets
        table.</fsummary>
      <desc>
        <p>Fills an already created ETS table with the objects in the
          already opened Dets table <c><anno>DetsTab</anno></c>.
          Existing objects in the ETS table are kept unless
          overwritten.</p>
        <p>If any of the tables does not exist or the Dets table is
          not open, a <c>badarg</c> exception is raised.</p>
      </desc>
    </func>

    <func>
      <name name="fun2ms" arity="1" since=""/>
      <fsummary>Pseudo function that transforms fun syntax to a match
        specification.</fsummary>
      <desc>
        <p>Pseudo function that by a <c>parse_transform</c> translates
          <c><anno>LiteralFun</anno></c> typed as parameter in the function
          call to a
          <seeerl marker="#match_spec">match specification</seeerl>.
          With "literal" is meant that the fun must textually be written
          as the parameter of the function, it cannot be held in a
          variable that in turn is passed to the function.</p>
        <p>The parse transform is provided in the <c>ms_transform</c>
          module and the source <em>must</em> include
          file <c>ms_transform.hrl</c> in STDLIB for this
          pseudo function to work. Failing to include the hrl file in
          the source results in a runtime error, not a compile
          time error. The include file is easiest included by adding line
          <c>-include_lib("stdlib/include/ms_transform.hrl").</c> to
          the source file.</p>
        <p>The fun is very restricted, it can take only a single
          parameter (the object to match): a sole variable or a
          tuple. It must use the <c>is_</c> guard tests.
          Language constructs that have no representation in a match
          specification (<c>if</c>, <c>case</c>, <c>receive</c>,
          and so on) are not allowed.</p>
        <p>The return value is the resulting match specification.</p>
        <p><em>Example:</em></p>
        <pre>
1> <input>ets:fun2ms(fun({M,N}) when N > 3 -> M end).</input>
[{{'$1','$2'},[{'>','$2',3}],['$1']}]</pre>
        <p>Variables from the environment can be imported, so that the
          following works:</p>
        <pre>
2> <input>X=3.</input>
3
3> <input>ets:fun2ms(fun({M,N}) when N > X -> M end).</input>
[{{'$1','$2'},[{'>','$2',{const,3}}],['$1']}]</pre>
        <p>The imported variables are replaced by match specification
          <c>const</c> expressions, which is consistent with the
          static scoping for Erlang funs. However, local or global function
          calls cannot be in the guard or body of the fun. Calls to built-in
          match specification functions is of course allowed:</p>
        <pre>
4> <input>ets:fun2ms(fun({M,N}) when N > X, my_fun(M) -> M end).</input>
Error: fun containing local Erlang function calls
('my_fun' called in guard) cannot be translated into match_spec
{error,transform_error}
5> <input>ets:fun2ms(fun({M,N}) when N > X, is_atom(M) -> M end).</input>
[{{'$1','$2'},[{'>','$2',{const,3}},{is_atom,'$1'}],['$1']}]</pre>
        <p>As shown by the example, the function can be called
          from the shell also. The fun must be literally in the call
          when used from the shell as well.</p>
        <warning>
          <p>If the <c>parse_transform</c> is not applied to a module that
            calls this pseudo function, the call fails in runtime
            (with a <c>badarg</c>). The <c>ets</c> module
            exports a function with this name, but it is never to
            be called except when using the function in the
            shell. If the <c>parse_transform</c> is properly applied by
            including header file <c>ms_transform.hrl</c>, compiled
            code never calls the function, but the function call is
            replaced by a literal match specification.</p>
        </warning>
        <p>For more information, see <seeerl marker="ms_transform#top">
          <c>ms_transform(3)</c></seeerl>.</p>
      </desc>
    </func>

    <func>
      <name name="give_away" arity="3" since=""/>
      <fsummary>Change owner of a table.</fsummary>
      <desc>
        <p>Make process <c><anno>Pid</anno></c> the new owner of table
          <c><anno>Table</anno></c>. If successful, message
          <c>{'ETS-TRANSFER',<anno>Table</anno>,FromPid,<anno>GiftData</anno>}</c>
          is sent to the new owner.</p>
        <p>The process <c><anno>Pid</anno></c> must be alive, local, and not
          already the owner of the table.
          The calling process must be the table owner.</p>
        <p>Notice that this function does not affect option
          <seeerl marker="#heir"><c>heir</c></seeerl> of the table. A table
          owner can, for example, set <c>heir</c> to itself, give the table
          away, and then get it back if the receiver terminates.</p>
      </desc>
    </func>

    <func>
      <name name="i" arity="0" since=""/>
      <fsummary>Display information about all ETS tables on a terminal.
      </fsummary>
      <desc>
        <p>Displays information about all ETS tables on a terminal.</p>
      </desc>
    </func>

    <func>
      <name name="i" arity="1" since=""/>
      <fsummary>Browse an ETS table on a terminal.</fsummary>
      <desc>
        <p>Browses table <c><anno>Table</anno></c> on a terminal.</p>
      </desc>
    </func>

    <func>
      <name name="info" arity="1" since=""/>
      <fsummary>Return information about an <c>table</c>.</fsummary>
      <desc>
        <p>Returns information about table <c><anno>Table</anno></c> as a list of
          tuples. If <c><anno>Table</anno></c> has the correct type
          for a table identifier, but does not refer to an existing ETS
          table, <c>undefined</c> is returned. If <c><anno>Table</anno></c> is
          not of the correct type, a <c>badarg</c> exception is raised.</p>
        <taglist>
          <tag><c>{compressed, boolean()}</c></tag>
          <item>
            <p>Indicates if the table is compressed.</p>
          </item>
          <tag><c>{decentralized_counters, boolean()}</c></tag>
          <item>
            <p>Indicates whether the table uses <c>decentralized_counters</c>.</p>
          </item>
          <tag><c>{heir, pid() | none}</c></tag>
          <item>
            <p>The pid of the heir of the table, or <c>none</c> if no heir
              is set.</p>
          </item>
          <tag><c>{id,</c><seetype marker="#tid">
              <c>tid()</c></seetype><c>}</c></tag>
          <item>
            <p>The table identifier.</p>
          </item>
          <tag><c>{keypos, integer() >= 1}</c></tag>
          <item>
            <p>The key position.</p>
          </item>
          <tag><c>{memory, integer() >= 0}</c></tag>
          <item>
            <p>The number of words allocated to the table.</p>
          </item>
          <tag><c>{name, atom()}</c></tag>
          <item>
            <p>The table name.</p>
          </item>
          <tag><c>{named_table, boolean()}</c></tag>
          <item>
            <p>Indicates if the table is named.</p>
          </item>
          <tag><c>{node, node()}</c></tag>
          <item>
            <p>The node where the table is stored. This field is no longer
              meaningful, as tables cannot be accessed from other nodes.</p>
          </item>
          <tag><c>{owner, pid()}</c></tag>
          <item>
            <p>The pid of the owner of the table.</p>
          </item>
          <tag><c>{protection,</c> <seetype marker="#table_access">
              <c>access()</c></seetype><c>}</c></tag>
          <item>
            <p>The table access rights.</p>
          </item>
          <tag><c>{size, integer() >= 0}</c></tag>
          <item>
            <p>The number of objects inserted in the table.</p>
          </item>
          <tag><c>{type,</c> <seetype marker="#table_type">
              <c>type()</c></seetype><c>}</c></tag>
          <item>
            <p>The table type.</p>
          </item>
          <tag><c>{read_concurrency, boolean()}</c></tag>
          <item>
            <p>Indicates whether the table uses <c>read_concurrency</c> or
              not.</p>
          </item>
          <tag><c>{write_concurrency, WriteConcurrencyAlternative}</c></tag>
          <item>
            <p>Indicates which <c>write_concurrency</c> option the table uses.</p>
          </item>
        </taglist>
	<note><p>The execution time of this function is affected by
          the <seeerl marker="#new_2_decentralized_counters">
          <c>decentralized_counters</c></seeerl> table option.
          The execution time is much longer when the <c>decentralized_counters</c>
          option is set to <c>true</c> than when the <c>decentralized_counters</c>
          option is set to <c>false</c>.</p>
	</note>
      </desc>
    </func>

    <func>
      <name name="info" arity="2" since=""/>
      <fsummary>Return the information associated with the specified item for
        an ETS table.</fsummary>
      <desc>
        <p>Returns the information associated with <c>Item</c> for table
          <c><anno>Table</anno></c>, or returns <c>undefined</c> if <c>Table</c>
          does not refer an existing ETS table. If
          <c><anno>Table</anno></c> is
          not of the correct type, or if <c><anno>Item</anno></c> is not
          one of the allowed values, a <c>badarg</c> exception is raised.</p>
          <p>In addition to the <c>{<anno>Item</anno>,<anno>Value</anno>}</c>
            pairs defined for <seemfa marker="#info/1"><c>info/1</c></seemfa>,
            the following items are allowed:</p>
        <list type="bulleted">
          <item>
            <p><c>Item=binary, Value=BinInfo</c></p>
	    <p><c>BinInfo</c> is a list containing miscellaneous
              information about binaries kept by the table.
              This <c><anno>Item</anno></c> can be changed or removed without
	      prior notice. In the current implementation <c>BinInfo</c> is a
	      list of tuples <c>{BinaryId,BinarySize,BinaryRefcCount}</c>.</p>
          </item>
          <item>
            <p><c>Item=fixed, Value=boolean()</c></p>
            <p>Indicates if the table is fixed by any process.</p>
          </item>
          <item>
            <p><marker id="info_2_safe_fixed_monotonic_time"/></p>
            <p><c>Item=safe_fixed|safe_fixed_monotonic_time,
              Value={FixationTime,Info}|false</c></p>
            <p>If the table is fixed using
              <seemfa marker="#safe_fixtable/2">
              <c>safe_fixtable/2</c></seemfa>,
              the call returns a tuple where <c>FixationTime</c> is the
              last time when the table changed from unfixed to fixed.</p>
            <p>The format and value of <c>FixationTime</c> depends on
              <c>Item</c>:</p>
            <taglist>
              <tag><c>safe_fixed</c></tag>
              <item>
                <p><c>FixationTime</c> corresponds to the result returned by
                  <seemfa marker="erts:erlang#timestamp/0">
                  <c>erlang:timestamp/0</c></seemfa> at the time of fixation.
                  Notice that when the system uses single or multi
                  <seeguide marker="erts:time_correction#Time_Warp_Modes">time
                  warp modes</seeguide> this can produce strange results, as
                  the use of <c>safe_fixed</c> is not
                  <seeguide marker="erts:time_correction#Time_Warp_Safe_Code">
                  time warp safe</seeguide>. Time warp safe code must use
                  <c>safe_fixed_monotonic_time</c> instead.</p>
              </item>
              <tag><c>safe_fixed_monotonic_time</c></tag>
              <item>
                <p><c>FixationTime</c> corresponds to the result returned by
                  <seemfa marker="erts:erlang#monotonic_time/0">
                  <c>erlang:monotonic_time/0</c></seemfa> at the time of
                  fixation. The use of <c>safe_fixed_monotonic_time</c> is
                  <seeguide marker="erts:time_correction#Time_Warp_Safe_Code">
                  time warp safe</seeguide>.</p>
              </item>
            </taglist>
            <p><c>Info</c> is a possibly empty lists of tuples
              <c>{Pid,RefCount}</c>, one tuple for every process the
              table is fixed by now. <c>RefCount</c> is the value
              of the reference counter and it keeps track of how many times
              the table has been fixed by the process.</p>
	    <p>Table fixations are not limited to <seemfa marker="#safe_fixtable/2">
	      <c>safe_fixtable/2</c></seemfa>. Temporary fixations may also
	      be done by for example <seeerl marker="#traversal">traversing
	      functions</seeerl> like <c>select</c> and <c>match</c>. Such
	      table fixations are automatically released before the
	      corresponding functions returns, but they may be seen by a
	      concurrent call to
	      <c>ets:info(T,safe_fixed|safe_fixed_monotonic_time)</c>.</p>
            <p>If the table is not fixed at all, the call returns <c>false</c>.</p>
          </item>
          <item>
            <p><c>Item=stats, Value=tuple()</c></p>
            <p>Returns internal statistics about tables on an internal format
	    used by OTP test suites. Not for production use.</p></item>
        </list>
        <note>
         <p>The execution time of this function is affected by
          the <seeerl marker="#new_2_decentralized_counters">
          <c>decentralized_counters</c></seeerl> table option when the second
          argument of the function is <c>size</c> or <c>memory</c>.
          The execution time is much longer when the <c>decentralized_counters</c>
          option is set to <c>true</c> than when the <c>decentralized_counters</c>
          option is set to <c>false</c>.</p>
	</note>
      </desc>
    </func>

    <func>
      <name name="init_table" arity="2" since=""/>
      <fsummary>Replace all objects of an ETS table.</fsummary>
      <desc>
        <p>Replaces the existing objects of table <c><anno>Table</anno></c> with
          objects created by calling the input function
          <c><anno>InitFun</anno></c>,
          see below. This function is provided for compatibility with
          the <c>dets</c> module, it is not more efficient than filling
          a table by using
          <seemfa marker="#insert/2"><c>insert/2</c></seemfa>.</p>
        <p>When called with argument <c>read</c>, the function
          <c><anno>InitFun</anno></c> is assumed to return
          <c>end_of_input</c> when
          there is no more input, or <c>{<anno>Objects</anno>, Fun}</c>, where
          <c><anno>Objects</anno></c> is a list of objects and <c>Fun</c> is a
          new input function. Any other value <c>Value</c> is returned as an
          error <c>{error, {init_fun, Value}}</c>. Each input function is
          called exactly once, and if an error occur, the last
          function is called with argument <c>close</c>, the reply
          of which is ignored.</p>
        <p>If the table type is <c>set</c> and more than one object
          exists with a given key, one of the objects is
          chosen. This is not necessarily the last object with the given
          key in the sequence of objects returned by the input
          functions. This holds also for duplicated
          objects stored in tables of type <c>bag</c>.</p>
      </desc>
    </func>

    <func>
      <name name="insert" arity="2" since=""/>
      <fsummary>Insert an object into an ETS table.</fsummary>
      <desc>
        <p>Inserts the object or all of the objects in list
          <c><anno>ObjectOrObjects</anno></c> into table
          <c><anno>Table</anno></c>.</p>
        <list type="bulleted">
          <item>
            <p>If the table type is <c>set</c> and the key of the inserted
              objects <em>matches</em> the key of any object in the table,
              the old object is replaced.</p>
          </item>
          <item>
            <p>If the table type is <c>ordered_set</c> and the key of the
              inserted object <em>compares equal</em> to the key of any object
              in the table, the old object is replaced.</p>
          </item>
          <item>
            <p>
	      If the table type is <c>bag</c> and the object <em>matches</em>
	      any whole object in the table, the object is not inserted.
            </p>
          </item>
          <item>
            <p>If the list contains more than one object with
              <em>matching</em> keys and the table type is <c>set</c>, one is
              inserted, which one is not defined.
              The same holds for table type <c>ordered_set</c>
              if the keys <em>compare equal</em>.</p>
          </item>
        </list>
        <p>The entire operation is guaranteed to be
          <seeerl marker="#concurrency">atomic and isolated</seeerl>,
          even when a list of objects is inserted.</p>
        <marker id="insert_list_order"></marker>
        <p>
	  For <c>bag</c> and <c>duplicate_bag</c>, objects in the list with
	  identical keys will be inserted in list order (from head to tail). That
	  is, a subsequent call to <seemfa marker="#lookup/2"><c>lookup(T,Key)</c></seemfa>
	  will return them in that inserted order.
        </p>
	<note>
	  <p>
	    For <c>bag</c> the insertion order of indentical keys described above was
	    accidentally reverted in OTP 23.0 and later fixed in OTP 25.3. That
	    is, from OTP 23.0 up until OTP 25.3 the objects in a list are
	    inserted in reverse order (from tail to head).
          </p>
	  <p>
	    For <c>duplicate_bag</c> the same faulty reverse insertion exist
	    from OTP 23.0 until OTP 25.3. However, it is unpredictable and may
	    or may not happen. A longer list will increase the probabiliy of the
	    insertion being done in reverse.
          </p>
        </note>
      </desc>
    </func>

    <func>
      <name name="insert_new" arity="2" since=""/>
      <fsummary>Insert an object into an ETS table if the key is not
        already present.</fsummary>
      <desc>
        <p>Same as <seemfa marker="#insert/2"><c>insert/2</c></seemfa>
          except that instead of overwriting objects with the same key
          (for <c>set</c> or <c>ordered_set</c>) or adding more objects with
          keys already existing in the table (for <c>bag</c> and
          <c>duplicate_bag</c>), <c>false</c> is returned.</p>
        <p>If <c><anno>ObjectOrObjects</anno></c> is a
          list, the function checks <em>every</em> key before
          inserting anything. Nothing is inserted unless
          <em>all</em> keys present in the list are absent from the
          table. Like <c>insert/2</c>, the entire operation is guaranteed to be
          <seeerl marker="#concurrency">atomic and isolated</seeerl>.</p>
      </desc>
    </func>

    <func>
      <name name="is_compiled_ms" arity="1" since=""/>
      <fsummary>Check if an Erlang term is the result of
        <c>match_spec_compile</c>.</fsummary>
      <desc>
        <p>Checks if a term represent a valid compiled
	  <seeerl marker="#match_spec">match specification</seeerl>.
          A compiled match specification is only valid on the Erlang node where
	  it was compiled by calling <seemfa marker="#match_spec_compile/1">
	  <c>match_spec_compile/1</c></seemfa>.</p>
        <note>
          <p>
	    Before STDLIB 3.4 (OTP 20.0) compiled match specifications did
	    not have an external representation. If passed through
	    <c>binary_to_term(term_to_binary(CMS))</c> or sent to another node
	    and back, the result was always an empty binary <c>&lt;&lt;>></c>.</p>
	  <p>
	    After STDLIB 3.4 (OTP 20.0) compiled match specifications have an
	    external representation as a node specific reference to the original
	    compiled match specification. If passed through
	    <c>binary_to_term(term_to_binary(CMS))</c> or sent to another node
	    and back, the result <em>may or may not</em> be a valid compiled match
	    specification depending on if the original compiled match
	    specification was still alive.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="last" arity="1" since=""/>
      <fsummary>Return the last key in an ETS table of type
        <c>ordered_set</c>.</fsummary>
      <desc>
        <p>Returns the last key <c><anno>Key</anno></c> according to Erlang
          term order in table <c>Table</c> of type <c>ordered_set</c>. For
          other table types, the function is synonymous to
          <seemfa marker="#first/1"><c>first/1</c></seemfa>.
          If the table is empty, <c>'$end_of_table'</c> is returned.</p>
        <p>To find preceding keys in the table, use
          <seemfa marker="#prev/2"><c>prev/2</c></seemfa>.</p>
      </desc>
    </func>

    <func>
      <name name="lookup" arity="2" since=""/>
      <fsummary>Return all objects with a specified key in an ETS table.
      </fsummary>
      <desc>
        <p>Returns a list of all objects with key <c><anno>Key</anno></c> in
          table <c><anno>Table</anno></c>.</p>
        <list type="bulleted">
          <item>
            <p>For tables of type <c>set</c>, <c>bag</c>, or
              <c>duplicate_bag</c>, an object is returned only if the specified
              key <em>matches</em> the key of the object in the table.</p>
          </item>
          <item>
            <p>For tables of type <c>ordered_set</c>, an object is returned if
              the specified key <em>compares equal</em> to the key of an object
              in the table.</p>
          </item>
        </list>
        <p>The difference is the same as between <c>=:=</c> and <c>==</c>.</p>
        <p>As an example, one can insert an object with
          <c>integer()</c> <c>1</c> as a key in an <c>ordered_set</c>
          and get the object returned as a result of doing a <c>lookup/2</c>
          with <c>float()</c> <c>1.0</c> as the key to search for.</p>
        <p>For tables of type <c>set</c> or <c>ordered_set</c>,
          the function returns either the empty list or a list with one
          element, as there cannot be more than one object with the same
          key. For tables of type <c>bag</c> or <c>duplicate_bag</c>, the
          function returns a list of arbitrary length.</p>
        <p>Notice that the sequential order of object insertions is preserved;
          the first object inserted with the specified key is the first
          in the resulting list, and so on. See also the note about
          <seeerl marker="#insert_list_order">list insertion order</seeerl>.
        </p>
      </desc>
    </func>

    <func>
      <name name="lookup_element" arity="3" since=""/>
      <fsummary>Return the <c>Pos</c>:th element of all objects with a
        specified key in an ETS table.</fsummary>
      <desc>
        <p>For a table <c><anno>Table</anno></c> of type <c>set</c> or
          <c>ordered_set</c>, the function returns the
          <c><anno>Pos</anno></c>:th
          element of the object with key <c><anno>Key</anno></c>.</p>
        <p>For tables of type <c>bag</c> or <c>duplicate_bag</c>,
          the functions returns a list with the <c><anno>Pos</anno></c>:th
          element of every object with key <c><anno>Key</anno></c>.</p>
        <p>If no object with key <c><anno>Key</anno></c> exists, the
          function exits with reason <c>badarg</c>.</p>
        <p>If <c><anno>Pos</anno></c> is larger than the size of the tuple,
          the function exits with reason <c>badarg</c>.</p>
        <p>The difference between <c>set</c>, <c>bag</c>, and
          <c>duplicate_bag</c> on one hand, and <c>ordered_set</c> on
          the other, regarding the fact that <c>ordered_set</c>
          view keys as equal when they <em>compare equal</em>
          whereas the other table types regard them equal only when
          they <em>match</em>, holds for <c>lookup_element/3</c>.</p>
      </desc>
    </func>

    <func>
      <name name="lookup_element" arity="4" since="OTP 26.0"/>
      <fsummary>Return the <c>Pos</c>:th element of all objects with a
        specified key in an ETS table, or <c>Default</c> if there is no such object.</fsummary>
      <desc>
        <p>For a table <c><anno>Table</anno></c> of type <c>set</c> or
          <c>ordered_set</c>, the function returns the
          <c><anno>Pos</anno></c>:th
          element of the object with key <c><anno>Key</anno></c>.</p>
        <p>For tables of type <c>bag</c> or <c>duplicate_bag</c>,
          the functions returns a list with the <c><anno>Pos</anno></c>:th
          element of every object with key <c><anno>Key</anno></c>.</p>
        <p>If no object with key <c><anno>Key</anno></c> exists, the
          function returns <c><anno>Default</anno></c>.</p>
        <p>If <c><anno>Pos</anno></c> is larger than the size of
          any tuple with a matching key, the function exits with
          reason <c>badarg</c>.</p>
        <p>The difference between <c>set</c>, <c>bag</c>, and
          <c>duplicate_bag</c> on one hand, and <c>ordered_set</c> on
          the other, regarding the fact that <c>ordered_set</c>
          view keys as equal when they <em>compare equal</em>
          whereas the other table types regard them equal only when
          they <em>match</em>, holds for <c>lookup_element/4</c>.</p>
      </desc>
    </func>

    <func>
      <name name="match" arity="1" since=""/>
      <fsummary>Continues matching objects in an ETS table.</fsummary>
      <desc>
        <p>Continues a match started with
          <seemfa marker="#match/3"><c>match/3</c></seemfa>. The next
          chunk of the size specified in the initial <c>match/3</c>
          call is returned together with a new <c><anno>Continuation</anno></c>,
          which can be used in subsequent calls to this function.</p>
        <p>When there are no more objects in the table, <c>'$end_of_table'</c>
          is returned.</p>
      </desc>
    </func>

    <func>
      <name name="match" arity="2" since=""/>
      <fsummary>Match the objects in an ETS table against a pattern.
      </fsummary>
      <desc>
        <p>Matches the objects in table <c><anno>Table</anno></c> against
          pattern <c><anno>Pattern</anno></c>.</p>
        <p>A pattern is a term that can contain:</p>
        <list type="bulleted">
          <item>Bound parts (Erlang terms)</item>
          <item><c>'_'</c> that matches any Erlang term</item>
          <item>Pattern variables <c>'$N'</c>, where <c>N</c>=0,1,...</item>
        </list>
        <p>The function returns a list with one element for each
          matching object, where each element is an ordered list of
          pattern variable bindings, for example:</p>
        <pre>
6> <input>ets:match(T, '$1').</input> % Matches every object in table
[[{rufsen,dog,7}],[{brunte,horse,5}],[{ludde,dog,5}]]
7> <input>ets:match(T, {'_',dog,'$1'}).</input>
[[7],[5]]
8> <input>ets:match(T, {'_',cow,'$1'}).</input>
[]</pre>
        <p>If the key is specified in the pattern, the match is very
          efficient. If the key is not specified, that is, if it is a
          variable or an underscore, the entire table must be searched.
          The search time can be substantial if the table is very large.</p>
        <p>For tables of type <c>ordered_set</c>, the result is in
          the same order as in a <c>first</c>/<c>next</c> traversal.</p>
      </desc>
    </func>

    <func>
      <name name="match" arity="3" since=""/>
      <fsummary>Match the objects in an ETS table against a pattern
        and return part of the answers.</fsummary>
      <desc>
        <p>Works like <seemfa marker="#match/2"><c>match/2</c></seemfa>, 
          but returns only a limited (<c><anno>Limit</anno></c>) number of
          matching objects. Term <c><anno>Continuation</anno></c> can then
          be used in subsequent calls to <seemfa marker="#match/1">
          <c>match/1</c></seemfa> to get the next chunk of matching
          objects. This is a space-efficient way to work on objects in a
          table, which is faster than traversing the table object
          by object using
          <seemfa marker="#first/1"><c>first/1</c></seemfa> and
          <seemfa marker="#next/2"><c>next/2</c></seemfa>.</p>
        <p>If the table is empty, <c>'$end_of_table'</c> is returned.</p>
	<p>Use <seemfa marker="#safe_fixtable/2"><c>safe_fixtable/2</c></seemfa>
	  to guarantee <seeerl marker="#traversal">safe traversal</seeerl>
	  for subsequent calls to <seemfa marker="#match/1"><c>match/1</c></seemfa>.</p>
      </desc>
    </func>

    <func>
      <name name="match_delete" arity="2" since=""/>
      <fsummary>Delete all objects that match a specified pattern from an
        ETS table.</fsummary>
      <desc>
        <p>Deletes all objects that match pattern <c><anno>Pattern</anno></c>
          from table <c><anno>Table</anno></c>. For a description of patterns,
          see <seemfa marker="#match/2"><c>match/2</c></seemfa>.</p>
      </desc>
    </func>

    <func>
      <name name="match_object" arity="1" since=""/>
      <fsummary>Continues matching objects in an ETS table.</fsummary>
      <desc>
        <p>Continues a match started with
          <seemfa marker="#match_object/3"><c>match_object/3</c></seemfa>.
          The next chunk of the size specified in the initial
          <c>match_object/3</c> call is returned together with a new
          <c><anno>Continuation</anno></c>, which can be used in subsequent
          calls to this function.</p>
        <p>When there are no more objects in the table, <c>'$end_of_table'</c>
          is returned.</p>
      </desc>
    </func>

    <func>
      <name name="match_object" arity="2" since=""/>
      <fsummary>Match the objects in an ETS table against a pattern.
      </fsummary>
      <desc>
        <p>Matches the objects in table <c><anno>Table</anno></c> against
          pattern <c><anno>Pattern</anno></c>. For a description of patterns,
          see <seemfa marker="#match/2"><c>match/2</c></seemfa>.
          The function returns a list of all objects that
          match the pattern.</p>
        <p>If the key is specified in the pattern, the match is very
          efficient. If the key is not specified, that is, if it is a
          variable or an underscore, the entire table must be searched.
          The search time can be substantial if the table is very large.</p>
        <p>For tables of type <c>ordered_set</c>, the result is in
          the same order as in a <c>first</c>/<c>next</c> traversal.</p>
      </desc>
    </func>

    <func>
      <name name="match_object" arity="3" since=""/>
      <fsummary>Match the objects in an ETS table against a pattern and
        return part of the answers.</fsummary>
      <desc>
        <p>Works like <seemfa marker="#match_object/2">
          <c>match_object/2</c></seemfa>, but only returns a
          limited (<c><anno>Limit</anno></c>) number of matching objects. Term
          <c><anno>Continuation</anno></c> can then be used in subsequent
          calls to <seemfa marker="#match_object/1">
          <c>match_object/1</c></seemfa> to get the next chunk of matching
          objects. This is a space-efficient way to work on objects in a
          table, which is faster than traversing the table object
          by object using
          <seemfa marker="#first/1"><c>first/1</c></seemfa> and
          <seemfa marker="#next/2"><c>next/2</c></seemfa>.</p>
        <p>If the table is empty, <c>'$end_of_table'</c> is returned.</p>
	<p>Use <seemfa marker="#safe_fixtable/2"><c>safe_fixtable/2</c></seemfa>
	  to guarantee <seeerl marker="#traversal">safe traversal</seeerl>
	  for subsequent calls to <seemfa marker="#match_object/1">
	  <c>match_object/1</c></seemfa>.</p>
      </desc>
    </func>

    <func>
      <name name="match_spec_compile" arity="1" since=""/>
      <fsummary>Compile a match specification into its internal representation.
      </fsummary>
      <desc>
        <p>Transforms a
          <seeerl marker="#match_spec">match specification</seeerl> into an
          internal representation that can be used in subsequent calls to
          <seemfa marker="#match_spec_run/2"><c>match_spec_run/2</c></seemfa>.
          The internal representation is opaque.
          To check the validity of a compiled match specification, use
          <seemfa marker="#is_compiled_ms/1"><c>is_compiled_ms/1</c></seemfa>.
        </p>
        <p>If term <c><anno>MatchSpec</anno></c> does not represent a valid
	match specification, a <c>badarg</c> exception is raised.</p>
        <note>
          <p>This function has limited use in normal code. It is used by the
            <seeerl marker="dets"><c>dets</c></seeerl> module
            to perform the <c>dets:select()</c> operations.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="match_spec_run" arity="2" since=""/>
      <fsummary>Perform matching, using a compiled match specification on a
        list of terms.</fsummary>
      <desc>
        <p>Executes the matching specified in a compiled
          <seeerl marker="#match_spec">match specification</seeerl> on a list
          of terms. Term <c><anno>CompiledMatchSpec</anno></c> is to be
          the result of a call to <seemfa marker="#match_spec_compile/1">
          <c>match_spec_compile/1</c></seemfa> and is hence the internal
          representation of the match specification one wants to use.</p>
        <p>The matching is executed on each element in <c><anno>List</anno></c>
          and the function returns a list containing all results. If an element
          in <c><anno>List</anno></c> does not match, nothing is returned
          for that element. The length of the result list is therefore
          equal or less than the length of parameter <c><anno>List</anno></c>.
        </p>
        <p><em>Example:</em></p>
        <p>The following two calls give the same result (but certainly not the
          same execution time):</p>
        <code type="none">
Table = ets:new...
MatchSpec = ...
% The following call...
ets:match_spec_run(ets:tab2list(Table),
                   ets:match_spec_compile(MatchSpec)),
% ...gives the same result as the more common (and more efficient)
ets:select(Table, MatchSpec),</code>
        <note>
          <p>This function has limited use in normal code. It is used by the
            <seeerl marker="dets"><c>dets</c></seeerl> module
            to perform the <c>dets:select()</c> operations and by
            Mnesia during transactions.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="member" arity="2" since=""/>
      <fsummary>Tests for occurrence of a key in an ETS table.</fsummary>
      <desc>
        <p>Works like <seemfa marker="#lookup/2"><c>lookup/2</c></seemfa>,
          but does not return the objects. Returns <c>true</c> if one or more
          elements in the table has key <c><anno>Key</anno></c>, otherwise
          <c>false</c>.</p>
      </desc>
    </func>

    <func>
      <name name="new" arity="2" since=""/>
      <fsummary>Create a new ETS table.</fsummary>
      <desc>
        <p>Creates a new table and returns a table identifier that can
          be used in subsequent operations. The table identifier can be
          sent to other processes so that a table can be shared between
          different processes within a node.</p>
        <p>Parameter <c><anno>Options</anno></c> is a list of options that
          specifies table type, access rights, key position, and whether the
          table is named. Default values are used for omitted options.
          This means that not specifying any options (<c>[]</c>) is the same
          as specifying <c>[set, protected, {keypos,1}, {heir,none},
          {write_concurrency,false}, {read_concurrency,false},
          {decentralized_counters,false}]</c>.</p>
        <taglist>
          <tag><c>set</c></tag>
          <item>
            <p>The table is a <c>set</c> table: one key, one object,
              no order among objects. This is the default table type.</p>
          </item>
          <tag><c>ordered_set</c></tag>
          <item>
            <p>The table is a <c>ordered_set</c> table: one key, one
              object, ordered in Erlang term order, which is the order
              implied by the &lt; and &gt; operators. Tables of this type
              have a somewhat different behavior in some situations
              than tables of other types. Most notably, the
              <c>ordered_set</c> tables regard keys as equal when they
              <em>compare equal</em>, not only when they match. This
              means that to an <c>ordered_set</c> table, <c>integer()</c>
              <c>1</c> and <c>float()</c> <c>1.0</c> are regarded as equal.
              This also means that the
              key used to lookup an element does not necessarily
              <em>match</em> the key in the returned elements, if
              <c>float()</c>'s and <c>integer()</c>'s are mixed in
              keys of a table.</p>
          </item>
          <tag><c>bag</c></tag>
          <item>
            <p>The table is a <c>bag</c> table, which can have many
              objects, but only one instance of each object, per key.</p>
          </item>
          <tag><c>duplicate_bag</c></tag>
          <item>
            <p>The table is a <c>duplicate_bag</c> table, which can have
              many objects, including multiple copies of the same
              object, per key.</p>
          </item>
          <tag><c>public</c></tag>
          <item>
            <p>Any process can read or write to the table.</p>
            <marker id="protected"></marker>
          </item>
          <tag><c>protected</c></tag>
          <item>
            <p>The owner process can read and write to the table. Other
              processes can only read the table. This is the default
              setting for the access rights.</p>
            <marker id="private"></marker>
          </item>
          <tag><c>private</c></tag>
          <item>
            <p>Only the owner process can read or write to the table.</p>
          </item>
          <tag><c>named_table</c></tag>
          <item>
            <p>If this option is present, the table is registered under its
              <c><anno>Name</anno></c> which can then be used instead of the
              table identifier in subsequent operations.</p>
            <p>The function will also return the <c><anno>Name</anno></c>
              instead of the table identifier. To get the table identifier of a
              named table, use
              <seemfa marker="#whereis/1"><c>whereis/1</c></seemfa>.</p>
          </item>
          <tag><c>{keypos,<anno>Pos</anno>}</c></tag>
          <item>
            <p>Specifies which element in the stored tuples to use
              as key. By default, it is the first element, that is,
              <c><anno>Pos</anno>=1</c>. However, this is not always
              appropriate. In
              particular, we do not want the first element to be the
              key if we want to store Erlang records in a table.</p>
            <p>Notice that any tuple stored in the table must have at
              least <c><anno>Pos</anno></c> number of elements.</p>
            <marker id="heir"></marker>
          </item>
          <tag><c>{heir,<anno>Pid</anno>,<anno>HeirData</anno>} |
              {heir,none}</c></tag>
          <item>
            <p>Set a process as heir. The heir inherits the table if
              the owner terminates. Message
              <c>{'ETS-TRANSFER',tid(),FromPid,<anno>HeirData</anno>}</c> is
              sent to the heir when that occurs. The heir must be a local
              process. Default heir is <c>none</c>, which destroys the table
              when the owner terminates.</p>
            <marker id="new_2_write_concurrency"></marker>
          </item>
          <tag><c>{write_concurrency,WriteConcurrencyAlternative}</c></tag>
          <item>
            <p>Performance tuning. Defaults to <c>false</c>, in which case an
              operation that
              mutates (writes to) the table obtains exclusive access,
              blocking any concurrent access of the same table until finished.
              If set to <c>true</c>, the table is optimized for concurrent
              write access. Different objects of the same table can be mutated
              (and read) by concurrent processes. This is achieved to some
              degree at the expense of memory consumption and the performance
              of sequential access and concurrent reading.</p>
            <p>The <c>auto</c> alternative for the
            <c>write_concurrency</c> option is similar to the
            <c>true</c> option but automatically adjusts the
            synchronization granularity during runtime depending on how the
            table is used. This is the recommended
            <c>write_concurrency</c> option when using Erlang/OTP 25
            and above as it performs well in most scenarios.</p>
              <p>The <c>write_concurrency</c> option can be combined with the options
              <seeerl marker="#new_2_read_concurrency">
              <c>read_concurrency</c></seeerl> and
              <seeerl marker="#new_2_decentralized_counters">
              <c>decentralized_counters</c></seeerl>. You typically want to combine
              <c>write_concurrency</c> with <c>read_concurrency</c> when large
              concurrent read bursts and large concurrent
              write bursts are common; for more information, see option
              <seeerl marker="#new_2_read_concurrency">
              <c>read_concurrency</c></seeerl>. It is almost always a
              good idea to combine the <c>write_concurrency</c> option
              with the
              <seeerl marker="#new_2_decentralized_counters">
              <c>decentralized_counters</c></seeerl> option.</p>
            <p>Notice that this option does not change any guarantees about
              <seeerl marker="#concurrency">atomicity and isolation</seeerl>.
              Functions that makes such promises over many objects (like
              <seemfa marker="#insert/2"><c>insert/2</c></seemfa>)
              gain less (or nothing) from this option.</p>
            <p>The memory consumption inflicted by both
            <c>write_concurrency</c> and <c>read_concurrency</c> is a
            constant overhead per table for <c>set</c>, <c>bag</c> and
            <c>duplicate_bag</c> when the <c>true</c> alternative for
            the <c>write_concurrency</c> option is not used. For
            all tables with the <c>auto</c> alternative and <c>ordered_set</c>
            tables with <c>true</c> alternative the
            memory overhead depends on the amount of actual detected concurrency during
            runtime. The memory overhead can be especially large when
            both <c>write_concurrency</c> and <c>read_concurrency</c> are combined.</p>
	    <note>
              <p>Prior to stdlib-3.7 (OTP-22.0) <c>write_concurrency</c> had no
	      effect on <c>ordered_set</c>.</p>
            </note>
            <note>
              <p>The <c>auto</c> alternative for the <c>write_concurrency</c>
              option is only available in OTP-25.0 and above.</p>
            </note>
            <marker id="new_2_read_concurrency"></marker>
          </item>
          <tag since="OTP R14B"><c>{read_concurrency,boolean()}</c></tag>
          <item>
            <p>Performance tuning. Defaults to <c>false</c>. When set to
              <c>true</c>, the table is optimized for concurrent read
              operations. When this option is enabled read operations
	      become much cheaper; especially on
              systems with multiple physical processors. However, switching
              between read and write operations becomes more expensive.</p>
            <p>You typically want to enable this option when concurrent read
              operations are much more frequent than write operations, or when
              concurrent reads and writes comes in large read and write bursts
              (that is, many reads not interrupted by writes, and many
              writes not interrupted by reads).</p>
            <p>You typically do
              <em>not</em> want to enable this option when the common access
              pattern is a few read operations interleaved with a few write
              operations repeatedly. In this case, you would get a performance
              degradation by enabling this option.</p>
            <p>Option <c>read_concurrency</c> can be combined with option
              <seeerl marker="#new_2_write_concurrency">
              <c>write_concurrency</c></seeerl>.
              You typically want to combine these when large concurrent
              read bursts and large concurrent write bursts are common.</p>
            <marker id="new_2_decentralized_counters"></marker>
          </item>
          <tag since="OTP 23.0"><c>{decentralized_counters,boolean()}</c></tag>
          <item>
            <p>
              Performance tuning. Defaults to <c>true</c> for all
              tables with the <c>write_concurrency</c> option set
              to <c>auto</c>. For
              tables of type <c>ordered_set</c> the option also
              defaults to true when the <c>write_concurrency</c> option
              is set to <c>true</c>. The option defaults to
              <c>false</c> for all other configurations. This option
              has no effect if the <c>write_concurrency</c> option is
              set to <c>false</c>.</p>
	    <p>
	      When this option is set to <c>true</c>, the table is optimized for
	      frequent concurrent calls to operations that modify the tables
	      size and/or its memory consumption (e.g., <seemfa
              marker="#insert/2"><c>insert/2</c></seemfa> and <seemfa
              marker="#delete/2"><c>delete/2</c></seemfa>).
	      The drawback is that calls to
	      <seemfa marker="#info/1"><c>info/1</c></seemfa> and
	      <seemfa marker="#info/2"><c>info/2</c></seemfa> with <c>size</c> or
              <c>memory</c> as the second argument can get much slower when the
              <c>decentralized_counters</c> option is turned on.</p>
            <p>
              When this option is enabled the counters for the
              table size and memory consumption are distributed over
              several cache lines and the scheduling threads are
              mapped to one of those cache lines. The <c>erl</c>
              option <seecom
              marker="erts:erl#+dcg"><c>+dcg</c></seecom> can be used
              to control the number of cache lines that the counters
              are distributed over.
            </p>
              <marker id="new_2_compressed"></marker>
          </item>
          <tag since="OTP R14B01"><c>compressed</c></tag>
          <item>
            <p>If this option is present, the table data is stored in a more
              compact format to consume less memory. However, it will make
              table operations slower. Especially operations that need to
              inspect entire objects, such as <c>match</c> and <c>select</c>,
              get much slower. The key element is not compressed.</p>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="next" arity="2" since=""/>
      <fsummary>Return the next key in an ETS table.</fsummary>
      <desc>
        <p>Returns the next key <c><anno>Key2</anno></c>, following key
          <c><anno>Key1</anno></c> in table <c><anno>Table</anno></c>. For table
          type <c>ordered_set</c>, the next key in Erlang term order is
          returned. For other table types, the next key
          according to the internal order of the table is returned. If no
          next key exists, <c>'$end_of_table'</c> is returned.</p>
        <p>To find the first key in the table, use
          <seemfa marker="#first/1"><c>first/1</c></seemfa>.</p>
        <p>Unless a table of type <c>set</c>, <c>bag</c>, or
          <c>duplicate_bag</c> is fixated using
          <seemfa marker="#safe_fixtable/2"><c>safe_fixtable/2</c></seemfa>,
          a call to <c>next/2</c> will fail if <c><anno>Key1</anno></c> no longer
	  exists in the table. For table type <c>ordered_set</c>, the function
	  always returns the next key after <c><anno>Key1</anno></c> in term
	  order, regardless whether <c><anno>Key1</anno></c> ever existed in the
	  table.</p>
      </desc>
    </func>

    <func>
      <name name="prev" arity="2" since=""/>
      <fsummary>Return the previous key in an ETS table of type
        <c>ordered_set</c>.</fsummary>
      <desc>
        <p>Returns the previous key <c><anno>Key2</anno></c>, preceding key
          <c><anno>Key1</anno></c> according to Erlang term order in table
          <c><anno>Table</anno></c> of type <c>ordered_set</c>. For other
          table types, the function is synonymous to
          <seemfa marker="#next/2"><c>next/2</c></seemfa>.
          If no previous key exists, <c>'$end_of_table'</c> is returned.</p>
        <p>To find the last key in an <c>ordered_set</c> table, use
          <seemfa marker="#last/1"><c>last/1</c></seemfa>.</p>
      </desc>
    </func>

    <func>
      <name name="rename" arity="2" since=""/>
      <fsummary>Rename a named ETS table.</fsummary>
      <desc>
        <p>Renames the named table <c><anno>Table</anno></c> to the new name
          <c><anno>Name</anno></c>. Afterwards, the old name cannot be used to
          access the table. Renaming an unnamed table has no effect.</p>
      </desc>
    </func>

    <func>
      <name name="repair_continuation" arity="2" since=""/>
      <fsummary>Repair a continuation from <c>ets:select/1 or ets:select/3</c>
        that has passed through external representation.</fsummary>
      <desc>
        <p>Restores an opaque continuation returned by
          <seemfa marker="#select/3"><c>select/3</c></seemfa> or
          <seemfa marker="#select/1"><c>select/1</c></seemfa> if the
          continuation has passed through external term format (been
          sent between nodes or stored on disk).</p>
        <p>The reason for this function is that continuation terms
          contain compiled match specifications and may therefore be
          invalidated if converted to external term format. Given that the
          original match specification is kept intact, the continuation can
          be restored, meaning it can once again be used in subsequent
          <c>select/1</c> calls even though it has been stored on
          disk or on another node.</p>
        <p><em>Examples:</em></p>
        <p>The following sequence of calls may fail:</p>
        <code type="none">
T=ets:new(x,[]),
...
MS = ets:fun2ms(fun({N,_}=A) when (N rem 10) =:= 0 -> A end),
{_,C} = ets:select(T, MS, 10),
MaybeBroken = binary_to_term(term_to_binary(C)),
ets:select(MaybeBroken).</code>
        <p>The following sequence works, as the call to
          <c>repair_continuation/2</c> reestablishes the
          <c>MaybeBroken</c> continuation.</p>
        <code type="none">
T=ets:new(x,[]),
...
MS = ets:fun2ms(fun({N,_}=A) when (N rem 10) =:= 0 -> A end),
{_,C} = ets:select(T,MS,10),
MaybeBroken = binary_to_term(term_to_binary(C)),
ets:select(ets:repair_continuation(MaybeBroken,MS)).</code>
        <note>
          <p>This function is rarely needed in application code. It is used
            by Mnesia to provide distributed <c>select/3</c>
            and <c>select/1</c> sequences. A normal application would
            either use Mnesia or keep the continuation from being
            converted to external format.</p>
          <p>The actual behavior of compiled match specifications when recreated
	    from external format has changed and may change in future releases,
	    but this interface remains for backward compatibility.
	    See <seemfa marker="#is_compiled_ms/1"><c>is_compiled_ms/1</c></seemfa>.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="safe_fixtable" arity="2" since=""/>
      <fsummary>Fix an ETS table for safe traversal.</fsummary>
      <desc>
        <p>Fixes a table of type <c>set</c>, <c>bag</c>, or
        <c>duplicate_bag</c> for <seeerl marker="#traversal">
	safe traversal</seeerl> using
	<seemfa marker="#first/1"><c>first/1</c></seemfa> &amp;
	<seemfa marker="#next/2"><c>next/2</c></seemfa>,
	<seemfa marker="#match/3"><c>match/3</c></seemfa> &amp;
	<seemfa marker="#match/1"><c>match/1</c></seemfa>,
	<seemfa marker="#match_object/3"><c>match_object/3</c></seemfa> &amp;
	<seemfa marker="#match_object/1"><c>match_object/1</c></seemfa>, or
	<seemfa marker="#select/3"><c>select/3</c></seemfa> &amp;
	<seemfa marker="#select/1"><c>select/1</c></seemfa>.</p>
        <p>A process fixes a table by calling
          <c>safe_fixtable(<anno>Table</anno>, true)</c>. The table remains
          fixed until the process releases it by calling
          <c>safe_fixtable(<anno>Table</anno>, false)</c>, or until the process
          terminates.</p>
        <p>If many processes fix a table, the table remains fixed
          until all processes have released it (or terminated).
          A reference counter is kept on a per process basis, and N
          consecutive fixes requires N releases to release the table.</p>
        <p>When a table is fixed, a sequence of
          <seemfa marker="#first/1"><c>first/1</c></seemfa> and
          <seemfa marker="#next/2"><c>next/2</c></seemfa> calls are
          guaranteed to succeed even if keys are removed during the
	  traversal. The keys for objects inserted or deleted during a
	  traversal may or may not be returned by <c>next/2</c> depending on
	  the ordering of keys within the table and if the key exists at the time
	  <c>next/2</c> is called.</p>
        <p><em>Example:</em></p>
        <code type="none">
clean_all_with_value(Table,X) ->
    safe_fixtable(Table,true),
    clean_all_with_value(Table,X,ets:first(Table)),
    safe_fixtable(Table,false).

clean_all_with_value(Table,X,'$end_of_table') ->
    true;
clean_all_with_value(Table,X,Key) ->
    case ets:lookup(Table,Key) of
        [{Key,X}] ->
            ets:delete(Table,Key);
        _ ->
            true
    end,
    clean_all_with_value(Table,X,ets:next(Table,Key)).</code>
        <p>Notice that deleted objects are not freed from a
          fixed table until it has been released. If a process fixes a
          table but never releases it, the memory used by the deleted
          objects is never freed. The performance of operations on
          the table also degrades significantly.</p>
        <p>To retrieve information about which processes have fixed which
          tables, use <seeerl marker="#info_2_safe_fixed_monotonic_time">
          <c>info(Table, safe_fixed_monotonic_time)</c></seeerl>. A system with
          many processes fixing tables can need a monitor that sends alarms
          when tables have been fixed for too long.</p>
        <p>Notice that <c>safe_fixtable/2</c> is not necessary for table type
	<c>ordered_set</c> and for traversals done by a single ETS function call,
	like <seemfa marker="#select/2"><c>select/2</c></seemfa>.</p>
      </desc>
    </func>

    <func>
      <name name="select" arity="1" since=""/>
      <fsummary>Continue matching objects in an ETS table.</fsummary>
      <desc>
        <p>Continues a match started with
          <seemfa marker="#select/3"><c>select/3</c></seemfa>. The next
          chunk of the size specified in the initial <c>select/3</c>
          call is returned together with a new <c><anno>Continuation</anno></c>,
          which can be used in subsequent calls to this function.</p>
        <p>When there are no more objects in the table, <c>'$end_of_table'</c>
          is returned.</p>
      </desc>
    </func>

    <func>
      <name name="select" arity="2" since=""/>
      <fsummary>Match the objects in an ETS table against a
        match specification.</fsummary>
      <desc>
        <p>Matches the objects in table <c><anno>Table</anno></c> using a
          <seeerl marker="#match_spec">match specification</seeerl>.
          This is a more general call than
          <seemfa marker="#match/2"><c>match/2</c></seemfa> and
          <seemfa marker="#match_object/2"><c>match_object/2</c></seemfa>
          calls. In its simplest form, the match specification is as
          follows:</p>
        <code type="none">
MatchSpec = [MatchFunction]
MatchFunction = {MatchHead, [Guard], [Result]}
MatchHead = "Pattern as in ets:match"
Guard = {"Guardtest name", ...}
Result = "Term construct"</code>
        <p>This means that the match specification is always a list of one or
          more tuples (of arity 3). The first element of the tuple is to be
          a pattern as described in
          <seemfa marker="#match/2"><c>match/2</c></seemfa>.
          The second element of the tuple is to
          be a list of 0 or more guard tests (described below). The
          third element of the tuple is to be a list containing a
          description of the value to return. In almost all
          normal cases, the list contains exactly one term that fully
          describes the value to return for each object.</p>
        <p>The return value is constructed using the "match variables"
          bound in <c>MatchHead</c> or using the special match variables
          <c>'$_'</c> (the whole matching object) and <c>'$$'</c> (all
          match variables in a list), so that the following
          <c>match/2</c> expression:</p>
        <code type="none">
ets:match(Table,{'$1','$2','$3'})</code>
        <p>is exactly equivalent to:</p>
        <code type="none">
ets:select(Table,[{{'$1','$2','$3'},[],['$$']}])</code>
        <p>And that the following <c>match_object/2</c> call:</p>
        <code type="none">
ets:match_object(Table,{'$1','$2','$1'})</code>
        <p>is exactly equivalent to</p>
        <code type="none">
ets:select(Table,[{{'$1','$2','$1'},[],['$_']}])</code>
        <p>Composite terms can be constructed in the <c>Result</c> part
          either by simply writing a list, so that the following code:</p>
        <code type="none">
ets:select(Table,[{{'$1','$2','$3'},[],['$$']}])</code>
        <p>gives the same output as:</p>
        <code type="none">
ets:select(Table,[{{'$1','$2','$3'},[],[['$1','$2','$3']]}])</code>
        <p>That is, all the bound variables in the match head as a list. If
          tuples are to be constructed, one has to write a tuple of
          arity 1 where the single element in the tuple is the tuple
          one wants to construct (as an ordinary tuple can be mistaken
          for a <c>Guard</c>).</p>
        <p>Therefore the following call:</p>
        <code type="none">
ets:select(Table,[{{'$1','$2','$1'},[],['$_']}])</code>
        <p>gives the same output as:</p>
        <code type="none">
ets:select(Table,[{{'$1','$2','$1'},[],[{{'$1','$2','$3'}}]}])</code>
        <p>This syntax is equivalent to the syntax used in the trace
          patterns (see the
          <seeerl marker="runtime_tools:dbg">
          <c>dbg(3)</c></seeerl>) module in Runtime_Tools.</p>
        <p>The <c>Guard</c>s are constructed as tuples, where the first
          element is the test name and the remaining elements
          are the test parameters. To check for a specific type
          (say a list) of the element bound to the match variable
          <c>'$1'</c>, one would write the test as
          <c>{is_list, '$1'}</c>. If the test fails, the object in the
          table does not match and the next <c>MatchFunction</c> (if
          any) is tried. Most guard tests present in Erlang can be
          used, but only the new versions prefixed <c>is_</c> are
          allowed (<c>is_float</c>, <c>is_atom</c>, and so on).</p>
        <p>The <c>Guard</c> section can also contain logic and
          arithmetic operations, which are written with the same syntax
          as the guard tests (prefix notation), so that the following
          guard test written in Erlang:</p>
        <code type="none"><![CDATA[
is_integer(X), is_integer(Y), X + Y < 4711]]></code>
        <p>is expressed as follows (<c>X</c> replaced with <c>'$1'</c> and
          <c>Y</c> with <c>'$2'</c>):</p>
        <code type="none"><![CDATA[
[{is_integer, '$1'}, {is_integer, '$2'}, {'<', {'+', '$1', '$2'}, 4711}]]]></code>
        <p>For tables of type <c>ordered_set</c>, objects are visited
          in the same order as in a <c>first</c>/<c>next</c>
          traversal. This means that the match specification is
          executed against objects with keys in the <c>first</c>/<c>next</c>
          order and the corresponding result list is in the order of that
          execution.</p>
      </desc>
    </func>

    <func>
      <name name="select" arity="3" since=""/>
      <fsummary>Match the objects in an ETS table against a match
        specification and return part of the answers.</fsummary>
      <desc>
        <p>Works like <seemfa marker="#select/2"><c>select/2</c></seemfa>,
          but only returns a limited
          (<c><anno>Limit</anno></c>) number of matching objects. Term
          <c><anno>Continuation</anno></c> can then be used in subsequent
          calls to <seemfa marker="#select/1"><c>select/1</c></seemfa>
          to get the next chunk of matching
          objects. This is a space-efficient way to work on objects in a
          table, which is still faster than traversing the table object by
          object using <seemfa marker="#first/1"><c>first/1</c></seemfa>
          and <seemfa marker="#next/2"><c>next/2</c></seemfa>.</p>
          <p>If the table is empty, <c>'$end_of_table'</c> is returned.</p>
	  <p>Use <seemfa marker="#safe_fixtable/2"><c>safe_fixtable/2</c></seemfa>
	  to guarantee <seeerl marker="#traversal">safe traversal</seeerl>
	  for subsequent calls to <seemfa marker="#select/1"><c>select/1</c></seemfa>.</p>
      </desc>
    </func>

    <func>
      <name name="select_count" arity="2" since=""/>
      <fsummary>Match the objects in an ETS table against a match
        specification and return the number of objects for which the match
        specification returned <c>true</c>.</fsummary>
      <desc>
        <p>Matches the objects in table <c><anno>Table</anno></c> using a
          <seeerl marker="#match_spec">match specification</seeerl>. If the
          match specification returns <c>true</c> for an object, that object
          considered a match and is counted. For any other result from
          the match specification the object is not considered a match and is
          therefore not counted.</p>
        <p>This function can be described as a
          <seemfa marker="#select_delete/2"><c>select_delete/2</c></seemfa>
          function that does not delete any elements, but only counts them.</p>
        <p>The function returns the number of objects matched.</p>
      </desc>
    </func>

    <func>
      <name name="select_delete" arity="2" since=""/>
      <fsummary>Match the objects in an ETS table against a match
        specification and delete objects where the match specification
        returns <c>true</c>.</fsummary>
      <desc>
        <p>Matches the objects in table <c><anno>Table</anno></c> using a
          <seeerl marker="#match_spec">match specification</seeerl>. If the
          match specification returns <c>true</c> for an object, that object is
          removed from the table. For any other result from the match
          specification the object is retained. This is a more general
          call than the <seemfa marker="#match_delete/2">
          <c>match_delete/2</c></seemfa> call.</p>
        <p>The function returns the number of objects
          deleted from the table.</p>
        <note>
          <p>The match specification has to return the atom <c>true</c> if
            the object is to be deleted. No other return value gets the
            object deleted. So one cannot use the same match specification for
            looking up elements as for deleting them.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="select_replace" arity="2" since="OTP 20.0"/>
      <fsummary>Match and replace objects atomically in an ETS table</fsummary>
      <desc>
        <p>Matches the objects in the table <c><anno>Table</anno></c> using a
          <seeerl marker="#match_spec">match specification</seeerl>. For each
          matched object, the existing object is replaced with
          the match specification result.</p>
	<p>The match-and-replace operation for each individual object is guaranteed to be
	  <seeerl marker="#concurrency">atomic and isolated</seeerl>. The
	  <c>select_replace</c> table traversal as a whole, like all other select functions,
	  does not give such guarantees.</p>
	<p>The match specification must be guaranteed to <em>retain the key</em>
	  of any matched object. If not, <c>select_replace</c> will fail with <c>badarg</c>
	  without updating any objects.</p>
        <p>For the moment, due to performance and semantic constraints,
          tables of type <c>bag</c> are not yet supported.</p>
        <p>The function returns the total number of replaced objects.</p>
        <p><em>Example</em></p>
	<p>For all 2-tuples with a list in second position, add atom <c>'marker'</c> first in the list:</p>
	<pre>
1> <input>T = ets:new(x,[]), ets:insert(T, {key, [1, 2, 3]}).</input>
true
2> <input>MS = ets:fun2ms(fun({K, L}) when is_list(L) -> {K, [marker | L]} end).</input>
[{{'$1','$2'},[{is_list,'$2'}],[{{'$1',[marker|'$2']}}]}]
3> <input>ets:select_replace(T, MS).</input>
1
4> <input>ets:tab2list(T).</input>
[{key,[marker,1,2,3]}]
	</pre>
	<p>A generic single object compare-and-swap operation:</p>
        <pre>
[Old] = ets:lookup(T, Key),
New = update_object(Old),
Success = (1 =:= ets:select_replace(T, [{Old, [], [{const, New}]}])),
	</pre>
      </desc>
    </func>

    <func>
      <name name="select_reverse" arity="1" since="OTP R14B"/>
      <fsummary>Continue matching objects in an ETS table.</fsummary>
      <desc>
      <p>Continues a match started with <seemfa marker="#select_reverse/3">
        <c>select_reverse/3</c></seemfa>. For tables of type
        <c>ordered_set</c>, the traversal of the table continues
        to objects with keys earlier in the Erlang term order. The
        returned list also contains objects with keys in reverse order.
        For all other table types, the behavior is exactly that of
        <seemfa marker="#select/1"><c>select/1</c></seemfa>.</p>
      <p><em>Example:</em></p>
      <code>
1> T = ets:new(x,[ordered_set]).
2> [ ets:insert(T,{N}) || N &lt;- lists:seq(1,10) ].
...
3> {R0,C0} = ets:select_reverse(T,[{'_',[],['$_']}],4).
...
4> R0.
[{10},{9},{8},{7}]
5> {R1,C1} = ets:select_reverse(C0).
...
6> R1.
[{6},{5},{4},{3}]
7> {R2,C2} = ets:select_reverse(C1).
...
8> R2.
[{2},{1}]
9> '$end_of_table' = ets:select_reverse(C2).
...</code>
      </desc>
    </func>

    <func>
      <name name="select_reverse" arity="2" since="OTP R14B"/>
      <fsummary>Match the objects in an ETS table against a
        match specification.</fsummary>
      <desc>
      <p>Works like <seemfa marker="#select/2"><c>select/2</c></seemfa>,
        but returns the list in reverse order for table type <c>ordered_set</c>.
        For all other table types, the return value is identical to that of
        <c>select/2</c>.</p>
      </desc>
    </func>

    <func>
      <name name="select_reverse" arity="3" since="OTP R14B"/>
      <fsummary>Match the objects in an ETS table against a
        match specification and return part of the answers.</fsummary>
      <desc>
      <p>Works like <seemfa marker="#select/3"><c>select/3</c></seemfa>,
        but for table type <c>ordered_set</c>
        traversing is done starting at the last object in
        Erlang term order and moves to the first. For all other table
        types, the return value is identical to that of <c>select/3</c>.</p>
      <p>Notice that this is <em>not</em> equivalent to
        reversing the result list of a <c>select/3</c> call, as the result list
        is not only reversed, but also contains the last
        <c><anno>Limit</anno></c>
        matching objects in the table, not the first.</p>
      </desc>
    </func>

    <func>
      <name name="setopts" arity="2" since=""/>
      <fsummary>Set table options.</fsummary>
      <desc>
        <p>Sets table options. The only allowed option to be set after the
          table has been created is
          <seeerl marker="#heir"><c>heir</c></seeerl>.
          The calling process must be the table owner.</p>
      </desc>
    </func>

    <func>
      <name name="slot" arity="2" since=""/>
      <fsummary>Return all objects in a specified slot of an ETS table.
      </fsummary>
      <desc>
        <p>This function is mostly for debugging purposes, Normally
          <c>first</c>/<c>next</c> or <c>last</c>/<c>prev</c> are to be used
          instead.</p>
        <p>Returns all objects in slot <c><anno>I</anno></c> of table
          <c><anno>Table</anno></c>. A table can be traversed by repeatedly
          calling the function,
          starting with the first slot <c><anno>I</anno>=0</c> and
          ending when <c>'$end_of_table'</c> is returned.
          If argument <c><anno>I</anno></c> is out of range,
          the function fails with reason <c>badarg</c>.</p>
        <p>Unless a table of type <c>set</c>, <c>bag</c>, or
          <c>duplicate_bag</c> is protected using
          <seemfa marker="#safe_fixtable/2"><c>safe_fixtable/2</c></seemfa>,
          a traversal can fail if
          concurrent updates are made to the table. For table type
          <c>ordered_set</c>, the function returns a list containing
          object <c><anno>I</anno></c> in Erlang term order.</p>
      </desc>
    </func>

    <func>
      <name name="tab2file" arity="2" since=""/>
      <fsummary>Dump an ETS table to a file.</fsummary>
      <desc>
        <p>Dumps table <c><anno>Table</anno></c> to file
          <c><anno>Filename</anno></c>.</p>
        <p>Equivalent to
          <c>tab2file(<anno>Table</anno>, <anno>Filename</anno>,[])</c></p>
      </desc>
    </func>

    <func>
      <name name="tab2file" arity="3" since=""/>
      <fsummary>Dump an ETS table to a file.</fsummary>
      <desc>
        <p>Dumps table <c><anno>Table</anno></c> to file
          <c><anno>Filename</anno></c>.</p>
        <p>When dumping the table, some information about the table
          is dumped to a header at the beginning of the dump. This
          information contains data about the table type,
          name, protection, size, version, and if it is a named table. It
          also contains notes about what extended information is added
          to the file, which can be a count of the objects in the file
          or a MD5 sum of the header and records in the file.</p>
        <p>The size field in the header might not correspond to the
          number of records in the file if the table is public
          and records are added or removed from the table during
          dumping. Public tables updated during dump, and that one wants
          to verify when reading, needs at least one field of extended
          information for the read verification process to be reliable
          later.</p>
        <p>Option <c>extended_info</c> specifies what extra
          information is written to the table dump:</p>
        <taglist>
          <tag><c>object_count</c></tag>
          <item>
            <p>The number of objects written to the file is
              noted in the file footer, so file truncation can be
              verified even if the file was updated during dump.</p>
          </item>
          <tag><c>md5sum</c></tag>
          <item>
            <p>The header and objects in the file are checksummed using
              the built-in MD5 functions. The MD5 sum of all objects is
              written in the file footer, so that verification while reading
              detects the slightest bitflip in the file data. Using this
              costs a fair amount of CPU time.</p>
          </item>
        </taglist>
        <p>Whenever option <c>extended_info</c> is used, it
          results in a file not readable by versions of ETS before
          that in STDLIB 1.15.1</p>
        <p>If option <c>sync</c> is set to <c>true</c>, it ensures that
          the content of the file is written to the disk before
          <c>tab2file</c> returns. Defaults to <c>{sync, false}</c>.</p>
      </desc>
    </func>

    <func>
      <name name="tab2list" arity="1" since=""/>
      <fsummary>Return a list of all objects in an ETS table.</fsummary>
      <desc>
        <p>Returns a list of all objects in table <c><anno>Table</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="tabfile_info" arity="1" since=""/>
      <fsummary>Return a list of all objects in an ETS table.</fsummary>
      <desc>
        <p>Returns information about the table dumped to file by
          <seemfa marker="#tab2file/2"><c>tab2file/2</c></seemfa> or 
          <seemfa marker="#tab2file/3"><c>tab2file/3</c></seemfa>.</p>
        <p>The following items are returned:</p>
        <taglist>
          <tag><c>name</c></tag>
          <item>
            <p>The name of the dumped table. If the table was a
              named table, a table with the same name cannot exist when the
              table is loaded from file with 
              <seemfa marker="#file2tab/2"><c>file2tab/2</c></seemfa>.
              If the table is
              not saved as a named table, this field has no significance
              when loading the table from file.</p>
          </item>
          <tag><c>type</c></tag>
          <item>
            <p>The ETS type of the dumped table (that is, <c>set</c>,
              <c>bag</c>, <c>duplicate_bag</c>, or <c>ordered_set</c>). This
              type is used when loading the table again.</p>
          </item>
          <tag><c>protection</c></tag>
          <item>
            <p>The protection of the dumped table (that is, <c>private</c>,
              <c>protected</c>, or <c>public</c>). A table loaded from the
              file gets the same protection.</p>
          </item>
          <tag><c>named_table</c></tag>
          <item>
            <p><c>true</c> if the table was a named table when dumped
              to file, otherwise <c>false</c>. Notice that when a named table
              is loaded from a file, there cannot exist a table in the
              system with the same name.</p>
          </item>
          <tag><c>keypos</c></tag>
          <item>
            <p>The <c>keypos</c> of the table dumped to file, which
              is used when loading the table again.</p>
          </item>
          <tag><c>size</c></tag>
          <item>
            <p>The number of objects in the table when the table dump
              to file started. For a <c>public</c> table, this number
              does not need to correspond to the number of objects saved to
              the file, as objects can have been added or deleted by another
              process during table dump.</p>
          </item>
          <tag><c>extended_info</c></tag>
          <item>
            <p>The extended information written in the file footer to
              allow stronger verification during table loading from file, as
              specified to <seemfa marker="#tab2file/3">
              <c>tab2file/3</c></seemfa>. Notice that this
              function only tells <em>which</em> information is present, not
              the values in the file footer. The value is a list containing one
              or more of the atoms <c>object_count</c> and <c>md5sum</c>.</p>
          </item>
          <tag><c>version</c></tag>
          <item>
            <p>A tuple <c>{<anno>Major</anno>,<anno>Minor</anno>}</c>
              containing the major and
              minor version of the file format for ETS table dumps. This
              version field was added beginning with STDLIB 1.5.1.
              Files dumped with older versions return <c>{0,0}</c> in this
              field.</p>
          </item>
        </taglist>
        <p>An error is returned if the file is inaccessible,
          badly damaged, or not produced with
          <seemfa marker="#tab2file/2"><c>tab2file/2</c></seemfa> or
          <seemfa marker="#tab2file/3"><c>tab2file/3</c></seemfa>.</p>
      </desc>
    </func>

    <func>
      <name name="table" arity="1" since=""/>
      <name name="table" arity="2" since=""/>
      <fsummary>Return a QLC query handle.</fsummary>
      <desc>
        <p>Returns a Query List
          Comprehension (QLC) query handle. The
          <seeerl marker="qlc"><c>qlc</c></seeerl> module provides
          a query language aimed mainly at Mnesia, but ETS
          tables, Dets tables,
          and lists are also recognized by QLC as sources of
          data. Calling <c>table/1,2</c> is the means to make the
          ETS table <c>Table</c> usable to QLC.</p>
        <p>When there are only simple restrictions on the key position,
          QLC uses <seemfa marker="#lookup/2"><c>lookup/2</c></seemfa>
          to look up the keys. When
          that is not possible, the whole table is traversed.
          Option <c>traverse</c> determines how this is done:</p>
        <taglist>
          <tag><c>first_next</c></tag>
          <item>
            <p>The table is traversed one key at a time by calling
              <seemfa marker="#first/1"><c>first/1</c></seemfa> and
              <seemfa marker="#next/2"><c>next/2</c></seemfa>.</p>
          </item>
          <tag><c>last_prev</c></tag>
          <item>
            <p>The table is traversed one key at a time by calling
              <seemfa marker="#last/1"><c>last/1</c></seemfa> and
              <seemfa marker="#prev/2"><c>prev/2</c></seemfa>.</p>
          </item>
          <tag><c>select</c></tag>
          <item>
            <p>The table is traversed by calling
              <seemfa marker="#select/3"><c>select/3</c></seemfa> and
              <seemfa marker="#select/1"><c>select/1</c></seemfa>.
              Option <c>n_objects</c> determines the number of objects
              returned (the third argument of <c>select/3</c>); the
              default is to return <c>100</c> objects at a time. The
              <seeerl marker="#match_spec">match specification</seeerl> (the
              second argument of <c>select/3</c>) is assembled by QLC: simple
              filters are translated into equivalent match specifications
              while more complicated filters must be applied to all
              objects returned by <c>select/3</c> given a match specification
              that matches all objects.</p>
          </item>
          <tag><c>{select, <anno>MatchSpec</anno>}</c></tag>
          <item>
            <p>As for <c>select</c>, the table is traversed by calling
              <seemfa marker="#select/3"><c>select/3</c></seemfa> and
              <seemfa marker="#select/1"><c>select/1</c></seemfa>.
              The difference is that the match specification is explicitly
              specified. This is how to state match specifications that cannot
              easily be expressed within the syntax provided by QLC.</p>
          </item>
        </taglist>
        <p><em>Examples:</em></p>
        <p>An explicit match specification is here used to traverse the
          table:</p>
        <pre>
9> <input>true = ets:insert(Table = ets:new(t, []), [{1,a},{2,b},{3,c},{4,d}]),</input>
<input>MS = ets:fun2ms(fun({X,Y}) when (X > 1) or (X &lt; 5) -> {Y} end),</input>
<input>QH1 = ets:table(Table, [{traverse, {select, MS}}]).</input></pre>
        <p>An example with an implicit match specification:</p>
        <pre>
10> <input>QH2 = qlc:q([{Y} || {X,Y} &lt;- ets:table(Table), (X > 1) or (X &lt; 5)]).</input></pre>
        <p>The latter example is equivalent to the former, which
          can be verified using function <c>qlc:info/1</c>:</p>
        <pre>
11> <input>qlc:info(QH1) =:= qlc:info(QH2).</input>
true</pre>
        <p><c>qlc:info/1</c> returns information about a query handle,
          and in this case identical information is returned for the
          two query handles.</p>
      </desc>
    </func>

    <func>
      <name name="take" arity="2" since="OTP 18.0"/>
      <fsummary>Return and remove all objects with a specified key from an
        ETS table.</fsummary>
      <desc>
        <p>Returns and removes a list of all objects with key
          <c><anno>Key</anno></c> in table <c><anno>Table</anno></c>.</p>
        <p>The specified <c><anno>Key</anno></c> is used to identify the object
          by either <em>comparing equal</em> the key of an object in an
          <c>ordered_set</c> table, or <em>matching</em> in other types of
          tables (for details on the difference, see
          <seemfa marker="#lookup/2"><c>lookup/2</c></seemfa> and
          <seemfa marker="#new/2"><c>new/2</c></seemfa>).</p>
      </desc>
    </func>
    <func>
      <name name="test_ms" arity="2" since=""/>
      <fsummary>Test a match specification for use in <c>select/2</c>.
      </fsummary>
      <desc>
        <p>This function is a utility to test a
          <seeerl marker="#match_spec">match specification</seeerl> used in
          calls to <seemfa marker="#select/2"><c>select/2</c></seemfa>.
          The function both tests <c><anno>MatchSpec</anno></c> for "syntactic"
          correctness and runs the match specification against object
          <c><anno>Tuple</anno></c>.</p>
        <p>If the match specification is syntactically correct, the function
          either returns <c>{ok,<anno>Result</anno>}</c>, where
          <c><anno>Result</anno></c> is what would have been the result in a
          real <c>select/2</c> call, or <c>false</c> if the match specification
          does not match object <c><anno>Tuple</anno></c>.</p>
        <p>If the match specification contains errors, tuple
          <c>{error, <anno>Errors</anno>}</c> is returned,
          where <c><anno>Errors</anno></c> is a list of natural language
          descriptions of what was wrong with the match specification.</p>
        <p>This is a useful debugging and test tool, especially when
          writing complicated <c>select/2</c> calls.</p>
        <p>See also: <seemfa marker="erts:erlang#match_spec_test/3">
          erlang:match_spec_test/3</seemfa>.</p>
      </desc>
    </func>

    <func>
      <name name="to_dets" arity="2" since=""/>
      <fsummary>Fill a Dets table with objects from an ETS table.
      </fsummary>
      <desc>
        <p>Fills an already created/opened Dets table with the objects
          in the already opened ETS table named <c><anno>Table</anno></c>.
          The Dets table is emptied before the objects are inserted.</p>
      </desc>
    </func>

    <func> 
      <name name="update_counter" arity="3" clause_i="1" since=""/>
      <name name="update_counter" arity="4" clause_i="1" since="OTP 18.0"/>
      <name name="update_counter" arity="3" clause_i="2" since=""/>
      <name name="update_counter" arity="4" clause_i="2" since="OTP 18.0"/>
      <name name="update_counter" arity="3" clause_i="3" since=""/>
      <name name="update_counter" arity="4" clause_i="3" since="OTP 18.0"/>
      <fsummary>Update a counter object in an ETS table.</fsummary>
      <type variable="Table"/>
      <type variable="Key"/>
      <type variable="UpdateOp" name_i="1"/>
      <type variable="Pos" name_i="1"/>
      <type variable="Threshold" name_i="1"/>
      <type variable="SetValue" name_i="1"/>
      <type variable="Default"/>
      <desc>
        <p>This function provides an efficient way to update one or more 
          counters, without the trouble of having to look up an object, update 
          the object by incrementing an element, and insert the resulting
          object into the table again. The operation is guaranteed to be
          <seeerl marker="#concurrency">atomic and isolated</seeerl>.</p>
        <p>This function destructively updates the object with key
          <c><anno>Key</anno></c> in table <c><anno>Table</anno></c> by adding
          <c><anno>Incr</anno></c> to the element at position
          <c><anno>Pos</anno></c>. The new counter value is
          returned. If no position is specified, the element directly
          following key (<c><![CDATA[<keypos>+1]]></c>) is updated.</p>
        <p>If a <c><anno>Threshold</anno></c> is specified, the counter is
          reset to value <c><anno>SetValue</anno></c> if the following
          conditions occur:</p>
        <list type="bulleted">
          <item><p><c><anno>Incr</anno></c> is not negative (<c>>= 0</c>) and
            the result would be greater than (<c>></c>)
            <c><anno>Threshold</anno></c>.</p>
          </item>
          <item><p><c><anno>Incr</anno></c> is negative
            (<c><![CDATA[< 0]]></c>) and the result would be less than
            (<c><![CDATA[<]]></c>) <c><anno>Threshold</anno></c>.</p>
          </item>
        </list>
        <p>A list of <c><anno>UpdateOp</anno></c> can be supplied to do many
          update operations within the object.
          The operations are carried out in the
          order specified in the list. If the same counter position occurs 
          more than once in the list, the corresponding counter is thus 
          updated many times, each time based on the previous result.
          The return value is a list of the new counter values from each 
          update operation in the same order as in the operation list. If an 
          empty list is specified, nothing is updated and an empty list is 
          returned. If the function fails, no updates are done.</p>
        <p>The specified <c><anno>Key</anno></c> is used to identify the object
          by either <em>matching</em> the key of an object in a <c>set</c>
          table, or <em>compare equal</em> to the key of an object in an
          <c>ordered_set</c> table (for details on the difference, see 
          <seemfa marker="#lookup/2"><c>lookup/2</c></seemfa> and 
          <seemfa marker="#new/2"><c>new/2</c></seemfa>).</p>
        <p>If a default object <c><anno>Default</anno></c> is specified,
          it is used
          as the object to be updated if the key is missing from the table. The
          value in place of the key is ignored and replaced by the proper key
          value. The return value is as if the default object had not been used,
          that is, a single updated element or a list of them.</p>
        <p>The function fails with reason <c>badarg</c> in the following
          situations:</p>
        <list type="bulleted">
          <item>The table type is not <c>set</c> or
            <c>ordered_set</c>.</item>
          <item>No object with the correct key exists and no default object was
            supplied.</item>
          <item>The object has the wrong arity.</item>
          <item>The default object arity is smaller than
            <c><![CDATA[<keypos>]]></c>.</item>
          <item>Any field from the default object that is updated is not an
            integer.</item>
          <item>The element to update is not an integer.</item>
          <item>The element to update is also the key.</item>
          <item>Any of <c><anno>Pos</anno></c>, <c><anno>Incr</anno></c>,
            <c><anno>Threshold</anno></c>, or <c><anno>SetValue</anno></c>
            is not an integer.</item>
        </list>
      </desc>
    </func>

    <func>
      <name name="update_element" arity="3" clause_i="1" since=""/>
      <name name="update_element" arity="3" clause_i="2" since=""/>
      <fsummary>Update the <c>Pos</c>:th element of the object with a
        specified key in an ETS table.</fsummary>
      <type variable="Table"/>
      <type variable="Key"/>
      <type variable="Value"/>
      <type variable="Pos"/>
      <desc>
        <p>This function provides an efficient way to update one or more 
          elements within an object, without the trouble of having to look up, 
          update, and write back the entire object.</p>
        <p>This function destructively updates the object with key
          <c><anno>Key</anno></c> in table <c><anno>Table</anno></c>.
          The element at position <c><anno>Pos</anno></c> is given
          the value <c><anno>Value</anno></c>.</p>
        <p>A list of <c>{<anno>Pos</anno>,<anno>Value</anno>}</c> can be
          supplied to update many
          elements within the same object. If the same position occurs more 
          than once in the list, the last value in the list is written. If
          the list is empty or the function fails, no updates are done.
          The function is also atomic in the sense that other processes 
          can never see any intermediate results.</p>
        <p>Returns <c>true</c> if an object with key <c><anno>Key</anno></c>
          is found, otherwise <c>false</c>.</p>
        <p>The specified <c><anno>Key</anno></c> is used to identify the object
          by either <em>matching</em> the key of an object in a <c>set</c>
          table, or <em>compare equal</em> to the key of an object in an
          <c>ordered_set</c> table (for details on the difference, see
          <seemfa marker="#lookup/2"><c>lookup/2</c></seemfa> and 
          <seemfa marker="#new/2"><c>new/2</c></seemfa>).</p>
        <p>The function fails with reason <c>badarg</c> in the following
          situations:</p>
        <list type="bulleted">
          <item>The table type is not <c>set</c> or <c>ordered_set</c>.</item>
          <item><c><anno>Pos</anno></c> &lt; 1.</item>
          <item><c><anno>Pos</anno></c> &gt; object arity.</item>
          <item>The element to update is also the key.</item>
        </list>
      </desc>
    </func>

    <func>
      <name name="whereis" arity="1" since="OTP 21.0"/>
      <fsummary>Retrieves the tid() of a named table.</fsummary>
      <desc>
        <p>This function returns the
          <seetype marker="#tid"><c>tid()</c></seetype> of the named table
          identified by <c><anno>TableName</anno></c>, or <c>undefined</c> if
          no such table exists. The <c>tid()</c> can be used in place of the
          table name in all operations, which is slightly faster since the name
          does not have to be resolved on each call.</p>
        <p>If the table is deleted, the <c>tid()</c> will be invalid even if
          another named table is created with the same name.</p>
      </desc>
    </func>
  </funcs>
</erlref>

