
  [;1m-spec replace(Subject, RE, Replacement) -> iodata() | unicode:charlist()[0m
  [;1m                 when[0m
  [;1m                     Subject :: iodata() | unicode:charlist(),[0m
  [;1m                     RE :: mp() | iodata(),[0m
  [;1m                     Replacement ::[0m
  [;1m                         iodata() | unicode:charlist() | replace_fun().[0m

  Same as [;;4mreplace(Subject, RE, Replacement, [])[0m.

  [;1m-spec replace(Subject, RE, Replacement, Options) ->[0m
  [;1m                 iodata() | unicode:charlist()[0m
  [;1m                 when[0m
  [;1m                     Subject :: iodata() | unicode:charlist(),[0m
  [;1m                     RE :: mp() | iodata() | unicode:charlist(),[0m
  [;1m                     Replacement ::[0m
  [;1m                         iodata() | unicode:charlist() | replace_fun(),[0m
  [;1m                     Options :: [Option],[0m
  [;1m                     Option ::[0m
  [;1m                         anchored | global | notbol | noteol |[0m
  [;1m                         notempty | notempty_atstart |[0m
  [;1m                         {offset, non_neg_integer()} |[0m
  [;1m                         {newline, NLSpec} |[0m
  [;1m                         bsr_anycrlf |[0m
  [;1m                         {match_limit, non_neg_integer()} |[0m
  [;1m                         {match_limit_recursion, non_neg_integer()} |[0m
  [;1m                         bsr_unicode |[0m
  [;1m                         {return, ReturnType} |[0m
  [;1m                         CompileOpt,[0m
  [;1m                     ReturnType :: iodata | list | binary,[0m
  [;1m                     CompileOpt :: compile_option(),[0m
  [;1m                     NLSpec :: cr | crlf | lf | anycrlf | any.[0m

  Replaces the matched part of the [;;4mSubject[0m string with [;;4m[0m
  [;;4mReplacement[0m.

  The permissible options are the same as for [;;4mrun/3[0m, except that
  option[;;4m capture[0m is not allowed. Instead a [;;4m{return, ReturnType}[0m
  is present. The default return type is [;;4miodata[0m, constructed in a
  way to minimize copying. The [;;4miodata[0m result can be used directly
  in many I/O operations. If a flat [;;4mlist()[0m is desired, specify [;;4m[0m
  [;;4m{return, list}[0m. If a binary is desired, specify [;;4m{return, binary}[0m.

  As in function [;;4mrun/3[0m, an [;;4mmp()[0m compiled with option [;;4municode[0m
  requires [;;4mSubject[0m to be a Unicode [;;4mcharlist()[0m. If compilation is
  done implicitly and the [;;4municode[0m compilation option is specified
  to this function, both the regular expression and [;;4mSubject[0m are to
  specified as valid Unicode [;;4mcharlist()[0ms.

  If the replacement is given as a string, it can contain the
  special character [;;4m&[0m, which inserts the whole matching expression
  in the result, and the special sequence [;;4m\[0mN (where N is an
  integer > 0), [;;4m\g[0mN, or [;;4m\g{[0mN[;;4m}[0m, resulting in the subexpression
  number N, is inserted in the result. If no subexpression with that
  number is generated by the regular expression, nothing is
  inserted.

  To insert an & or a \ in the result, precede it with a \. Notice
  that Erlang already gives a special meaning to \ in literal
  strings, so a single \ must be written as [;;4m"\\"[0m and therefore a
  double \ as [;;4m"\\\\"[0m.

  Example:

    re:replace("abcd","c","[&]",[{return,list}]).

  gives

    "ab[c]d"

  while

    re:replace("abcd","c","[\\&]",[{return,list}]).

  gives

    "ab[&]d"

  If the replacement is given as a fun, it will be called with the
  whole matching expression as the first argument and a list of
  subexpression matches in the order in which they appear in the
  regular expression. The returned value will be inserted in the
  result.

  Example:

    re:replace("abcd", ".(.)", fun(Whole, [<<C>>]) -> <<$#, Whole/binary, $-, (C - $a + $A), $#>> end, [{return, list}]).

  gives

    "#ab-B#cd"

  Note:
    Non-matching optional subexpressions will not be included in
    the list of subexpression matches if they are the last
    subexpressions in the regular expression.

    Example:

    The regular expression [;;4m"(a)(b)?(c)?"[0m ("a", optionally
    followed by "b", optionally followed by "c") will create the
    following subexpression lists:

     â€¢ [;;4m[<<"a">>, <<"b">>, <<"c">>][0m when applied to the string [;;4m[0m
       [;;4m"abc"[0m

     â€¢ [;;4m[<<"a">>, <<>>, <<"c">>][0m when applied to the string [;;4m[0m
       [;;4m"acx"[0m

     â€¢ [;;4m[<<"a">>, <<"b">>][0m when applied to the string [;;4m"abx"[0m

     â€¢ [;;4m[<<"a">>][0m when applied to the string [;;4m"axx"[0m

  As with [;;4mrun/3[0m, compilation errors raise the [;;4mbadarg[0m exception. [;;4m[0m
  [;;4mcompile/2[0m can be used to get more information about the error.
