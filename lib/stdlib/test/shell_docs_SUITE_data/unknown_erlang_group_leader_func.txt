
  [;1m-spec group_leader() -> pid().[0m

  Returns the process identifier of the group leader for the process
  evaluating the function.

  Every process is a member of some process group and all groups
  have a group leader. All I/O from the group is channeled to the
  group leader. When a new process is spawned, it gets the same
  group leader as the spawning process.

  Initially, at system startup, [;;4minit[0m is both its own group leader
  and the group leader of all processes. During the boot of a system
  the group leader for processes will be changed depending on the
  need of the system. Some examples where this is done are:

   â€¢ When an application is started, the top supervisor of that
     application will have its group leader set to the
     application master. See [;;4mapplication:start/2[0m for more
     details.

   â€¢ When running tests, both [;;4mcommon_test[0m and [;;4meunit[0m set the
     group leader in order to capture any I/O from the testcase.

   â€¢ The interactive shell sets the group leader to intercept
     I/O.

  [;1m-spec group_leader(GroupLeader, Pid) -> true[0m
  [;1m                      when GroupLeader :: pid(), Pid :: pid().[0m

  Sets the group leader of [;;4mPid[0m to [;;4mGroupLeader[0m. Typically, this
  is used when a process started from a certain shell is to have
  another group leader than [;;4minit[0m.

  The group leader should be rarely changed in applications with a
  supervision tree, because OTP assumes the group leader of their
  processes is their application master.

  Setting the group leader follows the signal ordering guarantees
  described in the Processes Chapter in the Erlang Reference
  Manual.

  See also [;;4mgroup_leader/0[0m and OTP design principles related to
  starting and stopping applications.

  Note:
    For some important information about distributed signals, see
    the Blocking Signaling Over Distribution section in the 
    Processes chapter of the Erlang Reference Manual.
