<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>2005</year><year>2017</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>

    <title>ssh_sftp</title>
    <prepared>OTP</prepared>
    <docno></docno>
    <date>2005-09-22</date>
    <rev></rev>
    <file>ssh_sftp.sgml</file>
  </header>
  <module>ssh_sftp</module>
  <modulesummary>SFTP client.</modulesummary>
  <description>
    <p>This module implements an SSH FTP (SFTP) client. SFTP is a
    secure, encrypted file transfer service available for
    SSH.</p>
  </description>
  
 <section>
    <title>DATA TYPES</title>
    <p>Type definitions that are used more than once in this module,
    or abstractions to indicate the intended use of the data type, or both:
    </p>

    <taglist>
      <tag><c>reason()</c></tag>
      <item>
	<p>= <c>atom()</c> A description of the reason why an operation failed.</p>
	<p>
	  The value is formed from the sftp error codes in the protocol-level responses as defined in 
	  <url href="https://tools.ietf.org/id/draft-ietf-secsh-filexfer-13.txt">draft-ietf-secsh-filexfer-13.txt</url>
	  section 9.1.
	</p>
	<p>
	  The codes are named as <c>SSH_FX_*</c> which are transformed into lowercase of the star-part.
	  E.g. the error code <c>SSH_FX_NO_SUCH_FILE</c>
	  will cause the <c>reason()</c> to be <c>no_such_file</c>.
	</p>
      </item>

      <tag><c>ssh_connection_ref() =</c></tag>
      <item><p><c>opaque()</c> - as returned by 
      <seealso marker="ssh#connect-3"><c>ssh:connect/3</c></seealso></p></item>

      <tag><c>timeout()</c></tag>
      <item><p>= <c>infinity | integer()</c> in milliseconds. Default infinity.</p></item>
    </taglist>
   </section>

 <section>
    <title>Time-outs</title>
    <p>If the request functions for the SFTP channel return <c>{error, timeout}</c>,
     no answer was received from the server within the expected time.</p>
     <p>The request may have reached the server and may have been performed.
     However, no answer was received from the server within the expected time.</p>
   </section>

  <funcs>
     <func>
       <name>apread(ChannelPid, Handle, Position, Len) -> {async, N} | {error, reason()}</name>
       <fsummary>Reads asynchronously from an open file.</fsummary>
       <type>
	 <v>ChannelPid = pid()</v>
         <v>Handle = term()</v>
         <v>Position = integer()</v>
         <v>Len = integer()</v>
         <v>N = term()</v>
       </type>
       <desc><p>The <c><![CDATA[apread/4]]></c> function reads from a specified position,
       combining the <seealso marker="#position-3"><c>position/3</c></seealso> and 
       <seealso marker="#aread-3"><c>aread/3</c></seealso> functions.</p>
       </desc>
     </func>
     
     <func>
	<name>apwrite(ChannelPid, Handle, Position, Data) -> {async, N} | {error, reason()}</name>
	<fsummary>Writes asynchronously to an open file.</fsummary>
	<type>
	  <v>ChannelPid = pid()</v>
	  <v>Handle = term()</v>
	  <v>Position = integer()</v>
	  <v>Len = integer()</v>
	  <v>Data = binary()</v>
	  <v>Timeout = timeout()</v>
          <v>N = term()</v>
	</type>
       <desc><p>The <c><![CDATA[apwrite/4]]></c> function writes to a specified position,
       combining the <seealso marker="#position-3"><c>position/3</c></seealso> and 
       <seealso marker="#awrite-3"><c>awrite/3</c></seealso> functions.</p>
       </desc>
      </func>
      
      <func>
	<name>aread(ChannelPid, Handle, Len) -> {async, N} | {error, reason()}</name>
	<fsummary>Reads asynchronously from an open file.</fsummary>
	<type>
	  <v>ChannelPid = pid()</v>
	  <v>Handle = term()</v>
	  <v>Position = integer()</v>
	  <v>Len = integer()</v>
	  <v>N = term()</v>
	</type>
	<desc>
	  <p>Reads from an open file, without waiting for the result. If the
          handle is valid, the function returns <c><![CDATA[{async, N}]]></c>, where <c>N</c>
          is a term guaranteed to be unique between calls of <c><![CDATA[aread]]></c>.
          The actual data is sent as a message to the calling process. This
          message has the form <c><![CDATA[{async_reply, N, Result}]]></c>, where
          <c><![CDATA[Result]]></c> is the result from the read, either <c><![CDATA[{ok, Data}]]></c>,
          <c><![CDATA[eof]]></c>, or <c><![CDATA[{error, reason()}]]></c>.</p>
      </desc>
    </func>

    <func>
      <name>awrite(ChannelPid, Handle, Data) -> {async, N} | {error, reason()}</name>
      <fsummary>Writes asynchronously to an open file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Handle = term()</v>
        <v>Position = integer()</v>
        <v>Len = integer()</v>
        <v>Data = binary()</v>
	<v>Timeout = timeout()</v>
      </type>
      <desc>
        <p>Writes to an open file, without waiting for the result. If the
          handle is valid, the function returns <c><![CDATA[{async, N}]]></c>, where <c>N</c>
          is a term guaranteed to be unique between calls of
          <c><![CDATA[awrite]]></c>. The result of the <c><![CDATA[write]]></c> operation is sent
          as a message to the calling process. This message has the form
          <c><![CDATA[{async_reply, N, Result}]]></c>, where <c><![CDATA[Result]]></c> is the result
          from the write, either <c><![CDATA[ok]]></c>, or <c><![CDATA[{error, reason()}]]></c>.</p>
      </desc>
    </func>

    <func>
      <name>close(ChannelPid, Handle) -></name>
      <name>close(ChannelPid, Handle, Timeout) -> ok | {error, reason()}</name>
      <fsummary>Closes an open handle.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Handle = term()</v>
	<v>Timeout = timeout()</v>
      </type>
      <desc>
        <p>Closes a handle to an open file or directory on the server.</p>
      </desc>
    </func>

    <func>
      <name>delete(ChannelPid, Name) -></name>
      <name>delete(ChannelPid, Name, Timeout) -> ok | {error, reason()}</name>
      <fsummary>Deletes a file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Name = string()</v>
	<v>Timeout = timeout()</v>
      </type>
      <desc>
        <p>Deletes the file specified by <c><![CDATA[Name]]></c>.
	</p>
      </desc>
    </func>

    <func>
      <name>del_dir(ChannelPid, Name) -></name>
      <name>del_dir(ChannelPid, Name, Timeout) -> ok | {error, reason()}</name>
      <fsummary>Deletes an empty directory.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Name = string()</v>
	<v>Timeout = timeout()</v>
      </type>
      <desc>
	<p>Deletes a directory specified by <c><![CDATA[Name]]></c>.
	The directory must be empty before it can be successfully deleted.
	</p>
      </desc>
    </func>

     <func>
      <name>list_dir(ChannelPid, Path) -></name>
      <name>list_dir(ChannelPid, Path, Timeout) -> {ok, Filenames} | {error, reason()}</name>
      <fsummary>Lists the directory.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Path = string()</v>
        <v>Filenames = [Filename]</v>
        <v>Filename = string()</v>
	<v>Timeout = timeout()</v>
      </type>
      <desc>
        <p>Lists the given directory on the server, returning the
          filenames as a list of strings.</p>
      </desc>
    </func>

    <func>
      <name>make_dir(ChannelPid, Name) -></name>
      <name>make_dir(ChannelPid, Name, Timeout) -> ok | {error, reason()}</name>
      <fsummary>Creates a directory.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Name = string()</v>
	<v>Timeout = timeout()</v>
      </type>
      <desc>
        <p>Creates a directory specified by <c><![CDATA[Name]]></c>. <c><![CDATA[Name]]></c>
          must be a full path to a new directory. The directory can only be
	created in an existing directory.</p>
      </desc>
    </func>

    <func>
      <name>make_symlink(ChannelPid, Name, Target) -></name>
      <name>make_symlink(ChannelPid, Name, Target, Timeout) -> ok | {error, reason()}</name>
      <fsummary>Creates a symbolic link.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Name = string()</v>
        <v>Target = string()</v>
      </type>
      <desc>
        <p>Creates a symbolic link pointing to <c><![CDATA[Target]]></c> with the
          name <c><![CDATA[Name]]></c>.
	</p>
      </desc>
    </func>

       <func>
      <name>open(ChannelPid, File, Mode) -></name>
      <name>open(ChannelPid, File, Mode, Timeout) -> {ok, Handle} | {error, reason()}</name>
      <fsummary>Opens a file and returns a handle.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>File = string()</v>
        <v>Mode = [Modeflag]</v>
        <v>Modeflag = read | write | creat | trunc | append | binary</v>
	<v>Timeout = timeout()</v>
	<v>Handle = term()</v>
      </type>
      <desc>
        <p>Opens a file on the server and returns a handle, which
          can be used for reading or writing.</p>
      </desc>
    </func>
    <func>
      <name>opendir(ChannelPid, Path) -></name>
      <name>opendir(ChannelPid, Path, Timeout) -> {ok, Handle} | {error, reason()}</name>
      <fsummary>Opens a directory and returns a handle.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Path = string()</v>
	<v>Timeout = timeout()</v>
      </type>
      <desc>
        <p>Opens a handle to a directory on the server. The handle
          can be used for reading directory contents.</p>
      </desc>
    </func>

    <func>
      <name>open_tar(ChannelPid, Path, Mode) -></name>
      <name>open_tar(ChannelPid, Path, Mode, Timeout) -> {ok, Handle} | {error, reason()}</name>
      <fsummary>Opens a tar file on the server to which <c>ChannelPid</c>
      is connected and returns a handle.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Path = string()</v>
	<v>Mode = [read] | [write] | [read,EncryptOpt] | [write,DecryptOpt]</v>
	<v>EncryptOpt = {crypto,{InitFun,EncryptFun,CloseFun}}</v>
	<v>DecryptOpt = {crypto,{InitFun,DecryptFun}}</v>
	<v>InitFun = (fun() -> {ok,CryptoState}) | (fun() -> {ok,CryptoState,ChunkSize})</v>
	<v>CryptoState = any()</v>
	<v>ChunkSize = undefined | pos_integer()</v>
	<v>EncryptFun = (fun(PlainBin,CryptoState) -> EncryptResult)</v>
	<v>EncryptResult = {ok,EncryptedBin,CryptoState} | {ok,EncryptedBin,CryptoState,ChunkSize}</v>
	<v>PlainBin = binary()</v>
	<v>EncryptedBin = binary()</v>
	<v>DecryptFun = (fun(EncryptedBin,CryptoState) -> DecryptResult)</v>
	<v>DecryptResult = {ok,PlainBin,CryptoState} | {ok,PlainBin,CryptoState,ChunkSize}</v>
	<v>CloseFun = (fun(PlainBin,CryptoState) -> {ok,EncryptedBin})</v>
	<v>Timeout = timeout()</v>
      </type>
      <desc>
        <p>Opens a handle to a tar file on the server, associated with <c>ChannelPid</c>.
	The handle can be used for remote tar creation and extraction, as defined by the
	<seealso marker="stdlib:erl_tar#init-3">erl_tar:init/3</seealso> function.
	</p>

	<p> For code exampel see Section
	<seealso marker="using_ssh">SFTP Client with TAR Compression and Encryption</seealso> in
	the ssh Users Guide. </p>

	<p>The <c>crypto</c> mode option is applied to the generated stream of bytes prior to sending
	them to the SFTP server. This is intended for encryption but can be used for other
	purposes.
	</p>
	<p>The <c>InitFun</c> is applied once
	prior to any other <c>crypto</c> operation. The returned <c>CryptoState</c> is then folded into
	repeated applications of the <c>EncryptFun</c> or <c>DecryptFun</c>. The binary returned
	from those funs are sent further to the remote SFTP server. Finally, if doing encryption,
	the <c>CloseFun</c> is applied to the last piece of data. The <c>CloseFun</c> is
	responsible for padding (if needed) and encryption of that last piece.
	</p>
	<p>The <c>ChunkSize</c> defines the size of the <c>PlainBin</c>s that <c>EncodeFun</c> is applied
	to. If the <c>ChunkSize</c> is <c>undefined</c>, the size of the <c>PlainBin</c>s varies,
	because this is	intended for stream crypto, whereas a fixed <c>ChunkSize</c> is intended for block crypto.
	<c>ChunkSize</c>s can be changed in the return from the <c>EncryptFun</c> or
	<c>DecryptFun</c>. The value can be changed between <c>pos_integer()</c> and <c>undefined</c>.
	</p>

      </desc>
    </func>

    <func>
      <name>position(ChannelPid, Handle, Location) -></name>
      <name>position(ChannelPid, Handle, Location, Timeout) -> {ok, NewPosition | {error, reason()}</name>
      <fsummary>Sets the file position of a file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Handle = term()</v>
        <v>Location = Offset
 | {bof, Offset} | {cur, Offset} | {eof, Offset} | bof | cur | eof</v>
        <v>Offset = integer()</v>
	<v>Timeout = timeout()</v>
        <v>NewPosition = integer()</v>
      </type>
      <desc>
        <p>Sets the file position of the file referenced by <c><![CDATA[Handle]]></c>.
          Returns <c><![CDATA[{ok, NewPosition}]]></c> (as an absolute offset) if
          successful, otherwise <c><![CDATA[{error, reason()}]]></c>. <c><![CDATA[Location]]></c> is
          one of the following:</p>
        <taglist>
          <tag><c><![CDATA[Offset]]></c></tag>
          <item>
            <p>The same as <c><![CDATA[{bof, Offset}]]></c>.</p>
          </item>
          <tag><c><![CDATA[{bof, Offset}]]></c></tag>
          <item>
            <p>Absolute offset.</p>
          </item>
          <tag><c><![CDATA[{cur, Offset}]]></c></tag>
          <item>
            <p>Offset from the current position.</p>
          </item>
          <tag><c><![CDATA[{eof, Offset}]]></c></tag>
          <item>
            <p>Offset from the end of file.</p>
          </item>
          <tag><c><![CDATA[bof | cur | eof]]></c></tag>
          <item>
            <p>The same as eariler with <c><![CDATA[Offset]]></c> 0,
	    that is, <c><![CDATA[{bof, 0} | {cur, 0} | {eof, 0}]]></c>.
	    </p>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name>pread(ChannelPid, Handle, Position, Len) -></name>
      <name>pread(ChannelPid, Handle, Position, Len, Timeout) -> {ok, Data} | eof | {error, reason()}</name>
      <fsummary>Reads from an open file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Handle = term()</v>
        <v>Position = integer()</v>
        <v>Len = integer()</v>
	<v>Timeout = timeout()</v>
        <v>Data = string() | binary()</v>
      </type>
       <desc><p>The <c><![CDATA[pread/3,4]]></c> function reads from a specified position,
       combining the <seealso marker="#position-3"><c>position/3</c></seealso> and 
       <seealso marker="#read-3"><c>read/3,4</c></seealso> functions.</p>
       </desc>
     </func>

    <func>
      <name>pwrite(ChannelPid, Handle, Position, Data) -> ok</name>
      <name>pwrite(ChannelPid, Handle, Position, Data, Timeout) -> ok | {error, reason()}</name>
      <fsummary>Writes to an open file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Handle = term()</v>
        <v>Position = integer()</v>
        <v>Data = iolist()</v>
	<v>Timeout = timeout()</v>
      </type>
       <desc><p>The <c><![CDATA[pwrite/3,4]]></c> function writes to a specified position,
       combining the <seealso marker="#position-3"><c>position/3</c></seealso> and 
       <seealso marker="#write-3"><c>write/3,4</c></seealso> functions.</p>
       </desc>
    </func>

    <func>
      <name>read(ChannelPid, Handle, Len) -></name>
      <name>read(ChannelPid, Handle, Len, Timeout) -> {ok, Data} | eof | {error, reason()}</name>
      <fsummary>Reads from an open file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Handle = term()</v>
        <v>Position = integer()</v>
        <v>Len = integer()</v>
	<v>Timeout = timeout()</v>
        <v>Data = string() | binary()</v>
      </type>
      <desc>
        <p>Reads <c><![CDATA[Len]]></c> bytes from the file referenced by
          <c><![CDATA[Handle]]></c>. Returns <c><![CDATA[{ok, Data}]]></c>, <c><![CDATA[eof]]></c>, or
          <c><![CDATA[{error, reason()}]]></c>. If the file is opened with <c><![CDATA[binary]]></c>,
          <c><![CDATA[Data]]></c> is a binary, otherwise it is a string.</p>
        <p>If the file is read past <c>eof</c>, only the remaining bytes
          are read and returned. If no bytes are read, <c><![CDATA[eof]]></c>
          is returned.</p>
      </desc>
    </func>

      <func>
      <name>read_file(ChannelPid, File) -></name>
      <name>read_file(ChannelPid, File, Timeout) -> {ok, Data} | {error, reason()}</name>
      <fsummary>Reads a file.</fsummary>
      <type>
	<v>ChannelPid = pid()</v>
	<v>File = string()</v>
        <v>Data = binary()</v>
	<v>Timeout = timeout()</v>
      </type>
      <desc>
        <p>Reads a file from the server, and returns the data in a binary.</p>
      </desc>
    </func>

      <func>
      <name>read_file_info(ChannelPid, Name) -></name>
      <name>read_file_info(ChannelPid, Name, Timeout) -> {ok, FileInfo} | {error, reason()}</name>
      <fsummary>Gets information about a file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Name = string()</v>
        <v>Handle = term()</v>
	<v>Timeout = timeout()</v>
        <v>FileInfo = record()</v>
      </type>
      <desc>
        <p>Returns a <c><![CDATA[file_info]]></c> record from the file system object specified by
          <c><![CDATA[Name]]></c> or <c><![CDATA[Handle]]></c>. See
	<seealso marker="kernel:file#read_file_info-2">file:read_file_info/2</seealso>
	for information about the record.
	</p>
	<p>
	  Depending on the underlying OS:es links might be followed and info on the final file, directory
	  etc is returned. See <seealso marker="#read_link_info-2">ssh_sftp::read_link_info/2</seealso>
	  on how to get information on links instead.
	</p>
      </desc>
    </func>

     <func>
      <name>read_link(ChannelPid, Name) -></name>
      <name>read_link(ChannelPid, Name, Timeout) -> {ok, Target} | {error, reason()}</name>
      <fsummary>Reads symbolic link.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Name = string()</v>
        <v>Target = string()</v>
      </type>
      <desc>
        <p>Reads the link target from the symbolic link specified by <c><![CDATA[name]]></c>.
	</p>
      </desc>
    </func>

     <func>
      <name>read_link_info(ChannelPid, Name) -> {ok, FileInfo} | {error, reason()}</name>
      <name>read_link_info(ChannelPid, Name, Timeout) -> {ok, FileInfo} | {error, reason()}</name>
      <fsummary>Gets information about a symbolic link.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Name = string()</v>
        <v>Handle = term()</v>
	<v>Timeout = timeout()</v>
        <v>FileInfo = record()</v>
      </type>
      <desc>
        <p>Returns a <c><![CDATA[file_info]]></c> record from the symbolic
          link specified by <c><![CDATA[Name]]></c> or <c><![CDATA[Handle]]></c>.
	  See
	  <seealso marker="kernel:file#read_link_info-2">file:read_link_info/2</seealso>
	  for information about the record.
	</p>
      </desc>
    </func>

    <func>
      <name>rename(ChannelPid, OldName, NewName) -> </name>
      <name>rename(ChannelPid, OldName, NewName, Timeout) -> ok | {error, reason()}</name>
      <fsummary>Renames a file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>OldName = string()</v>
        <v>NewName = string()</v>
	<v>Timeout = timeout()</v>
      </type>
      <desc>
        <p>Renames a file named <c><![CDATA[OldName]]></c> and gives it the name
          <c><![CDATA[NewName]]></c>.
	</p>
      </desc>
    </func>

    <func>
      <name>start_channel(ConnectionRef) -></name>
      <name>start_channel(ConnectionRef, Options) ->
      {ok, Pid} | {error, reason()|term()}</name>

      <name>start_channel(Host, Options) -></name>
      <name>start_channel(Host, Port, Options) -> 
      {ok, Pid, ConnectionRef} | {error, reason()|term()}</name>

      <name>start_channel(TcpSocket) -></name>
      <name>start_channel(TcpSocket, Options) ->
      {ok, Pid, ConnectionRef} | {error, reason()|term()}</name>

      <fsummary>Starts an SFTP client.</fsummary>
      <type>
        <v>Host = string()</v>
        <v>ConnectionRef = ssh_connection_ref()</v>
        <v>Port = integer()</v>
	<v>TcpSocket = port()</v>
	<d>The socket is supposed to be from <seealso marker="kernel:gen_tcp#connect-3">gen_tcp:connect</seealso> or <seealso marker="kernel:gen_tcp#accept-1">gen_tcp:accept</seealso> with option <c>{active,false}</c></d>
        <v>Options = [{Option, Value}]</v>
      </type>
      <desc>
	<p>If no connection reference is provided, a connection is set
	up, and the new connection is returned. An SSH channel process
	is started to handle the communication with the SFTP server.
	The returned <c>pid</c> for this process is to be used as input to
	all other API functions in this module.</p>

	<p>Options:</p>
	<taglist>
          <tag><c><![CDATA[{timeout, timeout()}]]></c></tag>
	  <item>
	    <p>There are two ways to set a timeout for the underlying ssh connection:</p>
	    <list>
	      <item>If the connection timeout option <c>connect_timeout</c> is set, that value
	      is used also for the negotiation timeout and this option (<c>timeout</c>) is ignored.</item>
	      <item>Otherwise, this option (<c>timeout</c>) is used as the negotiation timeout
	      only and there is no connection timeout set</item>
	    </list>
	    <p>The value defaults to <c>infinity</c>.</p>
	  </item>
	  <tag>
	    <c><![CDATA[{sftp_vsn, integer()}]]></c>
	  </tag>
	  <item>
	    <p>
	      Desired SFTP protocol version.
	      The actual version is the minimum of
	      the desired version and the maximum supported
	      versions by the SFTP server.
	    </p>
	  </item>
	</taglist>
	<p>All other options are directly passed to
	<seealso marker="ssh">ssh:connect/3</seealso> or ignored if a
	connection is already provided.</p>
      </desc>
    </func>

     <func>
      <name>stop_channel(ChannelPid) -> ok</name>
      <fsummary>Stops the SFTP client channel.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
      </type>
      <desc>
	<p>Stops an SFTP channel. Does not close the SSH connection.
	Use <seealso marker="ssh#close-1">ssh:close/1</seealso> to close it.</p>
      </desc>
    </func>

    <func>
      <name>write(ChannelPid, Handle, Data) -></name>
      <name>write(ChannelPid, Handle, Data, Timeout) -> ok | {error, reason()}</name>
      <fsummary>Writes to an open file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Handle = term()</v>
        <v>Position = integer()</v>
        <v>Data = iolist()</v>
	<v>Timeout = timeout()</v>
      </type>
      <desc>
        <p>Writes <c><![CDATA[data]]></c> to the file referenced by <c><![CDATA[Handle]]></c>.
	The file is to be opened with <c><![CDATA[write]]></c> or <c><![CDATA[append]]></c>
	flag. Returns <c><![CDATA[ok]]></c> if successful or <c><![CDATA[{error, reason()}]]></c>
	otherwise.</p>
      </desc>
    </func>
    
    <func>
      <name>write_file(ChannelPid, File, Iolist) -></name>
      <name>write_file(ChannelPid, File, Iolist, Timeout) -> ok | {error, reason()}</name>
      <fsummary>Writes a file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>File = string()</v>
        <v>Iolist = iolist()</v>
	<v>Timeout = timeout()</v>
      </type>
      <desc>
        <p>Writes a file to the server.	The file is created if it does not exist
	but overwritten if it exists.</p>
      </desc>
    </func>
    
    <func>
      <name>write_file_info(ChannelPid, Name, Info) -></name>
      <name>write_file_info(ChannelPid, Name, Info, Timeout) -> ok | {error, reason()}</name>
      <fsummary>Writes information for a file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Name = string()</v>
        <v>Info = record()</v>
	<v>Timeout = timeout()</v>
      </type>
      <desc>
        <p>Writes file information from a <c><![CDATA[file_info]]></c> record to the
	file specified by <c><![CDATA[Name]]></c>. See
	<seealso marker="kernel:file#write_file_info-2">file:write_file_info/[2,3]</seealso>
	for information about the record.
	</p>
      </desc>
    </func>
  </funcs>
  
</erlref>

