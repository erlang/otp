<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>2005</year><year>2014</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>

    <title>ssh_sftp</title>
    <prepared>OTP</prepared>
    <docno></docno>
    <date>2005-09-22</date>
    <rev></rev>
    <file>ssh_sftp.sgml</file>
  </header>
  <module>ssh_sftp</module>
  <modulesummary>SFTP client.</modulesummary>
  <description>
    <p>This module implements an SSH FTP (SFTP) client. SFTP is a
    secure, encrypted file transfer service available for
    SSH.</p>
  </description>
  
 <section>
    <title>DATA TYPES</title>
    <p>Type definitions that are used more than once in this module,
    or abstractions to indicate the intended use of the data type, or both:
    </p>

    <taglist>
      <tag><c>ssh_connection_ref() =</c></tag>
      <item><p>opaque() - as returned by <c>ssh:connect/3</c></p></item>
      <tag><c>timeout()</c></tag>
      <item><p>= <c>infinity | integer() in milliseconds. Default infinity.</c></p></item>
    </taglist>
   </section>

 <section>
    <title>Time-outs</title>
    <p>If the request functions for the SFTP channel return <c>{error, timeout}</c>,
    it does not guarantee that the request never reached the server and was
    not performed. It only means that no answer was received from the
    server within the expected time.</p>
   </section>

  <funcs>
     <func>
      <name>apread(ChannelPid, Handle, Position, Len) -> {async, N} | {error, Error}</name>
      <v>ChannelPid = pid()</v>
        <v>Handle = term()</v>
        <v>Position = integer()</v>
        <v>Len = integer()</v>
        <v>N = term()</v>
        <v>Reason = term()</v>

	<desc><p>The <c><![CDATA[apread]]></c> function reads from a specified position,
	combining the <c><![CDATA[position]]></c> and <c><![CDATA[aread]]></c> functions.</p>
	<p><seealso marker="#apread-4">ssh_sftp:apread/4</seealso></p> </desc>
      </func>

      <func>
	<name>apwrite(ChannelPid, Handle, Position, Data) -> ok | {error, Reason}</name>
	<fsummary>Writes asynchronously to an open file.</fsummary>
	<type>
	  <v>ChannelPid = pid()</v>
	  <v>Handle = term()</v>
	  <v>Position = integer()</v>
	  <v>Len = integer()</v>
	  <v>Data = binary()</v>
	  <v>Timeout = timeout()</v>
	  <v>Reason = term()</v>
	</type>
	<desc>
	  <p><c><![CDATA[apwrite]]></c> writes on a specified position, combining
          the <c><![CDATA[position]]></c> and <c><![CDATA[awrite]]></c> operations.</p>
	<p><seealso marker="#awrite-3">ssh_sftp:awrite/3</seealso> </p></desc>
      </func>
      
      <func>
	<name>aread(ChannelPid, Handle, Len) -> {async, N} | {error, Error}</name>
	<fsummary>Reads asynchronously from an open file.</fsummary>
	<type>
	  <v>ChannelPid = pid()</v>
	  <v>Handle = term()</v>
	  <v>Position = integer()</v>
	  <v>Len = integer()</v>
	  <v>N = term()</v>
	  <v>Reason = term()</v>
	</type>
	<desc>
	  <p>Reads from an open file, without waiting for the result. If the
          handle is valid, the function returns <c><![CDATA[{async, N}]]></c>, where <c>N</c>
          is a term guaranteed to be unique between calls of <c><![CDATA[aread]]></c>.
          The actual data is sent as a message to the calling process. This
          message has the form <c><![CDATA[{async_reply, N, Result}]]></c>, where
          <c><![CDATA[Result]]></c> is the result from the read, either <c><![CDATA[{ok, Data}]]></c>,
          <c><![CDATA[eof]]></c>, or <c><![CDATA[{error, Error}]]></c>.</p>
      </desc>
    </func>

  

    <func>
      <name>awrite(ChannelPid, Handle, Data) -> ok | {error, Reason}</name>
      <fsummary>Writes asynchronously to an open file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Handle = term()</v>
        <v>Position = integer()</v>
        <v>Len = integer()</v>
        <v>Data = binary()</v>
	<v>Timeout = timeout()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Writes to an open file, without waiting for the result. If the
          handle is valid, the function returns <c><![CDATA[{async, N}]]></c>, where <c>N</c>
          is a term guaranteed to be unique between calls of
          <c><![CDATA[awrite]]></c>. The result of the <c><![CDATA[write]]></c> operation is sent
          as a message to the calling process. This message has the form
          <c><![CDATA[{async_reply, N, Result}]]></c>, where <c><![CDATA[Result]]></c> is the result
          from the write, either <c><![CDATA[ok]]></c>, or <c><![CDATA[{error, Error}]]></c>.</p>
      </desc>
    </func>

    <func>
      <name>close(ChannelPid, Handle) -></name>
      <name>close(ChannelPid, Handle, Timeout) -> ok | {error, Reason}</name>
      <fsummary>Closes an open handle.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Handle = term()</v>
	<v>Timeout = timeout()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Closes a handle to an open file or directory on the server.</p>
      </desc>
    </func>

    <func>
      <name>delete(ChannelPid, Name) -></name>
      <name>delete(ChannelPid, Name, Timeout) -> ok | {error, Reason}</name>
      <fsummary>Deletes a file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Name = string()</v>
	<v>Timeout = timeout()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Deletes the file specified by <c><![CDATA[Name]]></c>, like
	   <seealso marker="kernel:file#delete-1">file:delete/1</seealso></p>
      </desc>
    </func>

    <func>
      <name>del_dir(ChannelPid, Name) -></name>
      <name>del_dir(ChannelPid, Name, Timeout) -> ok | {error, Reason}</name>
      <fsummary>Deletes an empty directory.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Name = string()</v>
	<v>Timeout = timeout()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
	<p>Deletes a directory specified by <c><![CDATA[Name]]></c>.
	The directory must be empty before it can be successfully deleted.
	</p>
      </desc>
    </func>

     <func>
      <name>list_dir(ChannelPid, Path) -></name>
      <name>list_dir(ChannelPid, Path, Timeout) -> {ok, Filenames} | {error, Reason}</name>
      <fsummary>Lists the directory.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Path = string()</v>
        <v>Filenames = [Filename]</v>
        <v>Filename = string()</v>
	<v>Timeout = timeout()</v>
	<v>Reason = term()</v>
      </type>
      <desc>
        <p>Lists the given directory on the server, returning the
          filenames as a list of strings.</p>
      </desc>
    </func>

    <func>
      <name>make_dir(ChannelPid, Name) -></name>
      <name>make_dir(ChannelPid, Name, Timeout) -> ok | {error, Reason}</name>
      <fsummary>Creates a directory.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Name = string()</v>
	<v>Timeout = timeout()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Creates a directory specified by <c><![CDATA[Name]]></c>. <c><![CDATA[Name]]></c>
          must be a full path to a new directory. The directory can only be
	created in an existing directory.</p>
      </desc>
    </func>

    <func>
      <name>make_symlink(ChannelPid, Name, Target) -></name>
      <name>make_symlink(ChannelPid, Name, Target, Timeout) -> ok | {error, Reason}</name>
      <fsummary>Creates a symbolic link.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Name = string()</v>
        <v>Target = string()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Creates a symbolic link pointing to <c><![CDATA[Target]]></c> with the
          name <c><![CDATA[Name]]></c>, like
	   <seealso marker="kernel:file#make_symlink-2">file:make_symlink/2</seealso></p>
      </desc>
    </func>

       <func>
      <name>open(ChannelPid, File, Mode) -></name>
      <name>open(ChannelPid, File, Mode, Timeout) -> {ok, Handle} | {error, Reason}</name>
      <fsummary>Opens a file and returns a handle.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>File = string()</v>
        <v>Mode = [Modeflag]</v>
        <v>Modeflag = read | write | creat | trunc | append | binary</v>
	<v>Timeout = timeout()</v>
	<v>Handle = term()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Opens a file on the server and returns a handle, which
          can be used for reading or writing.</p>
      </desc>
    </func>
    <func>
      <name>opendir(ChannelPid, Path) -></name>
      <name>opendir(ChannelPid, Path, Timeout) -> {ok, Handle} | {error, Reason}</name>
      <fsummary>Opens a directory and returns a handle.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Path = string()</v>
	<v>Timeout = timeout()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Opens a handle to a directory on the server. The handle
          can be used for reading directory contents.</p>
      </desc>
    </func>

    <func>
      <name>open_tar(ChannelPid, Path, Mode) -></name>
      <name>open_tar(ChannelPid, Path, Mode, Timeout) -> {ok, Handle} | {error, Reason}</name>
      <fsummary>Opens a tar file on the server to which <c>ChannelPid</c>
      is connected and returns a handle.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Path = string()</v>
	<v>Mode = [read] | [write] | [read,EncryptOpt] | [write,DecryptOpt]</v>
	<v>EncryptOpt = {crypto,{InitFun,EncryptFun,CloseFun}}</v>
	<v>DecryptOpt = {crypto,{InitFun,DecryptFun}}</v>
	<v>InitFun = (fun() -> {ok,CryptoState}) | (fun() -> {ok,CryptoState,ChunkSize})</v>
	<v>CryptoState = any()</v>
	<v>ChunkSize = undefined | pos_integer()</v>
	<v>EncryptFun = (fun(PlainBin,CryptoState) -> EncryptResult)</v>
	<v>EncryptResult = {ok,EncryptedBin,CryptoState} | {ok,EncryptedBin,CryptoState,ChunkSize}</v>
	<v>PlainBin = binary()</v>
	<v>EncryptedBin = binary()</v>
	<v>DecryptFun = (fun(EncryptedBin,CryptoState) -> DecryptResult)</v>
	<v>DecryptResult = {ok,PlainBin,CryptoState} | {ok,PlainBin,CryptoState,ChunkSize}</v>
	<v>CloseFun = (fun(PlainBin,CryptoState) -> {ok,EncryptedBin})</v>
	<v>Timeout = timeout()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Opens a handle to a tar file on the server, associated with <c>ChannelPid</c>.
	The handle can be used for remote tar creation and extraction, as defined by the
	<seealso marker="stdlib:erl_tar#init-3">erl_tar:init/3</seealso> function.
	</p>

	<p> For code exampel see Section
	<seealso marker="using_ssh">SFTP Client with TAR Compression and Encryption</seealso> in
	the ssh Users Guide. </p>

	<p>The <c>crypto</c> mode option is applied to the generated stream of bytes prior to sending
	them to the SFTP server. This is intended for encryption but can be used for other
	purposes.
	</p>
	<p>The <c>InitFun</c> is applied once
	prior to any other <c>crypto</c> operation. The returned <c>CryptoState</c> is then folded into
	repeated applications of the <c>EncryptFun</c> or <c>DecryptFun</c>. The binary returned
	from those funs are sent further to the remote SFTP server. Finally, if doing encryption,
	the <c>CloseFun</c> is applied to the last piece of data. The <c>CloseFun</c> is
	responsible for padding (if needed) and encryption of that last piece.
	</p>
	<p>The <c>ChunkSize</c> defines the size of the <c>PlainBin</c>s that <c>EncodeFun</c> is applied
	to. If the <c>ChunkSize</c> is <c>undefined</c>, the size of the <c>PlainBin</c>s varies,
	because this is	intended for stream crypto, whereas a fixed <c>ChunkSize</c> is intended for block crypto.
	<c>ChunkSize</c>s can be changed in the return from the <c>EncryptFun</c> or
	<c>DecryptFun</c>. The value can be changed between <c>pos_integer()</c> and <c>undefined</c>.
	</p>

      </desc>
    </func>

    <func>
      <name>position(ChannelPid, Handle, Location) -></name>
      <name>position(ChannelPid, Handle, Location, Timeout) -> {ok, NewPosition | {error, Error}</name>
      <fsummary>Sets the file position of a file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Handle = term()</v>
        <v>Location = Offset
 | {bof, Offset} | {cur, Offset} | {eof, Offset} | bof | cur | eof</v>
        <v>Offset = integer()</v>
	<v>Timeout = timeout()</v>
        <v>NewPosition = integer()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Sets the file position of the file referenced by <c><![CDATA[Handle]]></c>.
          Returns <c><![CDATA[{ok, NewPosition}]]></c> (as an absolute offset) if
          successful, otherwise <c><![CDATA[{error, Reason}]]></c>. <c><![CDATA[Location]]></c> is
          one of the following:</p>
        <taglist>
          <tag><c><![CDATA[Offset]]></c></tag>
          <item>
            <p>The same as <c><![CDATA[{bof, Offset}]]></c>.</p>
          </item>
          <tag><c><![CDATA[{bof, Offset}]]></c></tag>
          <item>
            <p>Absolute offset.</p>
          </item>
          <tag><c><![CDATA[{cur, Offset}]]></c></tag>
          <item>
            <p>Offset from the current position.</p>
          </item>
          <tag><c><![CDATA[{eof, Offset}]]></c></tag>
          <item>
            <p>Offset from the end of file.</p>
          </item>
          <tag><c><![CDATA[bof | cur | eof]]></c></tag>
          <item>
            <p>The same as eariler with <c><![CDATA[Offset]]></c> 0,
	    that is, <c><![CDATA[{bof, 0} | {cur, 0} | {eof, 0}]]></c>.
	    </p>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name>pread(ChannelPid, Handle, Position, Len) -></name>
      <name>pread(ChannelPid, Handle, Position, Len, Timeout) -> {ok, Data} | eof | {error, Error}</name>
      <fsummary>Reads from an open file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Handle = term()</v>
        <v>Position = integer()</v>
        <v>Len = integer()</v>
	<v>Timeout = timeout()</v>
        <v>Data = string() | binary()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
	<p>The <c><![CDATA[pread]]></c> function reads from a specified position,
	combining the <c><![CDATA[position]]></c> and <c><![CDATA[read]]></c> functions.</p>
	<p><seealso marker="#read-4">ssh_sftp:read/4</seealso></p>
      </desc>
    </func>

    <func>
      <name>pwrite(ChannelPid, Handle, Position, Data) -> ok</name>
      <name>pwrite(ChannelPid, Handle, Position, Data, Timeout) -> ok | {error, Error}</name>
      <fsummary>Writes to an open file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Handle = term()</v>
        <v>Position = integer()</v>
        <v>Data = iolist()</v>
	<v>Timeout = timeout()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
	<p>The <c><![CDATA[pread]]></c> function writes to a specified position,
	combining the <c><![CDATA[position]]></c> and <c><![CDATA[write]]></c> functions.</p>
	<p><seealso marker="#write-3">ssh_sftp:write/3</seealso></p>
      </desc>
    </func>


     <func>
      <name>read(ChannelPid, Handle, Len) -></name>
      <name>read(ChannelPid, Handle, Len, Timeout) -> {ok, Data} | eof | {error, Error}</name>
      <fsummary>Reads from an open file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Handle = term()</v>
        <v>Position = integer()</v>
        <v>Len = integer()</v>
	<v>Timeout = timeout()</v>
        <v>Data = string() | binary()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Reads <c><![CDATA[Len]]></c> bytes from the file referenced by
          <c><![CDATA[Handle]]></c>. Returns <c><![CDATA[{ok, Data}]]></c>, <c><![CDATA[eof]]></c>, or
          <c><![CDATA[{error, Reason}]]></c>. If the file is opened with <c><![CDATA[binary]]></c>,
          <c><![CDATA[Data]]></c> is a binary, otherwise it is a string.</p>
        <p>If the file is read past <c>eof</c>, only the remaining bytes
          are read and returned. If no bytes are read, <c><![CDATA[eof]]></c>
          is returned.</p>
      </desc>
    </func>

      <func>
      <name>read_file(ChannelPid, File) -></name>
      <name>read_file(ChannelPid, File, Timeout) -> {ok, Data} | {error, Reason}</name>
      <fsummary>Reads a file.</fsummary>
      <type>
	<v>ChannelPid = pid()</v>
	<v>File = string()</v>
        <v>Data = binary()</v>
	<v>Timeout = timeout()</v>
	<v>Reason = term()</v>
      </type>
      <desc>
        <p>Reads a file from the server, and returns the data in a binary,
          like
	   <seealso marker="kernel:file#read_file-1">file:read_file/1</seealso></p>
      </desc>
    </func>

      <func>
      <name>read_file_info(ChannelPid, Name) -></name>
      <name>read_file_info(ChannelPid, Name, Timeout) -> {ok, FileInfo} | {error, Reason}</name>
      <fsummary>Gets information about a file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Name = string()</v>
        <v>Handle = term()</v>
	<v>Timeout = timeout()</v>
        <v>FileInfo = record()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Returns a <c><![CDATA[file_info]]></c> record from the file specified by
          <c><![CDATA[Name]]></c> or <c><![CDATA[Handle]]></c>,
	like <seealso marker="kernel:file#read_file_info-2">file:read_file_info/2</seealso></p>
      </desc>
    </func>

     <func>
      <name>read_link(ChannelPid, Name) -></name>
      <name>read_link(ChannelPid, Name, Timeout) -> {ok, Target} | {error, Reason}</name>
      <fsummary>Reads symbolic link.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Name = string()</v>
        <v>Target = string()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Reads the link target from the symbolic link specified
          by <c><![CDATA[name]]></c>, like
	  <seealso marker="kernel:file#read_link-1">file:read_link/1</seealso></p>
      </desc>
    </func>

     <func>
      <name>read_link_info(ChannelPid, Name) -> {ok, FileInfo} | {error, Reason}</name>
      <name>read_link_info(ChannelPid, Name, Timeout) -> {ok, FileInfo} | {error, Reason}</name>
      <fsummary>Gets information about a symbolic link.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Name = string()</v>
        <v>Handle = term()</v>
	<v>Timeout = timeout()</v>
        <v>FileInfo = record()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Returns a <c><![CDATA[file_info]]></c> record from the symbolic
          link specified by <c><![CDATA[Name]]></c> or <c><![CDATA[Handle]]></c>, like
	<seealso marker="kernel:file#read_link_info-2">file:read_link_info/2</seealso></p>
      </desc>
    </func>

    <func>
      <name>rename(ChannelPid, OldName, NewName) -> </name>
      <name>rename(ChannelPid, OldName, NewName, Timeout) -> ok | {error, Reason}</name>
      <fsummary>Renames a file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>OldName = string()</v>
        <v>NewName = string()</v>
	<v>Timeout = timeout()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Renames a file named <c><![CDATA[OldName]]></c> and gives it the name
          <c><![CDATA[NewName]]></c>, like
	    <seealso marker="kernel:file#rename-2">file:rename/2</seealso></p>
      </desc>
    </func>

    <func>
      <name>start_channel(ConnectionRef) -></name>
      <name>start_channel(ConnectionRef, Options) -></name>
      <name>start_channel(Host, Options) -></name>
      <name>start_channel(Host, Port, Options) -> {ok, Pid} | {ok, Pid, ConnectionRef} |
      {error, Reason}</name>
      <fsummary>Starts an SFTP client.</fsummary>
      <type>
        <v>Host = string()</v>
        <v>ConnectionRef = ssh_connection_ref()</v>
        <v>Port = integer()</v>
        <v>Options = [{Option, Value}]</v>
        <v>Reason = term()</v>
      </type>
      <desc>
	<p>If no connection reference is provided, a connection is set
	up, and the new connection is returned. An SSH channel process
	is started to handle the communication with the SFTP server.
	The returned <c>pid</c> for this process is to be used as input to
	all other API functions in this module.</p>

	<p>Options:</p>
	<taglist>
          <tag><c><![CDATA[{timeout, timeout()}]]></c></tag>
	  <item>
	    <p>The time-out is passed to the <c>ssh_channel</c> start function,
	    and defaults to <c>infinity</c>.</p>
	  </item>
	  <tag>
	    <c><![CDATA[{sftp_vsn, integer()}]]></c>
	  </tag>
	  <item>
	    <p>
	      Desired SFTP protocol version.
	      The actual version is the minimum of
	      the desired version and the maximum supported
	      versions by the SFTP server.
	    </p>
	  </item>
	</taglist>
	<p>All other options are directly passed to
	<seealso marker="ssh">ssh:connect/3</seealso> or ignored if a
	connection is already provided.</p>
      </desc>
    </func>

     <func>
      <name>stop_channel(ChannelPid) -> ok</name>
      <fsummary>Stops the SFTP client channel.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
      </type>
      <desc>
	<p>Stops an SFTP channel. Does not close the SSH connection.
	Use <seealso marker="ssh#close-1">ssh:close/1</seealso> to close it.</p>
      </desc>
    </func>

    <func>
      <name>write(ChannelPid, Handle, Data) -></name>
      <name>write(ChannelPid, Handle, Data, Timeout) -> ok | {error, Error}</name>
      <fsummary>Writes to an open file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Handle = term()</v>
        <v>Position = integer()</v>
        <v>Data = iolist()</v>
	<v>Timeout = timeout()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Writes <c><![CDATA[data]]></c> to the file referenced by <c><![CDATA[Handle]]></c>.
	The file is to be opened with <c><![CDATA[write]]></c> or <c><![CDATA[append]]></c>
	flag. Returns <c><![CDATA[ok]]></c> if successful or <c><![CDATA[{error, Reason}]]></c>
	otherwise.</p>
        <p>Typical error reasons:</p>
        <taglist>
          <tag><c><![CDATA[ebadf]]></c></tag>
          <item>
            <p>File is not opened for writing.</p>
          </item>
          <tag><c><![CDATA[enospc]]></c></tag>
          <item>
            <p>No space is left on the device.</p>
          </item>
        </taglist>
      </desc>
    </func>
    
    <func>
      <name>write_file(ChannelPid, File, Iolist) -></name>
      <name>write_file(ChannelPid, File, Iolist, Timeout) -> ok | {error, Reason}</name>
      <fsummary>Writes a file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>File = string()</v>
        <v>Iolist = iolist()</v>
	<v>Timeout = timeout()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Writes a file to the server, like <seealso
        marker="kernel:file#write_file-2">file:write_file/2</seealso> The
        file is created if it does not exist. The file is overwritten
        if it exists.</p>
      </desc>
    </func>
    
    <func>
      <name>write_file_info(ChannelPid, Name, Info) -></name>
      <name>write_file_info(ChannelPid, Name, Info, Timeout) -> ok | {error, Reason}</name>
      <fsummary>Writes information for a file.</fsummary>
      <type>
        <v>ChannelPid = pid()</v>
        <v>Name = string()</v>
        <v>Info = record()</v>
	<v>Timeout = timeout()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Writes file information from a <c><![CDATA[file_info]]></c> record to the
	file specified by <c><![CDATA[Name]]></c>, like
	<seealso marker="kernel:file#write_file_info-2">file:write_file_info/[2,3]</seealso></p>
      </desc>
    </func>
  </funcs>
  
</erlref>

