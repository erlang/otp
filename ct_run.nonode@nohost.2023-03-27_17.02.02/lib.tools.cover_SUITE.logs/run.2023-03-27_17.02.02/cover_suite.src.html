<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/home/chrys/otp/lib/tools/test/cover_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%% </i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 2001-2022. All Rights Reserved.</i>
<a name="5"/>    5: <i>%% </i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%% </i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: <b>-module</b>(cover_SUITE).
<a name="21"/>   21: 
<a name="22"/>   22: <b>-compile</b>(export_all).
<a name="23"/>   23: 
<a name="24"/>   24: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="25"/>   25: 
<a name="suite-0"/><a name="26"/>   26: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="27"/>   27:     [{ct_hooks,[ts_install_cth]},
<a name="28"/>   28:      {timetrap,{minutes,2}}].
<a name="29"/>   29: 
<a name="all-0"/><a name="30"/>   30: <b>all</b>() -&gt; 
<a name="31"/>   31:     NoStartStop = [eif,otp_5305,otp_5418,otp_7095,otp_8273,
<a name="32"/>   32:                    otp_8340,otp_8188,compile_beam_opts,eep37,
<a name="33"/>   33:                    analyse_no_beam, line_0, compile_beam_no_file,
<a name="34"/>   34:                    compile_beam_missing_backend,
<a name="35"/>   35:                    otp_13277, otp_13289, guard_in_lc, gh_4796,
<a name="36"/>   36:                    eep49],
<a name="37"/>   37:     StartStop = [start, compile, analyse, misc, stop,
<a name="38"/>   38:                  distribution, reconnect, die_and_reconnect,
<a name="39"/>   39:                  dont_reconnect_after_stop, stop_node_after_disconnect,
<a name="40"/>   40:                  export_import, otp_5031, otp_6115,
<a name="41"/>   41:                  otp_8270, otp_10979_hanging_node, otp_14817,
<a name="42"/>   42:                  local_only, startup_race, otp_16476, cover_clauses],
<a name="all-last_expr"/><a name="43"/>   43: <b>    case whereis</b>(cover_server) of
<a name="44"/>   44:         undefined -&gt;
<a name="45"/>   45:             [coverage,StartStop ++ NoStartStop];
<a name="46"/>   46:         _pid -&gt;
<a name="47"/>   47:             [coverage|NoStartStop++[coverage_analysis]]
<a name="48"/>   48:     end.
<a name="49"/>   49: 
<a name="init_per_suite-1"/><a name="50"/>   50: <b>init_per_suite</b>(Config) -&gt;
<a name="init_per_suite-last_expr"/><a name="51"/>   51: <b>    [{ct_is_running_cover,whereis</b>(cover_server) =/= undefined}|Config].
<a name="52"/>   52: 
<a name="end_per_suite-1"/><a name="53"/>   53: <b>end_per_suite</b>(_Config) -&gt;
<a name="end_per_suite-last_expr"/><a name="54"/>   54:     ok.
<a name="55"/>   55: 
<a name="init_per_testcase-2"/><a name="56"/>   56: <b>init_per_testcase</b>(TC, Config) when TC =:= misc; 
<a name="57"/>   57:                                    TC =:= compile;
<a name="58"/>   58:                                    TC =:= analyse;
<a name="59"/>   59:                                    TC =:= distribution;
<a name="60"/>   60:                                    TC =:= otp_5031;
<a name="61"/>   61:                                    TC =:= stop -&gt;
<a name="62"/>   62:     case code:which(crypto) of
<a name="63"/>   63:         Path when is_list(Path) -&gt;
<a name="64"/>   64:             init_per_testcase(dummy_tc, Config);
<a name="65"/>   65:         _Else -&gt;
<a name="66"/>   66:             {skip, &quot;No crypto file to test with&quot;}
<a name="67"/>   67:     end;
<a name="68"/>   68: <b>init_per_testcase</b>(_TestCase, Config) -&gt;
<a name="init_per_testcase-last_expr"/><a name="69"/>   69:     Config.
<a name="70"/>   70: 
<a name="end_per_testcase-2"/><a name="71"/>   71: <b>end_per_testcase</b>(TestCase, Config) -&gt;
<a name="72"/>   72:     NoStop = [start,compile,analyse,misc],
<a name="73"/>   73:     DontStop = proplists:get_bool(ct_is_running_cover, Config) orelse
<a name="74"/>   74:     lists:member(TestCase, NoStop),
<a name="75"/>   75:     case DontStop of
<a name="76"/>   76:         true -&gt; ok;
<a name="77"/>   77:         false -&gt; cover:stop()
<a name="78"/>   78:     end,
<a name="end_per_testcase-last_expr"/><a name="79"/>   79:     ok.
<a name="80"/>   80: 
<a name="coverage-1"/><a name="81"/>   81: <b>coverage</b>(Config) when is_list(Config) -&gt;
<a name="82"/>   82:     {ok,?MODULE} = cover:compile_beam(?MODULE),
<a name="coverage-last_expr"/><a name="83"/>   83: <b>    ?MODULE:do_coverage</b>(Config).
<a name="84"/>   84: 
<a name="do_coverage-1"/><a name="85"/>   85: <b>do_coverage</b>(Config) -&gt;
<a name="86"/>   86:     Outdir = proplists:get_value(priv_dir, Config),
<a name="87"/>   87:     ExportFile = filename:join(Outdir, &quot;export&quot;),
<a name="88"/>   88:     ok = cover:export(ExportFile, ?MODULE),
<a name="89"/>   89:     {error,{already_started,_}} = cover:start(),
<a name="90"/>   90:     {error,_} = cover:compile_beam(non_existing_module),
<a name="91"/>   91:     _ = cover:which_nodes(),
<a name="92"/>   92:     _ = cover:modules(),
<a name="93"/>   93:     _ = cover:imported(),
<a name="94"/>   94:     {error,{not_cover_compiled,lists}} = cover:analyze(lists),
<a name="95"/>   95: 
<a name="96"/>   96:     %% Cover escaping of '&amp;' in HTML files.
<a name="97"/>   97: 
<a name="do_coverage-last_expr"/><a name="98"/>   98: <b>    case proplists:get_bool</b>(ct_is_running_cover, Config) of
<a name="99"/>   99:         false -&gt;
<a name="100"/>  100:             %% Cover server was implicitly started when this module
<a name="101"/>  101:             %% was cover-compiled. We must stop the cover server, but
<a name="102"/>  102:             %% we must ensure that this module is not on the call
<a name="103"/>  103:             %% stack when it is unloaded. Therefore, the call that
<a name="104"/>  104:             %% follows MUST be tail-recursive.
<a name="105"/>  105:             cover:stop();
<a name="106"/>  106:         true -&gt;
<a name="107"/>  107:             %% Cover server was started by common_test; don't stop it.
<a name="108"/>  108:             ok
<a name="109"/>  109:     end.
<a name="110"/>  110: 
<a name="111"/>  111: <i>%% This test case will only be run when common_test is running cover.</i>
<a name="coverage_analysis-1"/><a name="112"/>  112: <b>coverage_analysis</b>(Config) when is_list(Config) -&gt;
<a name="113"/>  113:     {ok,Analysis1} = cover:analyze(?MODULE),
<a name="114"/>  114:     io:format(&quot;~p\n&quot;, [Analysis1]),
<a name="115"/>  115:     {ok,Analysis2} = cover:analyze(?MODULE, calls),
<a name="116"/>  116:     io:format(&quot;~p\n&quot;, [Analysis2]),
<a name="117"/>  117:     {ok,_Analysis3} = cover:analyze(?MODULE, calls, line),
<a name="118"/>  118: 
<a name="119"/>  119:     Outdir = proplists:get_value(priv_dir, Config),
<a name="120"/>  120:     Outfile = filename:join(Outdir, ?MODULE),
<a name="121"/>  121: 
<a name="122"/>  122:     {ok,Outfile} = cover:analyze_to_file(?MODULE, Outfile),
<a name="123"/>  123:     {ok,Contents} = file:read_file(Outfile),
<a name="124"/>  124:     ok = file:delete(Outfile),
<a name="125"/>  125:     ok = io:put_chars(Contents),
<a name="126"/>  126:     {ok,Outfile} = cover:analyze_to_file(?MODULE, Outfile, [html]),
<a name="coverage_analysis-last_expr"/><a name="127"/>  127:     ok.
<a name="128"/>  128: 
<a name="start-1"/><a name="129"/>  129: <b>start</b>(Config) when is_list(Config) -&gt;
<a name="130"/>  130:     ok = file:set_cwd(proplists:get_value(data_dir, Config)),
<a name="131"/>  131: 
<a name="132"/>  132:     Files = lsfiles(),
<a name="133"/>  133:     remove(files(Files, &quot;.out&quot;)),
<a name="134"/>  134: 
<a name="135"/>  135:     {ok, Pid} = cover:start(),
<a name="start-last_expr"/><a name="136"/>  136: <b>    {error, {already_started, Pid}} = cover:start</b>().
<a name="137"/>  137: 
<a name="compile-1"/><a name="138"/>  138: <b>compile</b>(Config) when is_list(Config) -&gt;
<a name="139"/>  139:     ok = file:set_cwd(proplists:get_value(data_dir, Config)),
<a name="140"/>  140: 
<a name="141"/>  141:     Result1 = cover:compile_directory(),
<a name="142"/>  142:     SortedResult = lists:sort(Result1),
<a name="143"/>  143:     {ok, CWD} = file:get_cwd(),
<a name="144"/>  144:     Result2 = cover:compile_directory(CWD),
<a name="145"/>  145:     SortedResult = lists:sort(Result2),
<a name="146"/>  146:     [{error,DFile},{ok,a},{ok,b},{ok,cc},{ok,f}] = SortedResult,
<a name="147"/>  147:     [{ok,e}] = cover:compile_directory(&quot;d1&quot;),
<a name="148"/>  148:     {error,enoent} = cover:compile_directory(&quot;d2&quot;),
<a name="149"/>  149: 
<a name="150"/>  150:     [] = cover:compile([]),
<a name="151"/>  151:     Result21 = cover:compile([a,b,&quot;cc.erl&quot;,d,&quot;f&quot;]),
<a name="152"/>  152:     SortedResult21 = lists:sort(Result21),
<a name="153"/>  153:     [{error,DFile},{ok,a},{ok,b},{ok,cc},{ok,f}] = SortedResult21,
<a name="154"/>  154: 
<a name="155"/>  155:     {ok,a} = cover:compile(a),
<a name="156"/>  156:     {ok,b} = compile:file(b),
<a name="157"/>  157:     code:purge(b),
<a name="158"/>  158:     {module,b} = code:load_file(b),
<a name="159"/>  159:     {ok,d} = cover:compile(&quot;d.erl&quot;, [{d,'AGE',42}]),
<a name="160"/>  160:     {error,_BBFile} = cover:compile(bb),
<a name="161"/>  161: 
<a name="162"/>  162:     StdlibDir = code:lib_dir(stdlib),
<a name="163"/>  163:     Lists = filename:join([StdlibDir, &quot;src&quot;, &quot;lists.erl&quot;]),
<a name="164"/>  164:     {error, Lists} = cover:compile(Lists),
<a name="165"/>  165: 
<a name="166"/>  166:     %% For compiling beam: using dummy files v,w,x,y and z
<a name="167"/>  167:     file:set_cwd(&quot;compile_beam&quot;),
<a name="168"/>  168:     {ok,_} = compile:file(v,[debug_info,report]),
<a name="169"/>  169:     {ok,_} = compile:file(w,[debug_info,report]),
<a name="170"/>  170:     {ok,_} = compile:file(x),
<a name="171"/>  171:     {ok,_} = compile:file(&quot;d/y&quot;,[debug_info,{outdir,&quot;d&quot;},report]),
<a name="172"/>  172:     Key = &quot;A Krypto Key&quot;,
<a name="173"/>  173:     CryptoWorks = crypto_works(),
<a name="174"/>  174:     case CryptoWorks of
<a name="175"/>  175:         false -&gt;
<a name="176"/>  176:             {ok,_} = compile:file(crypt, [debug_info,report]),
<a name="177"/>  177:             {ok,crypt} = cover:compile_beam(&quot;crypt.beam&quot;);
<a name="178"/>  178:         true -&gt;
<a name="179"/>  179:             {ok,_} = compile:file(crypt, [{debug_info_key,Key},report]),
<a name="180"/>  180:             {error,{encrypted_abstract_code,_}} =
<a name="181"/>  181:             cover:compile_beam(&quot;crypt.beam&quot;),
<a name="182"/>  182:             ok = beam_lib:crypto_key_fun(simple_crypto_fun(Key)),
<a name="183"/>  183:             {ok,crypt} = cover:compile_beam(&quot;crypt.beam&quot;)
<a name="184"/>  184:     end,
<a name="185"/>  185:     Path = filename:join([proplists:get_value(data_dir, Config), &quot;compile_beam&quot;, &quot;v.erl&quot;]),
<a name="186"/>  186:     {ok,v} = cover:compile_beam(v),
<a name="187"/>  187:     {source,Path} = lists:keyfind(source, 1, v:module_info(compile)),
<a name="188"/>  188:     {ok,w} = cover:compile_beam(&quot;w.beam&quot;),
<a name="189"/>  189:     {error,{no_abstract_code,&quot;./x.beam&quot;}} = cover:compile_beam(x),
<a name="190"/>  190:     {error,{already_cover_compiled,no_beam_found,a}}=cover:compile_beam(a),
<a name="191"/>  191:     {error,non_existing} = cover:compile_beam(z),
<a name="192"/>  192:     [{ok,y}] = cover:compile_beam_directory(&quot;d&quot;),
<a name="193"/>  193:     Result3 = lists:sort(cover:compile_beam_directory()),
<a name="194"/>  194:     [{error,{no_abstract_code,XBeam}},{ok,crypt},{ok,v},{ok,w}] = Result3,
<a name="195"/>  195:     {error,enoent} = cover:compile_beam_directory(&quot;d2&quot;),
<a name="196"/>  196: 
<a name="197"/>  197:     [] = cover:compile_beam([]),
<a name="198"/>  198:     Result31 = cover:compile_beam([crypt,&quot;v.beam&quot;,w,&quot;x&quot;]),
<a name="199"/>  199:     SortedResult31 = lists:sort(Result31),
<a name="200"/>  200:     [{error,{no_abstract_code,XBeam}},{ok,crypt},{ok,v},{ok,w}] = SortedResult31,
<a name="201"/>  201: 
<a name="202"/>  202:     decompile([v,w,y]),
<a name="203"/>  203:     Files = lsfiles(),
<a name="compile-last_expr"/><a name="204"/>  204: <b>    remove</b>(files(Files, &quot;.beam&quot;)).
<a name="205"/>  205: 
<a name="crypto_works-0"/><a name="206"/>  206: <b>crypto_works</b>() -&gt;
<a name="crypto_works-last_expr"/><a name="207"/>  207: <b>    try crypto:start</b>() of
<a name="208"/>  208:         {error,{already_started,crypto}} -&gt; true;
<a name="209"/>  209:         ok -&gt; true
<a name="210"/>  210:     catch
<a name="211"/>  211:         error:_ -&gt;
<a name="212"/>  212:             false
<a name="213"/>  213:     end.
<a name="214"/>  214: 
<a name="simple_crypto_fun-1"/><a name="215"/>  215: <b>simple_crypto_fun</b>(Key) -&gt;
<a name="simple_crypto_fun-last_expr"/><a name="216"/>  216: <b>    fun</b>(init) -&gt; ok;
<a name="217"/>  217:        ({debug_info, des3_cbc, crypt, _}) -&gt; Key
<a name="218"/>  218:     end.
<a name="219"/>  219: 
<a name="analyse-1"/><a name="220"/>  220: <b>analyse</b>(Config) when is_list(Config) -&gt;
<a name="221"/>  221:     ok = file:set_cwd(proplists:get_value(data_dir, Config)),
<a name="222"/>  222: 
<a name="223"/>  223:     done = a:start(5),
<a name="224"/>  224: 
<a name="225"/>  225:     {ok, {a,{17,2}}=ACovMod} = cover:analyse(a, coverage, module),
<a name="226"/>  226:     {ok, [{{a,exit_kalle,0},{1,0}},
<a name="227"/>  227:           {{a,loop,3},{5,1}},
<a name="228"/>  228:           {{a,pong,1},{1,0}},
<a name="229"/>  229:           {{a,start,1},{6,0}},
<a name="230"/>  230:           {{a,stop,1},{0,1}},
<a name="231"/>  231:           {{a,trycatch,1},{4,0}}]=ACovFunc} =
<a name="232"/>  232:     cover:analyse(a, coverage, function),
<a name="233"/>  233:     {ok, [{{a,exit_kalle,0,1},{1,0}},
<a name="234"/>  234:           {{a,loop,3,1},{3,1}},
<a name="235"/>  235:           {{a,loop,3,2},{2,0}},
<a name="236"/>  236:           {{a,pong,1,1},{1,0}},
<a name="237"/>  237:           {{a,start,1,1},{6,0}},
<a name="238"/>  238:           {{a,stop,1,1},{0,1}},
<a name="239"/>  239:           {{a,trycatch,1,1},{4,0}}]=ACovClause} =
<a name="240"/>  240:     cover:analyse(a, coverage, clause),
<a name="241"/>  241:     {ok, [{{a,9},{1,0}},
<a name="242"/>  242:           {{a,10},{1,0}},
<a name="243"/>  243:           {{a,11},{1,0}},
<a name="244"/>  244:           {{a,13},{1,0}},
<a name="245"/>  245:           {{a,14},{1,0}},
<a name="246"/>  246:           {{a,15},{1,0}},
<a name="247"/>  247:           {{a,21},{0,1}},
<a name="248"/>  248:           {{a,26},{1,0}},
<a name="249"/>  249:           {{a,31},{1,0}},
<a name="250"/>  250:           {{a,32},{1,0}},
<a name="251"/>  251:           {{a,34},{1,0}},
<a name="252"/>  252:           {{a,36},{0,1}},
<a name="253"/>  253:           {{a,39},{1,0}},
<a name="254"/>  254:           {{a,40},{1,0}},
<a name="255"/>  255:           {{a,44},{1,0}},
<a name="256"/>  256:           {{a,47},{1,0}},
<a name="257"/>  257:           {{a,49},{1,0}},
<a name="258"/>  258:           {{a,51},{1,0}},
<a name="259"/>  259:           {{a,55},{1,0}}]=ACovLine} = cover:analyse(a, coverage, line),
<a name="260"/>  260: 
<a name="261"/>  261:     {ok, {a,15}=ACallsMod} = cover:analyse(a, calls, module),
<a name="262"/>  262:     {ok, [{{a,exit_kalle,0},1},
<a name="263"/>  263:           {{a,loop,3},6},
<a name="264"/>  264:           {{a,pong,1},5},
<a name="265"/>  265:           {{a,start,1},1},
<a name="266"/>  266:           {{a,stop,1},0},
<a name="267"/>  267:           {{a,trycatch,1},2}]=ACallsFunc} = cover:analyse(a, calls, function),
<a name="268"/>  268:     {ok, [{{a,exit_kalle,0,1},1},
<a name="269"/>  269:           {{a,loop,3,1},5},
<a name="270"/>  270:           {{a,loop,3,2},1},
<a name="271"/>  271:           {{a,pong,1,1},5},
<a name="272"/>  272:           {{a,start,1,1},1},
<a name="273"/>  273:           {{a,stop,1,1},0},
<a name="274"/>  274:           {{a,trycatch,1,1},2}]=ACallsClause} = cover:analyse(a, calls, clause),
<a name="275"/>  275:     {ok, [{{a,9},1},
<a name="276"/>  276:           {{a,10},1},
<a name="277"/>  277:           {{a,11},1},
<a name="278"/>  278:           {{a,13},1},
<a name="279"/>  279:           {{a,14},1},
<a name="280"/>  280:           {{a,15},1},
<a name="281"/>  281:           {{a,21},0},
<a name="282"/>  282:           {{a,26},5},
<a name="283"/>  283:           {{a,31},5},
<a name="284"/>  284:           {{a,32},5},
<a name="285"/>  285:           {{a,34},5},
<a name="286"/>  286:           {{a,36},0},
<a name="287"/>  287:           {{a,39},1},
<a name="288"/>  288:           {{a,40},1},
<a name="289"/>  289:           {{a,44},2},
<a name="290"/>  290:           {{a,47},1},
<a name="291"/>  291:           {{a,49},1},
<a name="292"/>  292:           {{a,51},2},
<a name="293"/>  293:           {{a,55},1}]=ACallsLine} = cover:analyse(a, calls, line),
<a name="294"/>  294: 
<a name="295"/>  295:     {ok,ACovFunc} = cover:analyse(a),
<a name="296"/>  296:     {ok,ACovMod} = cover:analyse(a, module),
<a name="297"/>  297:     {ok,ACallsFunc} = cover:analyse(a, calls),
<a name="298"/>  298: 
<a name="299"/>  299:     {ok, &quot;a.COVER.out&quot;} = cover:analyse_to_file(a),
<a name="300"/>  300:     {ok, &quot;e.COVER.out&quot;} = cover:analyse_to_file(e),
<a name="301"/>  301:     {ok, &quot;a.COVER.html&quot;} = cover:analyse_to_file(a,[html]),
<a name="302"/>  302:     {ok, &quot;e.COVER.html&quot;} = cover:analyse_to_file(e,[html]),
<a name="303"/>  303: 
<a name="304"/>  304:     %% Analyse all modules
<a name="305"/>  305:     Modules = cover:modules(),
<a name="306"/>  306:     N = length(Modules),
<a name="307"/>  307: 
<a name="308"/>  308:     {result,CovFunc,[]} = cover:analyse(), % default = coverage, function
<a name="309"/>  309:     ACovFunc = [A || {{a,_,_},_}=A&lt;-CovFunc],
<a name="310"/>  310: 
<a name="311"/>  311:     {result,CovMod,[]} = cover:analyse(coverage,module),
<a name="312"/>  312:     ACovMod = lists:keyfind(a,1,CovMod),
<a name="313"/>  313: 
<a name="314"/>  314:     {result,CovClause,[]} = cover:analyse(coverage,clause),
<a name="315"/>  315:     ACovClause = [A || {{a,_,_,_},_}=A&lt;-CovClause],
<a name="316"/>  316: 
<a name="317"/>  317:     {result,CovLine,[]} = cover:analyse(coverage,line),
<a name="318"/>  318:     ACovLine = [A || {{a,_},_}=A&lt;-CovLine],
<a name="319"/>  319: 
<a name="320"/>  320:     {result,CallsFunc,[]} = cover:analyse(calls,function),
<a name="321"/>  321:     ACallsFunc = [A || {{a,_,_},_}=A&lt;-CallsFunc],
<a name="322"/>  322: 
<a name="323"/>  323:     {result,CallsMod,[]} = cover:analyse(calls,module),
<a name="324"/>  324:     ACallsMod = lists:keyfind(a,1,CallsMod),
<a name="325"/>  325: 
<a name="326"/>  326:     {result,CallsClause,[]} = cover:analyse(calls,clause),
<a name="327"/>  327:     ACallsClause = [A || {{a,_,_,_},_}=A&lt;-CallsClause],
<a name="328"/>  328: 
<a name="329"/>  329:     {result,CallsLine,[]} = cover:analyse(calls,line),
<a name="330"/>  330:     ACallsLine = [A || {{a,_},_}=A&lt;-CallsLine],
<a name="331"/>  331: 
<a name="332"/>  332:     {result,AllToFile,[]} = cover:analyse_to_file(),
<a name="333"/>  333:     N = length(AllToFile),
<a name="334"/>  334:     true = lists:member(&quot;a.COVER.out&quot;,AllToFile),
<a name="335"/>  335:     {result,AllToFileHtml,[]} = cover:analyse_to_file([html]),
<a name="336"/>  336:     N = length(AllToFileHtml),
<a name="337"/>  337:     true = lists:member(&quot;a.COVER.html&quot;,AllToFileHtml),
<a name="338"/>  338: 
<a name="339"/>  339:     %% Analyse list of modules
<a name="340"/>  340:     %% Listing all modules so we can compare result with above result
<a name="341"/>  341:     %% from analysing all.
<a name="342"/>  342: 
<a name="343"/>  343:     {result,CovFunc1,[]} = cover:analyse(Modules), % default = coverage, function
<a name="344"/>  344:     true = lists:sort(CovFunc) == lists:sort(CovFunc1),
<a name="345"/>  345: 
<a name="346"/>  346:     {result,CovMod1,[]} = cover:analyse(Modules,coverage,module),
<a name="347"/>  347:     true = lists:sort(CovMod) == lists:sort(CovMod1),
<a name="348"/>  348: 
<a name="349"/>  349:     {result,CovClause1,[]} = cover:analyse(Modules,coverage,clause),
<a name="350"/>  350:     true = lists:sort(CovClause) == lists:sort(CovClause1),
<a name="351"/>  351: 
<a name="352"/>  352:     {result,CovLine1,[]} = cover:analyse(Modules,coverage,line),
<a name="353"/>  353:     true = lists:sort(CovLine) == lists:sort(CovLine1),
<a name="354"/>  354: 
<a name="355"/>  355:     {result,CallsFunc1,[]} = cover:analyse(Modules,calls,function),
<a name="356"/>  356:     true = lists:sort(CallsFunc1) == lists:sort(CallsFunc1),
<a name="357"/>  357: 
<a name="358"/>  358:     {result,CallsMod1,[]} = cover:analyse(Modules,calls,module),
<a name="359"/>  359:     true = lists:sort(CallsMod) == lists:sort(CallsMod1),
<a name="360"/>  360: 
<a name="361"/>  361:     {result,CallsClause1,[]} = cover:analyse(Modules,calls,clause),
<a name="362"/>  362:     true = lists:sort(CallsClause) == lists:sort(CallsClause1),
<a name="363"/>  363: 
<a name="364"/>  364:     {result,CallsLine1,[]} = cover:analyse(Modules,calls,line),
<a name="365"/>  365:     true = lists:sort(CallsLine) == lists:sort(CallsLine1),
<a name="366"/>  366: 
<a name="367"/>  367:     {result,AllToFile1,[]} = cover:analyse_to_file(Modules),
<a name="368"/>  368:     true = lists:sort(AllToFile) == lists:sort(AllToFile1),
<a name="369"/>  369:     {result,AllToFileHtml1,[]} = cover:analyse_to_file(Modules,[html]),
<a name="370"/>  370:     true = lists:sort(AllToFileHtml) == lists:sort(AllToFileHtml1),
<a name="371"/>  371: 
<a name="372"/>  372:     %% analyse_to_file of file which is compiled from beam
<a name="373"/>  373:     {ok,f} = compile:file(f,[debug_info]),
<a name="374"/>  374:     code:purge(f),
<a name="375"/>  375:     {module,f} = code:load_file(f),
<a name="376"/>  376:     {ok,f} = cover:compile_beam(f),
<a name="377"/>  377:     f:f2(),
<a name="378"/>  378:     {ok, &quot;f.COVER.out&quot;} = cover:analyse_to_file(f),
<a name="379"/>  379: 
<a name="380"/>  380:     %% Source code can be found via source
<a name="381"/>  381:     {ok,v} = compile:file(&quot;compile_beam/v&quot;,[debug_info]),
<a name="382"/>  382:     code:purge(v),
<a name="383"/>  383:     {module,v} = code:load_file(v),
<a name="384"/>  384:     {ok,v} = cover:compile_beam(v),
<a name="385"/>  385:     {ok,&quot;v.COVER.out&quot;} = cover:analyse_to_file(v),
<a name="386"/>  386: 
<a name="387"/>  387:     %% Source code cannot be found
<a name="388"/>  388:     {ok,_} = file:copy(&quot;compile_beam/z.erl&quot;, &quot;z.erl&quot;),
<a name="389"/>  389:     {ok,z} = compile:file(z,[debug_info]),
<a name="390"/>  390:     code:purge(z),
<a name="391"/>  391:     {module,z} = code:load_file(z),
<a name="392"/>  392:     {ok,z} = cover:compile_beam(z),
<a name="393"/>  393:     ok = file:delete(&quot;z.erl&quot;),
<a name="394"/>  394:     {error,{no_source_code_found,z}} = cover:analyse_to_file(z),
<a name="395"/>  395:     {result,[],[{no_source_code_found,z}]} = cover:analyse_to_file([z]),
<a name="396"/>  396:     code:purge(z),
<a name="397"/>  397:     code:delete(z),
<a name="398"/>  398: 
<a name="399"/>  399:     {error,{not_cover_compiled,b}} = cover:analyse(b),
<a name="400"/>  400:     {error,{not_cover_compiled,g}} = cover:analyse(g),
<a name="401"/>  401:     {result,[],[{not_cover_compiled,b}]} = cover:analyse([b]),
<a name="402"/>  402:     {error,{not_cover_compiled,b}} = cover:analyse_to_file(b),
<a name="403"/>  403:     {error,{not_cover_compiled,g}} = cover:analyse_to_file(g),
<a name="analyse-last_expr"/><a name="404"/>  404: <b>    {result,[],[{not_cover_compiled,g}]} = cover:analyse_to_file</b>([g]).
<a name="405"/>  405: 
<a name="misc-1"/><a name="406"/>  406: <b>misc</b>(Config) when is_list(Config) -&gt;
<a name="407"/>  407:     ok = file:set_cwd(proplists:get_value(data_dir, Config)),
<a name="408"/>  408: 
<a name="409"/>  409:     [a,cc,crypt,d,e,f,v] = lists:sort(cover:modules()),
<a name="410"/>  410: 
<a name="411"/>  411:     {ok,cc} = compile:file(cc),
<a name="412"/>  412:     code:purge(cc),
<a name="413"/>  413:     {module,cc} = code:load_file(cc),
<a name="414"/>  414:     [a,crypt,d,e,f,v] = lists:sort(cover:modules()),
<a name="415"/>  415: 
<a name="416"/>  416:     {file, _File} = cover:is_compiled(a),
<a name="417"/>  417:     false = cover:is_compiled(b),
<a name="418"/>  418:     false = cover:is_compiled(g),
<a name="419"/>  419: 
<a name="420"/>  420:     ok = cover:reset(a),
<a name="421"/>  421:     {ok, {a,{0,19}}} = cover:analyse(a, module),
<a name="misc-last_expr"/><a name="422"/>  422: <b>    ok = cover:reset</b>().
<a name="423"/>  423: 
<a name="stop-1"/><a name="424"/>  424: <b>stop</b>(Config) when is_list(Config) -&gt;
<a name="425"/>  425:     ok = file:set_cwd(proplists:get_value(data_dir, Config)),
<a name="426"/>  426: 
<a name="427"/>  427:     cover_compiled = code:which(a),
<a name="428"/>  428:     {ok,d} = compile:file(d, [{d,'AGE',42}]),
<a name="429"/>  429:     code:purge(d),
<a name="430"/>  430:     {module,d} = code:load_file(d),
<a name="431"/>  431:     ok = cover:stop(),
<a name="432"/>  432:     Beam = code:which(a),
<a name="433"/>  433:     true = is_unloaded(Beam),
<a name="434"/>  434: 
<a name="435"/>  435:     Files = lsfiles(),
<a name="436"/>  436:     remove(files(Files, &quot;.out&quot;)),
<a name="437"/>  437:     remove(files(Files, &quot;.html&quot;)),
<a name="stop-last_expr"/><a name="438"/>  438: <b>    remove</b>(files(Files, &quot;.beam&quot;)).
<a name="439"/>  439: 
<a name="distribution-1"/><a name="440"/>  440: <b>distribution</b>(Config) when is_list(Config) -&gt;
<a name="441"/>  441:     DataDir = proplists:get_value(data_dir, Config),
<a name="442"/>  442:     ok = file:set_cwd(DataDir),
<a name="443"/>  443: 
<a name="444"/>  444:     {ok,P1,N1} = ?CT_PEER(),
<a name="445"/>  445:     {ok,P2,N2} = ?CT_PEER(),
<a name="446"/>  446:     {ok,P3,N3} = ?CT_PEER(),
<a name="447"/>  447:     {ok,P4,N4} = ?CT_PEER(),
<a name="448"/>  448: 
<a name="449"/>  449:     %% Check that an already compiled module is loaded on new nodes
<a name="450"/>  450:     {ok,f} = cover:compile(f),
<a name="451"/>  451:     {ok,[_,_,_,_]} = cover:start([N1,N2,N3,N4]),
<a name="452"/>  452:     cover_compiled = code:which(f),
<a name="453"/>  453:     cover_compiled = rpc:call(N1,code,which,[f]),
<a name="454"/>  454:     cover_compiled = rpc:call(N2,code,which,[f]),
<a name="455"/>  455:     cover_compiled = rpc:call(N3,code,which,[f]),
<a name="456"/>  456:     cover_compiled = rpc:call(N4,code,which,[f]),
<a name="457"/>  457: 
<a name="458"/>  458:     %% Check that a node cannot be started twice
<a name="459"/>  459:     {ok,[]} = cover:start(N2),
<a name="460"/>  460: 
<a name="461"/>  461:     %% Check that the current node (i.e. the main node) is not started with
<a name="462"/>  462:     %% start/1 and not stopped with stop/1
<a name="463"/>  463:     {ok,[]} = cover:start(node()),
<a name="464"/>  464:     ok = cover:stop(node()),
<a name="465"/>  465:     true = is_pid(whereis(cover_server)),
<a name="466"/>  466: 
<a name="467"/>  467:     %% Check that a new compiled module is loaded on all existing nodes
<a name="468"/>  468:     compile:file(&quot;compile_beam/v&quot;,[debug_info]),
<a name="469"/>  469:     {ok,v} = cover:compile_beam(v),
<a name="470"/>  470:     cover_compiled = code:which(v),
<a name="471"/>  471:     cover_compiled = rpc:call(N1,code,which,[v]),
<a name="472"/>  472:     cover_compiled = rpc:call(N2,code,which,[v]),
<a name="473"/>  473:     cover_compiled = rpc:call(N3,code,which,[v]),
<a name="474"/>  474:     cover_compiled = rpc:call(N4,code,which,[v]),
<a name="475"/>  475: 
<a name="476"/>  476:     %% this is lost when the node is killed
<a name="477"/>  477:     rpc:call(N3,f,f2,[]),
<a name="478"/>  478:     peer:stop(P3),
<a name="479"/>  479: 
<a name="480"/>  480:     %% this should be visible in analyse
<a name="481"/>  481:     rpc:call(N1,f,f1,[]),
<a name="482"/>  482: 
<a name="483"/>  483:     %% Check that data is collected from remote node when stopped
<a name="484"/>  484:     ok = cover:stop(N1),
<a name="485"/>  485:     N1Beam = rpc:call(N1,code,which,[f]),
<a name="486"/>  486:     true = is_unloaded(N1Beam),
<a name="487"/>  487:     check_f_calls(1,0),
<a name="488"/>  488: 
<a name="489"/>  489:     %% Call f:f1() again on another node and check that number of calls is
<a name="490"/>  490:     %% accumulated.
<a name="491"/>  491:     f:f1(),
<a name="492"/>  492:     check_f_calls(2,0),
<a name="493"/>  493: 
<a name="494"/>  494:     %% Check that reset works on all nodes
<a name="495"/>  495:     f:f1(),
<a name="496"/>  496:     rpc:call(N2,f,f1,[]),
<a name="497"/>  497:     ok = cover:reset(f),
<a name="498"/>  498:     check_f_calls(0,0),
<a name="499"/>  499: 
<a name="500"/>  500:     %% Check that data is collected from all nodes
<a name="501"/>  501:     rpc:call(N2,f,f1,[]),
<a name="502"/>  502:     f:f2(),
<a name="503"/>  503:     check_f_calls(1,1),
<a name="504"/>  504: 
<a name="505"/>  505:     %% Check that same data is not fetched again (i.e. that analyse does
<a name="506"/>  506:     %% reset on the remote node(s))
<a name="507"/>  507:     check_f_calls(1,1),
<a name="508"/>  508: 
<a name="509"/>  509:     %% Another checn that data is not fetched twice, i.e. when flushed
<a name="510"/>  510:     %% then analyse should not add the same data again.
<a name="511"/>  511:     rpc:call(N4,f,f2,[]),
<a name="512"/>  512:     ok = cover:flush(N4),
<a name="513"/>  513:     check_f_calls(1,2),
<a name="514"/>  514: 
<a name="515"/>  515:     %% Check that flush collects data so calls are not lost if node is killed
<a name="516"/>  516:     rpc:call(N4,f,f2,[]),
<a name="517"/>  517:     ok = cover:flush(N4),
<a name="518"/>  518:     peer:stop(P4),
<a name="519"/>  519:     check_f_calls(1,3),
<a name="520"/>  520: 
<a name="521"/>  521:     %% Check that stop() unloads on all nodes
<a name="522"/>  522:     ok = cover:stop(),
<a name="523"/>  523:     timer:sleep(100), %% Give nodes time to unload on slow machines.
<a name="524"/>  524:     LocalBeam = code:which(f),
<a name="525"/>  525:     N2Beam = rpc:call(N2,code,which,[f]),
<a name="526"/>  526:     true = is_unloaded(LocalBeam),
<a name="527"/>  527:     true = is_unloaded(N2Beam),
<a name="528"/>  528: 
<a name="529"/>  529:     %% Check that cover_server on remote node does not die if main node dies
<a name="530"/>  530:     {ok,[N1]} = cover:start(N1),
<a name="531"/>  531:     true = is_pid(N1Server = rpc:call(N1,erlang,whereis,[cover_server])),
<a name="532"/>  532:     exit(whereis(cover_server),kill),
<a name="533"/>  533:     timer:sleep(100),
<a name="534"/>  534:     N1Server = rpc:call(N1,erlang,whereis,[cover_server]),
<a name="535"/>  535: 
<a name="536"/>  536:     %% Cleanup
<a name="537"/>  537:     Files = lsfiles(),
<a name="538"/>  538:     remove(files(Files, &quot;.beam&quot;)),
<a name="539"/>  539:     peer:stop(P1),
<a name="distribution-last_expr"/><a name="540"/>  540: <b>    peer:stop</b>(P2).
<a name="541"/>  541: 
<a name="542"/>  542: <i>%% Test that a lost node is reconnected</i>
<a name="reconnect-1"/><a name="543"/>  543: <b>reconnect</b>(Config) -&gt;
<a name="544"/>  544:     DataDir = proplists:get_value(data_dir, Config),
<a name="545"/>  545:     ok = file:set_cwd(DataDir),
<a name="546"/>  546: 
<a name="547"/>  547:     {ok,a} = compile:file(a),
<a name="548"/>  548:     {ok,b} = compile:file(b),
<a name="549"/>  549:     {ok,f} = compile:file(f),
<a name="550"/>  550: 
<a name="551"/>  551:     {ok,P1,N1} = ?CT_PEER(#{connection =&gt; 0, args =&gt; [&quot;-pa&quot;, DataDir]}),
<a name="552"/>  552:     {ok,a} = cover:compile(a),
<a name="553"/>  553:     {ok,f} = cover:compile(f),
<a name="554"/>  554:     {ok,[N1]} = cover:start([N1]),
<a name="555"/>  555: 
<a name="556"/>  556:     %% Some calls to check later
<a name="557"/>  557:     rpc:call(N1,f,f1,[]),
<a name="558"/>  558:     cover:flush(N1),
<a name="559"/>  559:     rpc:call(N1,f,f1,[]),
<a name="560"/>  560: 
<a name="561"/>  561:     %% This will cause first cause the N1 node to initiate a
<a name="562"/>  562:     %% disconnect and then call f:f2() when nodes() =:= [] on N1.
<a name="563"/>  563:     rpc:cast(N1,f,call_f2_when_isolated,[]),
<a name="564"/>  564:     timer:sleep(500), % allow some to detect disconnect and for f:f2() call
<a name="565"/>  565:     cover_which_nodes([]),
<a name="566"/>  566: 
<a name="567"/>  567:     %% Do some add one module (b) and remove one module (a)
<a name="568"/>  568:     code:purge(a),
<a name="569"/>  569:     {module,a} = code:load_file(a),
<a name="570"/>  570:     {ok,b} = cover:compile(b),
<a name="571"/>  571:     cover_compiled = code:which(b),
<a name="572"/>  572: 
<a name="573"/>  573:     cover_which_nodes([]),
<a name="574"/>  574:     check_f_calls(1,0), % only the first call - before the flush
<a name="575"/>  575: 
<a name="576"/>  576:     %% Reconnect the node and check that b and f are cover compiled but not a
<a name="577"/>  577:     net_kernel:connect_node(N1),
<a name="578"/>  578:     timer:sleep(100),
<a name="579"/>  579:     [N1] = cover:which_nodes(), % we are reconnected
<a name="580"/>  580:     cover_compiled = rpc:call(N1,code,which,[b]),
<a name="581"/>  581:     cover_compiled = rpc:call(N1,code,which,[f]),
<a name="582"/>  582:     ABeam = rpc:call(N1,code,which,[a]),
<a name="583"/>  583:     false = (cover_compiled==ABeam),
<a name="584"/>  584: 
<a name="585"/>  585:     %% Ensure that we have:
<a name="586"/>  586:     %% * one f1 call from before the flush,
<a name="587"/>  587:     %% * one f1 call from after the flush but before disconnect
<a name="588"/>  588:     %% * one f2 call when disconnected
<a name="589"/>  589:     check_f_calls(2,1),
<a name="590"/>  590: 
<a name="591"/>  591:     cover:stop(),
<a name="592"/>  592:     peer:stop(P1),
<a name="reconnect-last_expr"/><a name="593"/>  593:     ok.
<a name="594"/>  594: 
<a name="595"/>  595: <i>%% Test that a lost node is reconnected - also if it has been dead</i>
<a name="die_and_reconnect-1"/><a name="596"/>  596: <b>die_and_reconnect</b>(Config) -&gt;
<a name="597"/>  597:     DataDir = proplists:get_value(data_dir, Config),
<a name="598"/>  598:     ok = file:set_cwd(DataDir),
<a name="599"/>  599: 
<a name="600"/>  600:     {ok,f} = compile:file(f),
<a name="601"/>  601: 
<a name="602"/>  602:     {ok, P1, N1} = ?CT_PEER(#{name =&gt; ?CT_PEER_NAME(), args =&gt; [&quot;-pa&quot;, DataDir]}),
<a name="603"/>  603:     %% {ok,a} = cover:compile(a),
<a name="604"/>  604:     {ok,f} = cover:compile(f),
<a name="605"/>  605:     {ok,[N1]} = cover:start([N1]),
<a name="606"/>  606: 
<a name="607"/>  607:     %% Some calls to check later
<a name="608"/>  608:     rpc:call(N1,f,f1,[]),
<a name="609"/>  609:     cover:flush(N1),
<a name="610"/>  610:     rpc:call(N1,f,f1,[]),
<a name="611"/>  611: 
<a name="612"/>  612:     %% Kill the node
<a name="613"/>  613:     peer:stop(P1),
<a name="614"/>  614:     cover_which_nodes([]),
<a name="615"/>  615: 
<a name="616"/>  616:     check_f_calls(1,0), % only the first call - before the flush
<a name="617"/>  617: 
<a name="618"/>  618:     %% Restart the node and check that cover reconnects
<a name="619"/>  619:     {ok,P2,N1} = ?CT_PEER(#{name =&gt; N1, args =&gt; [&quot;-pa&quot;, DataDir]}),
<a name="620"/>  620:     timer:sleep(100),
<a name="621"/>  621:     [N1] = cover:which_nodes(), % we are reconnected
<a name="622"/>  622:     cover_compiled = rpc:call(N1,code,which,[f]),
<a name="623"/>  623: 
<a name="624"/>  624:     %% One more call...
<a name="625"/>  625:     rpc:call(N1,f,f1,[]),
<a name="626"/>  626: 
<a name="627"/>  627:     %% Ensure that no more calls are counted
<a name="628"/>  628:     check_f_calls(2,0),
<a name="629"/>  629: 
<a name="630"/>  630:     cover:stop(),
<a name="631"/>  631:     peer:stop(P2),
<a name="die_and_reconnect-last_expr"/><a name="632"/>  632:     ok.
<a name="633"/>  633: 
<a name="634"/>  634: <i>%% Test that a stopped node is not marked as lost, i.e. that it is not</i>
<a name="635"/>  635: <i>%% reconnected if it is restarted (OTP-10638)</i>
<a name="dont_reconnect_after_stop-1"/><a name="636"/>  636: <b>dont_reconnect_after_stop</b>(Config) -&gt;
<a name="637"/>  637:     DataDir = proplists:get_value(data_dir, Config),
<a name="638"/>  638:     ok = file:set_cwd(DataDir),
<a name="639"/>  639: 
<a name="640"/>  640:     {ok,f} = compile:file(f),
<a name="641"/>  641: 
<a name="642"/>  642:     {ok, P1, N1} = ?CT_PEER(#{name =&gt; ?CT_PEER_NAME(), args =&gt; [&quot;-pa&quot;, DataDir],
<a name="643"/>  643:         start_cover =&gt; false}),
<a name="644"/>  644:     {ok,f} = cover:compile(f),
<a name="645"/>  645:     {ok,[N1]} = cover:start([N1]),
<a name="646"/>  646: 
<a name="647"/>  647:     %% A call to check later
<a name="648"/>  648:     rpc:call(N1,f,f1,[]),
<a name="649"/>  649: 
<a name="650"/>  650:     %% Stop cover on the node, then terminate the node
<a name="651"/>  651:     cover:stop(N1),
<a name="652"/>  652:     peer:stop(P1),
<a name="653"/>  653:     cover_which_nodes([]),
<a name="654"/>  654: 
<a name="655"/>  655:     check_f_calls(1,0),
<a name="656"/>  656: 
<a name="657"/>  657:     %% Restart the node and check that cover does not reconnect
<a name="658"/>  658:     {ok, P2, N1} = ?CT_PEER(#{name =&gt; N1, args =&gt; [&quot;-pa&quot;, DataDir], start_cover =&gt; false}),
<a name="659"/>  659:     timer:sleep(300),
<a name="660"/>  660:     cover_which_nodes([]),
<a name="661"/>  661:     Beam = rpc:call(N1,code,which,[f]),
<a name="662"/>  662:     false = (Beam==cover_compiled),
<a name="663"/>  663: 
<a name="664"/>  664:     %% One more call...
<a name="665"/>  665:     rpc:call(N1,f,f1,[]),
<a name="666"/>  666:     cover:flush(N1),
<a name="667"/>  667: 
<a name="668"/>  668:     %% Ensure that the last call is not counted
<a name="669"/>  669:     check_f_calls(1,0),
<a name="670"/>  670: 
<a name="671"/>  671:     cover:stop(),
<a name="672"/>  672:     peer:stop(P2),
<a name="dont_reconnect_after_stop-last_expr"/><a name="673"/>  673:     ok.
<a name="674"/>  674: 
<a name="675"/>  675: <i>%% Test that a node which is stopped while it is marked as lost is not</i>
<a name="676"/>  676: <i>%% reconnected if it is restarted (OTP-10638)</i>
<a name="stop_node_after_disconnect-1"/><a name="677"/>  677: <b>stop_node_after_disconnect</b>(Config) -&gt;
<a name="678"/>  678:     DataDir = proplists:get_value(data_dir, Config),
<a name="679"/>  679:     ok = file:set_cwd(DataDir),
<a name="680"/>  680: 
<a name="681"/>  681:     {ok,f} = compile:file(f),
<a name="682"/>  682: 
<a name="683"/>  683:     {ok, P1, N1} = ?CT_PEER(#{name =&gt; ?CT_PEER_NAME(), args =&gt; [&quot;-pa&quot;, DataDir],
<a name="684"/>  684:         start_cover =&gt; false}),
<a name="685"/>  685:     {ok,f} = cover:compile(f),
<a name="686"/>  686:     {ok,[N1]} = cover:start([N1]),
<a name="687"/>  687: 
<a name="688"/>  688:     %% A call to check later
<a name="689"/>  689:     rpc:call(N1,f,f1,[]),
<a name="690"/>  690: 
<a name="691"/>  691:     %% Flush the node, then terminate the node to make it marked as lost
<a name="692"/>  692:     cover:flush(N1),
<a name="693"/>  693:     peer:stop(P1),
<a name="694"/>  694: 
<a name="695"/>  695:     check_f_calls(1,0),
<a name="696"/>  696: 
<a name="697"/>  697:     %% Stop cover on node
<a name="698"/>  698:     cover:stop(N1),
<a name="699"/>  699: 
<a name="700"/>  700:     %% Restart the node and check that cover does not reconnect
<a name="701"/>  701:     {ok, P2, N1} = ?CT_PEER(#{name =&gt; N1, args =&gt; [&quot;-pa&quot;, DataDir], start_cover =&gt; false}),
<a name="702"/>  702:     timer:sleep(300),
<a name="703"/>  703:     cover_which_nodes([]),
<a name="704"/>  704:     Beam = rpc:call(N1,code,which,[f]),
<a name="705"/>  705:     false = (Beam==cover_compiled),
<a name="706"/>  706: 
<a name="707"/>  707:     %% One more call...
<a name="708"/>  708:     rpc:call(N1,f,f1,[]),
<a name="709"/>  709:     cover:flush(N1),
<a name="710"/>  710: 
<a name="711"/>  711:     %% Ensure that the last call is not counted
<a name="712"/>  712:     check_f_calls(1,0),
<a name="713"/>  713: 
<a name="714"/>  714:     cover:stop(),
<a name="715"/>  715:     peer:stop(P2),
<a name="stop_node_after_disconnect-last_expr"/><a name="716"/>  716:     ok.
<a name="717"/>  717: 
<a name="distribution_performance-1"/><a name="718"/>  718: <b>distribution_performance</b>(Config) -&gt;
<a name="719"/>  719:     PrivDir = proplists:get_value(priv_dir,Config),
<a name="720"/>  720:     Dir = filename:join(PrivDir,&quot;distribution_performance&quot;),
<a name="721"/>  721:     AllFiles = filename:join(Dir,&quot;*&quot;),
<a name="722"/>  722:     ok = filelib:ensure_dir(AllFiles),
<a name="723"/>  723:     code:add_patha(Dir),
<a name="724"/>  724:     M = 9,   % Generate M modules
<a name="725"/>  725:     F = 210, % with F functions
<a name="726"/>  726:     C = 10,  % and each function of C clauses
<a name="727"/>  727:     Mods = generate_modules(M,F,C,Dir),
<a name="728"/>  728: 
<a name="729"/>  729:     %    test_server:break(&quot;&quot;),
<a name="730"/>  730: 
<a name="731"/>  731:     {ok, P1, N1} = ?CT_PEER(),
<a name="732"/>  732:     %% CFun = fun() -&gt;
<a name="733"/>  733:     %% 		   [{ok,_} = cover:compile_beam(Mod) || Mod &lt;- Mods]
<a name="734"/>  734:     %% 	   end,
<a name="735"/>  735:     CFun = fun() -&gt; cover:compile_beam(Mods) end,
<a name="736"/>  736:     {_CT, _CA} = timer:tc(CFun),
<a name="737"/>  737: 
<a name="738"/>  738:     {ok,[N1]} = cover:start([N1]),
<a name="739"/>  739: 
<a name="740"/>  740:     [1 = rpc:call(N1,Mod,f1,[1]) || Mod &lt;- Mods],
<a name="741"/>  741: 
<a name="742"/>  742:     %    Fun = fun() -&gt; [cover:analyse(Mod,calls,function) || Mod&lt;-Mods] end,
<a name="743"/>  743:     %    Fun = fun() -&gt; analyse_all(Mods,calls,function) end,
<a name="744"/>  744:     %    Fun = fun() -&gt; cover:analyse('_',calls,function) end,
<a name="745"/>  745:     Fun = fun() -&gt; cover:analyse(Mods,calls,function) end,
<a name="746"/>  746: 
<a name="747"/>  747:     %    Fun = fun() -&gt; [begin cover:analyse_to_file(Mod,[html]) end || Mod&lt;-Mods] end,
<a name="748"/>  748:     %    Fun = fun() -&gt; analyse_all_to_file(Mods,[html]) end,
<a name="749"/>  749:     %    Fun = fun() -&gt; cover:analyse_to_file(Mods,[html]) end,
<a name="750"/>  750:     %    Fun = fun() -&gt; cover:analyse_to_file([html]) end,
<a name="751"/>  751: 
<a name="752"/>  752:     %    Fun = fun() -&gt; cover:reset() end,
<a name="753"/>  753: 
<a name="754"/>  754:     {_AT, _A} = timer:tc(Fun),
<a name="755"/>  755:     %    erlang:display(lists:sort([X || X={_MFA,N} &lt;- lists:append([L || {ok,L}&lt;-A]), N=/=0])),
<a name="756"/>  756: 
<a name="757"/>  757:     %% fprof:apply(Fun, [],[{procs,[whereis(cover_server)]}]),
<a name="758"/>  758:     %% fprof:profile(),
<a name="759"/>  759:     %% fprof:analyse(dest,[]),
<a name="760"/>  760: 
<a name="761"/>  761:     peer:stop(P1),
<a name="762"/>  762: 
<a name="763"/>  763:     code:del_path(Dir),
<a name="764"/>  764:     Files = filelib:wildcard(AllFiles),
<a name="765"/>  765:     [ok = file:delete(File) || File &lt;- Files],
<a name="766"/>  766:     ok = file:del_dir(Dir),
<a name="distribution_performance-last_expr"/><a name="767"/>  767:     ok.
<a name="768"/>  768: 
<a name="769"/>  769: <i>%% Run analysis in parallel</i>
<a name="analyse_all-3"/><a name="770"/>  770: <b>analyse_all</b>(Mods,Analysis,Level) -&gt;
<a name="771"/>  771:     Pids = [begin
<a name="772"/>  772:                 Pid = spawn(fun() -&gt;
<a name="773"/>  773:                                     {ok,A} = cover:analyse(Mod,Analysis,Level),
<a name="774"/>  774:                                     exit(A)
<a name="775"/>  775:                             end),
<a name="776"/>  776:                 erlang:monitor(process,Pid),
<a name="777"/>  777:                 Pid
<a name="778"/>  778:             end || Mod &lt;- Mods],
<a name="analyse_all-last_expr"/><a name="779"/>  779: <b>    get_downs</b>(Pids,[]).
<a name="780"/>  780: 
<a name="analyse_all_to_file-2"/><a name="781"/>  781: <b>analyse_all_to_file</b>(Mods,Opts) -&gt;
<a name="782"/>  782:     Pids = [begin
<a name="783"/>  783:                 Pid = cover:async_analyse_to_file(Mod,Opts),
<a name="784"/>  784:                 erlang:monitor(process,Pid),
<a name="785"/>  785:                 Pid
<a name="786"/>  786:             end || Mod &lt;- Mods],
<a name="analyse_all_to_file-last_expr"/><a name="787"/>  787: <b>    get_downs</b>(Pids,[]).
<a name="788"/>  788: 
<a name="get_downs-2"/><a name="789"/>  789: <b>get_downs</b>([],Acc) -&gt;
<a name="790"/>  790:     Acc;
<a name="791"/>  791: <b>get_downs</b>(Pids,Acc) -&gt;
<a name="get_downs-last_expr"/><a name="792"/>  792:     receive
<a name="793"/>  793:         {'DOWN', _Ref, _Type, Pid, A} -&gt;
<a name="794"/>  794:             get_downs(lists:delete(Pid,Pids),[A|Acc])
<a name="795"/>  795:     end.
<a name="796"/>  796: 
<a name="generate_modules-4"/><a name="797"/>  797: <b>generate_modules</b>(0,_,_,_) -&gt;
<a name="798"/>  798:     [];
<a name="799"/>  799: <b>generate_modules</b>(M,F,C,Dir) -&gt;
<a name="800"/>  800:     ModStr = &quot;m&quot; ++ integer_to_list(M),
<a name="801"/>  801:     Mod = list_to_atom(ModStr),
<a name="802"/>  802:     Src = [&quot;-module(&quot;,ModStr,&quot;).\n&quot;
<a name="803"/>  803:            &quot;-compile(export_all).\n&quot; |
<a name="804"/>  804:            generate_functions(F,C)],
<a name="805"/>  805:     Erl = filename:join(Dir,ModStr++&quot;.erl&quot;),
<a name="806"/>  806:     ok = file:write_file(Erl,Src),
<a name="807"/>  807:     {ok,Mod} = compile:file(Erl,[{outdir,Dir},debug_info,report]),
<a name="generate_modules-last_expr"/><a name="808"/>  808: <b>    [Mod | generate_modules</b>(M-1,F,C,Dir)].
<a name="809"/>  809: 
<a name="generate_functions-2"/><a name="810"/>  810: <b>generate_functions</b>(0,_) -&gt;
<a name="811"/>  811:     [];
<a name="812"/>  812: <b>generate_functions</b>(F,C) -&gt;
<a name="813"/>  813:     Func = &quot;f&quot; ++ integer_to_list(F),
<a name="generate_functions-last_expr"/><a name="814"/>  814: <b>    [generate_clauses</b>(C,Func) | generate_functions(F-1,C)].
<a name="815"/>  815: 
<a name="generate_clauses-2"/><a name="816"/>  816: <b>generate_clauses</b>(0,_) -&gt;
<a name="817"/>  817:     [];
<a name="818"/>  818: <b>generate_clauses</b>(C,Func) -&gt;
<a name="819"/>  819:     CStr = integer_to_list(C),
<a name="820"/>  820:     Sep = if C==1 -&gt; &quot;.&quot;; true -&gt; &quot;;&quot; end,
<a name="generate_clauses-last_expr"/><a name="821"/>  821: <b>    [Func,&quot;</b>(&quot;,CStr,&quot;) -&gt; &quot;,CStr,Sep,&quot;\n&quot; |
<a name="822"/>  822:      generate_clauses(C-1,Func)].
<a name="823"/>  823: 
<a name="824"/>  824: 
<a name="export_import-1"/><a name="825"/>  825: <b>export_import</b>(Config) when is_list(Config) -&gt;
<a name="826"/>  826:     DataDir = proplists:get_value(data_dir, Config),
<a name="827"/>  827:     ok = file:set_cwd(DataDir),
<a name="828"/>  828:     PortCount = length(erlang:ports()),
<a name="829"/>  829: 
<a name="830"/>  830:     %% Export one module
<a name="831"/>  831:     {ok,f} = cover:compile(f),
<a name="832"/>  832:     f:f1(),
<a name="833"/>  833:     %% check that no info is written about where data comes from when no
<a name="834"/>  834:     %% files are imported
<a name="835"/>  835:     test_server:capture_start(),
<a name="836"/>  836:     check_f_calls(1,0),
<a name="837"/>  837:     [] = test_server:capture_get(),
<a name="838"/>  838:     test_server:capture_stop(),
<a name="839"/>  839:     ok = cover:export(&quot;f_exported&quot;,f),
<a name="840"/>  840:     check_f_calls(1,0),
<a name="841"/>  841:     ok = cover:stop(),
<a name="842"/>  842: 
<a name="843"/>  843:     %% Check that same data exists after import and that info is written about
<a name="844"/>  844:     %% data coming from imported file
<a name="845"/>  845:     ok = cover:import(&quot;f_exported&quot;),
<a name="846"/>  846:     test_server:capture_start(),
<a name="847"/>  847:     check_f_calls(1,0),
<a name="848"/>  848:     [Text1] = test_server:capture_get(),
<a name="849"/>  849:     &quot;Analysis includes data from imported files&quot;++_ = lists:flatten(Text1),
<a name="850"/>  850:     test_server:capture_stop(),
<a name="851"/>  851: 
<a name="852"/>  852:     %% Export all modules
<a name="853"/>  853:     {ok,a} = cover:compile(a),
<a name="854"/>  854:     test_server:capture_start(),
<a name="855"/>  855:     ok = cover:export(&quot;all_exported&quot;),
<a name="856"/>  856:     [] = test_server:capture_get(),
<a name="857"/>  857:     %    &quot;Export includes data from imported files&quot;++_ = lists:flatten(Text2),
<a name="858"/>  858:     test_server:capture_stop(),
<a name="859"/>  859:     ok = cover:stop(),
<a name="860"/>  860:     ok = cover:import(&quot;all_exported&quot;),
<a name="861"/>  861:     check_f_calls(1,0),
<a name="862"/>  862: 
<a name="863"/>  863:     %% Check that data is reset when module is compiled again, and that
<a name="864"/>  864:     %% warning is written when data is deleted for imported module.
<a name="865"/>  865:     test_server:capture_start(),
<a name="866"/>  866:     {ok,f} = cover:compile(f),
<a name="867"/>  867:     timer:sleep(10), % capture needs some time
<a name="868"/>  868:     [Text3] = test_server:capture_get(),
<a name="869"/>  869:     &quot;WARNING: Deleting data for module f imported from&quot; ++ _ = lists:flatten(Text3),
<a name="870"/>  870:     test_server:capture_stop(),
<a name="871"/>  871:     check_f_calls(0,0),
<a name="872"/>  872: 
<a name="873"/>  873:     %% Check that data is summed up when first compiled and then imported
<a name="874"/>  874:     %% The module which has been compiled (f) is loaded from the file 
<a name="875"/>  875:     %% all_exported again (since it has been reset during cover compiling), 
<a name="876"/>  876:     %% but the other module (a) is not loaded since it is already loaded    
<a name="877"/>  877:     f:f1(),
<a name="878"/>  878:     f:f2(),
<a name="879"/>  879:     ok = cover:import(&quot;f_exported&quot;),
<a name="880"/>  880:     test_server:capture_start(),
<a name="881"/>  881:     ok = cover:import(&quot;all_exported&quot;),
<a name="882"/>  882:     [Text4] = test_server:capture_get(), % a is not loaded again
<a name="883"/>  883:     &quot;WARNING: Module a already imported from &quot; ++ _ = lists:flatten(Text4),
<a name="884"/>  884:     test_server:capture_stop(),
<a name="885"/>  885:     check_f_calls(3,1),
<a name="886"/>  886: 
<a name="887"/>  887:     %% Check that warning is written when same file is imported twice,
<a name="888"/>  888:     %% and that data is not imported again
<a name="889"/>  889:     test_server:capture_start(),
<a name="890"/>  890:     ok = cover:import(&quot;all_exported&quot;),
<a name="891"/>  891:     [Text5,Text6] = test_server:capture_get(),
<a name="892"/>  892:     &quot;WARNING: Module f already imported from &quot; ++ _ = lists:flatten(Text5),
<a name="893"/>  893:     &quot;WARNING: Module a already imported from &quot; ++ _ = lists:flatten(Text6),
<a name="894"/>  894:     test_server:capture_stop(),
<a name="895"/>  895:     check_f_calls(3,1),
<a name="896"/>  896: 
<a name="897"/>  897:     %% Check that reset removes all data and that the file which has been
<a name="898"/>  898:     %% reset can be imported again with no warning
<a name="899"/>  899:     cover:reset(f),
<a name="900"/>  900:     check_f_calls(0,0),
<a name="901"/>  901:     test_server:capture_start(),
<a name="902"/>  902:     ok = cover:import(&quot;all_exported&quot;),
<a name="903"/>  903:     [Text7] = test_server:capture_get(), % warning only on mod a
<a name="904"/>  904:     &quot;WARNING: Module a already imported from &quot; ++ _ = lists:flatten(Text7),
<a name="905"/>  905:     test_server:capture_stop(),
<a name="906"/>  906:     check_f_calls(1,0),
<a name="907"/>  907: 
<a name="908"/>  908:     %% same as above - only reset all
<a name="909"/>  909:     cover:reset(),
<a name="910"/>  910:     check_f_calls(0,0),
<a name="911"/>  911:     test_server:capture_start(),
<a name="912"/>  912:     ok = cover:import(&quot;all_exported&quot;),
<a name="913"/>  913:     [] = test_server:capture_get(), % no warnings
<a name="914"/>  914:     test_server:capture_stop(),
<a name="915"/>  915:     check_f_calls(1,0),
<a name="916"/>  916: 
<a name="917"/>  917:     %% Check no raw files are left open
<a name="918"/>  918:     PortCount = length(erlang:ports()),
<a name="919"/>  919: 
<a name="920"/>  920:     %% Cleanup
<a name="921"/>  921:     ok = cover:stop(),
<a name="922"/>  922:     Files = lsfiles(),
<a name="export_import-last_expr"/><a name="923"/>  923: <b>    remove</b>([&quot;f_exported&quot;,&quot;all_exported&quot;|files(Files, &quot;.beam&quot;)]).
<a name="924"/>  924: 
<a name="925"/>  925: 
<a name="otp_5031-1"/><a name="926"/>  926: <b>otp_5031</b>(Config) when is_list(Config) -&gt;
<a name="927"/>  927:     ct:timetrap({seconds, 10}),
<a name="928"/>  928: 
<a name="929"/>  929:     {ok,Peer,N1} = ?CT_PEER(),
<a name="930"/>  930:     {ok,[N1]} = cover:start(N1),
<a name="931"/>  931:     {error,not_main_node} = rpc:call(N1,cover,modules,[]),
<a name="932"/>  932:     cover:stop(),
<a name="933"/>  933:     peer:stop(Peer),
<a name="otp_5031-last_expr"/><a name="934"/>  934:     ok.
<a name="935"/>  935: 
<a name="936"/>  936: <i>%% Test the \'Exclude Included Functions\' functionality</i>
<a name="eif-1"/><a name="937"/>  937: <b>eif</b>(Config) when is_list(Config) -&gt;
<a name="938"/>  938:     ok = file:set_cwd(filename:join(proplists:get_value(data_dir, Config),
<a name="939"/>  939:                                     &quot;included_functions&quot;)),
<a name="940"/>  940:     {ok, cover_inc} = compile:file(cover_inc,[debug_info]),
<a name="941"/>  941:     {ok, cover_inc} = cover:compile_beam(cover_inc),
<a name="942"/>  942: 
<a name="943"/>  943:     %% This function will cause an included function to be executed.
<a name="944"/>  944:     %% The analysis should only show the lines that actually exist
<a name="945"/>  945:     %% in cover_inc.beam - not the ones from the included file.
<a name="946"/>  946:     cover_inc:func(),
<a name="947"/>  947:     {ok, [_, _]} = cover:analyse(cover_inc, line),
<a name="eif-last_expr"/><a name="948"/>  948:     ok.
<a name="949"/>  949: 
<a name="otp_5305-1"/><a name="950"/>  950: <b>otp_5305</b>(Config) when is_list(Config) -&gt;
<a name="951"/>  951:     ok = file:set_cwd(proplists:get_value(priv_dir, Config)),
<a name="952"/>  952: 
<a name="953"/>  953:     File = &quot;t.erl&quot;,
<a name="954"/>  954:     Test = &lt;&lt;&quot;-module(t).
<a name="955"/>  955:               -export([t/0]).
<a name="956"/>  956:               -include_lib(\&quot;stdlib/include/ms_transform.hrl\&quot;).
<a name="957"/>  957:               t() -&gt;
<a name="958"/>  958:                   ets:fun2ms(fun(X) -&gt; X end).
<a name="959"/>  959:              &quot;&gt;&gt;,
<a name="960"/>  960:     ok = file:write_file(File, Test),
<a name="961"/>  961:     {ok, t} = cover:compile(File),
<a name="962"/>  962:     ok = file:delete(File),
<a name="otp_5305-last_expr"/><a name="963"/>  963:     ok.
<a name="964"/>  964: 
<a name="otp_5418-1"/><a name="965"/>  965: <b>otp_5418</b>(Config) when is_list(Config) -&gt;
<a name="966"/>  966:     ok = file:set_cwd(proplists:get_value(priv_dir, Config)),
<a name="967"/>  967: 
<a name="968"/>  968:     File = &quot;t.erl&quot;,
<a name="969"/>  969:     Test = &lt;&lt;&quot;-module(t).
<a name="970"/>  970:              &quot;&gt;&gt;,
<a name="971"/>  971:     ok = file:write_file(File, Test),
<a name="972"/>  972:     {ok, t} = cover:compile(File),
<a name="973"/>  973:     {ok,{t,{0,0}}} = cover:analyse(t, module),
<a name="974"/>  974:     ok = file:delete(File),
<a name="otp_5418-last_expr"/><a name="975"/>  975:     ok.
<a name="976"/>  976: 
<a name="otp_6115-1"/><a name="977"/>  977: <b>otp_6115</b>(Config) when is_list(Config) -&gt;
<a name="978"/>  978:     {ok, CWD} = file:get_cwd(),
<a name="979"/>  979:     Dir = filename:join(proplists:get_value(data_dir, Config), otp_6115),
<a name="980"/>  980:     ok = file:set_cwd(Dir),
<a name="981"/>  981:     {ok, f1} = compile:file(f1, [debug_info]),
<a name="982"/>  982:     {ok, f2} = compile:file(f2, [debug_info]),
<a name="983"/>  983: 
<a name="984"/>  984:     %% Cover compile f1, but not f2
<a name="985"/>  985:     {ok, f1} = cover:compile(f1),
<a name="986"/>  986: 
<a name="987"/>  987:     %% This test used to ensure that a process containing a
<a name="988"/>  988:     %% fun referring to cover compiled code was killed.
<a name="989"/>  989:     %% check_process_code may however ignore funs as of ERTS
<a name="990"/>  990:     %% version 8.1. The test has therefore been rewritten to
<a name="991"/>  991:     %% check that a process with a direct reference (in this
<a name="992"/>  992:     %% case a return address) to the code is killed.
<a name="993"/>  993:     %% 
<a name="994"/>  994:     %% If f1 is cover compiled, a process P is started with a
<a name="995"/>  995:     %% direct reference to the f1, and cover:stop() is called,
<a name="996"/>  996:     %% then P should be killed.
<a name="997"/>  997:     %% This is because of the return address to the cover
<a name="998"/>  998:     %% compiled code which should be *unloaded* when cover:stop() is
<a name="999"/>  999:     %% called -- running cover compiled code when there is no cover
<a name="1000"/> 1000:     %% server and thus no ets tables to bump counters in, makes no
<a name="1001"/> 1001:     %% sense.
<a name="1002"/> 1002:     Pid = spawn(fun () -&gt; f1:non_tail_call_f2_wait() end),
<a name="1003"/> 1003: 
<a name="1004"/> 1004:     %% Now stop cover
<a name="1005"/> 1005:     cover:stop(),
<a name="1006"/> 1006: 
<a name="1007"/> 1007:     %% Ensure that f1 is loaded (and not cover compiled), and that
<a name="1008"/> 1008:     %% both Pid is dead.
<a name="1009"/> 1009:     case code:which(f1) of
<a name="1010"/> 1010:         Beam when is_list(Beam) -&gt;
<a name="1011"/> 1011:             ok;
<a name="1012"/> 1012:         Other -&gt;
<a name="1013"/> 1013:             ct:fail({&quot;f1 is not reloaded&quot;, Other})
<a name="1014"/> 1014:     end,
<a name="1015"/> 1015:     case process_info(Pid) of
<a name="1016"/> 1016:         undefined -&gt;
<a name="1017"/> 1017:             ok;
<a name="1018"/> 1018:         _PI -&gt;
<a name="1019"/> 1019:             RefToOldP = erlang:check_process_code(Pid, f1),
<a name="1020"/> 1020:             ct:fail({&quot;Pid still alive&quot;, RefToOldP})
<a name="1021"/> 1021:     end,
<a name="1022"/> 1022: 
<a name="1023"/> 1023:     file:set_cwd(CWD),
<a name="otp_6115-last_expr"/><a name="1024"/> 1024:     ok.
<a name="1025"/> 1025: 
<a name="1026"/> 1026: <i>%% andalso/orelse</i>
<a name="otp_7095-1"/><a name="1027"/> 1027: <b>otp_7095</b>(Config) when is_list(Config) -&gt;
<a name="1028"/> 1028:     ok = file:set_cwd(proplists:get_value(priv_dir, Config)),
<a name="1029"/> 1029: 
<a name="1030"/> 1030:     File = &quot;t.erl&quot;,
<a name="1031"/> 1031:     Test = &lt;&lt;&quot;-module(t).
<a name="1032"/> 1032:               -export([t/0]).
<a name="1033"/> 1033:               t() -&gt;
<a name="1034"/> 1034:                   t1(),
<a name="1035"/> 1035:                   t2(),
<a name="1036"/> 1036:                   t3(),
<a name="1037"/> 1037:                   t4(),
<a name="1038"/> 1038:                   t5(),
<a name="1039"/> 1039:                   put(t6, 0),
<a name="1040"/> 1040:                   0  = t6(),
<a name="1041"/> 1041:                   1 = erase(t6),
<a name="1042"/> 1042:                   t7(),
<a name="1043"/> 1043:                   put(t8, 0),
<a name="1044"/> 1044:                   {'EXIT',{{badarg,0},_}} = (catch t8()),
<a name="1045"/> 1045:                   1 = erase(t8),
<a name="1046"/> 1046:                   t9(),
<a name="1047"/> 1047:                   ok.
<a name="1048"/> 1048: 
<a name="1049"/> 1049:               t1() -&gt;
<a name="1050"/> 1050:                   false        % 20
<a name="1051"/> 1051:                     andalso
<a name="1052"/> 1052:                   true.        % 22
<a name="1053"/> 1053: 
<a name="1054"/> 1054:               t2() -&gt;
<a name="1055"/> 1055:                   true         % 25
<a name="1056"/> 1056:                     andalso
<a name="1057"/> 1057:                   true.        % 27
<a name="1058"/> 1058: 
<a name="1059"/> 1059:               t3() -&gt;
<a name="1060"/> 1060:                   false        % 30
<a name="1061"/> 1061:                     orelse
<a name="1062"/> 1062:                   true.        % 32
<a name="1063"/> 1063: 
<a name="1064"/> 1064:               t4() -&gt;
<a name="1065"/> 1065:                   true         % 35
<a name="1066"/> 1066:                     orelse
<a name="1067"/> 1067:                   true.        % 37
<a name="1068"/> 1068: 
<a name="1069"/> 1069:               t5() -&gt;
<a name="1070"/> 1070:                   true         % 40
<a name="1071"/> 1071:                     andalso
<a name="1072"/> 1072:                   true         % 42
<a name="1073"/> 1073:                     andalso 
<a name="1074"/> 1074:                   false.       % 44
<a name="1075"/> 1075: 
<a name="1076"/> 1076:               t6() -&gt;
<a name="1077"/> 1077:                   true andalso % 47
<a name="1078"/> 1078:                   add_one(t6). % 48
<a name="1079"/> 1079: 
<a name="1080"/> 1080:               t7() -&gt;
<a name="1081"/> 1081:                   true         % 51
<a name="1082"/> 1082:                     andalso
<a name="1083"/> 1083:                   false        % 53
<a name="1084"/> 1084:                     andalso 
<a name="1085"/> 1085:                   not_ok.      % 55
<a name="1086"/> 1086: 
<a name="1087"/> 1087:               t8() -&gt;
<a name="1088"/> 1088:                   true         % 58
<a name="1089"/> 1089:                     andalso 
<a name="1090"/> 1090:                   true         % 60
<a name="1091"/> 1091:                     andalso
<a name="1092"/> 1092:                   add_one(t8)  % 62
<a name="1093"/> 1093:                     andalso
<a name="1094"/> 1094:                   false.       % 64
<a name="1095"/> 1095: 
<a name="1096"/> 1096:               t9() -&gt;
<a name="1097"/> 1097:                   if           % 67
<a name="1098"/> 1098:                       true -&gt; 
<a name="1099"/> 1099:                           true % 69
<a name="1100"/> 1100:                             andalso 
<a name="1101"/> 1101:                           false % 71
<a name="1102"/> 1102:                   end
<a name="1103"/> 1103:                     orelse
<a name="1104"/> 1104:                   case ok of   % 74
<a name="1105"/> 1105:                       true -&gt; 
<a name="1106"/> 1106:                           a;   % 76
<a name="1107"/> 1107:                       _ -&gt; 
<a name="1108"/> 1108:                           true % 78
<a name="1109"/> 1109:                   end.
<a name="1110"/> 1110: 
<a name="1111"/> 1111:               add_one(T) -&gt;
<a name="1112"/> 1112:                   put(T, get(T) + 1). % 82
<a name="1113"/> 1113:              &quot;&gt;&gt;,
<a name="1114"/> 1114:     ok = file:write_file(File, Test),
<a name="1115"/> 1115:     {ok, t} = cover:compile(File),
<a name="1116"/> 1116:     ok = t:t(),
<a name="1117"/> 1117:     {ok,[{{t,4},1},{{t,5},1},{{t,6},1},{{t,7},1},{{t,8},1},{{t,9},1},
<a name="1118"/> 1118:          {{t,10},1},{{t,11},1},{{t,12},1},{{t,13},1},{{t,14},1},
<a name="1119"/> 1119:          {{t,15},1},{{t,16},1},{{t,17},1},
<a name="1120"/> 1120:          {{t,20},1},{{t,22},0},
<a name="1121"/> 1121:          {{t,25},1},{{t,27},1},
<a name="1122"/> 1122:          {{t,30},1},{{t,32},1},
<a name="1123"/> 1123:          {{t,35},1},{{t,37},0},
<a name="1124"/> 1124:          {{t,40},1},{{t,42},1},{{t,44},1},
<a name="1125"/> 1125:          {{t,47},1},{{t,48},1},
<a name="1126"/> 1126:          {{t,51},1},{{t,53},1},{{t,55},0},
<a name="1127"/> 1127:          {{t,58},1},{{t,60},1},{{t,62},1},{{t,64},0},
<a name="1128"/> 1128:          {{t,67},1},{{t,69},1},{{t,71},1},{{t,74},1},
<a name="1129"/> 1129:          {{t,76},0},{{t,78},1},
<a name="1130"/> 1130:          {{t,82},2}]} = cover:analyse(t, calls, line),
<a name="1131"/> 1131:     ok = file:delete(File),
<a name="otp_7095-last_expr"/><a name="1132"/> 1132:     ok.
<a name="1133"/> 1133: 
<a name="1134"/> 1134: 
<a name="1135"/> 1135: <i>%% OTP-8270. Bug.</i>
<a name="otp_8270-1"/><a name="1136"/> 1136: <b>otp_8270</b>(Config) when is_list(Config) -&gt;
<a name="1137"/> 1137:     DataDir = proplists:get_value(data_dir, Config),
<a name="1138"/> 1138:     ok = file:set_cwd(DataDir),
<a name="1139"/> 1139: 
<a name="1140"/> 1140:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="1141"/> 1141: 
<a name="1142"/> 1142:     As = [&quot;-pa&quot;, PrivDir],
<a name="1143"/> 1143:     {ok,P1,N1} = ?CT_PEER(As),
<a name="1144"/> 1144:     {ok,P2,N2} = ?CT_PEER(As),
<a name="1145"/> 1145:     {ok,P3,N3} = ?CT_PEER(As),
<a name="1146"/> 1146: 
<a name="1147"/> 1147:     timer:sleep(500),
<a name="1148"/> 1148:     {ok,[_,_,_]} = cover:start([N1,N2,N3]),
<a name="1149"/> 1149: 
<a name="1150"/> 1150:     Test = &lt;&lt;&quot;-module(m).\n&quot;
<a name="1151"/> 1151:              &quot;-compile(export_all).\n&quot;
<a name="1152"/> 1152:              &quot;t() -&gt; t(0).\n&quot;
<a name="1153"/> 1153:              &quot;l() -&gt;\n&quot;
<a name="1154"/> 1154:              &quot;   catch ets:tab2list(cover_internal_data_table).\n&quot;
<a name="1155"/> 1155:              &quot;t(Sz) -&gt;\n&quot;
<a name="1156"/> 1156:              &quot;   case ets:info(cover_internal_data_table, size) of\n&quot;
<a name="1157"/> 1157:              &quot;       Sz -&gt;\n&quot;
<a name="1158"/> 1158:              &quot;           m:t(Sz); % Not a local call! Newly loaded code is entered.\n&quot;
<a name="1159"/> 1159:              &quot;       NSz -&gt;\n&quot;
<a name="1160"/> 1160:              &quot;           % error_logger:info_msg(\&quot;~p: ~p ~p change~n L1 ~p~n\&quot;, \n&quot;
<a name="1161"/> 1161:              &quot;           % [node(), Sz, NSz, l()]),\n&quot;
<a name="1162"/> 1162:              &quot;           m:t(NSz)\n&quot;
<a name="1163"/> 1163:              &quot;   end.\n&quot;&gt;&gt;,
<a name="1164"/> 1164:     _File = c_mod(m, Test, Config),
<a name="1165"/> 1165:     Fun = fun m:t/0,
<a name="1166"/> 1166:     Pid1 = spawn(Fun),
<a name="1167"/> 1167:     Pid2 = spawn(N1, Fun),
<a name="1168"/> 1168:     Pid3 = spawn(N2, Fun),
<a name="1169"/> 1169:     Pid4 = spawn(N3, Fun),
<a name="1170"/> 1170: 
<a name="1171"/> 1171:     {ok, m} = cover:compile_beam(m),
<a name="1172"/> 1172: 
<a name="1173"/> 1173:     timer:sleep(1000),
<a name="1174"/> 1174: 
<a name="1175"/> 1175:     Info = erlang:process_info(Pid1),
<a name="1176"/> 1176:     N1_info = rpc:call(N1, erlang, process_info, [Pid2]),
<a name="1177"/> 1177:     N2_info = rpc:call(N2, erlang, process_info, [Pid3]),
<a name="1178"/> 1178:     N3_info = rpc:call(N3, erlang, process_info, [Pid4]),
<a name="1179"/> 1179: 
<a name="1180"/> 1180:     true = is_list(Info),
<a name="1181"/> 1181:     {N1,true} = {N1,is_list(N1_info)},
<a name="1182"/> 1182:     {N2,true} = {N2,is_list(N2_info)},
<a name="1183"/> 1183:     {N3,true} = {N3,is_list(N3_info)},
<a name="1184"/> 1184: 
<a name="1185"/> 1185:     exit(Pid1,kill),
<a name="1186"/> 1186:     peer:stop(P1),
<a name="1187"/> 1187:     peer:stop(P2),
<a name="1188"/> 1188:     peer:stop(P3),
<a name="otp_8270-last_expr"/><a name="1189"/> 1189:     ok.
<a name="1190"/> 1190: 
<a name="1191"/> 1191: <i>%% OTP-8273. Bug.</i>
<a name="otp_8273-1"/><a name="1192"/> 1192: <b>otp_8273</b>(Config) when is_list(Config) -&gt;
<a name="1193"/> 1193:     Test = &lt;&lt;&quot;-module(t).
<a name="1194"/> 1194:               -export([t/0]).
<a name="1195"/> 1195:               t() -&gt;
<a name="1196"/> 1196:                   foo = true andalso foo,
<a name="1197"/> 1197:                   bar = false orelse bar,
<a name="1198"/> 1198:                   ok.
<a name="1199"/> 1199:              &quot;&gt;&gt;,
<a name="1200"/> 1200:     File = cc_mod(t, Test, Config),
<a name="1201"/> 1201:     ok = t:t(),
<a name="1202"/> 1202:     ok = file:delete(File),
<a name="1203"/> 1203: 
<a name="otp_8273-last_expr"/><a name="1204"/> 1204:     ok.
<a name="1205"/> 1205: 
<a name="1206"/> 1206: <i>%% OTP-8340. Bug.</i>
<a name="otp_8340-1"/><a name="1207"/> 1207: <b>otp_8340</b>(Config) when is_list(Config) -&gt;
<a name="1208"/> 1208:     [{{t,1},1},{{t,2},1},{{t,4},1}] =
<a name="1209"/> 1209:     analyse_expr(&lt;&lt;&quot;&lt;&lt; \n&quot;
<a name="1210"/> 1210:                    &quot; &lt;&lt;3:2, \n&quot;
<a name="1211"/> 1211:                    &quot;   SeqId:62&gt;&gt; \n&quot;
<a name="1212"/> 1212:                    &quot;      || SeqId &lt;- [64] &gt;&gt;&quot;&gt;&gt;, Config),
<a name="otp_8340-last_expr"/><a name="1213"/> 1213:     ok.
<a name="1214"/> 1214: 
<a name="1215"/> 1215: <i>%% Clauses on the same line.</i>
<a name="otp_8188-1"/><a name="1216"/> 1216: <b>otp_8188</b>(Config) when is_list(Config) -&gt;
<a name="1217"/> 1217:     %% This example covers the bug report:
<a name="1218"/> 1218:     Test = &lt;&lt;&quot;-module(t).
<a name="1219"/> 1219:               -export([test/1]).
<a name="1220"/> 1220: 
<a name="1221"/> 1221:               -define(FOOBAR(X),
<a name="1222"/> 1222:                       case X of
<a name="1223"/> 1223:                           ok -&gt; true;
<a name="1224"/> 1224:                           _ -&gt; false
<a name="1225"/> 1225:                       end).
<a name="1226"/> 1226: 
<a name="1227"/> 1227:               test(X)-&gt;
<a name="1228"/> 1228:                   _Res = 
<a name="1229"/> 1229:                   ?FOOBAR(X).
<a name="1230"/> 1230:              &quot;&gt;&gt;,
<a name="1231"/> 1231:     File = cc_mod(t, Test, Config),
<a name="1232"/> 1232:     false = t:test(nok),
<a name="1233"/> 1233:     {ok,[{{t,11},1},{{t,12},1}]} = cover:analyse(t, calls, line),
<a name="1234"/> 1234:     ok = file:delete(File),
<a name="1235"/> 1235: 
<a name="1236"/> 1236:     %% Bit string comprehensions are now traversed;
<a name="1237"/> 1237:     %% the handling of list comprehensions has been improved:
<a name="1238"/> 1238:     comprehension_8188(Config),
<a name="1239"/> 1239: 
<a name="1240"/> 1240:     %% Variants of the reported bug:
<a name="1241"/> 1241:     bug_8188(Config),
<a name="otp_8188-last_expr"/><a name="1242"/> 1242:     ok.
<a name="1243"/> 1243: 
<a name="bug_8188-1"/><a name="1244"/> 1244: <b>bug_8188</b>(Cf) -&gt;
<a name="1245"/> 1245:     [{{t,1},1},{{t,2},1},{{t,3},1}] =
<a name="1246"/> 1246:     analyse_expr(&lt;&lt;&quot;A = 3,\n&quot; % 1
<a name="1247"/> 1247:                    &quot;    case A of\n&quot; % 1
<a name="1248"/> 1248:                    &quot;        2 -&gt; two; 3 -&gt; three end, A + 2&quot;&gt;&gt;,  % 1
<a name="1249"/> 1249:                  Cf),
<a name="1250"/> 1250: 
<a name="1251"/> 1251:     [{{t,1},1},
<a name="1252"/> 1252:      {{t,2},0},
<a name="1253"/> 1253:      {{t,3},1},
<a name="1254"/> 1254:      {{t,4},1},
<a name="1255"/> 1255:      {{t,5},1},
<a name="1256"/> 1256:      {{t,6},0},
<a name="1257"/> 1257:      {{t,7},1},
<a name="1258"/> 1258:      {{t,9},2}] =
<a name="1259"/> 1259:     analyse_expr(&lt;&lt;&quot;case two() of\n&quot; % 1
<a name="1260"/> 1260:                    &quot;     1 -&gt; 2;\n&quot; % 0
<a name="1261"/> 1261:                    &quot;    _  -&gt; begin 3 end\n&quot; % 1
<a name="1262"/> 1262:                    &quot;              +\n&quot; % 1
<a name="1263"/> 1263:                    &quot;          begin 4 end end, case two() of\n&quot; % 1
<a name="1264"/> 1264:                    &quot;                               1 -&gt; a;\n&quot; % 0
<a name="1265"/> 1265:                    &quot;                               2 -&gt; b; 3 -&gt; c\n&quot; % 1
<a name="1266"/> 1266:                    &quot;                           end.\n&quot;
<a name="1267"/> 1267:                    &quot;two() -&gt; 2&quot;&gt;&gt;, Cf), % 2
<a name="1268"/> 1268: 
<a name="1269"/> 1269:     [{{t,1},1}, {{t,2},1}, {{t,3},1},
<a name="1270"/> 1270:      {{t,4},1}, {{t,5},1}, {{t,6},0}] =
<a name="1271"/> 1271:     analyse_expr(&lt;&lt;&quot;    self() ! 1,\n&quot;
<a name="1272"/> 1272:                    &quot;    receive \n&quot;
<a name="1273"/> 1273:                    &quot;        X=1 -&gt; a;\n&quot;
<a name="1274"/> 1274:                    &quot;        X=2 -&gt; b end, case X of \n&quot;
<a name="1275"/> 1275:                    &quot;                          1 -&gt; a;\n&quot;
<a name="1276"/> 1276:                    &quot;                          2 -&gt; b\n&quot;
<a name="1277"/> 1277:                    &quot;                      end&quot;&gt;&gt;, Cf),
<a name="1278"/> 1278: 
<a name="1279"/> 1279:     T0 = &lt;&lt;&quot;t1(X) -&gt;\n &quot;
<a name="1280"/> 1280:            &quot;case X of\n&quot;
<a name="1281"/> 1281:            &quot;  1 -&gt; A=a,B=A,B; % bump Li\n&quot;
<a name="1282"/> 1282:            &quot;  2 -&gt; b; 3 -&gt; case X of % 2 -&gt; b shall bump Li\n&quot;
<a name="1283"/> 1283:            &quot;                  3 -&gt; a; % bump Li\n&quot;
<a name="1284"/> 1284:            &quot;                  2 -&gt; b end; 4 -&gt; d end, case X of  % Li\n&quot;
<a name="1285"/> 1285:            &quot;                                            1 -&gt; a;\n&quot;
<a name="1286"/> 1286:            &quot;                                            2 -&gt; b; 3 -&gt; c;\n&quot;
<a name="1287"/> 1287:            &quot;                                            4 -&gt; d\n&quot;
<a name="1288"/> 1288:            &quot;                                          end&quot;&gt;&gt;,
<a name="1289"/> 1289: 
<a name="1290"/> 1290:     T1 = [&lt;&lt;&quot;a = t1(1). &quot;&gt;&gt;,T0],
<a name="1291"/> 1291:     [{{t,1},1}, {{t,2},1}, {{t,3},1}, {{t,4},0},
<a name="1292"/> 1292:      {{t,5},0}, {{t,6},1}, {{t,7},1}, {{t,8},0}, {{t,9},0}] =
<a name="1293"/> 1293:       analyse_expr(T1, Cf),
<a name="1294"/> 1294: 
<a name="1295"/> 1295:     T2 = [&lt;&lt;&quot;b = t1(2). &quot;&gt;&gt;,T0],
<a name="1296"/> 1296:     [{{t,1},1}, {{t,2},1}, {{t,3},0}, {{t,4},1},
<a name="1297"/> 1297:      {{t,5},0}, {{t,6},1}, {{t,7},0}, {{t,8},1}, {{t,9},0}] =
<a name="1298"/> 1298:       analyse_expr(T2, Cf),
<a name="1299"/> 1299: 
<a name="1300"/> 1300:     T3 = [&lt;&lt;&quot;c = t1(3). &quot;&gt;&gt;,T0],
<a name="1301"/> 1301:     [{{t,1},1}, {{t,2},1}, {{t,3},0}, {{t,4},1},
<a name="1302"/> 1302:      {{t,5},1}, {{t,6},1}, {{t,7},0}, {{t,8},1}, {{t,9},0}] =
<a name="1303"/> 1303:       analyse_expr(T3, Cf),
<a name="1304"/> 1304: 
<a name="1305"/> 1305:     T4 = [&lt;&lt;&quot;d = t1(4). &quot;&gt;&gt;,T0],
<a name="1306"/> 1306:     [{{t,1},1}, {{t,2},1}, {{t,3},0}, {{t,4},0},
<a name="1307"/> 1307:      {{t,5},0}, {{t,6},1}, {{t,7},0}, {{t,8},0}, {{t,9},1}] =
<a name="1308"/> 1308:       analyse_expr(T4, Cf),
<a name="1309"/> 1309: 
<a name="1310"/> 1310:     [{{t,1},1},{{t,2},1},{{t,3},1},{{t,4},1},{{t,5},1}] =
<a name="1311"/> 1311:       analyse_expr(
<a name="1312"/> 1312:         &lt;&lt;&quot;2 = x3(1). &quot;
<a name="1313"/> 1313:           &quot;x3(X) -&gt;\n&quot;
<a name="1314"/> 1314:           &quot;    case X of \n&quot;
<a name="1315"/> 1315:           &quot;        1 -&gt; case X of\n&quot;
<a name="1316"/> 1316:           &quot;                 1 -&gt; a, Y = 2;\n&quot;
<a name="1317"/> 1317:           &quot;                 2 -&gt; b, Y = 3 end, Y; 2 -&gt; Y = 4 end, Y&quot;&gt;&gt;, Cf),
<a name="1318"/> 1318: 
<a name="1319"/> 1319:     [{{t,1},1},{{t,2},1},{{t,3},1},{{t,4},1}] =
<a name="1320"/> 1320:     analyse_expr(
<a name="1321"/> 1321:       &lt;&lt;&quot;1 = x4(1). &quot;
<a name="1322"/> 1322:         &quot;x4(X) -&gt;\n&quot;
<a name="1323"/> 1323:         &quot;  case X of\n&quot;
<a name="1324"/> 1324:         &quot;    1 -&gt; case X of\n&quot;
<a name="1325"/> 1325:         &quot;           1 -&gt; Y = 1 end, case X of 1 -&gt; Y = 1 end, Y end&quot;&gt;&gt;,
<a name="1326"/> 1326:       Cf),
<a name="1327"/> 1327: 
<a name="1328"/> 1328:     T10 = &lt;&lt;&quot;t1(X) -&gt;\n&quot;
<a name="1329"/> 1329:             &quot;if\n&quot;
<a name="1330"/> 1330:             &quot;  X =:= 1 -&gt; a;\n&quot;
<a name="1331"/> 1331:             &quot;  X =:= 2 -&gt; b; X =:= 3 -&gt; c end, case X of \n&quot;
<a name="1332"/> 1332:             &quot;                        1 -&gt; a;\n&quot;
<a name="1333"/> 1333:             &quot;                        2 -&gt; b; 3 -&gt; c end, case X of\n&quot;
<a name="1334"/> 1334:             &quot;                                              1 -&gt; a;\n&quot;
<a name="1335"/> 1335:             &quot;                                              2 -&gt; b; 3 -&gt; c\n&quot;
<a name="1336"/> 1336:             &quot;                                            end&quot;&gt;&gt;,
<a name="1337"/> 1337:     T11 = [&lt;&lt;&quot;a = t1(1). &quot;&gt;&gt;,T10],
<a name="1338"/> 1338:     [{{t,1},1}, {{t,2},1}, {{t,3},1}, {{t,4},1},
<a name="1339"/> 1339:      {{t,5},1}, {{t,6},1}, {{t,7},1}, {{t,8},0}] = analyse_expr(T11, Cf),
<a name="1340"/> 1340: 
<a name="1341"/> 1341:     T12 = [&lt;&lt;&quot;b = t1(2). &quot;&gt;&gt;,T10],
<a name="1342"/> 1342:     [{{t,1},1}, {{t,2},1}, {{t,3},0}, {{t,4},1},
<a name="1343"/> 1343:      {{t,5},0}, {{t,6},1}, {{t,7},0}, {{t,8},1}] = analyse_expr(T12, Cf),
<a name="1344"/> 1344: 
<a name="1345"/> 1345:     T13 = [&lt;&lt;&quot;c = t1(3). &quot;&gt;&gt;,T10],
<a name="1346"/> 1346:     [{{t,1},1}, {{t,2},1}, {{t,3},0}, {{t,4},1},
<a name="1347"/> 1347:      {{t,5},0}, {{t,6},1}, {{t,7},0}, {{t,8},1}] = analyse_expr(T13, Cf),
<a name="1348"/> 1348: 
<a name="1349"/> 1349:     T20 = &lt;&lt;&quot;t1(X) -&gt;\n&quot;
<a name="1350"/> 1350:             &quot;case X of\n&quot;
<a name="1351"/> 1351:             &quot;        1 -&gt; a;\n&quot;
<a name="1352"/> 1352:             &quot;        2 -&gt; b; 3 -&gt; case X of\n&quot;
<a name="1353"/> 1353:             &quot;                         1 -&gt; a;\n&quot;
<a name="1354"/> 1354:             &quot;                         2 -&gt; b; 3 -&gt; c end end, case X of\n&quot;
<a name="1355"/> 1355:             &quot;                                             1 -&gt; a;\n&quot;
<a name="1356"/> 1356:             &quot;                                             2 -&gt; b; 3 -&gt; c\n&quot;
<a name="1357"/> 1357:             &quot;                                         end&quot;&gt;&gt;,
<a name="1358"/> 1358: 
<a name="1359"/> 1359:     T21 = [&lt;&lt;&quot;a = t1(1). &quot;&gt;&gt;,T20],
<a name="1360"/> 1360:     [{{t,1},1}, {{t,2},1}, {{t,3},1}, {{t,4},0},
<a name="1361"/> 1361:      {{t,5},0}, {{t,6},1}, {{t,7},1}, {{t,8},0}] = analyse_expr(T21, Cf),
<a name="1362"/> 1362: 
<a name="1363"/> 1363:     T22 = [&lt;&lt;&quot;b = t1(2). &quot;&gt;&gt;,T20],
<a name="1364"/> 1364:     [{{t,1},1}, {{t,2},1}, {{t,3},0}, {{t,4},1},
<a name="1365"/> 1365:      {{t,5},0}, {{t,6},1}, {{t,7},0}, {{t,8},1}] = analyse_expr(T22, Cf),
<a name="1366"/> 1366: 
<a name="1367"/> 1367:     T23 = [&lt;&lt;&quot;c = t1(3). &quot;&gt;&gt;,T20],
<a name="1368"/> 1368:     [{{t,1},1}, {{t,2},1}, {{t,3},0}, {{t,4},1},
<a name="1369"/> 1369:      {{t,5},0}, {{t,6},1}, {{t,7},0}, {{t,8},1}] = analyse_expr(T23, Cf),
<a name="1370"/> 1370: 
<a name="1371"/> 1371:     T30 = &lt;&lt;
<a name="1372"/> 1372:             &quot;t1(X) -&gt;\n&quot;
<a name="1373"/> 1373:             &quot;case X of\n&quot;
<a name="1374"/> 1374:             &quot; 1 -&gt; a;\n&quot;
<a name="1375"/> 1375:             &quot; 2 -&gt; b; 3 -&gt; case X of 1 -&gt; a; 2 -&gt; b; 3 -&gt; c end end, case X of\n&quot;
<a name="1376"/> 1376:             &quot;                                                 1 -&gt; a;\n&quot;
<a name="1377"/> 1377:             &quot;                                                 2 -&gt; b; 3 -&gt; c\n&quot;
<a name="1378"/> 1378:             &quot;                                                end\n&quot;&gt;&gt;,
<a name="1379"/> 1379: 
<a name="1380"/> 1380:     T31 = [&lt;&lt;&quot;a = t1(1). &quot;&gt;&gt;,T30],
<a name="1381"/> 1381:     [{{t,1},1}, {{t,2},1}, {{t,3},1},
<a name="1382"/> 1382:      {{t,4},1}, {{t,5},1}, {{t,6},0}] = analyse_expr(T31, Cf),
<a name="1383"/> 1383: 
<a name="1384"/> 1384:     T32 = [&lt;&lt;&quot;b = t1(2). &quot;&gt;&gt;,T30],
<a name="1385"/> 1385:     [{{t,1},1}, {{t,2},1}, {{t,3},0},
<a name="1386"/> 1386:      {{t,4},1}, {{t,5},0}, {{t,6},1}] = analyse_expr(T32, Cf),
<a name="1387"/> 1387: 
<a name="1388"/> 1388:     T33 = [&lt;&lt;&quot;c = t1(3). &quot;&gt;&gt;,T30],
<a name="1389"/> 1389:     [{{t,1},1}, {{t,2},1}, {{t,3},0},
<a name="1390"/> 1390:      {{t,4},1}, {{t,5},0}, {{t,6},1}] = analyse_expr(T33, Cf),
<a name="1391"/> 1391: 
<a name="1392"/> 1392:     %% 'try' now traverses the body as a body...
<a name="1393"/> 1393:     [{{t,1},1},{{t,2},1},{{t,3},1},{{t,4},0},{{t,6},1}] =
<a name="1394"/> 1394:     analyse_expr(&lt;&lt;&quot;try \n&quot;
<a name="1395"/> 1395:                    &quot;    B = 2, \n&quot;
<a name="1396"/> 1396:                    &quot;    C = erlang:error(foo), \n&quot;
<a name="1397"/> 1397:                    &quot;    {B,C} \n&quot;
<a name="1398"/> 1398:                    &quot;catch _:_ -&gt; \n&quot;
<a name="1399"/> 1399:                    &quot;    foo \n&quot;
<a name="1400"/> 1400:                    &quot;end&quot;&gt;&gt;, Cf),
<a name="1401"/> 1401: 
<a name="1402"/> 1402:     %% receive after:
<a name="1403"/> 1403:     [{{t,1},1},{{t,2},0},{{t,3},1}] =
<a name="1404"/> 1404:     analyse_expr(&lt;&lt;&quot;receive \n&quot;
<a name="1405"/> 1405:                    &quot;    X=1 -&gt; a; \n&quot;
<a name="1406"/> 1406:                    &quot;    X=2 -&gt; b after begin 10 end -&gt; X=3 end&quot;&gt;&gt;, Cf),
<a name="1407"/> 1407:     [{{t,1},1},{{t,2},0},{{t,3},1}] =
<a name="1408"/> 1408:     analyse_expr(&lt;&lt;&quot;receive \n&quot;
<a name="1409"/> 1409:                    &quot;    X=1 -&gt; a; \n&quot;
<a name="1410"/> 1410:                    &quot;    X=2 -&gt; b after 10 -&gt; begin X=3 end end&quot;&gt;&gt;, Cf),
<a name="bug_8188-last_expr"/><a name="1411"/> 1411:     ok.
<a name="1412"/> 1412: 
<a name="comprehension_8188-1"/><a name="1413"/> 1413: <b>comprehension_8188</b>(Cf) -&gt;
<a name="1414"/> 1414:     [{{t,1},1}] = analyse_expr(&lt;&lt;&quot;[begin X end || X &lt;- [1,2,3], X &gt; 1]&quot;&gt;&gt;, Cf),
<a name="1415"/> 1415:     [{{t,1},1},{{t,2},1}] = analyse_expr(&lt;&lt;&quot;[begin X end || \n&quot;
<a name="1416"/> 1416:                                            &quot;    X &lt;- [1,2,3], X &gt; 1]&quot;&gt;&gt;, Cf),
<a name="1417"/> 1417:     [{{t,1},1},{{t,2},1},{{t,3},3}] = analyse_expr(&lt;&lt;&quot;[begin X end || \n &quot;
<a name="1418"/> 1418:                                                      &quot;    X &lt;- [1,2,3], \n &quot;
<a name="1419"/> 1419:                                                      &quot;    X &gt; 1]&quot;&gt;&gt;, Cf),
<a name="1420"/> 1420:     [{{t,1},1},{{t,3},1},{{t,4},3}] = analyse_expr(&lt;&lt;&quot;[begin X end || \n &quot;
<a name="1421"/> 1421:                                                      &quot;    X &lt;- \n &quot;
<a name="1422"/> 1422:                                                      &quot;        [1,2,3], \n &quot;
<a name="1423"/> 1423:                                                      &quot;    X &gt; 1]&quot;&gt;&gt;, Cf),
<a name="1424"/> 1424:     [{{t,1},1},{{t,2},2}] = analyse_expr(&lt;&lt;&quot;[  \n &quot;
<a name="1425"/> 1425:                                            &quot;   X || X &lt;- [1,2,3], X &gt; 1]&quot;&gt;&gt;, Cf),
<a name="1426"/> 1426:     [{{t,1},1},{{t,2},2},{{t,3},3}] = analyse_expr(&lt;&lt;&quot;[ \n&quot;
<a name="1427"/> 1427:                                                      &quot;  X || X &lt;- [1,2,3], \n&quot;
<a name="1428"/> 1428:                                                      &quot;  X &gt; 1]&quot;&gt;&gt;, Cf),
<a name="1429"/> 1429:     [{{t,1},1},{{t,2},1},{{t,3},2}] = analyse_expr(&lt;&lt;&quot;[ \n &quot;
<a name="1430"/> 1430:                                                      &quot;   X || X &lt;- [1,2,3], X &gt; 1, \n&quot;
<a name="1431"/> 1431:                                                      &quot;   X &gt; 2]&quot;&gt;&gt;, Cf),
<a name="1432"/> 1432: 
<a name="1433"/> 1433:     [{{t,1},1},
<a name="1434"/> 1434:      {{t,3},2},
<a name="1435"/> 1435:      {{t,5},1},
<a name="1436"/> 1436:      {{t,7},1},
<a name="1437"/> 1437:      {{t,8},0},
<a name="1438"/> 1438:      {{t,12},3},
<a name="1439"/> 1439:      {{t,15},2},
<a name="1440"/> 1440:      {{t,17},2},
<a name="1441"/> 1441:      {{t,18},1}] = analyse_expr(&lt;&lt;&quot;[ \n&quot; % 1
<a name="1442"/> 1442:                                   &quot;  begin\n&quot;
<a name="1443"/> 1443:                                   &quot;      X * 2\n&quot; % 2
<a name="1444"/> 1444:                                   &quot;  end ||\n&quot;
<a name="1445"/> 1445:                                   &quot;    X &lt;- [1,\n&quot; % 1
<a name="1446"/> 1446:                                   &quot;          case two() of\n&quot;
<a name="1447"/> 1447:                                   &quot;              2 -&gt; 2;\n&quot; % 1
<a name="1448"/> 1448:                                   &quot;              _ -&gt; two\n&quot; % 0
<a name="1449"/> 1449:                                   &quot;          end,\n&quot;
<a name="1450"/> 1450:                                   &quot;          3],\n&quot;
<a name="1451"/> 1451:                                   &quot;    begin\n&quot;
<a name="1452"/> 1452:                                   &quot;        math:sqrt(X) &gt; 1.0\n&quot; % 3
<a name="1453"/> 1453:                                   &quot;    end,\n&quot;
<a name="1454"/> 1454:                                   &quot;    begin\n&quot;
<a name="1455"/> 1455:                                   &quot;        true\n&quot; % 2
<a name="1456"/> 1456:                                   &quot;    end,\n&quot;
<a name="1457"/> 1457:                                   &quot;    true]. \n&quot; % 2
<a name="1458"/> 1458:                                   &quot;  two() -&gt; 2&quot;&gt;&gt;, Cf), % 1
<a name="1459"/> 1459: 
<a name="1460"/> 1460:     [{{t,1},1},
<a name="1461"/> 1461:      {{t,2},2},
<a name="1462"/> 1462:      {{t,3},1},
<a name="1463"/> 1463:      {{t,5},1},
<a name="1464"/> 1464:      {{t,6},0},
<a name="1465"/> 1465:      {{t,9},3},
<a name="1466"/> 1466:      {{t,10},2},
<a name="1467"/> 1467:      {{t,11},2},
<a name="1468"/> 1468:      {{t,12},1}] = analyse_expr(&lt;&lt;&quot;[ \n&quot;
<a name="1469"/> 1469:                                   &quot;      X * 2 || \n&quot; % 2
<a name="1470"/> 1470:                                   &quot;    X &lt;- [1,\n&quot; % 1
<a name="1471"/> 1471:                                   &quot;          case two() of\n&quot;
<a name="1472"/> 1472:                                   &quot;              2 -&gt; 2;\n&quot; % 1
<a name="1473"/> 1473:                                   &quot;              _ -&gt; two\n&quot; % 0
<a name="1474"/> 1474:                                   &quot;          end,\n&quot;
<a name="1475"/> 1475:                                   &quot;          3],\n&quot;
<a name="1476"/> 1476:                                   &quot;    math:sqrt(X) &gt; 1.0,\n&quot; % 3
<a name="1477"/> 1477:                                   &quot;    true,\n&quot; % 2
<a name="1478"/> 1478:                                   &quot;    true]. \n&quot; % 2
<a name="1479"/> 1479:                                   &quot;  two() -&gt; 2&quot;&gt;&gt;, Cf), % 1
<a name="1480"/> 1480: 
<a name="1481"/> 1481:     [{{t,1},1},
<a name="1482"/> 1482:      {{t,2},2},
<a name="1483"/> 1483:      {{t,3},1},
<a name="1484"/> 1484:      {{t,4},1},
<a name="1485"/> 1485:      {{t,5},0},
<a name="1486"/> 1486:      {{t,8},1},
<a name="1487"/> 1487:      {{t,9},0},
<a name="1488"/> 1488:      {{t,12},3},
<a name="1489"/> 1489:      {{t,13},2},
<a name="1490"/> 1490:      {{t,14},2}] = analyse_expr(&lt;&lt;&quot;&lt;&lt; \n&quot; % 1
<a name="1491"/> 1491:                                   &quot; &lt;&lt; (X*2) &gt;&gt; || \n&quot; % 2
<a name="1492"/> 1492:                                   &quot;    &lt;&lt;X&gt;&gt; &lt;= &lt;&lt; (case two() of\n&quot;
<a name="1493"/> 1493:                                   &quot;                     2 -&gt; 1;\n&quot; % 1
<a name="1494"/> 1494:                                   &quot;                     _ -&gt; 2\n&quot; % 0
<a name="1495"/> 1495:                                   &quot;                 end)/integer,\n&quot;
<a name="1496"/> 1496:                                   &quot;                (case two() of \n&quot;
<a name="1497"/> 1497:                                   &quot;                    2 -&gt; 2;\n&quot; % 1
<a name="1498"/> 1498:                                   &quot;                    _ -&gt; two\n&quot; % 0
<a name="1499"/> 1499:                                   &quot;                 end)/integer,\n&quot;
<a name="1500"/> 1500:                                   &quot;                3 &gt;&gt;, \n&quot;
<a name="1501"/> 1501:                                   &quot;    math:sqrt(X) &gt; 1.0,\n&quot; % 3
<a name="1502"/> 1502:                                   &quot;    true &gt;&gt;.\n&quot; % 2
<a name="1503"/> 1503:                                   &quot;two() -&gt; 2&quot;&gt;&gt;, Cf),
<a name="1504"/> 1504:     [{{t,1},1},
<a name="1505"/> 1505:      {{t,2},4},
<a name="1506"/> 1506:      {{t,4},1},
<a name="1507"/> 1507:      {{t,6},1},
<a name="1508"/> 1508:      {{t,7},0},
<a name="1509"/> 1509:      {{t,10},3},
<a name="1510"/> 1510:      {{t,11},2},
<a name="1511"/> 1511:      {{t,12},4},
<a name="1512"/> 1512:      {{t,13},1}] = analyse_expr(&lt;&lt;&quot;&lt;&lt; \n&quot; % 1
<a name="1513"/> 1513:                                   &quot; &lt;&lt; (2)\n&quot; % 4
<a name="1514"/> 1514:                                   &quot;     :(8) &gt;&gt; || \n&quot;
<a name="1515"/> 1515:                                   &quot;    &lt;&lt;X&gt;&gt; &lt;= &lt;&lt; 1,\n&quot; % 1
<a name="1516"/> 1516:                                   &quot;                (case two() of \n&quot;
<a name="1517"/> 1517:                                   &quot;                    2 -&gt; 2;\n&quot; % 1
<a name="1518"/> 1518:                                   &quot;                    _ -&gt; two\n&quot; % 0
<a name="1519"/> 1519:                                   &quot;                 end)/integer,\n&quot;
<a name="1520"/> 1520:                                   &quot;                3 &gt;&gt;, \n&quot;
<a name="1521"/> 1521:                                   &quot;    math:sqrt(X) &gt; 1.0,\n&quot; % 3
<a name="1522"/> 1522:                                   &quot;    &lt;&lt;_&gt;&gt; &lt;= &lt;&lt; 1, 2 &gt;&gt;,\n&quot; % 2
<a name="1523"/> 1523:                                   &quot;    true &gt;&gt;.\n&quot; % 4
<a name="1524"/> 1524:                                   &quot;two() -&gt; 2&quot;&gt;&gt;, Cf), % 1
<a name="1525"/> 1525: 
<a name="1526"/> 1526:     [{{t,1},1},
<a name="1527"/> 1527:      {{t,2},2},
<a name="1528"/> 1528:      {{t,3},2},
<a name="1529"/> 1529:      {{t,5},1},
<a name="1530"/> 1530:      {{t,8},3},
<a name="1531"/> 1531:      {{t,9},2},
<a name="1532"/> 1532:      {{t,10},1}] =
<a name="1533"/> 1533:         analyse_expr(&lt;&lt;&quot;#{\n&quot;               %1
<a name="1534"/> 1534:                        &quot;  K + 1 =&gt;\n&quot;       %2
<a name="1535"/> 1535:                        &quot;X * 2 ||\n&quot;         %2
<a name="1536"/> 1536:                        &quot;    K := X &lt;-\n&quot;
<a name="1537"/> 1537:                        &quot;             #{1 =&gt; 1,\n&quot; %1
<a name="1538"/> 1538:                        &quot;               2 =&gt; two(),\n&quot;
<a name="1539"/> 1539:                        &quot;               3 =&gt; 3},\n&quot;
<a name="1540"/> 1540:                        &quot;    X &gt; 1,\n&quot;           %3
<a name="1541"/> 1541:                        &quot;    true}. \n&quot;          %2
<a name="1542"/> 1542:                        &quot;  two() -&gt; 2&quot;&gt;&gt;, Cf),   %1
<a name="1543"/> 1543: 
<a name="comprehension_8188-last_expr"/><a name="1544"/> 1544:     ok.
<a name="1545"/> 1545: 
<a name="eep37-1"/><a name="1546"/> 1546: <b>eep37</b>(Config) when is_list(Config) -&gt;
<a name="1547"/> 1547:     [{{t,1},1},{{t,2},1},{{t,4},6},{{t,6},1},{{t,8},1}] =
<a name="1548"/> 1548:     analyse_expr(&lt;&lt;&quot;begin\n&quot; % 1
<a name="1549"/> 1549:                    &quot;    F =\n&quot; % 1
<a name="1550"/> 1550:                    &quot;        fun Fact(N) when N &gt; 0 -&gt;\n&quot;
<a name="1551"/> 1551:                    &quot;                N * Fact(N - 1);\n&quot; % 6
<a name="1552"/> 1552:                    &quot;            Fact(0) -&gt;\n&quot;
<a name="1553"/> 1553:                    &quot;                1\n&quot; % 1
<a name="1554"/> 1554:                    &quot;        end,\n&quot;
<a name="1555"/> 1555:                    &quot;    F(6)\n&quot; % 1
<a name="1556"/> 1556:                    &quot;end\n&quot;&gt;&gt;,
<a name="1557"/> 1557:                  Config),
<a name="eep37-last_expr"/><a name="1558"/> 1558:     ok.
<a name="1559"/> 1559: 
<a name="otp_10979_hanging_node-1"/><a name="1560"/> 1560: <b>otp_10979_hanging_node</b>(_Config) -&gt;
<a name="1561"/> 1561: 
<a name="1562"/> 1562:     P1 = processes(),
<a name="1563"/> 1563: 
<a name="1564"/> 1564:     cover:stop(non_existing_node),
<a name="1565"/> 1565:     cover:stop(),
<a name="1566"/> 1566: 
<a name="1567"/> 1567:     P2 = processes(),
<a name="1568"/> 1568: 
<a name="1569"/> 1569:     case P2--P1 of
<a name="1570"/> 1570:         [] -&gt;
<a name="1571"/> 1571:             ok;
<a name="1572"/> 1572:         New -&gt;
<a name="1573"/> 1573:             [io:format(&quot;New: ~p, ~p~n&quot;,[P,process_info(P)]) || P&lt;-New],
<a name="1574"/> 1574:             ct:fail(hanging_process)
<a name="1575"/> 1575:     end,
<a name="1576"/> 1576: 
<a name="otp_10979_hanging_node-last_expr"/><a name="1577"/> 1577:     ok.
<a name="1578"/> 1578: 
<a name="otp_14817-1"/><a name="1579"/> 1579: <b>otp_14817</b>(Config) when is_list(Config) -&gt;
<a name="1580"/> 1580:     Test = &lt;&lt;&quot;-module(otp_14817).
<a name="1581"/> 1581:               -export([a/0, b/0, c/0, d/0]).
<a name="1582"/> 1582:               a() -&gt; ok. b() -&gt; ok. c() -&gt; ok.
<a name="1583"/> 1583:               d() -&gt; ok.
<a name="1584"/> 1584:              &quot;&gt;&gt;,
<a name="1585"/> 1585:     File = cc_mod(otp_14817, Test, Config),
<a name="1586"/> 1586:     ok = otp_14817:a(),
<a name="1587"/> 1587:     ok = otp_14817:b(),
<a name="1588"/> 1588:     ok = otp_14817:c(),
<a name="1589"/> 1589:     ok = otp_14817:d(),
<a name="1590"/> 1590:     {ok,[{{otp_14817,3},1},
<a name="1591"/> 1591:          {{otp_14817,3},1},
<a name="1592"/> 1592:          {{otp_14817,3},1},
<a name="1593"/> 1593:          {{otp_14817,4},1}]} =
<a name="1594"/> 1594:         cover:analyse(otp_14817, calls, line),
<a name="1595"/> 1595:     {ok, CovOut} = cover:analyse_to_file(otp_14817),
<a name="1596"/> 1596:     {ok, Bin} = file:read_file(CovOut),
<a name="1597"/> 1597:     &lt;&lt;&quot;3..|&quot;,_/binary&gt;&gt; = string:find(Bin, &quot;3..|&quot;),
<a name="1598"/> 1598:     &lt;&lt;&quot;1..|&quot;,_/binary&gt;&gt; = string:find(Bin, &quot;1..|&quot;),
<a name="1599"/> 1599:     ok = file:delete(File),
<a name="1600"/> 1600:     ok = file:delete(CovOut),
<a name="otp_14817-last_expr"/><a name="1601"/> 1601:     ok.
<a name="1602"/> 1602: 
<a name="1603"/> 1603: <i>%% Tests a bug where cover failed for an export named clauses</i>
<a name="cover_clauses-1"/><a name="1604"/> 1604: <b>cover_clauses</b>(Config) when is_list(Config) -&gt;
<a name="1605"/> 1605:     Test = &lt;&lt;&quot;-module(cover_clauses).
<a name="1606"/> 1606:               -export([clauses/0]).
<a name="1607"/> 1607:               clauses() -&gt; ok.
<a name="1608"/> 1608:              &quot;&gt;&gt;,
<a name="1609"/> 1609:     _File = cc_mod(cover_clauses, Test, Config),
<a name="cover_clauses-last_expr"/><a name="1610"/> 1610:     ok.
<a name="1611"/> 1611: 
<a name="1612"/> 1612: <i>%% Take compiler options from beam in cover:compile_beam</i>
<a name="compile_beam_opts-1"/><a name="1613"/> 1613: <b>compile_beam_opts</b>(Config) when is_list(Config) -&gt;
<a name="1614"/> 1614:     {ok, Cwd} = file:get_cwd(),
<a name="1615"/> 1615:     ok = file:set_cwd(proplists:get_value(priv_dir, Config)),
<a name="1616"/> 1616:     IncDir = filename:join(proplists:get_value(data_dir, Config),
<a name="1617"/> 1617:                            &quot;included_functions&quot;),
<a name="1618"/> 1618:     File = filename:join([proplists:get_value(data_dir, Config), &quot;otp_11439&quot;, &quot;t.erl&quot;]),
<a name="1619"/> 1619:     %% use all compiler options allowed by cover:filter_options
<a name="1620"/> 1620:     %% i and d don't make sense when compiling from beam though
<a name="1621"/> 1621:     {ok, t} =
<a name="1622"/> 1622:     compile:file(File, [{i, IncDir},
<a name="1623"/> 1623:                         {d, 'BOOL'},
<a name="1624"/> 1624:                         {d, 'MACRO', macro_defined},
<a name="1625"/> 1625:                         export_all,
<a name="1626"/> 1626:                         debug_info,
<a name="1627"/> 1627:                         return_errors]),
<a name="1628"/> 1628:     code:purge(t),
<a name="1629"/> 1629:     code:delete(t),
<a name="1630"/> 1630:     Exports =
<a name="1631"/> 1631:     [{func1,0},
<a name="1632"/> 1632:      {macro, 0},
<a name="1633"/> 1633:      {exported,0},
<a name="1634"/> 1634:      {nonexported,0},
<a name="1635"/> 1635:      {module_info,0},
<a name="1636"/> 1636:      {module_info,1}],
<a name="1637"/> 1637:     Exports = t:module_info(exports),
<a name="1638"/> 1638:     {ok, t} = cover:compile_beam(&quot;t&quot;),
<a name="1639"/> 1639:     Exports = t:module_info(exports),
<a name="1640"/> 1640:     ok = file:delete(&quot;t.beam&quot;),
<a name="1641"/> 1641:     ok = file:set_cwd(Cwd),
<a name="compile_beam_opts-last_expr"/><a name="1642"/> 1642:     ok.
<a name="1643"/> 1643: 
<a name="1644"/> 1644: <i>%% Don't crash if beam is not available</i>
<a name="analyse_no_beam-1"/><a name="1645"/> 1645: <b>analyse_no_beam</b>(Config) when is_list(Config) -&gt;
<a name="1646"/> 1646:     {ok, Cwd} = file:get_cwd(),
<a name="1647"/> 1647:     ok = file:set_cwd(proplists:get_value(data_dir, Config)),
<a name="1648"/> 1648: 
<a name="1649"/> 1649:     code:purge(t),
<a name="1650"/> 1650:     code:delete(t),
<a name="1651"/> 1651: 
<a name="1652"/> 1652:     {ok,_} = file:copy(&quot;compile_beam/t.erl&quot;, &quot;t.erl&quot;),
<a name="1653"/> 1653:     {ok,t} = compile:file(t, [debug_info]),
<a name="1654"/> 1654:     {module,t} = code:load_file(t),
<a name="1655"/> 1655:     {ok,t} = cover:compile_beam(t),
<a name="1656"/> 1656:     t:f(),
<a name="1657"/> 1657:     ok = cover:export(&quot;t.coverdata&quot;),
<a name="1658"/> 1658: 
<a name="1659"/> 1659:     code:purge(t),
<a name="1660"/> 1660:     code:delete(t),
<a name="1661"/> 1661: 
<a name="1662"/> 1662:     %% this is just so that cover realises (without stopping)
<a name="1663"/> 1663:     %% that this module is not cover compiled any more
<a name="1664"/> 1664:     {error, {not_cover_compiled,t}} = cover:analyse(t),
<a name="1665"/> 1665: 
<a name="1666"/> 1666:     %% source and beam not available any more
<a name="1667"/> 1667:     ok = file:delete(&quot;t.erl&quot;),
<a name="1668"/> 1668:     ok = file:delete(&quot;t.beam&quot;),
<a name="1669"/> 1669: 
<a name="1670"/> 1670:     ok = cover:import(&quot;t.coverdata&quot;),
<a name="1671"/> 1671: 
<a name="1672"/> 1672:     {error,{no_source_code_found,t}} = cover:analyse_to_file(t),
<a name="1673"/> 1673:     {result,[],[{no_source_code_found,t}]} = cover:analyse_to_file([t]),
<a name="1674"/> 1674: 
<a name="1675"/> 1675:     ok = file:delete(&quot;t.coverdata&quot;),
<a name="1676"/> 1676:     ok = file:set_cwd(Cwd),
<a name="analyse_no_beam-last_expr"/><a name="1677"/> 1677:     ok.
<a name="1678"/> 1678: 
<a name="1679"/> 1679: <i>%% When including eunit.hrl, a parse transform adds the function</i>
<a name="1680"/> 1680: <i>%% test/0 to line 0 in your module. A bug in OTP-18.0 caused</i>
<a name="1681"/> 1681: <i>%% cover:analyse_to_file/1 to fail to insert cover data in the output</i>
<a name="1682"/> 1682: <i>%% file in this situation. The test below tests that this bug is</i>
<a name="1683"/> 1683: <i>%% corrected.</i>
<a name="line_0-1"/><a name="1684"/> 1684: <b>line_0</b>(Config) -&gt;
<a name="1685"/> 1685:     ok = file:set_cwd(filename:join(proplists:get_value(data_dir, Config),
<a name="1686"/> 1686:                                     &quot;include_eunit_hrl&quot;)),
<a name="1687"/> 1687:     {ok, cover_inc_eunit} = compile:file(cover_inc_eunit,[debug_info]),
<a name="1688"/> 1688:     {ok, cover_inc_eunit} = cover:compile_beam(cover_inc_eunit),
<a name="1689"/> 1689:     {ok, CovOut} = cover:analyse_to_file(cover_inc_eunit),
<a name="1690"/> 1690: 
<a name="1691"/> 1691:     {ok,Bin} = file:read_file(CovOut),
<a name="1692"/> 1692:     Match = &lt;&lt;&quot;0..|      ok.\n&quot;&gt;&gt;,  % &quot;0..&quot; is missing when bug is there
<a name="1693"/> 1693:     S = byte_size(Bin)-byte_size(Match),
<a name="1694"/> 1694:     &lt;&lt;_:S/binary,Match/binary&gt;&gt; = Bin,
<a name="line_0-last_expr"/><a name="1695"/> 1695:     ok.
<a name="1696"/> 1696: 
<a name="1697"/> 1697: 
<a name="1698"/> 1698: <i>%% OTP-13200: Return error instead of crashing when trying to compile</i>
<a name="1699"/> 1699: <i>%% a beam which has no 'file' attribute.</i>
<a name="compile_beam_no_file-1"/><a name="1700"/> 1700: <b>compile_beam_no_file</b>(Config) -&gt;
<a name="1701"/> 1701:     PrivDir = proplists:get_value(priv_dir,Config),
<a name="1702"/> 1702:     Dir = filename:join(PrivDir,&quot;compile_beam_no_file&quot;),
<a name="1703"/> 1703:     ok = filelib:ensure_dir(filename:join(Dir,&quot;*&quot;)),
<a name="1704"/> 1704:     code:add_patha(Dir),
<a name="1705"/> 1705:     Str = lists:concat(
<a name="1706"/> 1706:             [&quot;-module(nofile).\n&quot;
<a name="1707"/> 1707:              &quot;-compile(export_all).\n&quot;
<a name="1708"/> 1708:              &quot;foo() -&gt; ok.\n&quot;]),
<a name="1709"/> 1709:     TT = do_scan(Str),
<a name="1710"/> 1710:     Forms = [ begin {ok,Y} = erl_parse:parse_form(X),Y end || X &lt;- TT ],
<a name="1711"/> 1711:     {ok,_,Bin} = compile:forms(Forms,[debug_info]),
<a name="1712"/> 1712:     BeamFile = filename:join(Dir,&quot;nofile.beam&quot;),
<a name="1713"/> 1713:     ok = file:write_file(BeamFile,Bin),
<a name="1714"/> 1714:     {error,{no_file_attribute,BeamFile}} = cover:compile_beam(nofile),
<a name="1715"/> 1715:     [{error,{no_file_attribute,BeamFile}}] = cover:compile_beam_directory(Dir),
<a name="compile_beam_no_file-last_expr"/><a name="1716"/> 1716:     ok.
<a name="1717"/> 1717: 
<a name="1718"/> 1718: <i>%% GH-4353: Don't crash when the backend for generating the abstract code</i>
<a name="1719"/> 1719: <i>%% is missing.</i>
<a name="compile_beam_missing_backend-1"/><a name="1720"/> 1720: <b>compile_beam_missing_backend</b>(Config) -&gt;
<a name="1721"/> 1721:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="1722"/> 1722:     Dir = filename:join(PrivDir, ?FUNCTION_NAME),
<a name="1723"/> 1723:     ok = filelib:ensure_dir(filename:join(Dir, &quot;*&quot;)),
<a name="1724"/> 1724:     code:add_patha(Dir),
<a name="1725"/> 1725:     Str = lists:append(
<a name="1726"/> 1726:             [&quot;-module(no_backend).\n&quot;
<a name="1727"/> 1727:              &quot;-compile(export_all).\n&quot;
<a name="1728"/> 1728:              &quot;foo() -&gt; ok.\n&quot;]),
<a name="1729"/> 1729:     TT = do_scan(Str),
<a name="1730"/> 1730:     Forms = [ begin {ok,Y} = erl_parse:parse_form(X),Y end || X &lt;- TT ],
<a name="1731"/> 1731:     {ok,_,Bin} = compile:forms(Forms, [debug_info]),
<a name="1732"/> 1732: 
<a name="1733"/> 1733:     %% Create a debug_info chunk with a non-existing backend.
<a name="1734"/> 1734:     {ok,no_backend,All0} = beam_lib:all_chunks(Bin),
<a name="1735"/> 1735:     FakeBackend = definitely__not__an__existing__backend,
<a name="1736"/> 1736:     FakeDebugInfo = {debug_info_v1,FakeBackend,nothing_here},
<a name="1737"/> 1737:     All = lists:keyreplace(&quot;Dbgi&quot;, 1, All0, {&quot;Dbgi&quot;, term_to_binary(FakeDebugInfo)}),
<a name="1738"/> 1738:     {ok,NewBeam} = beam_lib:build_module(All),
<a name="1739"/> 1739:     BeamFile = filename:join(Dir, &quot;no_backend.beam&quot;),
<a name="1740"/> 1740:     ok = file:write_file(BeamFile, NewBeam),
<a name="1741"/> 1741: 
<a name="1742"/> 1742:     {error,{{missing_backend,FakeBackend},BeamFile}} = cover:compile_beam(no_backend),
<a name="1743"/> 1743:     [{error,{{missing_backend,FakeBackend},BeamFile}}] = cover:compile_beam_directory(Dir),
<a name="1744"/> 1744: 
<a name="compile_beam_missing_backend-last_expr"/><a name="1745"/> 1745:     ok.
<a name="1746"/> 1746: 
<a name="do_scan-1"/><a name="1747"/> 1747: <b>do_scan</b>([]) -&gt;
<a name="1748"/> 1748:     [];
<a name="1749"/> 1749: <b>do_scan</b>(Str) -&gt;
<a name="1750"/> 1750:     {done,{ok,T,_},C} = erl_scan:tokens([],Str,0),
<a name="do_scan-last_expr"/><a name="1751"/> 1751: <b>    [ T | do_scan</b>(C) ].
<a name="1752"/> 1752: 
<a name="1753"/> 1753: 
<a name="1754"/> 1754: <i>%% PR 856. Fix a bc bug.</i>
<a name="otp_13277-1"/><a name="1755"/> 1755: <b>otp_13277</b>(Config) -&gt;
<a name="1756"/> 1756:     Test = &lt;&lt;&quot;-module(t).
<a name="1757"/> 1757:               -export([t/0]).
<a name="1758"/> 1758: 
<a name="1759"/> 1759:               pad(A, L) -&gt;
<a name="1760"/> 1760:                   P = &lt;&lt; &lt;&lt;\&quot;#\&quot;&gt;&gt; || _ &lt;- lists:seq(1, L) &gt;&gt;,
<a name="1761"/> 1761:                   &lt;&lt;A/binary, P/binary&gt;&gt;.
<a name="1762"/> 1762: 
<a name="1763"/> 1763:               t() -&gt;
<a name="1764"/> 1764:                   pad(&lt;&lt;\&quot;hi\&quot;&gt;&gt;, 2).
<a name="1765"/> 1765:              &quot;&gt;&gt;,
<a name="1766"/> 1766:     File = cc_mod(t, Test, Config),
<a name="1767"/> 1767:     &lt;&lt;&quot;hi##&quot;&gt;&gt; = t:t(),
<a name="1768"/> 1768:     ok = file:delete(File),
<a name="otp_13277-last_expr"/><a name="1769"/> 1769:     ok.
<a name="1770"/> 1770: 
<a name="1771"/> 1771: <i>%% Test general expressions in a binary comprehension.</i>
<a name="otp_13289-1"/><a name="1772"/> 1772: <b>otp_13289</b>(Config) -&gt;
<a name="1773"/> 1773:     Test = &lt;&lt;&quot;-module(t).
<a name="1774"/> 1774:               -export([t/0]).
<a name="1775"/> 1775: 
<a name="1776"/> 1776:               t() -&gt;
<a name="1777"/> 1777:                   &lt;&lt; (id(&lt;&lt;I&gt;&gt;)) || I &lt;- [1,2,3] &gt;&gt;.
<a name="1778"/> 1778: 
<a name="1779"/> 1779:               id(I) -&gt; I.
<a name="1780"/> 1780:              &quot;&gt;&gt;,
<a name="1781"/> 1781:     File = cc_mod(t, Test, Config),
<a name="1782"/> 1782:     &lt;&lt;1,2,3&gt;&gt; = t:t(),
<a name="1783"/> 1783:     ok = file:delete(File),
<a name="otp_13289-last_expr"/><a name="1784"/> 1784:     ok.
<a name="1785"/> 1785: 
<a name="guard_in_lc-1"/><a name="1786"/> 1786: <b>guard_in_lc</b>(Config) -&gt;
<a name="1787"/> 1787:     Test = &lt;&lt;&quot;-module(t).
<a name="1788"/> 1788:               -export([lc/1]).
<a name="1789"/> 1789: 
<a name="1790"/> 1790:               lc(L) -&gt;
<a name="1791"/> 1791:                   [V || V &lt;- L, V == a orelse element(1, V) == a].
<a name="1792"/> 1792:              &quot;&gt;&gt;,
<a name="1793"/> 1793: 
<a name="1794"/> 1794:     %% The filter in the list comprehension must be compiled as a
<a name="1795"/> 1795:     %% guard expression. Therefore, `cover` must NOT rewrite the list
<a name="1796"/> 1796:     %% comprehension in the test code like this:
<a name="1797"/> 1797:     %%
<a name="1798"/> 1798:     %% [V || V &lt;- L,
<a name="1799"/> 1799:     %%       case V == a of
<a name="1800"/> 1800:     %%           true -&gt; true;
<a name="1801"/> 1801:     %%           false -&gt; element(1, V) == a
<a name="1802"/> 1802:     %%       end].
<a name="1803"/> 1803: 
<a name="1804"/> 1804:     File = cc_mod(t, Test, Config),
<a name="1805"/> 1805:     [a,{a,good}] = t:lc([a, b, {x,y}, {a,good}, &quot;ignore&quot;]),
<a name="1806"/> 1806:     ok = file:delete(File),
<a name="guard_in_lc-last_expr"/><a name="1807"/> 1807:     ok.
<a name="1808"/> 1808: 
<a name="local_only-1"/><a name="1809"/> 1809: <b>local_only</b>(Config) -&gt;
<a name="1810"/> 1810:     ok = file:set_cwd(proplists:get_value(data_dir, Config)),
<a name="1811"/> 1811: 
<a name="1812"/> 1812:     %% Trying restricting to local nodes too late.
<a name="1813"/> 1813:     cover:start(),
<a name="1814"/> 1814:     {ok,a} = cover:compile(a),
<a name="1815"/> 1815:     [a] = cover:modules(),
<a name="1816"/> 1816:     {error,too_late} = cover:local_only(),
<a name="1817"/> 1817:     cover:stop(),
<a name="1818"/> 1818: 
<a name="1819"/> 1819:     %% Now test local only mode.
<a name="1820"/> 1820:     cover:start(),
<a name="1821"/> 1821:     ok = cover:local_only(),
<a name="1822"/> 1822:     [] = cover:modules(),
<a name="1823"/> 1823:     {ok,a} = cover:compile(a),
<a name="1824"/> 1824:     [a] = cover:modules(),
<a name="1825"/> 1825:     done = a:start(5),
<a name="1826"/> 1826:     {ok, {a,{17,2}}} = cover:analyse(a, coverage, module),
<a name="1827"/> 1827:     {ok, [{{a,exit_kalle,0},{1,0}},
<a name="1828"/> 1828:           {{a,loop,3},{5,1}},
<a name="1829"/> 1829:           {{a,pong,1},{1,0}},
<a name="1830"/> 1830:           {{a,start,1},{6,0}},
<a name="1831"/> 1831:           {{a,stop,1},{0,1}},
<a name="1832"/> 1832:           {{a,trycatch,1},{4,0}}]} =
<a name="1833"/> 1833:         cover:analyse(a, coverage, function),
<a name="1834"/> 1834: 
<a name="1835"/> 1835:     %% Make sure that it is not possible to run cover on
<a name="1836"/> 1836:     %% slave nodes.
<a name="1837"/> 1837:     {ok,Peer,Name} = ?CT_PEER(),
<a name="1838"/> 1838:     {error,local_only} = cover:start([Name]),
<a name="1839"/> 1839:     peer:stop(Peer),
<a name="local_only-last_expr"/><a name="1840"/> 1840:     ok.
<a name="1841"/> 1841: 
<a name="1842"/> 1842: <i>%% ERL-943; We should not crash on startup when multiple servers race to</i>
<a name="1843"/> 1843: <i>%% register the server name.</i>
<a name="startup_race-1"/><a name="1844"/> 1844: <b>startup_race</b>(Config) when is_list(Config) -&gt;
<a name="1845"/> 1845:     PidRefs = [spawn_monitor(fun() -&gt;
<a name="1846"/> 1846:                                      case cover:start() of
<a name="1847"/> 1847:                                          {error, {already_started, _Pid}} -&gt;
<a name="1848"/> 1848:                                              ok;
<a name="1849"/> 1849:                                          {ok, _Pid} -&gt;
<a name="1850"/> 1850:                                              ok
<a name="1851"/> 1851:                                      end
<a name="1852"/> 1852:                              end) || _&lt;- lists:seq(1,8)],
<a name="startup_race-last_expr"/><a name="1853"/> 1853: <b>    startup_race_1</b>(PidRefs).
<a name="1854"/> 1854: 
<a name="startup_race_1-1"/><a name="1855"/> 1855: <b>startup_race_1</b>([{Pid, Ref} | PidRefs]) -&gt;
<a name="1856"/> 1856:     receive
<a name="1857"/> 1857:         {'DOWN', Ref, process, Pid, normal} -&gt;
<a name="1858"/> 1858:             startup_race_1(PidRefs);
<a name="1859"/> 1859:         {'DOWN', Ref, process, Pid, _Other} -&gt;
<a name="1860"/> 1860:             ct:fail(&quot;Cover server crashed on startup.&quot;)
<a name="1861"/> 1861:     after 5000 -&gt;
<a name="1862"/> 1862:             ct:fail(&quot;Timed out.&quot;)
<a name="1863"/> 1863:     end;
<a name="1864"/> 1864: <b>startup_race_1</b>([]) -&gt;
<a name="1865"/> 1865:     cover:stop(),
<a name="startup_race_1-last_expr"/><a name="1866"/> 1866:     ok.
<a name="1867"/> 1867: 
<a name="otp_16476-1"/><a name="1868"/> 1868: <b>otp_16476</b>(Config) when is_list(Config) -&gt;
<a name="1869"/> 1869:     Mod = obvious_booleans,
<a name="1870"/> 1870:     Dir = filename:join(proplists:get_value(data_dir, Config),
<a name="1871"/> 1871:                         ?FUNCTION_NAME),
<a name="1872"/> 1872:     ok = file:set_cwd(Dir),
<a name="1873"/> 1873:     {ok, Mod} = compile:file(Mod, [debug_info]),
<a name="1874"/> 1874:     {ok, Mod} = cover:compile(Mod),
<a name="1875"/> 1875:     ok = Mod:Mod(),
<a name="1876"/> 1876:     ok = cover:stop(),
<a name="otp_16476-last_expr"/><a name="1877"/> 1877:     ok.
<a name="1878"/> 1878: 
<a name="1879"/> 1879: <i>%% GH-4796: failure to preserve tuple_calls compiler option</i>
<a name="gh_4796-1"/><a name="1880"/> 1880: <b>gh_4796</b>(Config) -&gt;
<a name="1881"/> 1881:     Test = &lt;&lt;&quot;-module(gh_4796).
<a name="1882"/> 1882:               -export([test/0, foo/1]).
<a name="1883"/> 1883: 
<a name="1884"/> 1884:               test() -&gt;
<a name="1885"/> 1885:                   PMod = new(42),
<a name="1886"/> 1886:                   PMod:foo().
<a name="1887"/> 1887: 
<a name="1888"/> 1888:               new(X) -&gt; {?MODULE, X}.
<a name="1889"/> 1889: 
<a name="1890"/> 1890:               foo({?MODULE, 42}) -&gt; ok.
<a name="1891"/> 1891:               &quot;&gt;&gt;,
<a name="1892"/> 1892:     File = c_mod(gh_4796, Test, Config, [tuple_calls]),
<a name="1893"/> 1893:     {ok, gh_4796} = cover:compile_beam(gh_4796),
<a name="1894"/> 1894:     ok = file:delete(File),
<a name="gh_4796-last_expr"/><a name="1895"/> 1895: <b>    ok = gh_4796:test</b>().
<a name="1896"/> 1896: 
<a name="1897"/> 1897: <i>%% Test the maybe ... else ... end construct.</i>
<a name="eep49-1"/><a name="1898"/> 1898: <b>eep49</b>(Config) -&gt;
<a name="1899"/> 1899:         ok = file:set_cwd(proplists:get_value(priv_dir, Config)),
<a name="1900"/> 1900: 
<a name="1901"/> 1901:     File = &quot;t.erl&quot;,
<a name="1902"/> 1902:     Test = &lt;&lt;&quot;-module(t).
<a name="1903"/> 1903:               -feature(maybe_expr,enable).
<a name="1904"/> 1904:               -export([t/0]).
<a name="1905"/> 1905: 
<a name="1906"/> 1906:               t() -&gt;
<a name="1907"/> 1907:                   t1(),                         %6
<a name="1908"/> 1908: 
<a name="1909"/> 1909:                   {a,b} = t2({ok,a}, {ok,b}),   %8
<a name="1910"/> 1910:                   error = t2({ok,a}, error),    %9
<a name="1911"/> 1911:                   whatever = t2(whatever, thing), %10
<a name="1912"/> 1912: 
<a name="1913"/> 1913:                   {a,b} = t3({ok,a}, {ok,b}),   %12
<a name="1914"/> 1914:                   error = t3({ok,a}, {error,wrong}), %13
<a name="1915"/> 1915:                   {'EXIT',{{else_clause,whatever},_}} = catch t3(whatever, thing), %14
<a name="1916"/> 1916: 
<a name="1917"/> 1917:                   ok.                           %16
<a name="1918"/> 1918: 
<a name="1919"/> 1919:               t1() -&gt;
<a name="1920"/> 1920:                   maybe                         %19
<a name="1921"/> 1921:                        ok                       %20
<a name="1922"/> 1922:                   end.
<a name="1923"/> 1923: 
<a name="1924"/> 1924:               t2(X, Y) -&gt;
<a name="1925"/> 1925:                   maybe                         %24
<a name="1926"/> 1926:                       {ok,A} ?= X,              %25
<a name="1927"/> 1927:                       {ok,B} ?= Y,              %26
<a name="1928"/> 1928:                       {A,B}                     %27
<a name="1929"/> 1929:                   end.
<a name="1930"/> 1930: 
<a name="1931"/> 1931:               t3(X, Y) -&gt;
<a name="1932"/> 1932:                   maybe                         %31
<a name="1933"/> 1933:                       {ok,A} ?= X,              %32
<a name="1934"/> 1934:                       {ok,B} ?= Y,              %33
<a name="1935"/> 1935:                       {A,B}                     %34
<a name="1936"/> 1936:                   else
<a name="1937"/> 1937:                       {error,_} -&gt;
<a name="1938"/> 1938:                           error                 %37
<a name="1939"/> 1939:                   end.
<a name="1940"/> 1940:              &quot;&gt;&gt;,
<a name="1941"/> 1941:     ok = file:write_file(File, Test),
<a name="1942"/> 1942:     {ok, t} = cover:compile(File),
<a name="1943"/> 1943:     ok = t:t(),
<a name="1944"/> 1944:     {ok,[{{t,6},1}, {{t,8},1}, {{t,9},1}, {{t,10},1}, {{t,12},1},
<a name="1945"/> 1945:          {{t,13},1}, {{t,14},1}, {{t,16},1},
<a name="1946"/> 1946:          {{t,19},1}, {{t,20},1},
<a name="1947"/> 1947:          {{t,24},3}, {{t,25},3}, {{t,26},2}, {{t,27},1},
<a name="1948"/> 1948:          {{t,31},3}, {{t,32},3}, {{t,33},2}, {{t,34},1}, {{t,37},1}
<a name="1949"/> 1949:         ]} = cover:analyse(t, calls, line),
<a name="1950"/> 1950:     ok = file:delete(File),
<a name="eep49-last_expr"/><a name="1951"/> 1951:     ok.
<a name="1952"/> 1952: 
<a name="1953"/> 1953: 
<a name="1954"/> 1954: <i>%%--Auxiliary------------------------------------------------------------</i>
<a name="1955"/> 1955: 
<a name="analyse_expr-2"/><a name="1956"/> 1956: <b>analyse_expr</b>(Expr, Config) -&gt;
<a name="1957"/> 1957:     Binary = [&lt;&lt;&quot;-module(t). &quot;
<a name="1958"/> 1958:                 &quot;-export([t/0]). &quot;
<a name="1959"/> 1959:                 &quot;t() -&gt; &quot;&gt;&gt;, Expr, &lt;&lt;&quot;.\n&quot;&gt;&gt;],
<a name="1960"/> 1960:     File = cc_mod(t, Binary, Config),
<a name="1961"/> 1961:     t:t(),
<a name="1962"/> 1962:     {ok, Result} = cover:analyse(t, calls, line),
<a name="1963"/> 1963:     ok = file:delete(File),
<a name="analyse_expr-last_expr"/><a name="1964"/> 1964:     Result.
<a name="1965"/> 1965: 
<a name="cc_mod-3"/><a name="1966"/> 1966: <b>cc_mod</b>(M, Binary, Config) -&gt;
<a name="1967"/> 1967:     {ok, Dir} = file:get_cwd(),
<a name="1968"/> 1968:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="1969"/> 1969:     ok = file:set_cwd(PrivDir),
<a name="1970"/> 1970:     File = atom_to_list(M) ++ &quot;.erl&quot;,
<a name="cc_mod-last_expr"/><a name="1971"/> 1971:     try 
<a name="1972"/> 1972:         ok = file:write_file(File, Binary),
<a name="1973"/> 1973:         {ok, M} = cover:compile(File),
<a name="1974"/> 1974:         filename:join(PrivDir, File)
<a name="1975"/> 1975:     after file:set_cwd(Dir)
<a name="1976"/> 1976:     end.
<a name="1977"/> 1977: 
<a name="c_mod-3"/><a name="1978"/> 1978: <b>c_mod</b>(M, Binary, Config) -&gt;
<a name="c_mod-last_expr"/><a name="1979"/> 1979: <b>    c_mod</b>(M, Binary, Config, _CompileOpts = []).
<a name="1980"/> 1980: 
<a name="c_mod-4"/><a name="1981"/> 1981: <b>c_mod</b>(M, Binary, Config, CompileOpts) -&gt;
<a name="1982"/> 1982:     {ok, Dir} = file:get_cwd(),
<a name="1983"/> 1983:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="1984"/> 1984:     ok = file:set_cwd(PrivDir),
<a name="1985"/> 1985:     File = atom_to_list(M) ++ &quot;.erl&quot;,
<a name="c_mod-last_expr"/><a name="1986"/> 1986:     try 
<a name="1987"/> 1987:         ok = file:write_file(File, Binary),
<a name="1988"/> 1988:         {ok, M} = compile:file(File, CompileOpts ++ [debug_info]),
<a name="1989"/> 1989:         code:purge(M),
<a name="1990"/> 1990:         AbsFile = filename:rootname(File, &quot;.erl&quot;),
<a name="1991"/> 1991:         code:load_abs(AbsFile, M),
<a name="1992"/> 1992:         filename:join(PrivDir, File)
<a name="1993"/> 1993:     after file:set_cwd(Dir)
<a name="1994"/> 1994:     end.
<a name="1995"/> 1995: 
<a name="lsfiles-0"/><a name="1996"/> 1996: <b>lsfiles</b>() -&gt;
<a name="1997"/> 1997:     {ok, CWD} = file:get_cwd(),
<a name="lsfiles-last_expr"/><a name="1998"/> 1998: <b>    lsfiles</b>(CWD).
<a name="1999"/> 1999: 
<a name="lsfiles-1"/><a name="2000"/> 2000: <b>lsfiles</b>(Dir) -&gt;
<a name="2001"/> 2001:     {ok, Files} = file:list_dir(Dir),
<a name="lsfiles-last_expr"/><a name="2002"/> 2002:     Files.
<a name="2003"/> 2003: 
<a name="files-2"/><a name="2004"/> 2004: <b>files</b>(Files, Ext) -&gt;
<a name="files-last_expr"/><a name="2005"/> 2005: <b>    lists:filter</b>(fun(File) -&gt;
<a name="2006"/> 2006:                          case filename:extension(File) of
<a name="2007"/> 2007:                              Ext -&gt; true;
<a name="2008"/> 2008:                              _ -&gt; false
<a name="2009"/> 2009:                          end
<a name="2010"/> 2010:                  end,
<a name="2011"/> 2011:                  Files).
<a name="2012"/> 2012: 
<a name="remove-1"/><a name="2013"/> 2013: <b>remove</b>([File|Files]) -&gt;
<a name="2014"/> 2014:     ok = file:delete(File),
<a name="2015"/> 2015:     remove(Files);
<a name="2016"/> 2016: <b>remove</b>([]) -&gt;
<a name="remove-last_expr"/><a name="2017"/> 2017:     ok.
<a name="2018"/> 2018: 
<a name="decompile-1"/><a name="2019"/> 2019: <b>decompile</b>([Mod|Mods]) -&gt;
<a name="2020"/> 2020:     code:purge(Mod),
<a name="2021"/> 2021:     code:delete(Mod),
<a name="2022"/> 2022:     decompile(Mods);
<a name="2023"/> 2023: <b>decompile</b>([]) -&gt;
<a name="decompile-last_expr"/><a name="2024"/> 2024:     ok.
<a name="2025"/> 2025: 
<a name="is_unloaded-1"/><a name="2026"/> 2026: <b>is_unloaded</b>(What) -&gt;
<a name="is_unloaded-last_expr"/><a name="2027"/> 2027:     if
<a name="2028"/> 2028:         is_list(What) -&gt; true;
<a name="2029"/> 2029:         What==non_existing -&gt; true;
<a name="2030"/> 2030:         true -&gt; false
<a name="2031"/> 2031:     end.
<a name="2032"/> 2032: 
<a name="check_f_calls-2"/><a name="2033"/> 2033: <b>check_f_calls</b>(F1,F2) -&gt;
<a name="2034"/> 2034:     {ok,A} = cover:analyse(f,calls,function),
<a name="2035"/> 2035:     {_,F1} = lists:keyfind({f,f1,0},1,A),
<a name="check_f_calls-last_expr"/><a name="2036"/> 2036: <b>    {_,F2} = lists:keyfind</b>({f,f2,0},1,A).
<a name="2037"/> 2037: 
<a name="cover_which_nodes-1"/><a name="2038"/> 2038: <b>cover_which_nodes</b>(Expected) -&gt;
<a name="cover_which_nodes-last_expr"/><a name="2039"/> 2039: <b>    case cover:which_nodes</b>() of
<a name="2040"/> 2040:         Expected -&gt;
<a name="2041"/> 2041:             ok;
<a name="2042"/> 2042:         Other -&gt;
<a name="2043"/> 2043:             {Time,ok} = timer:tc(fun Retry() -&gt;
<a name="2044"/> 2044:                                          case cover:which_nodes() of
<a name="2045"/> 2045:                                              Expected -&gt; ok;
<a name="2046"/> 2046:                                              _ -&gt;
<a name="2047"/> 2047:                                                  timer:sleep(100),
<a name="2048"/> 2048:                                                  Retry()
<a name="2049"/> 2049:                                          end
<a name="2050"/> 2050:     end),
<a name="2051"/> 2051:             io:format(&quot;~p ms before cover:which_nodes() returned ~p&quot;,
<a name="2052"/> 2052:                       [Time,Expected]),
<a name="2053"/> 2053:             Expected = Other
<a name="2054"/> 2054:     end.
</pre>
</body>
</html>
