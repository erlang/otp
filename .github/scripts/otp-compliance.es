#!/usr/bin/env escript
%% -*- erlang -*-

%% SPDX-License-Identifier: Apache-2.0
%% SPDX-FileCopyrightText: 2024 Erlang/OTP and its contributors

%% Tool to generate fixes to the OTP SPDX file produced by ORT,
%% and tests to verify that given the scan-results generated by
%% ORT and the OTP SPDX, the OTP SPDX is compliant with SPDX 2.2
%%
%% Notice that ORT produces correct SPDX 2.2, this Erlang/OTP SPDX
%% needs to be futher split into packages. this need comes from users
%% wanting to opt-out of some applications, and also to keep track
%% of which packages are vendor packages/files.
%%
%% Because of this need, it is easy to break the correct SPDX
%% simply by, e.g., adding a package name that contains underscores.
%% To prevent from these issues, we have a test option that checks
%% (to some degree) that the SPDX generate is correct.
%%
%% After this validation, users of this script should still run
%% other validator tools, such as, ntia-conformance-checker.
%%

-include_lib("kernel/include/file.hrl").

-define(default_classified_result, "scan-result-classified.json").
-define(default_scan_result, "scan-result.json").
-define(diff_classified_result, "scan-result-diff.json").
-define(erlang_license, ~"Apache-2.0").
-define(spdxref_project_name, ~"SPDXRef-Project-OTP").
-define(spdx_project_name, ~"Erlang/OTP").
-define(spdx_creators_tooling, ~"Tool: otp_compliance").
-define(spdx_supplier, ~"Organization: Ericsson AB").
-define(spdx_download_location, ~"https://github.com/erlang/otp/releases").
-define(spdx_homepage, ~"https://www.erlang.org").
-define(spdx_version, ~"SPDX-2.2").
-define(spdx_project_purl, #{ ~"comment" => ~"",
                              ~"referenceCategory" => ~"PACKAGE-MANAGER",
                              ~"referenceLocator" => ~"pkg:github/erlang/otp",
                              ~"referenceType" => ~"purl"}).


%% Add more relations if necessary.
-type spdx_relations() :: #{ 'DOCUMENTATION_OF' => [],
                             'CONTAINS' => [],
                             'TEST_OF' => [],
                             'PACKAGE_OF' => []}.

-record(spdx_package, {'SPDXID'           :: unicode:chardata(),
                       'versionInfo'      :: unicode:chardata(),
                       'description'      :: unicode:chardata(),
                       'name'             :: unicode:chardata(),
                       'copyrightText'    :: unicode:chardata(),
                       'filesAnalyzed'    = false :: boolean(),
                       'hasFiles'         = [] :: [unicode:chardata()],
                       'purl'             = false :: false | unicode:chardata(),
                       'homepage'         :: unicode:chardata(),
                       'licenseConcluded' :: unicode:chardata(),
                       'licenseDeclared'  :: unicode:chardata(),
                       'licenseInfoFromFiles' = [] :: [unicode:chardata()],
                       'downloadLocation' = ~"https://github.com/erlang/otp/releases" :: unicode:chardata(),
                       'packageVerificationCode' :: #{ 'packageVerificationCodeValue' => unicode:chardata()},
                       'supplier' = ~"Organization: Ericsson AB" :: unicode:chardata(),
                       'relationships' = #{ 'DOCUMENTATION_OF' => [],
                                            'CONTAINS' => [],
                                            'TEST_OF' => [],
                                            'PACKAGE_OF' => []} :: spdx_relations()
                      }).
-type spdx_package() :: #spdx_package{}.

-record(app_info, { description  :: unicode:chardata(),
                    id           :: unicode:chardata(),
                    vsn          :: unicode:chardata(),

                    %% modules can only be included in one app.
                    %% not_loaded indicates a special handling of this module, e.g., erts.
                    modules      :: [atom()] | not_loaded,
                    applications :: [atom()],
                    included_applications :: [atom()],
                    optional_applications :: [atom()] }).

-type app_info() :: #app_info{}.

%%
%% Commands
%%
%% sbom
%%
%%    otp-info: given an oss-review-toolkit (ORT) scan result and a
%%              source SBOM, it populates the fields that ORT can't
%%              in Unmanaged projects.
%%
%% compliance   useful for CI/CD compliance checks.
%%
%%    detect:   given a scan-result from ORT, it detects files without license
%%              and writes them into disk.
%%
%%    check:    given a recent scan-result from ORT (possibly from PR), and an
%%              existing file with known files without licenses (from prev. commit),
%%              calculate if new files without licenses have been added to the repo.
%%
%% explore
%%
%%    classify: takes as input a scan of ort and returns a json file containing
%%              as keys the licenses and as values the files under those licenses.
%%
%%    diff:     performs a diff of existing classification file against
%%              other classification files. this is useful to guarantee that
%%              files that had license X had not unexpectedly been reported differently.
%%

%%
%% USE OF COMMANDS
%%
%% The commands `classify` and `diff` are useful for exploring the licenses.
%% ORT does not report in an easy way which files have been attached to which licenses,
%% unless one generates a report. At the time, we cannot generate an SBOM,
%% so we are in the dark.
%%
%% The commands `detect` and `check` can be used in CI/CD to
%% prevent entering new files with unknown license. In the normal case,
%% the `detect` command only needs to be issued once in the repo.
%% Once we keep track of this file, the command is not needed anymore,
%% as the list of files with no license should not grow, and only
%% the `check` command should be executed in the CI/CD.
%%
%%

main(Args) ->
    argparse:run(Args, cli(), #{progname => otp_compliance}).

cli() ->
    #{ commands =>
           #{"sbom" =>
                 #{ help => """
                            Contains useful commands to fix an ORT generated source SBOM.

                            """,
                   commands =>
                        #{"otp-info" =>
                              #{ help =>
                                     """
                                     Adds information missing in ORT's Erlang/OTP source SBOM
                                       - Add homepage
                                       - Fixes license of `*.beam` files
                                       - Fixes project name

                                     """,
                                 arguments => [ sbom_option(),
                                                write_to_file_option(),
                                                input_option() ],
                                 handler => fun sbom_otp/1},

                          "test-file" =>
                              #{ help => "Run unit tests",
                                 arguments => [ sbom_option() ],
                                 handler => fun test_file/1},

                          "remove-packages" =>
                              #{ help => "Remove the given packages from an OTP source SBOM",
                                 arguments => [ sbom_option(),
                                                input_option("removed.json")],
                                 handler => fun sbom_package_removal/1}
                         }},
             "explore" =>
                 #{  help => """
                            Explore license data.
                            Useful to figure out the mapping files-to-licenses.

                            """,
                    commands =>
                        #{"classify-license" =>
                              #{ help =>
                                     """
                                     Classify files by their license group.
                                       - Input file expects a scan-result from ORT.
                                       - Output file shows mapping between licenses and files.
                                         The output file can be fed to the `explore diff` command.

                                     """,
                                 arguments => [ input_option(?default_scan_result),
                                                output_option(?default_classified_result),
                                                apply_excludes(),
                                                apply_curations() ],
                                 handler => fun classify_license/1},
                          "classify-license-copyright" =>
                              #{ help =>
                                     """
                                     Pair files with their copyright and license.
                                     Depends on a `scan-result.json` and the output of the `classify-license`.

                                     """,
                                 arguments => [ input_option(?default_scan_result),
                                                base_file(?default_classified_result),
                                                output_option() ],
                                 handler => fun classify_path_license_copyright/1},

                          "diff" =>
                              #{ help =>
                                     """
                                     Compare against previous license results.
                                       - Input file should be the output of the `classify` command for input and base files.
                                       - Output returns a summary of additions and deletions per license.

                                     """,
                                 arguments => [ input_option(?default_classified_result),
                                                base_file(),
                                                output_option(?diff_classified_result) ],
                                 handler => fun diff/1}
                         }
                  },
             "compliance" =>
                 #{ help => """
                            Commands to enforce compliance policy towards unlicensed files.

                            """,
                    commands =>
                        #{"detect" =>
                              #{ help =>
                                     """
                                     Detects unlicensed files.
                                     - Input file expects a scan-result from ORT.
                                     - Output file is a list of files without license.
                                       The output file can be fed to the `compliance check` command.

                                     """,
                                 arguments => [ input_option(?default_scan_result),
                                                output_option(),
                                                apply_excludes() ],
                                 handler => fun detect_no_license/1},
                          "check" =>
                              #{ help =>
                                     """
                                     Checks that no new unlicensed files have been added.
                                     - Input file expects scan-result from ORT.
                                     - Base file expects output file from `no_license` command.

                                     """,
                                 arguments => [ input_option(?default_scan_result),
                                                base_file(),
                                                apply_excludes(),
                                                output_option() ],
                                 handler => fun check_no_license/1}}}}}.

%%
%% Options
%%
input_option() ->
    #{name => input_file,
      type => binary,
      long => "-input-file"}.


input_option(Default) ->
    (input_option())#{default => Default}.

sbom_option() ->
    #{name => sbom_file,
      type => binary,
      default => "bom.spdx.json",
      long => "-sbom-file"}.

write_to_file_option() ->
    #{name => write_to_file,
      type => binary,
      default => true,
      long => "-write_to_file"}.

output_option(Default) ->
    #{name => output_file,
      type => binary,
      default => Default,
      long => "-output-file"}.

output_option() ->
    #{name => output_file,
      type => binary,
      required => true,
      long => "-output-file"}.

apply_excludes() ->
    #{name => exclude,
      type => boolean,
      short => $e,
      default => true,
      long => "-apply-excludes"}.

apply_curations() ->
    #{name => curations,
      type => boolean,
      short => $c,
      default => true,
      long => "-apply-curations"}.

base_file() ->
    #{name => base_file,
      type => binary,
      long => "-base-file"}.
base_file(DefaultFile) ->
    #{name => base_file,
      type => binary,
      default => DefaultFile,
      long => "-base-file"}.


%%
%% Commands
%%

sbom_otp(#{sbom_file  := SbomFile, write_to_file := Write, input_file := Input}) ->
    Sbom = decode(SbomFile),
    ScanResults = decode(Input),
    Spdx = improve_sbom_with_info(Sbom, ScanResults),
    case Write of
        true ->
            file:write_file(SbomFile, json:format(Spdx));
            %% Should we not overwritte the given file?
            %% file:write_file("otp.spdx.json", json:format(Spdx));
        false ->
            {ok, Spdx}
    end.

improve_sbom_with_info(Sbom, ScanResults) ->
    {Licenses, Copyrights} = fetch_license_copyrights(ScanResults),
    Spdx = generate_spdx_fixes(Sbom, Licenses, Copyrights),
    generate_snippet_fixes(Spdx, ScanResults).


fetch_license_copyrights(Input) ->
    {path_to_license(Input), path_to_copyright(Input)}.

-spec generate_spdx_fixes(Json :: map(), Licenses :: map(), Copyrights :: map()) -> Result :: map().
generate_spdx_fixes(Input, Licenses, Copyrights) ->
    FixFuns = sbom_fixing_functions(Licenses, Copyrights),
    Spdx = lists:foldl(fun ({Fun, Data}, Acc) -> Fun(Data, Acc) end, Input, FixFuns),
    package_by_app(Spdx).

%% this function has a hard dependency to ScanResults.
%% ScanResults has license results on a per line found basis.
%% Spdx result builds using ScanResult and loses this information.
generate_snippet_fixes(Spdx, ScanResults) ->
    Licenses = licenses(scan_results(ScanResults)),
    %% We identify the known copied snippet
    [Snippet] = lists:filter(fun(#{~"location" := #{~"path" := Path}, ~"license" := License}) ->
                                    case {License, Path} of
                                        {~"Apache-2.0 WITH LLVM-exception AND BSL-1.0", ~"erts/emulator/ryu/d2s.c"} ->
                                            true;
                                        _ ->
                                            false
                                    end
                            end, Licenses),
    Snippets = generate_snippet(Spdx, [Snippet]),
    Spdx#{ ~"snippets" => Snippets }.

%% we are doing the assumption that we only have one known snippet.
generate_snippet(#{~"files" := Files}=_Spdx, [#{~"location" := #{~"path" := ~"erts/emulator/ryu/d2s.c"=Path}, ~"license" := License}]) ->
    [#{~"SPDXID" := SpdxId}=SpdxFile] = lists:filter(fun (#{~"fileName" := FileName}) -> FileName == Path end, Files),

    %% read file to find snippet byte range and lines
    {ok, Content} = file:read_file(Path),
    #{~"begin_byte" := StartOffsetBytes, ~"end_byte" := EndOffsetBytes,
      ~"start_line" := StartLine,        ~"end_line" := EndLine} = get_snippet_range(Content),

    [#{ ~"SPDXID" => ~"SPDXRef-Snippet-STL",
        ~"comment" => ~"""
                       vendor package.
                       This is inspired from the MS STL Charconv, under Apache with LLVM exception licence see https://github.com/microsoft/STL/blob/main/LICENSE.txt
                       The inspiration is at https://github.com/microsoft/STL/blob/e745bad3b1d05b5b19ec652d68abb37865ffa454/stl/inc/xcharconv_ryu.h#L1926
                       Changes are described in the file.
                       """,
        ~"copyrightText" => maps:get(~"copyrightText", SpdxFile),
        ~"licenseConcluded" => ~"Apache-2.0 WITH LLVM-exception AND BSL-1.0",
        ~"licenseInfoInSnippets" => split_licenses_in_individual_parts([License]),
        ~"name" => ~"stl",
        ~"ranges" => [ #{~"endPointer" => #{ ~"lineNumber" => EndLine, ~"reference" => SpdxId},
                         ~"startPointer" => #{ ~"lineNumber" => StartLine, ~"reference" => SpdxId}},
                       #{~"endPointer" => #{ ~"offset" => EndOffsetBytes, ~"reference" => SpdxId},
                         ~"startPointer" => #{ ~"offset" => StartOffsetBytes, ~"reference" => SpdxId}} ],
        ~"snippetFromFile" => SpdxId
      }].

%% assumes that there is only one snippet in the whole file.
-spec get_snippet_range(Content :: binary()) -> map().
get_snippet_range(Content) ->
    get_snippet_range(Content, {<<>>, 1}).
get_snippet_range(<<"\n", Rest/binary>>, {Acc, Lines}) ->
    get_snippet_range(Rest, {<<"\n", Acc/binary>>, Lines+1});
get_snippet_range(<<"// SPDX-SnippetBegin", Rest/binary>>, {Content, Line}) ->
    {BeginContent, StartLine} = {Content, Line},
    {EndContent, EndLine} = get_snippet_range(Rest, {<<"// SPDX-SnippetBegin", Content/binary>>, Line+1}),
    #{~"begin_byte" => byte_size(BeginContent),
      ~"end_byte" => byte_size(EndContent),
      ~"start_line" => StartLine,
      ~"end_line" => EndLine};
get_snippet_range(<<"// SPDX-SnippetEnd", _Rest/binary>>, {Content, Line}) ->
    {Content, Line};
get_snippet_range(<<C, Rest/binary>>, {Content, Line}) ->
    get_snippet_range(Rest, {<<C, Content/binary>>, Line}).

sbom_fixing_functions(Licenses, Copyrights) ->
    [{fun fix_project_name/2, ?spdxref_project_name},
     {fun fix_name/2, ?spdx_project_name},
     {fun fix_creators_tooling/2, ?spdx_creators_tooling},
     {fun fix_supplier/2, ?spdx_supplier},
     {fun fix_download_location/2, ?spdx_download_location},
     {fun fix_project_package_license/2, {Licenses, Copyrights}},
     {fun fix_project_package_version/2, 'OTP_VERSION'},
     {fun fix_has_extracted_license_info/2, extracted_license_info()},
     {fun fix_project_purl/2, ?spdx_project_purl},
     {fun fix_beam_licenses/2, {Licenses, Copyrights}} ].

fix_project_name(ProjectName, #{ ~"documentDescribes" := [ ProjectName0 ],
                                 ~"packages" := Packages}=Sbom) ->
    Packages1 = [begin
                     case maps:get(~"SPDXID", Package) of
                         ProjectName0 ->
                             Package#{~"SPDXID" := ProjectName};
                         _ ->
                             Package
                     end
                 end || Package <- Packages],
    Sbom#{ ~"documentDescribes" := [ ProjectName ], ~"packages" := Packages1}.

fix_name(Name, Sbom) ->
    Sbom#{ ~"name" => Name}.

fix_creators_tooling(Tool, #{ ~"creationInfo" := #{~"creators" := [ORT | _]}=Creators}=Sbom) ->
    SHA = list_to_binary(string:trim(".sha." ++ os:cmd("git rev-parse HEAD"))),
    Sbom#{~"creationInfo" := Creators#{ ~"creators" := [ORT, <<Tool/binary, SHA/binary>>]}}.

fix_supplier(_Name, #{~"packages" := [ ] }=Sbom) ->
    io:format("[warn] no packages available!~n"),
    Sbom;
fix_supplier(Name, #{~"packages" := [_ | _]=Packages }=Sbom) ->
    Sbom#{~"packages" := [maps:update_with(~"supplier", fun(_) -> Name end, Name, Package) || Package <- Packages]}.

fix_download_location(_Url, #{~"packages" := [ ] }=Sbom) ->
    io:format("[warn] no packages available!~n"),
    Sbom;
fix_download_location(Url, #{~"packages" := [ _ | _ ]=Packages }=Sbom) ->
    PackagesUpdated = [ Package#{~"downloadLocation" := Url } || Package <- Packages],
    Sbom#{~"packages" := PackagesUpdated}.

fix_project_package_license(_, #{ ~"documentDescribes" := [RootProject],
                                  ~"packages" := Packages}=Spdx) ->
    Packages1= [case maps:get(~"SPDXID", Package) of
                    RootProject ->
                        Package#{ ~"homepage" := ~"https://www.erlang.org",
                                  ~"licenseConcluded" := ~"Apache-2.0"};
                    _ ->
                        Package
                end || Package <- Packages],
    Spdx#{~"packages" := Packages1}.

fix_project_package_version(OtpVersion, #{ ~"documentDescribes" := [RootProject],
                                           ~"packages" := Packages}=Spdx) ->
    {ok, Content} = file:read_file(OtpVersion),
    Packages1= [case maps:get(~"SPDXID", Package) of
                    RootProject ->
                        Package#{ ~"versionInfo" := string:trim(Content) };
                    _ ->
                        Package
                end || Package <- Packages],
    Spdx#{~"packages" := Packages1}.

fix_project_purl(Purl, #{ ~"documentDescribes" := [RootProject],
                          ~"packages" := Packages}=Spdx) ->
    Packages1= [case maps:get(~"SPDXID", Package) of
                    RootProject ->
                        Package#{ ~"externalRefs" => [Purl]};
                    _ ->
                        Package
                end || Package <- Packages],
    Spdx#{~"packages" := Packages1}.

otp_purl(Name, VersionInfo) ->
    <<"pkg:otp/", Name/binary, "@", VersionInfo/binary>>.

fix_has_extracted_license_info(MissingLicenses, #{~"hasExtractedLicensingInfos" := LicenseInfos,
                                                   ~"packages" := Packages,
                                                  ~"documentDescribes" := [RootProject]}=Spdx) ->
    ExtractedLicenses = [maps:get(~"licenseId", ExtractedLicense) || ExtractedLicense <- LicenseInfos ],
    MissingExtractedLicenses =
        lists:foldl(fun (Package, Acc) ->
                            case maps:get(~"SPDXID", Package) of
                                RootProject ->
                                    %% list of SPDX identifier
                                    InfoFromFiles = maps:get(~"licenseInfoFromFiles", Package),

                                    %% Licenses is a list of tuples (Spdx Id, License Text)
                                    Licenses = lists:filter(
                                                 fun (License) ->
                                                         %% License must be used, and not already extracted.
                                                         %% this only makes sense for LicenseRef-XXXX
                                                         lists:member(element(1, License), InfoFromFiles) andalso
                                                             not lists:member(element(1, License), ExtractedLicenses)
                                                 end, MissingLicenses),
                                    Licenses ++ Acc;
                              _ ->
                                  Acc
                          end
                  end, [], Packages),
    AddAllExtractedLicenses = lists:foldl(fun ({K, V}, Acc) ->
                                                  [#{~"extractedText" => V, ~"licenseId" => K} | Acc]
                                          end, LicenseInfos, MissingExtractedLicenses),
    Spdx#{~"hasExtractedLicensingInfos" := AddAllExtractedLicenses}.

-spec create_externalRef_purl(Desc :: binary(), Purl :: binary()) -> map().
create_externalRef_purl(Description, Purl) ->
    #{ ~"comment" => Description,
       ~"referenceCategory" => ~"PACKAGE-MANAGER",
       ~"referenceLocator" => Purl,
       ~"referenceType" => ~"purl"}.

%% re-populate licenses to .beam files from their .erl files
%% e.g., the lists.beam file should have the same license as lists.erl
fix_beam_licenses(_LicensesAndCopyrights, #{ ~"packages" := []}=Sbom) ->
    io:format("[warn] no packages available!~n"),
    Sbom;
fix_beam_licenses(LicensesAndCopyrights,
                  #{ ~"files"   := Files}=Sbom) ->

    Files1= lists:map(
              fun (SPDX) ->
                      %% Adds license and copyright from .erl or .hrl file to its .beam equivalent
                      case SPDX of
                          #{~"fileName" := <<"lib/stdlib/uc_spec/", _Filename/binary>>,
                            ~"licenseInfoInFiles" := [License]}  when License =/= ~"NONE", License =/= ~"NOASSERTION"->
                              files_have_no_license(SPDX#{~"licenseConcluded" := License});

                          #{~"fileName" := ~"bootstrap/lib/stdlib/ebin/erl_parse.beam"} ->
                              %% beam file auto-generated from grammar file
                              files_have_no_license(fix_beam_spdx_license(~"lib/stdlib/src/erl_parse.yrl", LicensesAndCopyrights, SPDX));

                          #{~"fileName" := ~"bootstrap/lib/stdlib/ebin/unicode_util.beam"} ->
                              %% follows from otp/lib/stdlib/uc_spec/README-UPDATE.txt
                              files_have_no_license(SPDX#{~"licenseConcluded" := ~"Unicode-3.0 AND Apache-2.0"});

                          #{~"fileName" := <<"erts/emulator/internal_doc/",Filename/binary>>} ->
                              case binary:split(Filename, ~".md") of
                                  [_File, _Ext] ->
                                      SPDX#{~"licenseConcluded" := ~"Apache-2.0"};
                                  _ ->
                                      SPDX
                              end;

                          #{~"fileName" := Filename} ->
                              case bootstrap_mappings(Filename) of
                                  {error, not_beam_file} ->
                                      fix_spdx_license(SPDX);
                                  {Path, Filename1} ->
                                      case binary:split(Filename1, ~".beam") of
                                          [File, _] ->
                                              files_have_no_license(fix_beam_spdx_license(Path, File, LicensesAndCopyrights, SPDX));
                                          _ ->
                                              SPDX
                                      end
                              end
                          end
              end, Files),
    Sbom#{ ~"files" := Files1}.

bootstrap_mappings(<<"bootstrap/lib/compiler/ebin/", Filename/binary>>) -> {~"lib/compiler/src/", Filename};
bootstrap_mappings(<<"bootstrap/lib/kernel/ebin/",Filename/binary>>) -> {<<"lib/kernel/src/">>, Filename};
bootstrap_mappings(<<"bootstrap/lib/kernel/include/",Filename/binary>>) -> {<<"lib/kernel/include/">>, Filename};
bootstrap_mappings(<<"bootstrap/lib/stdlib/ebin/",Filename/binary>>) -> {<<"lib/stdlib/src/">>, Filename};
bootstrap_mappings(<<"erts/preloaded/ebin/",Filename/binary>>) -> {<<"erts/preloaded/src/">>, Filename};
bootstrap_mappings(_Other) ->
    {error, not_beam_file}.

%% fixes spdx license of beam files
fix_beam_spdx_license(Path, {Licenses, Copyrights}, SPDX) ->
    License = maps:get(Path, Licenses, ~"NOASSERTION"),
    Copyright = maps:get(Path, Copyrights, ~"NOASSERTION"),
    fix_spdx_license(SPDX#{ ~"copyrightText" := Copyright, ~"licenseConcluded" := License }).

fix_beam_spdx_license(Path, File, LicensesAndCopyrights, SPDX) when is_binary(Path),
                                                                    is_binary(File) ->
    Spdx0 = fix_beam_spdx_license(<<Path/binary, File/binary, ".erl">>, LicensesAndCopyrights, SPDX),
    case maps:get(~"licenseConcluded", Spdx0) of
        ~"NOASSERTION" ->
            fix_beam_spdx_license(<<Path/binary, File/binary, ".hrl">>, LicensesAndCopyrights, Spdx0);
        _ ->
            Spdx0
    end.

files_have_no_license(Spdx) ->
    Spdx#{~"licenseInfoInFiles" := [~"NONE"]}.

none_to_noassertion(~"NONE") ->
    ~"NOASSERTION";
none_to_noassertion(X) ->
    X.

%% TODO: check which license curations have actually licenses in files, and which ones
%%       are added to annotate a file with a license. this latter should not be a curation
%%       in ORT, but in this script.
%% fixes spdx license of non-beam files
fix_spdx_license(#{~"licenseInfoInFiles" := [LicenseInFile],
                   ~"licenseConcluded" := License,
                   ~"copyrightText" := C}=SPDX) ->
    License1 = case License of
                   ~"NONE" -> LicenseInFile;
                   ~"NOASSERTION" -> LicenseInFile;
                   Other -> Other
               end,
    SPDX#{ ~"licenseConcluded" := none_to_noassertion(License1),
           ~"copyrightText" := none_to_noassertion(C)
         };
fix_spdx_license(#{~"copyrightText" := C}=SPDX) ->
    SPDX#{ ~"copyrightText" := none_to_noassertion(C)}.

%% Given an input file, returns a mapping of
%% #{filepath => license} for each file path towards its license.
-spec path_to_license(Input :: map()) -> #{Path :: binary() => License :: binary()}.
path_to_license(Input) ->
    match_path_to(Input, fun group_by_licenses/3).

-spec path_to_copyright(Input :: map()) -> #{Path :: binary() => License :: binary()}.
path_to_copyright(Input) ->
    match_path_to(Input, fun group_by_copyrights/3).

-spec match_path_to(Input :: map(), GroupFun :: fun()) -> #{ Path :: binary() => Result :: binary() }.
match_path_to(Json, GroupFun) ->
    Exclude = true,
    Curations = false,
    GroupedResult = GroupFun(Json, Exclude, Curations),
    maps:fold(fun (K, Vs, Acc) ->
                      maps:merge(maps:from_keys(Vs, K), Acc)
              end, #{}, GroupedResult).

%%
%% Explore command
%%
classify_license(#{output_file := Output,
                   input_file := Filename,
                   exclude := ApplyExclude,
                   curations := ApplyCuration}) ->
    Json = decode(Filename),
    R = group_by_licenses(Json, ApplyExclude, ApplyCuration),
    ok = file:write_file(Output, json:encode(R)).

classify_path_license_copyright(#{output_file := Output,
                     input_file := Filename,
                     base_file  := LicenseFileGroup}) ->
    Copyrights = classify_copyright_result(Filename),
    Licenses = expand_license_result(LicenseFileGroup),
    Files = lists:sort(lists:uniq(maps:keys(Copyrights) ++ maps:keys(Licenses))),
    X = lists:foldl(fun (Path, Acc) ->
                          Copyright = maps:get(Path, Copyrights, ~"NONE"),
                          License = maps:get(Path, Licenses, ~"NONE"),
                          Acc#{Path => #{ ~"Copyright" => Copyright, ~"License" => License}}
                    end, #{}, Files),
    ok = file:write_file(Output, json:encode(X)).

expand_license_result(Filename) ->
    Json = decode(Filename),
    maps:fold(fun (License, Paths, Acc) ->
                      maps:merge(Acc, maps:from_list([{Path, License} || Path <- Paths]))
              end, #{}, Json).

classify_copyright_result(Filename) ->
    Json = decode(Filename),
    Copyrights = copyrights(scan_results(Json)),
    lists:foldl(fun (Copyright, Acc) ->
                        #{<<"statement">> := CopyrightSt, <<"location">> := Location} = Copyright,
                        #{<<"path">> := Path, <<"start_line">> := _StartLine, <<"end_line">> := _EndLine} = Location,
                        Acc#{Path => CopyrightSt}
                    end, #{}, Copyrights).

-spec group_by_licenses(map(), boolean(), boolean()) -> #{License :: binary() => [Path :: binary()]}.
group_by_licenses(Json, ApplyExclude, ApplyCuration) ->
    Excludes = apply_excludes(Json, ApplyExclude),
    Curations = apply_curations(Json, ApplyCuration),

    Licenses = licenses(scan_results(Json)),
    lists:foldl(fun (License, Acc) ->
                            group_by_license(Excludes, Curations, License, Acc)
                    end, #{}, Licenses).

group_by_copyrights(Json, ApplyExclude, _ApplyCuration) ->
    Excludes = apply_excludes(Json, ApplyExclude),
    Copyrights = copyrights(scan_results(Json)),
    lists:foldl(fun (Copyright, Acc) ->
                            group_by_copyright(Excludes, Copyright, Acc)
                    end, #{}, Copyrights).


apply_excludes(Json, ApplyExclude) ->
    onlyif([], ApplyExclude, fun () -> convert_excludes(excludes(Json)) end).

apply_curations(Json, ApplyCuration) ->
    onlyif([], ApplyCuration, fun () -> curations(Json) end).

diff(#{input_file := InputFile, base_file := BaseFile, output_file := Output}) ->
    Input = decode(InputFile),
    Base = decode(BaseFile),
    KeyList = maps:keys(Input) ++ maps:keys(Base),
    KeySet = sets:from_list(KeyList),
    Data = sets:fold(fun(Key, Acc) -> set_difference(Key, Input, Base, Acc) end, #{}, KeySet),
    file:write_file(Output, json:encode(Data)).

detect_no_license(#{input_file := InputFile,
                    output_file := OutputFile,
                    exclude := ApplyExcludes}) ->
    Input = decode(InputFile),
    SortedResult = compute_unlicense_files(Input, ApplyExcludes),
    file:write_file(OutputFile, json:encode(SortedResult)).

compute_unlicense_files(Input, ApplyExcludes) ->
    Licenses = licenses(scan_results(Input)),

    PathsWithLicense =
        lists:foldl(fun (#{<<"location">> := #{<<"path">> := Path}}, Acc) ->
                            sets:add_element(Path, Acc)
                    end, sets:new(), Licenses),

    %% Get all files, incluiding those without license
    Files = files_from_scanner(Input),
    AllPaths =
        lists:foldl(fun (#{<<"path">> := Path}, Acc) ->
                            sets:add_element(Path, Acc)
                    end, sets:new(), Files),

    %% Paths without license
    PathsWithoutLicense = sets:to_list(sets:subtract(AllPaths, PathsWithLicense)),

    %% Excluded files that should be ignored
    Excludes = excludes(Input),
    ExcludeRegex = onlyif([], ApplyExcludes, fun () -> convert_excludes(Excludes) end),
    Result = lists:foldl(fun(Path, Acc) ->
                                 case exclude_path(Path, ExcludeRegex) of
                                     true ->
                                         Acc;
                                     false ->
                                         [Path | Acc]
                                 end
                         end, [], PathsWithoutLicense),
    lists:sort(Result).

check_no_license(#{input_file := InputFile,
                   base_file := BaseFile,
                   exclude := ApplyExcludes,
                   output_file := OutputFile}) ->
    UnlicenseNew = compute_unlicense_files(decode(InputFile), ApplyExcludes),
    Unlicense = decode(BaseFile),
    UnlicenseSet = sets:from_list(Unlicense),
    UnlicenseNewSet =  sets:from_list(UnlicenseNew),
    Result = sets:to_list(sets:subtract(UnlicenseNewSet, UnlicenseSet)),
    file:write_file(OutputFile, json:encode(Result)).


%%
%% Helper functions
%%

excludes(Input) ->
    try
        #{<<"repository">> :=
              #{<<"config">> :=
                    #{<<"excludes">> := #{<<"paths">> := Excludes}}}} = Input,
        Excludes
    catch
        _:_ ->
            []
    end.


curations(Input) ->
    #{<<"repository">> :=
          #{<<"config">> :=
                #{<<"curations">> := #{<<"license_findings">> := Curations}}}} = Input,
    Curations.

scan_results(Input) ->
    #{<<"scanner">> := #{<<"scan_results">> := ScanResults}} = Input,
    ScanResult = hd(ScanResults),
    NewSummary =
        lists:foldl(fun(#{ ~"summary" := #{ ~"licenses" := Licenses, ~"copyrights" := Copyrights}}, Acc) ->
            Acc#{ ~"licenses" := Licenses ++ maps:get(~"licenses", Acc),
                ~"copyrights" := Copyrights ++ maps:get(~"copyrights", Acc) }
        end, maps:get(~"summary",ScanResult), tl(ScanResults)),
    ScanResult#{ ~"summary" := NewSummary }.

licenses(Input) ->
    #{<<"summary">> := #{<<"licenses">> := Licenses}} = Input,
    Licenses.

copyrights(Input) ->
    #{<<"summary">> := #{<<"copyrights">> := Copyrights}} = Input,
    Copyrights.


files_from_scanner(Input) ->
    #{<<"scanner">> := #{<<"files">> := [#{<<"files">> := Files}]}} = Input,
    Files.

set_difference(Key, Input, Base, Acc) ->
    InputValues = sets:from_list(maps:get(Key, Input, [])),
    BaseValues = sets:from_list(maps:get(Key, Base, [])),
    Additions = sets:subtract(InputValues, BaseValues),
    Deletions = sets:subtract(BaseValues, InputValues),
    Acc#{Key => #{addition => sets:to_list(Additions), deletions => sets:to_list(Deletions)}}.

onlyif(_Default, true, Command) -> Command();
onlyif(Default, false, _Command) -> Default.

decode(Filename) ->
    {ok, Bin} = file:read_file(Filename),
    json:decode(Bin).

decode_without_spdx_license(Filename) ->
    {ok, Bin} = file:read_file(Filename),

    %% remove comments
    Lines = string:split(Bin, "\n", all),
    Lines1 = lists:map(fun (Line) -> re:replace(Line, "%.*", "", [global]) end, Lines),
    Bin1 = erlang:iolist_to_binary(Lines1),

    json:decode(Bin1).

group_by_license(ExcludeRegexes, Curations, License, Acc) ->
    #{<<"license">> := LicenseName, <<"location">> := Location} = License,
    #{<<"path">> := Path, <<"start_line">> := _StartLine, <<"end_line">> := _EndLine} = Location,
    maybe
        false ?= exclude_path(Path, ExcludeRegexes),
        LicenseName1 = curated_path_license(LicenseName, Path, Curations),
        case maps:get(LicenseName1, Acc, []) of
            [] ->
                Acc#{LicenseName1 => [Path]};
            Ls ->
                Ls1 = case lists:search(fun(X) -> X == Path end, Ls) of
                          false -> [Path | Ls];
                          _ -> Ls
                      end,
                Acc#{LicenseName1 => Ls1}
        end
    else
        _ ->
            Acc
    end.

group_by_copyright(ExcludeRegexes, Copyright, Acc) ->
    #{<<"statement">> := CopyrightSt, <<"location">> := Location} = Copyright,
    #{<<"path">> := Path, <<"start_line">> := _StartLine, <<"end_line">> := _EndLine} = Location,
    maybe
        false ?= exclude_path(Path, ExcludeRegexes),
        case maps:get(CopyrightSt, Acc, []) of
            [] ->
                Acc#{CopyrightSt => [Path]};
            Ls ->
                Ls1 = case lists:search(fun(X) -> X == Path end, Ls) of
                          false -> [Path | Ls];
                          _ -> Ls
                      end,
                Acc#{CopyrightSt => Ls1}
        end
    else
        _ ->
            Acc
    end.

convert_excludes(Excludes) ->
    lists:map(fun (#{<<"pattern">> := Pattern}) ->
                      Pattern1 = re:replace(Pattern, <<"\\.">>, <<"\\\\.">>, [global, {return, binary}]),
                      re:replace(Pattern1, <<"\\*\\*">>, <<".*">>, [global, {return, binary}])
              end, Excludes).

exclude_path(_Path, []) ->
    false;
exclude_path(Path, ExcludeRegexes) ->
    lists:any(fun (Regex) ->
                      case re:run(Path, Regex) of
                          {match, _} -> true;
                          _ -> false
                      end
              end, ExcludeRegexes).

curated_path_license(Name, _Path, []) -> Name;
curated_path_license(_Name, Path, [#{<<"path">> := Path}=Cur | _Curations]) ->
    maps:get(<<"concluded_license">>, Cur);
curated_path_license(Name, Path, [_Cur | Curations]) ->
    curated_path_license(Name, Path, Curations).

%% fixes the Spdx to split Spdx by app, and adds vendor dependencies
package_by_app(Spdx) ->
    %% add App packages, e.g., stdlib, erts, ssh, ssl
    AppSrcFiles = find_app_src_files("."),
    PackageTemplates = generate_spdx_mappings(AppSrcFiles),
    Packages = generate_spdx_packages(PackageTemplates, Spdx),
    AppPackages = lists:map(fun create_spdx_package/1, Packages),
    Spdx1 = add_packages(AppPackages, Spdx),
    Spdx2 = create_otp_relationships(Packages, PackageTemplates, Spdx1),

    %% create vendor packages
    VendorSrcFiles = find_vendor_src_files("."),
    VendorInfoPackage = generate_vendor_info_package(VendorSrcFiles),
    VendorPackages = generate_spdx_vendor_packages(VendorInfoPackage, Spdx2),

    %% Remove possible duplicates of vendor packages
    {NewVendorPackages, Spdx3} = remove_duplicate_packages(VendorPackages, Spdx2),

    SpdxWithVendor = add_packages(NewVendorPackages, Spdx3),
    create_vendor_relations(NewVendorPackages, SpdxWithVendor).

create_otp_relationships(Packages, PackageTemplates, Spdx) ->
    Spdx1 = create_package_relationships(Packages, Spdx),
    Spdx2 = create_depends_on_relationships(PackageTemplates, Spdx1),
    create_opt_depency_relationships(PackageTemplates, Spdx2).

-spec add_packages(Packages :: [spdx_package()], Spdx :: map()) -> SpdxResult :: map().
add_packages(AppPackages, Spdx) ->
    #{~"packages" := SpdxPackages}=Spdx1 = remove_package_files_from_project(Spdx, AppPackages),
    Spdx1#{~"packages" := SpdxPackages ++ AppPackages}.

%% Removes duplicate packages and adds a comment for existing vendor Packages in SPDX
%% it also remove files in top-level directories and they onyly exist  in vendor libraries
-spec remove_duplicate_packages(VendorPackages :: map(), Spdx2 :: map()) -> {ResultVendorPackages :: map(), SPDX :: map()}.
remove_duplicate_packages(VendorPackages, #{~"packages" := Packages}=Spdx) ->
    #{~"vendor" := Vendors, ~"app" := Apps} =
        lists:foldl(fun (#{~"SPDXID" := VendorId}=Vendor, #{~"vendor" := Vcc, ~"app" := Apc}=Acc) ->
                            case lists:search(fun (#{~"SPDXID" := Id}) -> VendorId == Id end, Packages) of
                                {value, P} ->
                                    Packages1 = Apc -- [P],
                                    Comment = maps:get(~"comment", P, ~""),
                                    Acc#{~"app" := [P#{~"comment" => <<Comment/binary, " vendor package">>} | Packages1]};
                                _ ->
                                    Acc#{~"vendor" := [Vendor | Vcc]}
                            end
                    end, #{~"vendor" => [], ~"app" => Packages}, VendorPackages),

    %%
    VendorFileIds = lists:flatten(lists:map(fun (#{~"hasFiles" := Fs}) -> Fs end, Vendors)),
    FixedApps = lists:map(fun (#{~"hasFiles" := SPDXIDs}=AppPackage) ->
                                  AppPackage#{~"hasFiles" := SPDXIDs -- VendorFileIds}
                          end, Apps),
    {Vendors, Spdx#{~"packages" := FixedApps}}.

%% project package contains `hasFiles` fields with all files.
%% remove all files included in other packages from project package.
%% there exists already a package relation between packages and project package.
remove_package_files_from_project(#{~"documentDescribes" := [ProjectPackageId],
                                    ~"packages" := Packages}=Spdx, AppPackages) ->
    [#{~"hasFiles" := FilesId}=ProjectPackage] = lists:filter(fun (#{~"SPDXID" := SPDXID}) -> SPDXID == ProjectPackageId end, Packages),
    AppFilesId = lists:foldl(fun (#{~"hasFiles" := Files}, Acc) -> Files ++ Acc end, [], AppPackages),
    ProjectPackage1 = ProjectPackage#{~"hasFiles" := FilesId -- AppFilesId},
    Spdx#{~"packages" := [ProjectPackage1 | Packages -- [ProjectPackage]]}.


-spec create_spdx_package(Package :: spdx_package()) -> map().
create_spdx_package(Pkg) ->
    SPDXID = Pkg#spdx_package.'SPDXID',
    VersionInfo= Pkg#spdx_package.'versionInfo',
    Name = Pkg#spdx_package.'name',
    CopyrightText = Pkg#spdx_package.'copyrightText',

    FilesAnalyzed = Pkg#spdx_package.'filesAnalyzed',
    HasFiles = Pkg#spdx_package.'hasFiles',
    Homepage = Pkg#spdx_package.'homepage',
    LicenseConcluded = Pkg#spdx_package.'licenseConcluded',
    LicenseDeclared = Pkg#spdx_package.'licenseDeclared',
    LicenseInfo = Pkg#spdx_package.'licenseInfoFromFiles',
    DownloadLocation = Pkg#spdx_package.'downloadLocation',
    PackageVerification = Pkg#spdx_package.'packageVerificationCode',
    PackageVerificationCodeValue = maps:get('packageVerificationCodeValue', PackageVerification),
    Supplier = Pkg#spdx_package.'supplier',
    Purl1 = case Pkg#spdx_package.'purl' of
               false -> [];
               _ -> [Pkg#spdx_package.'purl']
           end,
    #{ ~"SPDXID" => SPDXID,
       ~"versionInfo" => VersionInfo,
       ~"name" => Name,
       ~"copyrightText" => CopyrightText,
       ~"filesAnalyzed" => FilesAnalyzed,
       ~"hasFiles" => HasFiles,
       ~"homepage" => Homepage,
       ~"licenseConcluded" => LicenseConcluded,
       ~"licenseDeclared" => LicenseDeclared,
       ~"licenseInfoFromFiles" => LicenseInfo,
       ~"downloadLocation" => DownloadLocation,
       ~"externalRefs" => Purl1,
       ~"packageVerificationCode" => #{~"packageVerificationCodeValue" => PackageVerificationCodeValue},
       ~"supplier" => Supplier
     }.

%% Example:
%% https://github.com/spdx/tools-java/blob/master/testResources/SPDXJSONExample-v2.2.spdx.json#L240-L275
create_package_relationships(Packages, Spdx) ->
    Relationships =
        lists:foldl(fun (Pkg, Acc) ->
                            {Key, Ls} = case Pkg#spdx_package.'relationships' of
                                            #{'PACKAGE_OF' := L } -> {'PACKAGE_OF', L};
                                            #{'TEST_OF' := L} -> {'TEST_OF', L};
                                            #{'DOCUMENTATION_OF' := L} -> {'DOCUMENTATION_OF', L}
                                        end,
                            lists:foldl(fun ({ElementId, RelatedElement}, Acc1) ->
                                              [create_spdx_relation(Key, ElementId, RelatedElement) | Acc1]
                                      end, Acc, Ls)
                    end, [], Packages),
    Spdx#{~"relationships" => Relationships}.

-spec create_depends_on_relationships(PackageMappings, Spdx) -> map() when
      PackageMappings :: #{AppName => {AppPath, app_info()}},
      AppName :: binary(),
      AppPath :: binary(),
      Spdx :: map().
create_depends_on_relationships(PackageTemplates, #{~"relationships" := Relationships}=Spdx) ->
    DependsOn =
        maps:fold(fun (PackageName, {_Path, AppInfo}, Acc) ->
                          DependsOnApps = lists:map(fun erlang:atom_to_binary/1, AppInfo#app_info.applications),
                          SpdxPackageName = generate_spdxid_name(PackageName),
                          Relations = [create_spdx_relation('DEPENDS_ON', SpdxPackageName, generate_spdxid_name(RelatedElement))
                                        || RelatedElement <- [~"erts" | DependsOnApps], generate_spdxid_name(RelatedElement) =/= SpdxPackageName],
                           Relations ++ Acc
                   end, [], PackageTemplates),
    Spdx#{~"relationships" := DependsOn ++ Relationships}.

create_opt_depency_relationships(PackageTemplates, #{~"relationships" := Relationships}=Spdx) ->
    DependsOn =
        maps:fold(fun (PackageName, {_Path, AppInfo}, Acc) ->
                          Optional = AppInfo#app_info.included_applications ++ AppInfo#app_info.optional_applications,
                          DependsOnApps = lists:map(fun erlang:atom_to_binary/1, Optional),
                          SpdxPackageName = generate_spdxid_name(PackageName),
                          Relations = [create_spdx_relation('OPTIONAL_DEPENDENCY_OF', generate_spdxid_name(RelatedElement), SpdxPackageName)
                                        || RelatedElement <- DependsOnApps, generate_spdxid_name(RelatedElement) =/= SpdxPackageName],
                           Relations ++ Acc
                   end, [], PackageTemplates),
    Spdx#{~"relationships" := DependsOn ++ Relationships}.


%% adds package of to packages within packages in OTP.
%% example: asmjit is a subpackage of erts
create_vendor_relations(NewVendorPackages, #{~"packages" := Packages, ~"relationships" := Relations}=SpdxWithVendor) ->
    VendorRelations =
        lists:map(fun (#{~"name" := _Name, ~"SPDXID" := ID}=_Vendor) ->
                          [App | _] = string:split(undo_spdxid_name(ID), ~"-"),
                          case lists:filter(fun (#{~"name" := N}) -> App == generate_spdx_valid_name(N) end, Packages) of
                              [#{~"SPDXID" := RootId}=_RootPackage] ->
                                  create_spdx_relation('PACKAGE_OF', ID, RootId);
                              [] ->
                                  %% Attach to root level package
                                  create_spdx_relation('PACKAGE_OF', ID, ?spdxref_project_name)
                              end
                  end, NewVendorPackages),
    SpdxWithVendor#{~"relationships" := Relations ++ VendorRelations}.

-spec create_spdx_relation('PACKAGE_OF' | 'DEPENDS_ON', SpdxId :: binary(), RelatedId :: binary()) -> map().
create_spdx_relation(Relation, ElementId, RelatedElement) ->
    #{~"spdxElementId" => ElementId,
      ~"relatedSpdxElement" => RelatedElement,
      ~"relationshipType" => Relation}.

-spec find_app_src_files(Folder :: string()) -> [string()].
find_app_src_files(Folder) ->
    S = os:cmd("find "++ Folder ++ " -regex .*.app.src | grep -v test | grep -v smoke-build | cut -d/ -f2-"),

    %% TODO: merge above and below command into a single command
    %% specific line to include common_test, if it were to exist
    SCommonTest = os:cmd("find " ++ Folder ++ " -regex .*.app.src | grep -v test_dir | grep common_test | cut -d/ -f2-"),
    lists:map(fun erlang:list_to_binary/1, string:split(S ++ SCommonTest, "\n", all)).

get_otp_apps_from_table() ->
    {ok, BinTable} = file:read_file("otp_versions.table"),
    {ok, ReleaseBin0} = file:read_file("OTP_VERSION"),
    ReleaseBin = string:trim(ReleaseBin0),
    OTPVersion = <<"OTP-", ReleaseBin/binary>>,

    Lines = string:split(BinTable, "\n", all),
    LineOTP = lists:filter(fun (Line) ->
                                   [V | _Rest] = string:split(Line, " "),
                                   V == OTPVersion
                           end, Lines),
    case LineOTP of
        [Line] ->
            Line1 = re:replace(Line, "(#|:)", "", [global]),
            Line2 = string:trim(re:replace(Line1, OTPVersion, "", [global])),

            AppsWithVersion = string:split(Line2, " ", all),
            AppsWithVersion1 = lists:filter(fun (Bin) ->
                                                    case Bin of
                                                        <<>> ->
                                                            false;
                                                        _ ->
                                                            true
                                                    end
                                            end, AppsWithVersion),
            lists:map(fun (App) ->
                              [Name, Version] = string:split(App, "-"),
                              {Name, Version}
                      end, AppsWithVersion1);
            %% lists:map(fun (App) -> iolist_to_binary(re:replace(App, "-.*", "", [global])) end, AppsWithVersion);
        [] ->
            [];
        _ ->
            io:format("ERROR, there cannot be multiple lines matching")
    end.

find_vendor_src_files(Folder) ->
    S = os:cmd("find "++ Folder ++ " -name vendor.info"),
    lists:map(fun erlang:list_to_binary/1, string:split(S, "\n", all)).

-spec generate_spdx_mappings(Path :: [binary()]) -> Result when
      Result :: #{AppName :: binary() => {AppPath :: binary(), AppInfo :: app_info()}}.
generate_spdx_mappings(AppSrcPath) ->
    lists:foldl(fun (AppSrcPath0, Acc) ->
                        DetectedPackages = build_package_location(AppSrcPath0),
                        maps:merge(Acc, DetectedPackages)
                end, #{}, AppSrcPath).

-spec generate_vendor_info_package(VendorSrcPath :: [binary()]) -> map().
generate_vendor_info_package(VendorSrcPath) ->
    lists:foldl(fun vendor_info_to_map/2, [], VendorSrcPath).


%% Read Path file and generate Json (map) following vendor.info specification
vendor_info_to_map(<<>>, Acc) ->
    Acc;
vendor_info_to_map(Path, Acc) ->
    case decode_without_spdx_license(Path) of
        Json when is_list(Json) ->
            Json ++ Acc;
        Json when is_map(Json) ->
            [Json | Acc]
    end.

-spec generate_spdx_vendor_packages(VendorInfoPackage :: map(), map()) -> map().
generate_spdx_vendor_packages(VendorInfoPackages, #{~"files" := SpdxFiles}=_SPDX) ->
    lists:map(fun
                  (#{~"ID" := Id, ~"path" := [_ | _]=ExplicitFiles}=Package) when is_list(ExplicitFiles) ->
                      %% Deals with the cases of creating a package out of specific files
                      Paths = lists:map(fun cleanup_path/1, ExplicitFiles),
                      Package1 = maps:remove(~"ID", Package),
                      Package2 = maps:remove(~"path", Package1),

                      %% place files in SPDX in the corresponding package
                      Files = lists:filter(fun (#{~"fileName" := Filename}) ->
                                                   lists:member(Filename, Paths)
                                           end, SpdxFiles),

                      LicenseInfoInFiles = split_licenses_in_individual_parts(
                        lists:foldl(fun(#{~"licenseInfoInFiles" := Licenses}, Acc) ->
                                            Licenses ++ Acc
                                    end, [], Files)),

                      PackageVerificationCodeValue = generate_verification_code_value(Files),
                      Package2#{
                                ~"SPDXID" => generate_spdxid_name(Id),
                                ~"filesAnalyzed" => true,
                                ~"hasFiles" => lists:map(fun (#{~"SPDXID":=Id0}) -> Id0 end, Files),
                                ~"licenseConcluded" => ~"NOASSERTION",
                                ~"licenseInfoFromFiles" => lists:uniq(LicenseInfoInFiles),
                                ~"packageVerificationCode" => #{~"packageVerificationCodeValue" => PackageVerificationCodeValue},
                                ~"comment" => ~"vendor package"
                       };
                  (#{~"ID" := Id, ~"path" := DirtyPath}=Package) when is_binary(DirtyPath) ->
                      %% Deals with the case of creating a package out of a path
                      Path = cleanup_path(DirtyPath),
                      Package1 = maps:remove(~"ID", Package),
                      Package2 = maps:remove(~"path", Package1),

                      %% place files in SPDX in the corresponding package
                      Files = lists:filter(fun (#{~"fileName" := Filename}) ->
                                                   case string:prefix(Filename, Path) of
                                                       nomatch -> false;
                                                       _ -> true
                                                   end
                                           end, SpdxFiles),
                      LicenseInfoInFiles = split_licenses_in_individual_parts(
                        lists:foldl(fun(#{~"licenseInfoInFiles" := Licenses}, Acc) ->
                                            Licenses ++ Acc
                                    end, [], Files)),

                      PackageVerificationCodeValue = generate_verification_code_value(Files),
                      Package2#{
                                ~"SPDXID" => generate_spdxid_name(Id),
                                ~"filesAnalyzed" => true,
                                ~"hasFiles" => lists:map(fun (#{~"SPDXID":=Id0}) -> Id0 end, Files),
                                ~"licenseConcluded" => ~"NOASSERTION",
                                ~"licenseInfoFromFiles" => lists:uniq(LicenseInfoInFiles),
                                ~"packageVerificationCode" => #{~"packageVerificationCodeValue" => PackageVerificationCodeValue},
                                ~"comment" => ~"vendor package"
                       }
              end, VendorInfoPackages).

cleanup_path(<<"./", Path/binary>>) when is_binary(Path) -> Path;
cleanup_path(Path) when is_binary(Path) -> Path.

build_package_location(<<>>) -> #{};
build_package_location(AppSrcPath) ->
    case string:split(AppSrcPath, "/", all) of
        [~"lib", App | _] ->
            AppName = erlang:binary_to_atom(App),
            _ = case application:load(AppName) of
                    R when R==ok orelse R=={error, {already_loaded, AppName}} ->
                        %% somewhat unsafe binary_to_atom/1 but we have guarantees to receive
                        %% only apps in Erlang/OTP
                        {ok, AppKey} = application:get_all_key(AppName),
                        AppKey1 = app_key_to_record(AppKey),
                        #{App => {<<"lib/", App/binary>>, AppKey1}};
                    _E ->
                        % useful only for debugging.
                        % this script should have all dependencies and never end up here.
                        io:format("[Error] ~p~n", [{AppSrcPath, _E, AppName, App}]),
                        error(?FUNCTION_NAME)
                end;
        [~"erts"=Erts | _] ->
            #{Erts => {Erts, #app_info{ description = ~"Erlang Runtime System",
                                        id           = [],
                                        vsn          = erlang:list_to_binary(erlang:system_info(version)),
                                        modules      = not_loaded,
                                        applications = [],
                                        included_applications = [],
                                        optional_applications = [] }}}
    end.

app_key_to_record(AppKey) ->
    [{description, Description}, {id, Id},
     {vsn, Vsn}, {modules, Modules},
     {maxP, _}, {maxT, _},
     {registered, _Registered},
     {included_applications, Included},
     {optional_applications, Optional},
     {applications, Apps},
     {env, _Env}, {mod, _Mod},
     {start_phases,_Phases}] = AppKey,
    #app_info{ description  = erlang:list_to_binary(Description),
               id           = erlang:list_to_binary(Id),
               vsn          = erlang:list_to_binary(Vsn),
               modules      = Modules,
               applications = Apps,
               included_applications = Included,
               optional_applications = Optional }.


-spec generate_spdx_packages(PackageMappings, Spdx) -> [spdx_package()] when
      PackageMappings :: #{AppName => {AppPath, app_info()}},
      AppName         :: unicode:chardata(),
      AppPath         :: unicode:chardata(),
      Spdx            :: map().
generate_spdx_packages(PackageMappings, #{~"files" := Files,
                                          ~"documentDescribes" := [ProjectName]}=_Spdx) ->
    maps:fold(fun (PackageName, {PrefixPath, AppInfo}, Acc) ->
                      SpdxPackageFiles = group_files_by_app(Files, PrefixPath),

                      TestFiles = group_files_by_folder(SpdxPackageFiles, binary_to_list(PrefixPath)++"/test/**"),

                      DocFiles = group_files_by_folder(SpdxPackageFiles, binary_to_list(PrefixPath)++"/doc/**"),
                      OTPAppFiles = (SpdxPackageFiles -- TestFiles) -- DocFiles,

                      LicenseOTPApp = otp_app_license_mapping(PackageName),
                      Package = create_spdx_package_record(PackageName, AppInfo#app_info.vsn,
                                                           AppInfo#app_info.description,
                                                           OTPAppFiles, ?spdx_homepage,
                                                           LicenseOTPApp,LicenseOTPApp, true),
                      DocPackage = create_spdx_package_record(<<PackageName/binary, "-documentation">>,
                                                              AppInfo#app_info.vsn,
                                                              <<"Documentation of ", PackageName/binary>>,
                                                              DocFiles, ?spdx_homepage,
                                                              LicenseOTPApp, LicenseOTPApp, false),
                      TestPackage = create_spdx_package_record(<<PackageName/binary, "-test">>,
                                                              AppInfo#app_info.vsn,
                                                              <<"Tests of ", PackageName/binary>>,
                                                              TestFiles, ?spdx_homepage,
                                                              LicenseOTPApp, LicenseOTPApp, false),

                      Relations = [ {'PACKAGE_OF', [{ Package#spdx_package.'SPDXID', ProjectName }]},
                                    {'DOCUMENTATION_OF', [{ DocPackage#spdx_package.'SPDXID', Package#spdx_package.'SPDXID' }]},
                                    {'TEST_OF', [{ TestPackage#spdx_package.'SPDXID', Package#spdx_package.'SPDXID' }]} ],

                      Packages = lists:zipwith(fun (P, {K, R}) ->
                                                       P#spdx_package { 'relationships' = #{ K => R} }
                                               end, [Package, DocPackage, TestPackage], Relations),
                      Packages ++ Acc
               end, [], PackageMappings).

create_spdx_package_record(PackageName, Vsn, Description, SpdxPackageFiles,
                           Homepage, LicenseConcluded, LicenseDeclared, Purl) ->
    SpdxPackageName = generate_spdxid_name(PackageName),
    VerificationCodeValue = generate_verification_code_value(SpdxPackageFiles),
    Purl1 = case Purl of
                false -> false;
                true -> create_externalRef_purl(Description, otp_purl(PackageName, Vsn))
            end,
    #spdx_package {
       'SPDXID' = SpdxPackageName,
       'versionInfo' = Vsn,
       'description' = Description,
       'name' = PackageName,
       'copyrightText' = generate_copyright_text(SpdxPackageFiles),
       'filesAnalyzed' = true,

       %% O(n2) complexity... fix if necessary
       'hasFiles' = generate_has_files(SpdxPackageFiles),

       'purl' = Purl1,
       'homepage' = Homepage,
       'licenseConcluded' = LicenseConcluded,
       'licenseDeclared'  = LicenseDeclared,
       'licenseInfoFromFiles' = generate_license_info_from_files(SpdxPackageFiles),
       'packageVerificationCode' = #{ 'packageVerificationCodeValue' => VerificationCodeValue},
       'relationships' = #{}
      }.


otp_app_license_mapping(Name) ->
    case Name of
        ~"edoc" -> ~"Apache-2.0 OR LGPL-2.1-or-later";
        ~"syntax_tools" -> ~"Apache-2.0 OR LGPL-2.1-or-later";
        ~"eunit" -> ~"Apache-2.0 OR LGPL-2.1-or-later";
        ~"eldap" -> ~"MIT";
        _ -> ?erlang_license
    end.


generate_spdxid_name(PackageName) ->
    PackageName1 = generate_spdx_valid_name(PackageName),
    <<"SPDXRef-otp-", PackageName1/binary>>.

undo_spdxid_name(Name) ->
    <<"SPDXRef-otp-", PackageName/binary>> = Name,
    PackageName.

generate_spdx_valid_name(PackageName) ->
    iolist_to_binary(string:replace(PackageName, ~"_", ~"", all)).

generate_license_info_from_files(SpdxPackageFiles) ->
    Result = lists:foldl(fun (#{~"licenseInfoInFiles" := LicenseInfoInFiles}, AccLicenses) ->
                                 split_licenses_in_individual_parts(LicenseInfoInFiles) ++ AccLicenses
                         end, [], SpdxPackageFiles),
    lists:uniq(Result).

split_licenses_in_individual_parts(Licenses) ->
    lists:foldl(fun (License, Acc) ->
                        L = re:replace(License, "[\(|\)]", "", [global, {return, list}]),
                        Licenses0 = string:split(list_to_binary(L), ~" OR "),
                        Licenses1 = lists:foldl(fun (L1, Acc1) -> string:split(L1, ~" AND ") ++ Acc1  end, [], Licenses0),
                        lists:uniq(lists:map(fun string:trim/1, Licenses1 ++ Acc))
                end, [], Licenses).

generate_has_files(SpdxPackageFiles) ->
    lists:map(fun (#{~"SPDXID" := SpdxId}) -> SpdxId end, SpdxPackageFiles).

%% alg. described in https://spdx.github.io/spdx-spec/v2.2.2/package-information/#791-description
-spec generate_verification_code_value(SpdxPackageFiles :: [SPDXFile :: map()]) -> binary().
generate_verification_code_value(SpdxPackageFiles) ->
    SHA1s = lists:map(fun (#{~"checksums" := [#{~"algorithm" := ~"SHA1", ~"checksumValue" := SHA1}]}) ->
                              SHA1
                      end, SpdxPackageFiles),
    Sorted = lists:sort(SHA1s),
    Merged = lists:foldl(fun(SHA1, Acc) ->
                                 <<Acc/binary, SHA1/binary>>
                         end, <<>>, Sorted),

    %% The crypto hash returns a binary that's not HEX encoded.
    HEX = binary:encode_hex(crypto:hash(sha, Merged)),

    %% encode_hex returns uppercase letters, but the output to SPDX must be lowercase
    StringHex = binary_to_list(HEX),
    list_to_binary(string:to_lower(StringHex)).

generate_copyright_text(SpdxPackageFiles) ->
    CopyrightText = lists:foldl(fun (#{~"copyrightText" := CopyrightText}, Acc0) ->
                                        lists:uniq([CopyrightText | Acc0])
                                end, [], SpdxPackageFiles),
    lists:foldl(fun (Copyright, Acc0) ->
                    <<Copyright/binary, "\n", Acc0/binary>>
                end, <<>>, CopyrightText).

group_files_by_app(Files, PrefixPath) ->
    lists:filter(fun (#{~"fileName" := Filename}) ->
                         case string:prefix(Filename, PrefixPath) of
                             nomatch ->
                                 false;
                             _ ->
                                 true
                         end
                 end, Files).

group_files_by_folder(Files, Wildcard) ->
    FilesInFolder = lists:map(fun unicode:characters_to_binary/1, filelib:wildcard(Wildcard)),
    lists:filter(fun (#{~"fileName" := Filename}) ->
                         lists:member(Filename, FilesInFolder)
                 end, Files).

%%
%% Tool
%%


sbom_package_removal(#{input_file := File, sbom_file := SbomFile}) ->
    Dependencies = decode(File),
    Spdx = decode(SbomFile),

    Spdx1 = remove_dependencies(Spdx, Dependencies),
    file:write_file(SbomFile, json:format(Spdx1)).

remove_dependencies(#{~"packages" := Packages,
                      ~"documentDescribes" := [ ProjectName ],
                      ~"files" := Files,
                      ~"relationships" := Relations}=Spdx, Dependencies) ->

    %% assert that the package to remove is not root
    false = lists:member(ProjectName, Dependencies),

    %%
    %% Filter relationships
    %%
    %% lists of packages to be removed
    Relations1 = fixpoint_package_removal(Relations, Dependencies),

    Relationships = lists:filter(fun (#{~"relatedSpdxElement" := Id, ~"spdxElementId" := ElemId }) ->
                                         not (lists:member(Id, Relations1) orelse lists:member(ElemId, Relations1))
                                 end, Relations),

    {Packages1, RemoveFiles} = lists:foldl(fun(#{~"SPDXID" := Id, ~"hasFiles" := PkgFiles}=Pkg, {Stay, Leave}) ->
                                                   case lists:member(Id, Relations1) of
                                                       true ->
                                                           {Stay, PkgFiles ++ Leave};
                                                       false ->
                                                           {[Pkg | Stay], Leave}
                                                   end
                                           end, {[], []}, Packages),
    Files1 = lists:filter(fun(#{~"SPDXID" := Id}) -> not lists:member(Id, RemoveFiles) end, Files),
    Spdx#{~"packages" := Packages1, ~"relationships" := Relationships, ~"files" := Files1}.


fixpoint_package_removal(Relations, PackagesToRemove) ->
    PackagesToRemove1 =
        lists:uniq(lists:foldl(fun (RelationElem, ToRemovedAcc) ->
                                       PkgToBeRemoved = relation_analysis(RelationElem, PackagesToRemove),
                                       case PkgToBeRemoved of
                                           false ->
                                               ToRemovedAcc;
                                           _ ->
                                               [PkgToBeRemoved | ToRemovedAcc]
                                       end
                               end, PackagesToRemove, Relations)),
    case lists:sort(PackagesToRemove1) == lists:sort(PackagesToRemove) of
        true ->
            PackagesToRemove1;
        false ->
            fixpoint_package_removal(Relations, PackagesToRemove1)
    end.

relation_analysis(#{~"spdxElementId" := ElementId,
                    ~"relatedSpdxElement" := RelatedElement}, PackagesToRemove) ->
    case lists:member(RelatedElement, PackagesToRemove) of
        true ->
            ElementId;
        false ->
            false
    end.


%%
%% Tests
%%

test_file(#{sbom_file := SbomFile}) ->
    Sbom = decode(SbomFile),
    test_generator(Sbom).

test_generator(Sbom) ->
    ok = project_generator(Sbom),
    ok = package_generator(Sbom),
    ok.

project_generator(Sbom) ->
    ok = test_project_name(Sbom),
    ok = test_name(Sbom),
    ok = test_creators_tooling(Sbom),
    ok = test_spdx_version(Sbom),
    ok.

package_generator(Sbom) ->
    ok = test_minimum_apps(Sbom),
    ok = test_copyright_not_empty(Sbom),
    ok = test_filesAnalised(Sbom),
    ok = test_hasFiles_not_empty(Sbom),
    ok = test_homepage(Sbom),
    ok = test_licenseConcluded_exists(Sbom),
    ok = test_licenseDeclared_exists(Sbom),
    ok = test_licenseInfoFromFiles_not_empty(Sbom),
    ok = test_package_names(Sbom),
    ok = test_package_ids(Sbom),
    ok = test_verificationCode(Sbom),
    ok = test_supplier_Ericsson(Sbom),
    ok = test_originator_Ericsson(Sbom),
    ok = test_versionInfo_not_empty(Sbom),
    ok = test_package_hasFiles(Sbom),
    ok = test_project_purl(Sbom),
    ok = test_packages_purl(Sbom),
    ok = test_download_location(Sbom),
    ok = test_package_relations(Sbom),
    ok = test_has_extracted_licenses(Sbom),
    ok = test_snippets(Sbom),
    ok = test_package_removal(Sbom),
    ok = test_vendor_packages(Sbom),
    ok.

test_project_name(#{~"documentDescribes" := [ProjectName]}=_Sbom) ->
    ?spdxref_project_name = ProjectName,
    ok.

test_name(#{~"name" := Name}=_Sbom) ->
    ?spdx_project_name = Name,
    ok.

test_creators_tooling(#{~"creationInfo" := #{~"creators" := Creators}}=_Sbom) ->
    true = lists:any(fun (Name) ->
                             case string:prefix(Name, ?spdx_creators_tooling) of
                                 nomatch -> false;
                                 _ -> true
                             end
                     end, Creators),
    ok.

test_spdx_version(#{~"spdxVersion" := Version}=_Sbom) ->
    ?spdx_version = Version,
    ok.

test_minimum_apps(#{~"documentDescribes" := [ProjectName], ~"packages" := Packages}=_Sbom) ->
    _ = lists:foreach(fun (X) -> application:load(erlang:binary_to_atom(X)) end, minimum_otp_apps()),
    [#{~"name" := Project}] = lists:filter(fun (#{~"SPDXID" := Id}) -> Id == ProjectName end, Packages),
    TestPackageNames = [Project | minimum_otp_apps() ++ root_vendor_packages()],
    SPDXIds = lists:map(fun (#{~"name" := SPDXId}) -> SPDXId end, Packages),
    try
        %% test know packages are captured
        true = [] == TestPackageNames -- SPDXIds
    catch
        _E:_S:_ ->
            io:format("Minimum apps not captured.~n~p distinct from ~p~n", [TestPackageNames -- SPDXIds, SPDXIds -- TestPackageNames]),
            error(?FUNCTION_NAME)
    end,
    AppNamesVersion = lists:map(fun ({Name, Version}) -> {generate_spdxid_name(Name), Version} end, get_otp_apps_from_table()),
    true = lists:all(fun (#{~"SPDXID" := Id, ~"versionInfo" := Version}) ->
                              case lists:keyfind(Id, 1, AppNamesVersion) of
                                  {_, TableVersion} ->
                                      io:format("Table ~p AppVersion ~p, ~p~n", [TableVersion, Version, Id]),
                                      TableVersion == Version;
                                  false ->
                                      true
                              end
                      end, Packages),
    ok.

minimum_otp_apps() ->
    [~"kernel", ~"stdlib", ~"xmerl", ~"wx", ~"tools", ~"tftp", ~"syntax_tools", ~"ssl",
     ~"ssh", ~"snmp", ~"sasl", ~"runtime_tools", ~"reltool", ~"public_key", ~"parsetools",
     ~"os_mon", ~"observer", ~"mnesia", ~"megaco", ~"jinterface", ~"inets", ~"ftp", ~"eunit",
     ~"et", ~"erl_interface", ~"eldap", ~"edoc", ~"diameter", ~"dialyzer", ~"debugger", ~"crypto",
     ~"compiler", ~"common_test", ~"erts", ~"asn1", ~"odbc"].

root_vendor_packages() ->
    [ ~"asmjit", ~"pcre2", ~"zlib", ~"ryu", ~"fp16", ~"zstd"].

minimum_vendor_packages() ->
    %% self-contained
    root_vendor_packages() ++
        [~"tcl", ~"json-test-suite", ~"openssl", ~"Autoconf", ~"wx", ~"jquery", ~"jquery-tablesorter"].

test_copyright_not_empty(#{~"packages" := Packages}) ->
    true = lists:all(fun (#{~"copyrightText" := Copyright}) -> Copyright =/= ~"" end, Packages),
    ok.

test_filesAnalised(#{~"packages" := Packages}) ->
    true = lists:all(fun (#{~"filesAnalyzed" := Bool}) -> Bool = true end, Packages),
    ok.

test_hasFiles_not_empty(#{~"packages" := Packages}) ->
    try
        true = lists:all(fun (#{~"hasFiles" := Files}) -> length(Files) > 0 end, Packages)
    catch
        _:_:_ ->
            lists:map(fun (#{~"hasFiles" := Files, ~"SPDXID":=Id}) ->
                              io:format("~p: length: ~p~n", [Id, length(Files)])
                      end, Packages),
            error(?FUNCTION_NAME)
    end,
    ok.

test_homepage(#{~"packages" := Packages})->
    true = lists:all(fun (#{~"homepage" := Homepage}) -> Homepage == ?spdx_homepage orelse Homepage =/= <<>> end, Packages),
    ok.

test_licenseConcluded_exists(#{~"packages" := Packages}) ->
    true = lists:all(fun (#{~"licenseConcluded" := License}) -> License =/= ~"" andalso License =/= ~"NONE" end, Packages),
    ok.

test_licenseDeclared_exists(#{~"packages" := Packages}) ->
    true = lists:all(fun (#{~"licenseDeclared" := License}) -> License =/= ~"" andalso License =/= ~"NONE" end, Packages),
    ok.

test_licenseInfoFromFiles_not_empty(#{~"packages" := Packages}) ->
    true = lists:all(fun (#{~"licenseInfoFromFiles" := Ls}) ->
                             case Ls of
                                 [] ->
                                     false;
                                 [L | _] when is_list(L) ->
                                     false;
                                 _ ->
                                     true = lists:all(fun (License) -> not erlang:is_integer(License) end, Ls)
                             end
                     end, Packages),

    %% check no duplicates
    true = lists:all(fun (#{~"licenseInfoFromFiles" := Ls}) ->
                             erlang:length(lists:uniq(Ls)) == erlang:length(Ls)
                     end, Packages),
    ok.

test_package_names(#{~"packages" := Packages}) ->
    %% not repeated names
    Names = lists:map(fun (#{~"name" := Name}) -> Name end, Packages),

    %% we know openssl is repeated twice, and Autconf is placed in multiple packages.
    SkippedNames = [~"openssl", ~"Autoconf"],
    Names1 = lists:filter(fun (N) -> not lists:member(N, SkippedNames) end, Names),
    try
        true = length(Names1) == length(lists:uniq(Names1))
    catch
        _:_:_ ->
            io:format("Names are not unique: ~p -- ~p", [Names1, lists:uniq(Names1)]),
            error(?FUNCTION_NAME)
    end,

    true = lists:all(fun (N) -> lists:member(N, Names) end, minimum_otp_apps()),
    ok.

test_package_ids(#{~"packages" := Packages}) ->
    %% Test name starts with SPDXRef-, and contains alphanumeric and -
    true = lists:all(fun (#{~"SPDXID" := <<"SPDXRef-", Rest/binary>>}) ->
                             %% Match on alphanumeric and -
                             Query = "^[a-zA-Z0-9-]*$",
                             {match, _} = re:run(Rest, Query),
                             true
                     end, Packages),
    ok.


test_verificationCode(#{~"packages" := Packages}) ->
    true = lists:all(fun (#{~"packageVerificationCode" := #{~"packageVerificationCodeValue" := Value}}) ->
                             Value =/= ~"TODO" andalso Value =/= <<>>
                     end, Packages),
    ok.

test_supplier_Ericsson(#{~"packages" := Packages}) ->
    true = lists:all(fun (#{~"supplier" := Supplier, ~"name" := Name}) ->
                             %% logical implication (->) expressed in boolean logic (not A or B)
                             not lists:member(Name, minimum_otp_apps()) orelse Supplier == ?spdx_supplier
                     end, Packages),
    ok.

test_originator_Ericsson(#{~"packages" := Packages}) ->
    %% TODO: needs fixing ORT otp
    true = lists:all(fun (#{~"name" := Name}=Spdx) ->
                             case maps:get(~"originator", Spdx, badkey) of
                                 badkey ->
                                     true;
                                 Originator ->
                                     %% logical implication (->) expressed in boolean logic (not A or B)
                                     not lists:member(Name, minimum_otp_apps()) orelse Originator == ?spdx_supplier
                             end
                     end, Packages),
    ok.

test_versionInfo_not_empty(#{~"packages" := Packages}) ->
    true = lists:all(fun (#{~"versionInfo" := Version}) -> Version =/= ~"" end, Packages),
    ok.

test_download_location(#{~"packages" := Packages}) ->
    true = lists:all(fun (#{~"downloadLocation" := Loc}) -> Loc =/= ~"" end, Packages),
    ok.

test_package_hasFiles(#{~"packages" := Packages}) ->
    %% test files are not repeated
    AllFiles = lists:foldl(fun (#{~"hasFiles" := FileIds}, Acc) -> FileIds ++ Acc end, [], Packages),
    true = length(AllFiles) == length(lists:uniq(AllFiles)),

    %% Test all files contain at least one file
    true = lists:all(fun (#{~"hasFiles" := Files}) -> erlang:length(Files) > 0 end, Packages),
    ok.

test_project_purl(#{~"documentDescribes" := [ProjectName], ~"packages" := Packages}=_Sbom) ->
    [#{~"externalRefs" := [Purl]}] = lists:filter(fun (#{~"SPDXID" := Id}) -> ProjectName == Id end, Packages),
    true = Purl == ?spdx_project_purl,
    ok.

test_packages_purl(#{~"documentDescribes" := [ProjectName], ~"packages" := Packages}=_Sbom) ->
    [#{~"externalRefs" := [Purl]}] = lists:filter(fun (#{~"SPDXID" := Id}) -> ProjectName == Id end, Packages),
    true = Purl == ?spdx_project_purl,

    OTPPackages = lists:filter(fun (#{~"SPDXID" := Id, ~"name" := Name}) -> ProjectName =/= Id andalso lists:member(Name, minimum_otp_apps()) end, Packages),
    true = lists:all(fun (#{~"name" := Name, ~"versionInfo" := Version, ~"externalRefs" := [Ref]}) ->
                             ExternalRef = create_externalRef_purl(~"", otp_purl(Name, Version)),
                             maps:remove(~"comment", ExternalRef) == maps:remove(~"comment", Ref)
                     end, OTPPackages),
    ok.

test_vendor_packages(Sbom) ->
    ok = minimum_vendor_packages(Sbom),
    ok = vendor_relations(Sbom),
    ok.

minimum_vendor_packages(#{~"packages" := Packages}=_Sbom) ->
    VendorNames = minimum_vendor_packages(),
    Names = lists:map(fun (#{~"name" := Name}) -> Name end, Packages),
    true = [] == VendorNames -- Names,
    ok.

vendor_relations(#{~"packages" := Packages, ~"relationships" := Relations}) ->
    PackageIds = lists:map(fun (#{~"SPDXID" := Id}) -> Id end, Packages),
    VendorIds = lists:filtermap(fun (#{~"comment" := ~"vendor package", ~"SPDXID" := Id}) -> {true, Id} ;
                                      (_) -> false
                                  end, Packages),
    true = lists:all(fun (#{~"relatedSpdxElement" := Related,
                            ~"relationshipType"   := _,
                            ~"spdxElementId" := PackageId}) ->
                             case lists:member(PackageId, VendorIds) of
                                 true ->
                                     lists:member(Related, PackageIds) andalso
                                         PackageId =/= Related ;
                                 false ->
                                     %% ignore non-vendor relations
                                     true
                             end
                     end, Relations),
    ok.


test_package_relations(#{~"packages" := Packages}=Spdx) ->
    PackageIds = lists:map(fun (#{~"SPDXID" := Id}) -> Id end, Packages),
    Relations = maps:get(~"relationships", Spdx),
    true = lists:all(fun (#{~"relatedSpdxElement" := Related,
                            ~"relationshipType"   := Relation,
                            ~"spdxElementId" := PackageId}) ->
                             lists:member(Relation, [~"PACKAGE_OF", ~"DEPENDS_ON", ~"TEST_OF",
                                                     ~"OPTIONAL_DEPENDENCY_OF", ~"DOCUMENTATION_OF"]) andalso
                                 lists:member(Related, PackageIds) andalso
                                 lists:member(PackageId, PackageIds) andalso
                                 PackageId =/= Related
                     end, Relations),
    ok.

test_has_extracted_licenses(#{~"hasExtractedLicensingInfos" := LicensesInfo,
                              ~"packages" := Packages}=_Spdx) ->
    LicenseRefsInProject =
        lists:uniq(
          lists:foldl(fun (#{~"licenseInfoFromFiles" := InfoFromFilesInPackage }, Acc) ->
                              LicenseRefs = lists:filter(fun (<<"LicenseRef-", _/binary>>) -> true ;
                                                             (_) -> false
                                                         end, InfoFromFilesInPackage),
                              LicenseRefs ++ Acc
                      end, [], Packages)),
    true = lists:all(fun (#{~"licenseId" := LicenseId}) -> lists:member(LicenseId, LicenseRefsInProject) end, LicensesInfo),
    ok.

test_snippets(#{~"snippets" := Snippets, ~"files" := Files}=_Spdx) ->
    true = lists:all(fun (#{ ~"SPDXID" := _Id,
                         ~"copyrightText" := _Copyright,
                         ~"licenseConcluded" := License,
                         ~"licenseInfoInSnippets" := Licenses,
                         ~"name" := _Name,
                         ~"ranges" := [ #{~"endPointer" := #{ ~"lineNumber" := EndLine, ~"reference" := SpdxId},
                                          ~"startPointer" := #{ ~"lineNumber" := StartLine, ~"reference" := SpdxId}},
                                        #{~"endPointer" := #{ ~"offset" := EndOffsetBytes, ~"reference" := SpdxId},
                                          ~"startPointer" := #{ ~"offset" := StartOffsetBytes, ~"reference" := SpdxId}} ],
                         ~"snippetFromFile" := SpdxId}) ->
                       EndLine >= StartLine andalso
                      EndOffsetBytes >= StartOffsetBytes andalso
                      lists:all(fun (L) -> lists:member(L, Licenses) end, split_licenses_in_individual_parts([License])) andalso
                      length(lists:filter(fun (#{~"SPDXID" := Id}) -> SpdxId == Id end, Files)) == 1
                     end, Snippets),
    ok.


test_package_removal(Sbom) ->
    test_remove_erlang_app(Sbom),
    test_remove_erlang_doc(Sbom),
    test_remove_erlang_test(Sbom),
    test_remove_vendor(Sbom),
    ok.

test_remove_erlang_app(Sbom) ->
    PackageToRemove = generate_spdxid_name(~"dialyzer"),
    test_remove_package(Sbom, PackageToRemove),
    ok.

test_remove_erlang_doc(Sbom) ->
    PackageToRemove = generate_spdxid_name(~"dialyzer-documentation"),
    test_remove_package(Sbom, PackageToRemove),
    ok.

test_remove_erlang_test(Sbom) ->
    PackageToRemove = generate_spdxid_name(~"dialyzer-test"),
    test_remove_package(Sbom, PackageToRemove),
    ok.

test_remove_vendor(Sbom) ->
    test_remove_package(Sbom, generate_spdxid_name(~"erts-asmjit")),
    test_remove_package(Sbom, generate_spdxid_name(~"erts-zlib")),
    test_remove_package(Sbom, generate_spdxid_name(~"erts-install-sh")),
    ok.

test_remove_package(Sbom, PackageToRemove) ->
    #{~"packages" := Packages,
      ~"relationships" := Relationships,
      ~"files" := SpdxFiles} = remove_dependencies(Sbom, [PackageToRemove]),
    PackageIds = lists:map(fun (#{~"SPDXID" := Id}) -> Id end, Packages),
    RelatedIds = lists:map(fun (#{~"relatedSpdxElement" := Id}) -> Id end, Relationships),
    ElementIds = lists:map(fun (#{~"spdxElementId" := Id}) -> Id end, Relationships),

    %% test package was removed
    false = lists:member(PackageToRemove, PackageIds),

    %% test package not in related or spdx element id list.
    false = lists:member(PackageToRemove, RelatedIds ++ ElementIds),

    %% TODO test remove package with dependencies and check dependencies are gone.
    [#{~"hasFiles" := FilesRemoved}] =
        lists:filter(fun (#{~"SPDXID" := Id}) -> Id == PackageToRemove end, maps:get(~"packages", Sbom)),
    FileIds = lists:map(fun (#{~"SPDXID" := Id}) -> Id end, SpdxFiles),
    [] = lists:filter(fun (Id) -> lists:member(Id, FileIds) end, FilesRemoved),
    ok.

%% Adds LicenseRef licenses where the text is missing.
extracted_license_info() ->
    [{~"LicenseRef-scancode-wxwindows-free-doc-3",
      ~"""
wxWindows Free Documentation Licence, Version 3
===============================================

Everyone is permitted to copy and distribute verbatim copies
of this licence document, but changing it is not allowed.

                 WXWINDOWS FREE DOCUMENTATION LICENCE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

1. Permission is granted to make and distribute verbatim copies of this
manual or piece of documentation provided any copyright notice and this
permission notice are preserved on all copies.

2. Permission is granted to process this file or document through a
document processing system and, at your option and the option of any third
party, print the results, provided a printed document carries a copying
permission notice identical to this one.

3. Permission is granted to copy and distribute modified versions of this
manual or piece of documentation under the conditions for verbatim copying,
provided also that any sections describing licensing conditions for this
manual, such as, in particular, the GNU General Public Licence, the GNU
Library General Public Licence, and any wxWindows Licence are included
exactly as in the original, and provided that the entire resulting derived
work is distributed under the terms of a permission notice identical to
this one.

4. Permission is granted to copy and distribute translations of this manual
or piece of documentation into another language, under the above conditions
for modified versions, except that sections related to licensing, including
this paragraph, may also be included in translations approved by the
copyright holders of the respective licence documents in addition to the
original English.

                          WARRANTY DISCLAIMER

5. BECAUSE THIS MANUAL OR PIECE OF DOCUMENTATION IS LICENSED FREE OF
CHARGE, THERE IS NO WARRANTY FOR IT, TO THE EXTENT PERMITTED BY APPLICABLE
LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THIS MANUAL OR PIECE OF DOCUMENTATION "AS IS" WITHOUT
WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF
THE MANUAL OR PIECE OF DOCUMENTATION IS WITH YOU.  SHOULD THE MANUAL OR
PIECE OF DOCUMENTATION PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR OR CORRECTION.

6. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE MANUAL OR PIECE OF DOCUMENTATION AS PERMITTED ABOVE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE MANUAL
OR PIECE OF DOCUMENTATION (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES
OR A FAILURE OF A PROGRAM BASED ON THE MANUAL OR PIECE OF DOCUMENTATION TO
OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
"""}].



%% Parts easiest to relate:

%% - Information too scatered
%% - Processes slow us down
%% - Lack of use of best software in class
%% - Coordination with other teams via private repos
%% - no connection to internet from logged computer
