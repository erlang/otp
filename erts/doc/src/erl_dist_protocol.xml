<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE chapter SYSTEM "chapter.dtd">

<chapter>
  <header>
    <copyright>
      <year>2007</year>
      <year>2023</year>
      <holder>Ericsson AB, All Rights Reserved</holder>
    </copyright>
    <legalnotice>
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
 
      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  The Initial Developer of the Original Code is Ericsson AB.
    </legalnotice>

    <title>Distribution Protocol</title>
    <prepared></prepared>
    <docno></docno>
    <date>2007-09-21</date>
    <rev>PA1</rev>
    <file>erl_dist_protocol.xml</file>
  </header>

  <p>This description is far from complete. It will be updated if the
    protocol is updated. However, the protocols, both from Erlang
    nodes to the Erlang Port Mapper Daemon (EPMD) and between Erlang nodes
    are stable since many years.</p>

  <p>The distribution protocol can be divided into four parts:</p>

  <list type="bulleted">
    <item>
      <p>Low-level socket connection (1)</p>
    </item>
    <item>
      <p>Handshake, interchange node name, and authenticate (2)</p>
    </item>
    <item>
      <p>Authentication (done by <seeerl marker="kernel:net_kernel">
        <c>net_kernel(3)</c></seeerl>) (3)</p>
    </item>
    <item>
      <p>Connected (4)</p> 
    </item>
  </list>

  <p>A node fetches the port number of another node through the EPMD (at the
    other host) to initiate a connection request.</p>

  <p>For each host, where a distributed Erlang node is running, also an EPMD
    is to be running. The EPMD can be started explicitly or automatically
    as a result of the Erlang node startup.</p>

  <p>By default the EPMD listens on port 4369.</p>

  <p>(3) and (4) above are performed at the same level but the <c>net_kernel</c>
    disconnects the other node if it communicates using an invalid cookie (after
    1 second).</p>

  <p>The integers in all multibyte fields are in big-endian order.</p>

  <warning>
    <p>
      The Erlang Distribution protocol is not by itself secure and does not
      aim to be so. In order to get secure distribution the distributed nodes
      should be configured to use distribution over tls.
      See the <seeguide marker="ssl:ssl_distribution">
      Using SSL for Erlang Distribution</seeguide> User's Guide
      for details on how to setup a secure distributed node.
    </p>
  </warning>

  <section>
    <title>EPMD Protocol</title>
    <p>The requests served by the EPMD are summarized in the following
      figure.</p>

    <image file="erl_ext_fig.gif">
      <icaption>Summary of EPMD Requests</icaption>
    </image>

    <p>Each request <c>*_REQ</c> is preceded by a 2 byte length field.
      Thus, the overall request format is as follows:</p>

    <table align="left">
      <row>
        <cell align="center">2</cell>
        <cell align="center">n</cell>
      </row>
      <row>
        <cell align="center"><c>Length</c></cell>
        <cell align="center"><c>Request</c></cell>
      </row>
      <tcaption>Request Format</tcaption>
    </table>

    <section>
      <title>Register a Node in EPMD</title>
      <p>When a distributed node is started it registers itself in the EPMD.
        The message <c>ALIVE2_REQ</c> described below is sent from the node to
        the EPMD. The response from the EPMD is <c>ALIVE2_X_RESP</c> (or
        <c>ALIVE2_RESP</c>).</p>

      <table align="left">
        <row>
          <cell align="center">1</cell>
          <cell align="center">2</cell>
          <cell align="center">1</cell>
          <cell align="center">1</cell>
          <cell align="center">2</cell>
          <cell align="center">2</cell>
          <cell align="center">2</cell>
          <cell align="center">Nlen</cell>
          <cell align="center">2</cell>
          <cell align="center">Elen</cell>
        </row>
        <row>
          <cell align="center"><c>120</c></cell>
          <cell align="center"><c>PortNo</c></cell>
          <cell align="center"><c>NodeType</c></cell>
          <cell align="center"><c>Protocol</c></cell>
          <cell align="center"><c>HighestVersion</c></cell>
          <cell align="center"><c>LowestVersion</c></cell>
          <cell align="center"><c>Nlen</c></cell>
          <cell align="center"><c>NodeName</c></cell>
          <cell align="center"><c>Elen</c></cell>
          <cell align="center"><c>Extra</c></cell>
        </row>
        <tcaption>ALIVE2_REQ (120)</tcaption>
      </table>

      <taglist>
        <tag><c>PortNo</c></tag>
        <item>
          <p>The port number on which the node accept connection requests.</p>
        </item>
        <tag><c>NodeType</c></tag>
        <item>
          <p>77 = normal Erlang node, 72 = hidden node (C-node), ...</p>
        </item>
        <tag><c>Protocol</c></tag>
        <item>
          <p>0 = TCP/IPv4, ...</p>
        </item>
        <tag><c>HighestVersion</c></tag>
        <item>
          <p>The highest distribution protocol version this node can handle.
            The value in OTP 23 and later is 6. Older nodes only support version 5.</p>
        </item>
        <tag><c>LowestVersion</c></tag>
        <item>
          <p>The lowest distribution version that this node can handle.
            The value in OTP 25 and later is 6 as support for connections to
	    nodes older than OTP 23 has been dropped.</p>
        </item>
        <tag><c>Nlen</c></tag>
        <item>
          <p>The length (in bytes) of field <c>NodeName</c>.</p>
        </item>
        <tag><c>NodeName</c></tag>
        <item>
          <p>The node name as an UTF-8 encoded string of <c>Nlen</c> bytes.</p>
        </item>
        <tag><c>Elen</c></tag>
        <item>
          <p>The length of field <c>Extra</c>.</p>
        </item>
        <tag><c>Extra</c></tag>
        <item>
          <p>Extra field of <c>Elen</c> bytes.</p>
        </item>
      </taglist>

      <p>The connection created to the EPMD must be kept as long as the
        node is a distributed node. When the connection is closed,
        the node is automatically unregistered from the EPMD.</p>

      <p>The response message is either <c>ALIVE2_X_RESP</c> or
        <c>ALIVE2_RESP</c> depending on distribution version. If both the node
        and EPMD support distribution version 6 then the response is
        <c>ALIVE2_X_RESP</c> otherwise it is the older <c>ALIVE2_RESP</c>:</p>

      <table align="left">
        <row>
          <cell align="center">1</cell>
          <cell align="center">1</cell>
          <cell align="center">4</cell>
        </row>
        <row>
          <cell align="center"><c>118</c></cell>
          <cell align="center"><c>Result</c></cell>
          <cell align="center"><c>Creation</c></cell>
        </row>
        <tcaption>ALIVE2_X_RESP (118) with 32 bit creation</tcaption>
      </table>

      <table align="left">
        <row>
          <cell align="center">1</cell>
          <cell align="center">1</cell>
          <cell align="center">2</cell>
        </row>
        <row>
          <cell align="center"><c>121</c></cell>
          <cell align="center"><c>Result</c></cell>
          <cell align="center"><c>Creation</c></cell>
        </row>
        <tcaption>ALIVE2_RESP (121) with 16-bit creation</tcaption>
      </table>

      <p>Result = 0 -> ok, result &gt; 0 -> error.</p>
    </section>

    <section>
      <title>Unregister a Node from EPMD</title>
      <p>A node unregisters itself from the EPMD by closing the TCP
        connection to EPMD established when the node was registered.</p>
    </section>

    <section>
      <title>Get the Distribution Port of Another Node</title>
      <p>When one node wants to connect to another node it starts with
        a <c>PORT_PLEASE2_REQ</c> request to the EPMD on the host where the
        node resides to get the distribution port that the node listens to.</p>

      <table align="left">
        <row>
          <cell align="center">1</cell>
          <cell align="center">N</cell>
        </row>
        <row>
          <cell align="center"><c>122</c></cell>
          <cell align="center"><c>NodeName</c></cell>
        </row>
        <tcaption>PORT_PLEASE2_REQ (122)</tcaption>
      </table>

      <p>where N = <c>Length</c> - 1.</p>

      <table align="left">
        <row>
          <cell align="center">1</cell>
          <cell align="center">1</cell>
        </row>
        <row>
          <cell align="center"><c>119</c></cell>
          <cell align="center"><c>Result</c></cell>
        </row>
        <tcaption>PORT2_RESP (119) Response Indicating Error, Result &gt; 0
        </tcaption>
      </table>

      <p>or</p>

      <table align="left">
        <row>
          <cell align="center">1</cell>
          <cell align="center">1</cell>
          <cell align="center">2</cell>
          <cell align="center">1</cell>
          <cell align="center">1</cell>
          <cell align="center">2</cell>
          <cell align="center">2</cell>
          <cell align="center">2</cell>
          <cell align="center">Nlen</cell>
          <cell align="center">2</cell>
          <cell align="center">Elen</cell>
        </row>
        <row>
          <cell align="center"><c>119</c></cell>
          <cell align="center"><c>Result</c></cell>
          <cell align="center"><c>PortNo</c></cell>
          <cell align="center"><c>NodeType</c></cell>
          <cell align="center"><c>Protocol</c></cell>
          <cell align="center"><c>HighestVersion</c></cell>
          <cell align="center"><c>LowestVersion</c></cell>
          <cell align="center"><c>Nlen</c></cell>
          <cell align="center"><c>NodeName</c></cell>
          <cell align="center"><c>Elen</c></cell>
          <cell align="center">><c>Extra</c></cell>
        </row>
        <tcaption>PORT2_RESP, Result = 0</tcaption>
      </table>

      <p>If <c>Result</c> &gt; 0, the packet only consists of
        <c>[119, Result]</c>.</p>

      <p>The EPMD closes the socket when it has sent the information.</p>
    </section>

    <section>
      <title>Get All Registered Names from EPMD</title>
      <p>This request is used through the Erlang function
        <seemfa marker="kernel:net_adm#names/1">
        <c>net_adm:names/1,2</c></seemfa>. A TCP connection is opened
        to the  EPMD and this request is sent.</p>

      <table align="left">
        <row>
          <cell align="center">1</cell>
        </row>
        <row>
          <cell align="center"><c>110</c></cell>
        </row>
        <tcaption>NAMES_REQ (110)</tcaption>
      </table>	

      <p>The response for a <c>NAMES_REQ</c> is as follows:</p>

      <table align="left">
        <row>
          <cell align="center">4</cell>
          <cell align="center">&nbsp;</cell>
        </row>
        <row>
          <cell align="center"><c>EPMDPortNo</c></cell>
          <cell align="center"><c>NodeInfo*</c></cell>
        </row>
        <tcaption>NAMES_RESP</tcaption>
      </table>

      <p><c>NodeInfo</c> is a string written for each active node.
        When all <c>NodeInfo</c> has been written the connection is
        closed by the EPMD.</p>

      <p><c>NodeInfo</c> is, as expressed in Erlang:</p>

      <code>
io:format("name ~ts at port ~p~n", [NodeName, Port]).</code>
    </section>

    <section>
      <title>Dump All Data from EPMD</title>
      <p>This request is not really used, it is to be regarded as a debug
        feature.</p>

      <table align="left">
        <row>
          <cell align="center">1</cell>
        </row>
        <row>
          <cell align="center"><c>100</c></cell>
        </row>
        <tcaption>DUMP_REQ</tcaption>
      </table>

      <p>The response for a <c>DUMP_REQ</c> is as follows:</p>

      <table align="left">
        <row>
          <cell align="center">4</cell>
          <cell align="center">&nbsp;</cell>
        </row>
        <row>
          <cell align="center"><c>EPMDPortNo</c></cell>
          <cell align="center"><c>NodeInfo*</c></cell>
        </row>
        <tcaption>DUMP_RESP</tcaption>
      </table>

      <p><c>NodeInfo</c> is a string written for each node kept in the EPMD.
        When all <c>NodeInfo</c> has been written the connection is
        closed by the EPMD.</p>

      <p><c>NodeInfo</c> is, as expressed in Erlang:</p>

      <code>
io:format("active name     ~ts at port ~p, fd = ~p~n",
          [NodeName, Port, Fd]).</code>

      <p>or</p>

      <code>
io:format("old/unused name ~ts at port ~p, fd = ~p ~n",
          [NodeName, Port, Fd]).</code>
    </section>

    <section>
      <title>Kill EPMD</title>
      <p>This request kills the running EPMD. It is almost never used.</p>

      <table align="left">
        <row>
          <cell align="center">1</cell>
        </row>
        <row>
          <cell align="center"><c>107</c></cell>
        </row>
        <tcaption>KILL_REQ</tcaption>
      </table>

      <p>The response for a <c>KILL_REQ</c> is as follows:</p>

      <table align="left">
        <row>
          <cell align="center">2</cell>
        </row>
        <row>
          <cell align="center"><c>OKString</c></cell>
        </row>
        <tcaption>KILL_RESP</tcaption>
      </table>

      <p>where <c>OKString</c> is "OK".</p>
    </section>

    <section>
      <title>STOP_REQ  (Not Used)</title>
      <table align="left">
        <row>
          <cell align="center">1</cell>
          <cell align="center">n</cell>
        </row>
        <row>
          <cell align="center"><c>115</c></cell>
          <cell align="center"><c>NodeName</c></cell>
        </row>
        <tcaption>STOP_REQ</tcaption>
      </table>

      <p>where n = <c>Length</c> - 1.</p>

      <p>The response for a <c>STOP_REQ</c> is as follows:</p>

      <table align="left">
        <row>
          <cell align="center">7</cell>
        </row>
        <row>
          <cell align="center"><c>OKString</c></cell>
        </row>
        <tcaption>STOP_RESP</tcaption>
      </table>

      <p>where <c>OKString</c> is "STOPPED".</p>

      <p>A negative response can look as follows:</p>

      <table align="left">
        <row>
          <cell align="center">7</cell>
        </row>
        <row>
          <cell align="center"><c>NOKString</c></cell>
        </row>
        <tcaption>STOP_NOTOK_RESP</tcaption>
      </table>

      <p>where <c>NOKString</c> is "NOEXIST".</p>
    </section>
<!--
    <section>
      <title>ALIVE_REQ (97)</title>
      <table align="left">
        <row>
          <cell align="center">1</cell>
          <cell align="center">2</cell>
          <cell align="center">n</cell>
        </row>
        <row>
          <cell align="center"><c>97</c></cell>
          <cell align="center"><c>PortNo</c></cell>
          <cell align="center"><c>NodeName</c></cell>
        </row>
        <tcaption></tcaption>
      </table>

      <p>where n = <c>Length</c> - 3.</p>

      <p>The connection created to the EPMD must be kept until the node is
        not a distributed node any longer.</p>
    </section>

    <section>
      <title>ALIVE_OK_RESP (89)</title>
      <table align="left">
        <row>
          <cell align="center">1</cell>
          <cell align="center">2</cell>
        </row>
        <row>
          <cell align="center"><c>89</c></cell>
          <cell align="center"><c>Creation</c></cell>
        </row>
        <tcaption></tcaption>
      </table>
    </section>

    <section>
      <title>ALIVE_NOTOK_RESP ()</title>
      <p>The EPMD closed the connection.</p>
    </section>

    <section>
      <title>PORT_PLEASE_REQ (112)</title>
      <table align="left">
        <row>
          <cell align="center">1</cell>
          <cell align="center">n</cell>
        </row>
        <row>
          <cell align="center"><c>112</c></cell>
          <cell align="center"><c>NodeName</c></cell>
        </row>
        <tcaption></tcaption>
      </table>

      <p>where n = <c>Length</c> - 1.</p>
    </section>

    <section>
      <title>PORT_OK_RESP ()</title>
      <table align="left">
        <row>
          <cell align="center">2</cell>
        </row>
        <row>
          <cell align="center"><c>PortNo</c></cell>
        </row>
        <tcaption></tcaption>
      </table>
    </section>

    <section>
      <title>PORT_NOTOK_RESP ()</title>
      <p>The EPMD closed the connection.</p>
    </section>

    <section>
      <title>PORT_NOTOK_RESP ()</title>
      <p>The EPMD closed the connection.</p>
    </section>
-->
  </section>

  <section>
    <marker id="distribution_handshake"/>
    <title>Distribution Handshake</title>
    <p>
      This section describes the distribution handshake protocol used between
      nodes to establishing a connection. The protocol was introduced in
      Erlang/OTP R6 and amended in OTP 23. From OTP 25 support for the older
      protocol was dropped. Therefore an OTP 25 node can not connect to nodes
      older than OTP 23. This documentation only decribes the part of the
      protocol used by OTP 25.
    </p>
    <note>
      <p>
	A bug introduced in OTP 25.0 may cause OTP 25 nodes to reject connection
	attempts from OTP 23 and 24 nodes that are not using <c>epmd</c> to gain
	version information about the remote node.
	This is fixed in OTP 25.3.
      </p>
    </note>
    <section>
      <title>General</title>
      <p>The TCP/IP distribution uses a handshake that expects a
        connection-based protocol, that is, the protocol does not include any
        authentication after the handshake procedure.</p>

      <p>This is not entirely safe, as it is vulnerable against takeover
        attacks, but it is a tradeoff between fair safety and performance.</p>

      <p>The cookies are never sent in cleartext and the handshake procedure
        expects the client (called <c>A</c>) to be the first one to prove that
        it can generate a sufficient digest. The digest is generated with the
        MD5 message digest algorithm and the challenges are expected to be
        random numbers.</p>
    </section>

    <section>
      <title>Definitions</title>
      <p>A challenge is a 32-bit integer in big-endian order. Below the function
        <c>gen_challenge()</c> returns a random 32-bit integer used as a
        challenge.</p>

      <p>A digest is a (16 bytes) MD5 hash of the challenge (as text)
        concatenated with the cookie (as text). Below, the function
        <c>gen_digest(Challenge, Cookie)</c> generates a digest as described
        above.</p>

      <p>An <c>out_cookie</c> is the cookie used in outgoing communication to a
        certain node, so that <c>A</c>'s <c>out_cookie</c> for <c>B</c> is to
        correspond with <c>B</c>'s <c>in_cookie</c> for <c>A</c> and conversely.
        <c>A</c>'s <c>out_cookie</c> for <c>B</c> and <c>A</c>'s
        <c>in_cookie</c> for <c>B</c> need <em>not</em> be the same. Below the
        function <c>out_cookie(Node)</c> returns the current node's
        <c>out_cookie</c> for <c>Node</c>.</p>

      <p>An <c>in_cookie</c> is the cookie expected to be used by another node
        when communicating with us, so that <c>A</c>'s <c>in_cookie</c> for
        <c>B</c> corresponds with <c>B</c>'s <c>out_cookie</c> for <c>A</c>.
        Below the function <c>in_cookie(Node)</c> returns the current node's
        <c>in_cookie</c> for <c>Node</c>.</p>

      <p>The cookies are text strings that can be viewed as passwords.</p>

      <p>Every message in the handshake starts with a 16-bit big-endian integer,
        which contains the message length (not counting the two initial bytes).
        In Erlang this corresponds to option <c>{packet, 2}</c> in
        <seeerl marker="kernel:gen_tcp"><c>gen_tcp(3)</c></seeerl>.
        Notice that after the handshake, the distribution switches to 4 byte
        packet headers.</p>
    </section>

    <section>
      <title>The Handshake in Detail</title>
      <p>Imagine two nodes, <c>A</c> that initiates the handshake and <c>B</c>
        that accepts the connection.</p>

      <taglist>
      <tag>1) connect/accept</tag>
        <item>
          <p><c>A</c> connects to <c>B</c> through TCP/IP and <c>B</c> accepts
            the connection.</p>
        </item>
        <tag>2) <c>send_name</c>/<c>receive_name</c></tag>
        <item>
          <p><c>A</c> sends an initial identification to <c>B</c>, which
            receives the message. The message can have two different formats
	    which looks as follows (the packet headers are removed):
	  </p>
	  <table align="left">
            <row>
              <cell align="center">1</cell>
              <cell align="center">2</cell>
              <cell align="center">4</cell>
	      <cell align="center">Nlen</cell>
            </row>
            <row>
              <cell align="center"><c>'n'</c></cell>
              <cell align="center"><c>Version=5</c></cell>
              <cell align="center"><c>Flags</c></cell>
	      <cell align="center"><c>Name</c></cell>
            </row>
            <tcaption>Old send_name ('n') for protocol version 5</tcaption>
	  </table>

	  <table align="left">
            <row>
              <cell align="center">1</cell>
              <cell align="center">8</cell>
              <cell align="center">4</cell>
	      <cell align="center">2</cell>
	      <cell align="center">Nlen</cell>
            </row>
            <row>
              <cell align="center"><c>'N'</c></cell>
              <cell align="center"><c>Flags</c></cell>
	      <cell align="center"><c>Creation</c></cell>
	      <cell align="center"><c>Nlen</c></cell>
	      <cell align="center"><c>Name</c></cell>
            </row>
            <tcaption>New send_name ('N') for protocol version 6</tcaption>
	  </table>

	  <p>
	    The old <c>send_name</c> format is only sent from OTP 23 and 24
	    nodes that are not using <c>epmd</c> and therefore do not know if
	    the remote node only supports protocol version 5. The <c>Version</c> is
	    a 16-bit big endian integer and <em>must</em> always have the value
	    5 (even though node <c>A</c> supports version 6). <c>Flags</c> are the
	    <seeguide marker="#dflags">capability flags</seeguide>
	    of node <c>A</c> in 32-bit big endian. The flag bit
	    <seeguide marker="#DFLAG_HANDSHAKE_23"><c>DFLAG_HANDSHAKE_23</c></seeguide>
	    must be set (as node <c>A</c> must supports version 6).
	    <c>Name</c> is the full node name of <c>A</c>, as a string of bytes
	    (the packet length denotes how long it is).
	  </p>
	  <p>
	    The new <c>send_name</c> is sent to
	    nodes known to support version 6. <c>Flags</c> are the
	    <seeguide marker="#dflags">capability flags</seeguide> of node
	    <c>A</c> in 64-bit big endian. The flag bit
	    <seeguide marker="#DFLAG_HANDSHAKE_23"><c>DFLAG_HANDSHAKE_23</c></seeguide>
            must always be set. <c>Creation</c> is the node incarnation
	    identifier used by node <c>A</c> to create its pids, ports and
	    references. <c>Name</c> is the full node name of <c>A</c>, as a
	    string of bytes. <c>Nlen</c> is the byte length of the node name in
	    16-bit big endian. Any extra data after the node <c>Name</c> must be
	    accepted and ignored.
	  </p>
          <p>
            The <c>Name</c> must be just the host name (without @) when
            <seeguide marker="#DFLAG_NAME_ME"><c>DFLAG_NAME_ME</c></seeguide>
            is set.
          </p>
        </item>
        <tag>3) <c>recv_status</c>/<c>send_status</c></tag>
        <item>
          <p>
	    <c>B</c> sends a status message to <c>A</c>, which indicates if the
            connection is allowed.
	  </p>
	  <table align="left">
            <row>
              <cell align="center">1</cell>
	      <cell align="center">Slen</cell>
            </row>
            <row>
              <cell align="center"><c>'s'</c></cell>
	      <cell align="center"><c>Status</c></cell>
            </row>
            <tcaption>The format of the status message</tcaption>
	  </table>
          <p>
	    's' is the message tag. <c>Status</c> is the status code as a
            string (not null terminated). The following status codes are
	    defined:
	  </p>
          <taglist>
            <tag><c>ok</c></tag>
            <item>
              <p>The handshake will continue.</p>
            </item>
            <tag><c>ok_simultaneous</c></tag>
            <item>
              <p>The handshake will continue, but <c>A</c> is informed that
                <c>B</c> has another ongoing connection attempt that will be
                shut down (simultaneous connect where <c>A</c>'s name is
                greater than <c>B</c>'s name, compared literally).</p>
            </item>
            <tag><c>nok</c></tag>
            <item>
              <p>The handshake will not continue, as <c>B</c> already has an
                ongoing handshake, which it itself has initiated (simultaneous
                connect where <c>B</c>'s name is greater than <c>A</c>'s).</p>
            </item>
            <tag><c>not_allowed</c></tag>
            <item>
              <p>The connection is disallowed for some (unspecified) security
                reason.</p>
            </item>
            <tag><c>alive</c></tag>
            <item>
              <p>A connection to the node is already active, which either means
                that node <c>A</c> is confused or that the TCP connection
                breakdown of a previous node with this name has not yet reached
                node <c>B</c>. See step 3B below.</p>
            </item>
	    <tag><c>named:</c></tag>
            <item><p>
	      The handshake will continue, but <c>A</c> requested a dynamic
	      node name by setting flag <seeguide marker="#DFLAG_NAME_ME">
	      <c>DFLAG_NAME_ME</c></seeguide>. The dynamic node name of
	      <c>A</c> is supplied at the end of the status message from
	      <c>B</c>. The host name of <c>A</c> which was sent as <c>Name</c>
              in <c>send_name</c> will be used by node <c>B</c> to generate
              the full dynamic node name.</p>
	      <table align="left">
		<row>
		  <cell align="center">1</cell>
		  <cell align="center">Slen=6</cell>
		  <cell align="center">2</cell>
		  <cell align="center">Nlen</cell>
		  <cell align="center">4</cell>
		</row>
		<row>
		  <cell align="center"><c>'s'</c></cell>
		  <cell align="center"><c>Status='named:'</c></cell>
		  <cell align="center"><c>Nlen</c></cell>
		  <cell align="center"><c>Name</c></cell>
		  <cell align="center"><c>Creation</c></cell>
		</row>
		<tcaption>The format of the 'named:' status message</tcaption>
	      </table>
	      <p>
		<c>Name</c> is the full dynamic node name of <c>A</c>, as a
		string of bytes. <c>Nlen</c> is the byte length of the node name in
		16-bit big endian. <c>Creation</c> is the incarnation identifier
		of node <c>A</c> generated by node <c>B</c>.
		Any extra data after the node <c>Creation</c> must be accepted and ignored.
	      </p>
	    </item>
          </taglist>
          </item>
        <tag>3B) <c>send_status</c>/<c>recv_status</c></tag>
        <item>
          <p>If status was <c>alive</c>, node <c>A</c> answers with another
            status message containing either <c>true</c>, which means that the
            connection is to continue (the old connection from this node is
            broken), or <c>false</c>, which means that the connection is to be
            closed (the connection attempt was a mistake.</p>
        </item>
        <tag>4) <c>recv_challenge</c>/<c>send_challenge</c></tag>
        <item>
          <p>If the status was <c>ok</c> or <c>ok_simultaneous</c>, the
            handshake continues with <c>B</c> sending <c>A</c> another message,
            the challenge. The challenge contains the same type of information
            as the "name" message initially sent from <c>A</c> to <c>B</c>, plus
            a 32-bit challenge:
	  </p>
	  <table align="left">
            <row>
              <cell align="center">1</cell>
	      <cell align="center">8</cell>
	      <cell align="center">4</cell>
	      <cell align="center">4</cell>
	      <cell align="center">2</cell>
	      <cell align="center">Nlen</cell>
            </row>
            <row>
              <cell align="center"><c>'N'</c></cell>
	      <cell align="center"><c>Flags</c></cell>
	      <cell align="center"><c>Challenge</c></cell>
	      <cell align="center"><c>Creation</c></cell>
	      <cell align="center"><c>Nlen</c></cell>
	      <cell align="center"><c>Name</c></cell>
            </row>
            <tcaption>The new challenge message format (version 6)</tcaption>
	  </table>
          <p>
	    <c>Challenge</c> is a 32-bit big-endian integer. The other fields
	    are node <c>B</c>'s flags, creation and full node name, similar to
	    the <c>send_name</c> message. Any extra data after the node
            <c>Name</c> must be accepted and ignored.
	  </p>
	</item>
        <tag>4B) <c>send_complement</c>/<c>recv_complement</c></tag>
        <item>
          <p>
	    The complement message, from <c>A</c> to <c>B</c>, is only sent if
	    node <c>A</c> initially sent an old name message. It contains complementary
	    information missing in the initial old name message from node <c>A</c>.
	  </p>
	  <table align="left">
            <row>
              <cell align="center">1</cell>
	      <cell align="center">4</cell>
	      <cell align="center">4</cell>
            </row>
            <row>
              <cell align="center"><c>'c'</c></cell>
	      <cell align="center"><c>FlagsHigh</c></cell>
	      <cell align="center"><c>Creation</c></cell>
            </row>
            <tcaption>The complement message</tcaption>
	  </table>
	  <p>
	    <c>FlagsHigh</c> are the high capability flags (bit 33-64) of node
	    <c>A</c> as a 32-bit big endian integer. <c>Creation</c> is the
	    incarnation identifier of node <c>A</c>.
	  </p>
        </item>

        <tag>5) <c>send_challenge_reply</c>/<c>recv_challenge_reply</c></tag>
        <item>
          <p>Now <c>A</c> has generated a digest and its own challenge. Those
            are sent together in a package to <c>B</c>:</p>
	  <table align="left">
            <row>
              <cell align="center">1</cell>
	      <cell align="center">4</cell>
	      <cell align="center">16</cell>
            </row>
            <row>
              <cell align="center"><c>'r'</c></cell>
	      <cell align="center"><c>Challenge</c></cell>
	      <cell align="center"><c>Digest</c></cell>
            </row>
            <tcaption>The challenge_reply message</tcaption>
	  </table>
          <p>
	    <c>Challenge</c> is <c>A</c>'s challenge for <c>B</c> to
	    handle. <c>Digest</c> is the MD5 digest that <c>A</c> constructed
	    from the challenge <c>B</c> sent in the previous step.
	  </p>
        </item>
        <tag>6) <c>recv_challenge_ack</c>/<c>send_challenge_ack</c></tag>
        <item>
          <p><c>B</c> checks that the digest received from <c>A</c> is correct
            and generates a digest from the challenge received from <c>A</c>.
            The digest is then sent to <c>A</c>. The message is as follows:</p>
	  <table align="left">
            <row>
              <cell align="center">1</cell>
	      <cell align="center">16</cell>
            </row>
            <row>
              <cell align="center"><c>'a'</c></cell>
	      <cell align="center"><c>Digest</c></cell>
            </row>
            <tcaption>The challenge_ack message</tcaption>
	  </table>
          <p>
	    <c>Digest</c> is the digest calculated by <c>B</c> for <c>A</c>'s
	    challenge.
	  </p>
        </item>
        <tag>7) check</tag>
        <item>
          <p><c>A</c> checks the digest from <c>B</c> and the connection is
            up.</p>
        </item>
      </taglist>
    </section>

    <section>
      <title>Semigraphic View</title>
      <pre>
A (initiator)                                      B (acceptor)

TCP connect ------------------------------------&gt;
                                                   TCP accept

send_name --------------------------------------&gt;
                                                   recv_name

  &lt;---------------------------------------------- send_status
recv_status
(if status was 'alive'
 send_status - - - - - - - - - - - - - - - - - -&gt;
                                                   recv_status)

                          (ChB)                      ChB = gen_challenge()
  &lt;---------------------------------------------- send_challenge
recv_challenge

(if old send_name
 send_complement - - - - - - - - - - - - - - - -&gt;
                                                   recv_complement)

ChA = gen_challenge(),
OCA = out_cookie(B),
DiA = gen_digest(ChB, OCA)
                          (ChA, DiA)
send_challenge_reply ---------------------------&gt;
                                                   recv_challenge_reply
                                                   ICB = in_cookie(A),
                                                   check:
                                                   DiA == gen_digest (ChB, ICB)?
                                                   - if OK:
                                                    OCB = out_cookie(A),
                                                    DiB = gen_digest (ChA, OCB)
                          (DiB)
  &lt;----------------------------------------------- send_challenge_ack
recv_challenge_ack                                  DONE
ICA = in_cookie(B),                                - else:
check:                                              CLOSE
DiB == gen_digest(ChA, ICA)?
- if OK:
 DONE
- else:
 CLOSE</pre>
    </section>

    <section>
      <marker id="dflags"/>
      <title>Distribution Flags</title>
      <p>Early in the distribution handshake the two participating nodes
      exchange capability flags. This is done in order to determine how the
      communication between the two nodes should be performed. The intersection
      of the capabilities presented by the two nodes defines the capabilities
      that will be used. The following capability flags are defined:</p>
      <taglist>
        <tag><c>-define(DFLAG_PUBLISHED,16#1).</c></tag>
        <item>
          <p>The node is to be published and part of the global namespace.</p>
        </item>
        <tag><c>-define(DFLAG_ATOM_CACHE,16#2).</c></tag>
        <item>
          <p>The node implements an atom cache (obsolete).</p>
        </item>
        <tag><c>-define(DFLAG_EXTENDED_REFERENCES,16#4).</c></tag>
        <item>
          <p>The node implements extended (3 &times; 32 bits) references. This
            flag is mandatory. If not present, the  connection is refused.</p>
        </item>
        <tag><c>-define(DFLAG_DIST_MONITOR,16#8).</c></tag>
        <item>
          <p>The node implements distributed process monitoring.</p>
        </item>
        <tag><c>-define(DFLAG_FUN_TAGS,16#10).</c></tag>
        <item>
          <p>The node uses separate tags for funs (lambdas) in the
          distribution protocol. This flag is mandatory. If not
          present, the connection is refused.</p>
        </item>
        <tag><c>-define(DFLAG_DIST_MONITOR_NAME,16#20).</c></tag>
        <item>
          <p>The node implements distributed named process monitoring.</p>
        </item>
        <tag><c>-define(DFLAG_HIDDEN_ATOM_CACHE,16#40).</c></tag>
        <item>
          <p>The (hidden) node implements atom cache (obsolete).</p>
        </item>
        <tag><c>-define(DFLAG_NEW_FUN_TAGS,16#80).</c></tag>
        <item>
	  <p>The node understands the <seeguide
	  marker="erl_ext_dist#NEW_FUN_EXT">
	  <c>NEW_FUN_EXT</c></seeguide> tag. This flag is
	  mandatory. If not present, the connection is refused.</p>
        </item>
        <tag><c>-define(DFLAG_EXTENDED_PIDS_PORTS,16#100).</c></tag>
        <item>
          <p>The node can handle extended pids and ports. This
          flag is mandatory.  If not present, the connection is
          refused.</p>
        </item>
        <tag><c>-define(DFLAG_EXPORT_PTR_TAG,16#200).</c></tag>
        <item>
	  <p>The node understands the <seeguide marker="erl_ext_dist#EXPORT_EXT">
	  <c>EXPORT_EXT</c></seeguide> tag.
          This flag is mandatory. If not present, the connection is refused.
          </p>
        </item>
        <tag><c>-define(DFLAG_BIT_BINARIES,16#400).</c></tag>
        <item>
	  <p>The node understands the <seeguide marker="erl_ext_dist#BIT_BINARY_EXT">
	  <c>BIT_BINARY_EXT</c></seeguide> tag.
          This flag is mandatory. If not present, the connection is refused.</p>
        </item>
        <tag><c>-define(DFLAG_NEW_FLOATS,16#800).</c></tag>
        <item>
	  <p>The node understands the <seeguide marker="erl_ext_dist#NEW_FLOAT_EXT">
	  <c>NEW_FLOAT_EXT</c></seeguide> tag. This flag is
	  mandatory. If not present, the connection is refused.</p>
        </item>
        <tag><c>-define(DFLAG_UNICODE_IO,16#1000).</c></tag>
        <item>
        </item>
        <tag><c>-define(DFLAG_DIST_HDR_ATOM_CACHE,16#2000).</c></tag>
        <item>
          <p>The node implements atom cache in distribution header.</p>
        </item>
        <tag><marker id="DFLAG_SMALL_ATOM_TAGS"/><c>-define(DFLAG_SMALL_ATOM_TAGS, 16#4000).</c></tag>
        <item>
          <p>The node understands the <seeguide marker="erl_ext_dist#SMALL_ATOM_EXT">
	  <c>SMALL_ATOM_EXT</c></seeguide> tag.</p>
        </item>
        <tag><marker id="DFLAG_UTF8_ATOMS"/><c>-define(DFLAG_UTF8_ATOMS, 16#10000).</c></tag>
        <item>
          <p>The node understands UTF-8 atoms encoded with
	    <seeguide marker="erl_ext_dist#ATOM_UTF8_EXT">
	    <c>ATOM_UTF8_EXT</c></seeguide> and
	    <seeguide marker="erl_ext_dist#SMALL_ATOM_UTF8_EXT">
	      <c>SMALL ATOM_UTF8_EXT</c></seeguide>.  This flag is
	      mandatory. If not present, the connection is refused.</p>
        </item>
        <tag><c>-define(DFLAG_MAP_TAG, 16#20000).</c></tag>
        <item>
          <p>The node understands the map tag
	  <seeguide marker="erl_ext_dist#MAP_EXT"><c>MAP_EXT</c></seeguide>. This flag is
	  mandatory. If not present, the connection is refused.</p>
        </item>
        <tag><marker id="DFLAG_BIG_CREATION"/><c>-define(DFLAG_BIG_CREATION, 16#40000).</c></tag>
        <item>
          <p>The node understands big node creation tags
	  <seeguide marker="erl_ext_dist#NEW_PID_EXT"><c>NEW_PID_EXT</c></seeguide>,
	  <seeguide marker="erl_ext_dist#NEW_PORT_EXT"><c>NEW_PORT_EXT</c></seeguide> and
	  <seeguide marker="erl_ext_dist#NEWER_REFERENCE_EXT"><c>NEWER_REFERENCE_EXT</c></seeguide>.
          This flag is mandatory. If not present, the connection is refused.</p>
        </item>
        <tag><c>-define(DFLAG_SEND_SENDER, 16#80000).</c></tag>
        <item>
          <p>
	    Use the <c>SEND_SENDER</c>
	    <seeguide marker="#control_message">control message</seeguide>
	    instead of the <c>SEND</c> control message and use the
	    <c>SEND_SENDER_TT</c> control message instead
	    of the <c>SEND_TT</c> control message.
	  </p>
        </item>
        <tag><c>-define(DFLAG_BIG_SEQTRACE_LABELS, 16#100000).</c></tag>
        <item>
          <p>The node understands any term as the seqtrace label.</p>
        </item>
        <tag><c>-define(DFLAG_EXIT_PAYLOAD, 16#400000).</c></tag>
        <item>
          <p>Use the <c>PAYLOAD_EXIT</c>, <c>PAYLOAD_EXIT_TT</c>,
            <c>PAYLOAD_EXIT2</c>, <c>PAYLOAD_EXIT2_TT</c>
            and <c>PAYLOAD_MONITOR_P_EXIT</c>
            <seeguide marker="#control_message">control message</seeguide>s
            instead of the non-PAYLOAD variants.</p>
        </item>
        <tag><marker id="DFLAG_FRAGMENTS"/><c>-define(DFLAG_FRAGMENTS, 16#800000).</c></tag>
        <item>
          <p>Use <seeguide marker="erl_ext_dist#fragments">fragmented</seeguide>
            distribution messages to send large messages.</p>
        </item>
        <tag><marker id="DFLAG_HANDSHAKE_23"/><c>-define(DFLAG_HANDSHAKE_23, 16#1000000).</c></tag>
        <item>
          <p>The node supports the new connection setup handshake (version 6)
	  introduced in OTP 23. This flag is mandatory (from OTP 25). If not
          present, the connection is refused.</p>
        </item>
        <tag><marker id="DFLAG_UNLINK_ID"/><c>-define(DFLAG_UNLINK_ID, 16#2000000).</c></tag>
        <item>
	  <p>Use the <seeguide marker="#link_protocol">new link protocol</seeguide>.</p>
	  <note><p>This flag is mandatory as of OTP 26.</p></note>
	</item>
	<tag><c>-define(DFLAG_MANDATORY_25_DIGEST, (1 bsl 36)).</c></tag>
        <item>
	  <p>The node supports all capabilities that are mandatory in OTP 25.
          Introduced in OTP 25.</p>
          <note><p>This flag will become mandatory in OTP 27.</p></note>
        </item>
        <tag><marker id="DFLAG_SPAWN"/><c>-define(DFLAG_SPAWN, (1 bsl 32)).</c></tag>
        <item>
          <p>Set if the <seeguide marker="#SPAWN_REQUEST"><c>SPAWN_REQUEST</c></seeguide>,
	  <seeguide marker="#SPAWN_REQUEST_TT"><c>SPAWN_REQUEST_TT</c></seeguide>,
	  <seeguide marker="#SPAWN_REPLY"><c>SPAWN_REPLY</c></seeguide>,
	  <seeguide marker="#SPAWN_REPLY_TT"><c>SPAWN_REPLY_TT</c></seeguide>
	  control messages are supported.</p>
        </item>
	<tag><marker id="DFLAG_NAME_ME"/><c>-define(DFLAG_NAME_ME, (1 bsl 33)).</c></tag>
        <item><p>
	  Dynamic node name. This is not a capability but rather used as a
	  request from the connecting node to receive its node name from the
	  accepting node as part of the handshake.</p>
	</item>
	<tag><marker id="DFLAG_V4_NC"/><c>-define(DFLAG_V4_NC, (1 bsl 34)).</c></tag>
        <item>
	  <p>The node accepts a larger amount of data in pids, ports and
	  references (node container types version 4). In the pid case full 32-bit
	  <c>ID</c> and <c>Serial</c> fields in
	  <seeguide marker="erl_ext_dist#NEW_PID_EXT"><c>NEW_PID_EXT</c></seeguide>,
	  in the port case a 64-bit integer in
	  <seeguide marker="erl_ext_dist#V4_PORT_EXT"><c>V4_PORT_EXT</c></seeguide>,
	  and in the reference case up to 5 32-bit ID words are now accepted in
	  <seeguide marker="erl_ext_dist#NEWER_REFERENCE_EXT"><c>NEWER_REFERENCE_EXT</c></seeguide>.
	  This flag was introduced in OTP 24 and became mandatory in OTP 26.</p>
        </item>
	<tag><marker id="DFLAG_ALIAS"/><c>-define(DFLAG_ALIAS, (1 bsl 35)).</c></tag>
        <item>
	  <p>The node supports process alias and can by this handle the 
	  <seeguide marker="#ALIAS_SEND"><c>ALIAS_SEND</c></seeguide> and
	  <seeguide marker="#ALIAS_SEND_TT"><c>ALIAS_SEND_TT</c></seeguide>
	  control messages.
	  Introduced in OTP 24.</p>
        </item>
      </taglist>
      <p>
	There is also function <c>dist_util:strict_order_flags/0</c>
	returning all flags (bitwise or:ed together) corresponding to features
	that require strict ordering of data over distribution channels.
      </p>
    </section>
  </section>

  <section>
    <marker id="connected_nodes"/>
    <title>Protocol between Connected Nodes</title>
    <p>Since ERTS 5.7.2 (OTP R13B) the runtime system passes a distribution flag
      in the handshake stage that enables the use of a
      <seeguide marker="erl_ext_dist#distribution_header">distribution header
      </seeguide> on all messages passed. Messages passed between nodes have in
      this case the following format:</p>

    <table align="left">
      <row>
        <cell align="center">4</cell>
        <cell align="center">d</cell>
        <cell align="center">n</cell>
        <cell align="center">m</cell>
      </row>
      <row>
        <cell align="center"><c>Length</c></cell>
        <cell align="center"><c>DistributionHeader</c></cell>
        <cell align="center"><c>ControlMessage</c></cell>
        <cell align="center"><c>Message</c></cell>
      </row>
      <tcaption>Format of Messages Passed between Nodes (as from ERTS 5.7.2 (OTP R13B))
      </tcaption>
    </table>

    <taglist>
      <tag><c>Length</c></tag>
      <item>
        <p>Equal to d + n + m.</p>
      </item>
      <tag><c>DistributionHeader</c></tag>
      <item>
        <p>
          <seeguide marker="erl_ext_dist#distribution_header">Distribution header
          describing the atom cache and fragmented distribution messages.
          </seeguide>
        </p>
      </item>
      <tag><c>ControlMessage</c></tag>
      <item>
        <p>A tuple passed using the external format of Erlang.</p>
      </item>
      <tag><c>Message</c></tag>
      <item>
        <p>The message sent to another node using the '!'
          or the reason for a EXIT, EXIT2 or DOWN signal using
          the external term format.</p>
      </item>
    </taglist>

    <p>Notice that <seeguide marker="erl_ext_dist#overall_format">the version
      number is omitted from the terms that follow a distribution header
      </seeguide>.</p>

    <p>Nodes with an ERTS version earlier than 5.7.2 (OTP R13B) does not pass the
      distribution flag that enables the distribution header. Messages passed
      between nodes have in this case the following format:</p>

    <table align="left">
      <row>
        <cell align="center">4</cell>
        <cell align="center">1</cell>
        <cell align="center">n</cell>
        <cell align="center">m</cell>
      </row>
      <row>
        <cell align="center"><c>Length</c></cell>
        <cell align="center"><c>Type</c></cell>
        <cell align="center"><c>ControlMessage</c></cell>
        <cell align="center"><c>Message</c></cell>
      </row>
      <tcaption>Format of Messages Passed between Nodes (before ERTS 5.7.2 (OTP R13B))
      </tcaption>
    </table>

    <taglist>
      <tag><c>Length</c></tag>
      <item>
        <p>Equal to 1 + n + m.</p>
      </item>
      <tag><c>Type</c></tag>
      <item>
        <p>Equal to <c>112</c> (pass through).</p>
      </item>
      <tag><c>ControlMessage</c></tag>
      <item>
        <p>A tuple passed using the external format of Erlang.</p>
      </item>
      <tag><c>Message</c></tag>
      <item>
        <p>The message sent to another node using the '!' (in external format).
          Notice that <c>Message</c> is only passed in combination with a
          <c>ControlMessage</c> encoding a send ('!').</p>
      </item>
    </taglist>

    <marker id="control_message"/>
    <p>The <c>ControlMessage</c> is a tuple, where the first element indicates
      which distributed operation it encodes:</p>

    <taglist>
      <tag><marker id="LINK"/><c>LINK</c></tag>
      <item>
        <p><c>{1, FromPid, ToPid}</c></p>
	<p>This signal is sent by <c>FromPid</c> in order
	to create a link between <c>FromPid</c> and
	<c>ToPid</c>.</p>
      </item>
      <tag><c>SEND</c></tag>
      <item>
        <p><c>{2, Unused, ToPid}</c></p>
        <p>Followed by <c>Message</c>.</p>
        <p><c>Unused</c> is kept for backward compatibility.</p>
      </item>
      <tag><c>EXIT</c></tag>
      <item>
        <p><c>{3, FromPid, ToPid, Reason}</c></p>
        <p>This signal is sent when a link has been broken</p>
      </item>
      <tag><marker id="UNLINK"/><c>UNLINK</c> (obsolete)</tag>
      <item>
        <p><c>{4, FromPid, ToPid}</c></p>
	<warning><p>This signal is obsolete and not supported as of
        OTP 26. For more information see the documentation of the
	<seeguide marker="#link_protocol">link protocol</seeguide>.
	</p></warning>
      </item>
      <tag><c>NODE_LINK</c></tag>
      <item>
        <p><c>{5}</c></p>
      </item>
      <tag><c>REG_SEND</c></tag>
      <item>
        <p><c>{6, FromPid, Unused, ToName}</c></p>
        <p>Followed by <c>Message</c>.</p>
        <p><c>Unused</c> is kept for backward compatibility.</p>
      </item>
      <tag><c>GROUP_LEADER</c></tag>
      <item>
        <p><c>{7, FromPid, ToPid}</c></p>
      </item>	
      <tag><c>EXIT2</c></tag>
      <item>
        <p><c>{8, FromPid, ToPid, Reason}</c></p>
        <p>This signal is sent by a call to the erlang:exit/2 bif</p>
      </item>
      <tag><c>SEND_TT</c></tag>
      <item>
        <p><c>{12, Unused, ToPid, TraceToken}</c></p>
        <p>Followed by <c>Message</c>.</p>
        <p><c>Unused</c> is kept for backward compatibility.</p>
      </item>
      <tag><c>EXIT_TT</c></tag>
      <item>
        <p><c>{13, FromPid, ToPid, TraceToken, Reason}</c></p>
      </item>
      <tag><c>REG_SEND_TT</c></tag>
      <item>
        <p><c>{16, FromPid, Unused, ToName, TraceToken}</c></p>
        <p>Followed by <c>Message</c>.</p>
        <p><c>Unused</c> is kept for backward compatibility.</p>
      </item>
      <tag><c>EXIT2_TT</c></tag>
      <item>
        <p><c>{18, FromPid, ToPid, TraceToken, Reason}</c></p>
      </item>
      <tag><c>MONITOR_P</c></tag>
      <item>
        <p><c>{19, FromPid, ToProc, Ref}</c>, where
          <c>FromPid</c> = monitoring process and
          <c>ToProc</c> = monitored process pid or name (atom)</p>
      </item>
      <tag><c>DEMONITOR_P</c></tag>
      <item>
        <p><c>{20, FromPid, ToProc, Ref}</c>, where
          <c>FromPid</c> = monitoring process and
          <c>ToProc</c> = monitored process pid or name (atom)</p>
        <p>We include <c>FromPid</c> just in case we want to trace this.</p>
      </item>
      <tag><c>MONITOR_P_EXIT</c></tag>
      <item>
        <p><c>{21, FromProc, ToPid, Ref, Reason}</c>, where
          <c>FromProc</c> = monitored process pid or name (atom),
          <c>ToPid</c> = monitoring process, and
          <c>Reason</c> = exit reason for the monitored process</p>
      </item>
    </taglist>

    <section>
    <title>New Ctrlmessages for Erlang/OTP 21</title>
    <taglist>
      <tag><c>SEND_SENDER</c></tag>
      <item>
        <p><c>{22, FromPid, ToPid}</c></p>
        <p>Followed by <c>Message</c>.</p>
	<p>
	  This control message replaces the <c>SEND</c> control
	  message and will be sent when the distribution flag
	  <seeguide marker="erl_dist_protocol#dflags"><c>DFLAG_SEND_SENDER</c></seeguide>
	  has been negotiated in the connection setup handshake.
	</p>
	<note><p>
	  Messages encoded before the connection has
	  been set up may still use the <c>SEND</c> control
	  message. However, once a <c>SEND_SENDER</c> or <c>SEND_SENDER_TT</c>
	  control message has been sent, no more <c>SEND</c>
	  control messages will be sent in the same direction
	  on the connection.
	</p></note>
      </item>
      <tag><c>SEND_SENDER_TT</c></tag>
      <item>
        <p><c>{23, FromPid, ToPid, TraceToken}</c></p>
        <p>Followed by <c>Message</c>.</p>
	<p>
	  This control message replaces the <c>SEND_TT</c> control
	  message and will be sent when the distribution flag
	  <seeguide marker="erl_dist_protocol#dflags"><c>DFLAG_SEND_SENDER</c></seeguide>
	  has been negotiated in the connection setup handshake.
	</p>
	<note><p>
	  Messages encoded before the connection has
	  been set up may still use the <c>SEND_TT</c> control
	  message. However, once a <c>SEND_SENDER</c> or <c>SEND_SENDER_TT</c>
	  control message has been sent, no more <c>SEND_TT</c>
	  control messages will be sent in the same direction
	  on the connection.
	</p></note>
      </item>
    </taglist>
  </section>

  <section>
    <title>New Ctrlmessages for Erlang/OTP 22</title>
    <note><p>
      Messages encoded before the connection has
      been set up may still use the non-PAYLOAD variant.
      However, once a PAYLOAD control message has been sent,
      no more non-PAYLOAD control messages will be sent in
      the same direction on the connection.
    </p></note>
    <taglist>
      <tag><c>PAYLOAD_EXIT</c></tag>
      <item>
        <p><c>{24, FromPid, ToPid}</c></p>
        <p>Followed by <c>Reason</c>.</p>
	<p>
	  This control message replaces the <c>EXIT</c> control
	  message and will be sent when the distribution flag
	  <seeguide marker="erl_dist_protocol#dflags"><c>DFLAG_EXIT_PAYLOAD</c></seeguide>
	  has been negotiated in the connection setup handshake.
	</p>
      </item>
      <tag><c>PAYLOAD_EXIT_TT</c></tag>
      <item>
        <p><c>{25, FromPid, ToPid, TraceToken}</c></p>
        <p>Followed by <c>Reason</c>.</p>
	<p>
	  This control message replaces the <c>EXIT_TT</c> control
	  message and will be sent when the distribution flag
	  <seeguide marker="erl_dist_protocol#dflags"><c>DFLAG_EXIT_PAYLOAD</c></seeguide>
	  has been negotiated in the connection setup handshake.
	</p>
      </item>
      <tag><c>PAYLOAD_EXIT2</c></tag>
      <item>
        <p><c>{26, FromPid, ToPid}</c></p>
        <p>Followed by <c>Reason</c>.</p>
	<p>
	  This control message replaces the <c>EXIT2</c> control
	  message and will be sent when the distribution flag
	  <seeguide marker="erl_dist_protocol#dflags"><c>DFLAG_EXIT_PAYLOAD</c></seeguide>
	  has been negotiated in the connection setup handshake.
	</p>
      </item>
      <tag><c>PAYLOAD_EXIT2_TT</c></tag>
      <item>
        <p><c>{27, FromPid, ToPid, TraceToken}</c></p>
        <p>Followed by <c>Reason</c>.</p>
	<p>
	  This control message replaces the <c>EXIT2_TT</c> control
	  message and will be sent when the distribution flag
	  <seeguide marker="erl_dist_protocol#dflags"><c>DFLAG_EXIT_PAYLOAD</c></seeguide>
	  has been negotiated in the connection setup handshake.
	</p>
      </item>
      <tag><c>PAYLOAD_MONITOR_P_EXIT</c></tag>
      <item>
        <p><c>{28, FromProc, ToPid, Ref}</c></p>
        <p>Followed by <c>Reason</c>.</p>
	<p>
	  This control message replaces the <c>MONITOR_P_EXIT</c> control
	  message and will be sent when the distribution flag
	  <seeguide marker="erl_dist_protocol#dflags"><c>DFLAG_EXIT_PAYLOAD</c></seeguide>
	  has been negotiated in the connection setup handshake.
	</p>
      </item>
      
    </taglist>
  </section>
  <section>
    <title>New Ctrlmessages for Erlang/OTP 23</title>
    <taglist>
      <tag><marker id="SPAWN_REQUEST"/><c>SPAWN_REQUEST</c></tag>
      <item>
        <p><c>{29, ReqId, From, GroupLeader, {Module, Function, Arity}, OptList}</c></p>
        <p>Followed by <c>ArgList</c>.</p>
	<p>This signal is sent by the
	<seemfa marker="erlang#spawn_request/5"><c>spawn_request()</c></seemfa> BIF.</p>
	<taglist>
	  <tag><c>ReqId :: reference()</c></tag>
	  <item><p>Request identifier. Also used as monitor
	  reference in case the <c>monitor</c> option has been
	  passed.</p></item>
	  <tag><c>From :: pid()</c></tag>
	  <item><p>Process identifier of the process making the
	  request. That is, the parent process to be.</p></item>
	  <tag><c>GroupLeader :: pid()</c></tag>
	  <item><p>Process identifier of the group leader of the
	  newly created process.</p></item>
	  <tag><c>{Module :: atom(), Function :: atom(), Arity :: integer() >= 0}</c></tag>
	  <item><p>Entry point for the the new process.</p></item>
	  <tag><c>OptList :: [term()]</c></tag>
	  <item><p>A proper list of spawn options to use when spawning.</p></item>
	  <tag><c>ArgList :: [term()]</c></tag>
	  <item><p>A proper list of arguments to use in the call to the entry point.</p></item>
	</taglist>
	<p>
	  Only supported when the
	  <seeguide marker="erl_dist_protocol#DFLAG_SPAWN"><c>DFLAG_SPAWN</c></seeguide>
	  <seeguide marker="erl_dist_protocol#dflags">distribution flag</seeguide>
	  has been passed.
	</p>
      </item>
      <tag><marker id="SPAWN_REQUEST_TT"/><c>SPAWN_REQUEST_TT</c></tag>
      <item>
        <p><c>{30, ReqId, From, GroupLeader, {Module, Function, Arity}, OptList, Token}</c></p>
        <p>Followed by <c>ArgList</c>.</p>
	<p>Same as <seeguide marker="#SPAWN_REQUEST"><c>SPAWN_REQUEST</c></seeguide>, but also
	with a sequential trace <c>Token</c>.
	</p>
	<p>
	  Only supported when the
	  <seeguide marker="erl_dist_protocol#DFLAG_SPAWN"><c>DFLAG_SPAWN</c></seeguide>
	  <seeguide marker="erl_dist_protocol#dflags">distribution flag</seeguide>
	  has been passed.
	</p>
      </item>
      <tag><marker id="SPAWN_REPLY"/><c>SPAWN_REPLY</c></tag>
      <item>
        <p><c>{31, ReqId, To, Flags, Result}</c></p>
	<p>This signal is sent as a reply to a process previously sending
	a <seeguide marker="#SPAWN_REQUEST"><c>SPAWN_REQUEST</c></seeguide> signal.</p>
	<taglist>
	  <tag><c>ReqId :: reference()</c></tag>
	  <item><p>Request identifier. Also used as monitor
	  reference in case the <c>monitor</c> option has been
	  passed.</p></item>
	  <tag><c>To :: pid()</c></tag>
	  <item><p>Process identifier of the process making the
	  spawn request.</p></item>
	  <tag><c>Flags :: integer() >= 0</c></tag>
	  <item><p>A bit flag field of bit flags bitwise or:ed together. Currently the
	  following flags are defined:</p>
	  <taglist>
	    <tag><c>1</c></tag>
	    <item><p>A link between <c>To</c> and <c>Result</c> was set up on
	    the node where <c>Result</c> resides.</p></item>
	    <tag><c>2</c></tag>
	    <item><p>A monitor from <c>To</c> to <c>Result</c> was set up on
	    the node where <c>Result</c> resides.</p></item>
	  </taglist>
	  </item>
	  <tag><c>Result :: pid() | atom()</c></tag>
	  <item><p>Result of the operation. If <c>Result</c> is a process
	  identifier, the operation succeeded and the process identifier
	  is the identifier of the newly created process. If <c>Result</c>
	  is an atom, the operation failed and the atom identifies failure
	  reason.</p></item>
	</taglist>
	<p>
	  Only supported when the
	  <seeguide marker="erl_dist_protocol#DFLAG_SPAWN"><c>DFLAG_SPAWN</c></seeguide>
	  <seeguide marker="erl_dist_protocol#dflags">distribution flag</seeguide>
	  has been passed.
	</p>
      </item>
      <tag><marker id="SPAWN_REPLY_TT"/><c>SPAWN_REPLY_TT</c></tag>
      <item>
        <p><c>{32, ReqId, To, Flags, Result, Token}</c></p>
	<p>Same as <seeguide marker="#SPAWN_REPLY"><c>SPAWN_REPLY</c></seeguide>, but also
	with a sequential trace <c>Token</c>.</p>
	<p>
	  Only supported when the
	  <seeguide marker="erl_dist_protocol#DFLAG_SPAWN"><c>DFLAG_SPAWN</c></seeguide>
	  <seeguide marker="erl_dist_protocol#dflags">distribution flag</seeguide>
	  has been passed.
	</p>
      </item>
      <tag><marker id="UNLINK_ID"/><c>UNLINK_ID</c></tag>
      <item>
        <p><c>{35, Id, FromPid, ToPid}</c></p>
	<p>This signal is sent by <c>FromPid</c> in order to remove a
	link between <c>FromPid</c> and <c>ToPid</c>. This unlink signal
        replaces the <seeguide marker="#UNLINK"><c>UNLINK</c></seeguide>
	signal. Besides process identifiers of the sender and receiver
	the <c>UNLINK_ID</c> signal also contains an integer identifier
	<c>Id</c>. Valid range of <c>Id</c> is <c>[1, (1 bsl 64) - 1]</c>.
	<c>Id</c> is to be passed back to the sender by the receiver in an
	<seeguide marker="#UNLINK_ID_ACK"><c>UNLINK_ID_ACK</c></seeguide>
	signal. <c>Id</c> must uniquely identify the <c>UNLINK_ID</c> signal
	among all not yet acknowledged <c>UNLINK_ID</c> signals from
	<c>FromPid</c> to <c>ToPid</c>.</p>
	<p>
	  This signal is part of the
	  <seeguide marker="#link_protocol">new link protocol</seeguide>
          which became mandatory as of OTP 26.
	</p>
      </item>
      <tag><marker id="UNLINK_ID_ACK"/><c>UNLINK_ID_ACK</c></tag>
      <item>
        <p><c>{36, Id, FromPid, ToPid}</c></p>
        <p>An unlink acknowledgement signal. This signal is sent as an
	acknowledgement of the reception of an 
	<seeguide marker="#UNLINK_ID"><c>UNLINK_ID</c></seeguide>
	signal. The <c>Id</c> element should be the same <c>Id</c>
	as present in the <c>UNLINK_ID</c> signal. <c>FromPid</c>
	identifies the sender of the <c>UNLINK_ID_ACK</c> signal and
	<c>ToPid</c> identifies the sender of the <c>UNLINK_ID</c>
	signal.</p>
	<p>
	  This signal is part of the
	  <seeguide marker="#link_protocol">new link protocol</seeguide>
          which became mandatory as of OTP 26.
	</p>
      </item>
    </taglist>
  </section>
  <section>
    <title>New Ctrlmessages for Erlang/OTP 24</title>
    <taglist>
      <tag><marker id="ALIAS_SEND"/><c>ALIAS_SEND</c></tag>
      <item>
        <p><c>{33, FromPid, Alias}</c></p>
        <p>Followed by <c>Message</c>.</p>
	<p>
	  This control message is used when sending the message <c>Message</c>
	  to the process identified by the process alias <c>Alias</c>. Nodes that
	  can handle this control message sets the distribution flag
	  <seeguide marker="erl_dist_protocol#dflags"><c>DFLAG_ALIAS</c></seeguide>
	  in the connection setup handshake.
	</p>
      </item>
      <tag><marker id="ALIAS_SEND_TT"/><c>ALIAS_SEND_TT</c></tag>
      <item>
        <p><c>{34, FromPid, Alias, Token}</c></p>
        <p>Followed by <c>Message</c>.</p>
	<p>Same as <seeguide marker="#ALIAS_SEND"><c>ALIAS_SEND</c></seeguide>, but also
	with a sequential trace <c>Token</c>.</p>
      </item>
    </taglist>
  </section>
  <section>
    <marker id="link_protocol"/>
    <!-- The following markers kept in order not to break links
         from the outside world... -->
    <marker id="new_link_protocol"/>
    <marker id="old_link_protocol"/>
    <title>Link Protocol</title>

    <p>
      The new link protocol introduced in OTP 23.3 became mandatory
      as of OTP 26. As of OTP 26, OTP nodes will therefor refuse to
      connect to nodes that do not indicate that they support the
      new link protocol using the
      <seeguide marker="#DFLAG_UNLINK_ID"><c>DFLAG_UNLINK_ID</c></seeguide>
      <seeguide marker="#dflags">distribution flag</seeguide>.
    </p>

    <p>
      The new link protocol introduced two new signals,
      <seeguide marker="#UNLINK_ID"><c>UNLINK_ID</c></seeguide> and
      <seeguide marker="#UNLINK_ID"><c>UNLINK_ID_ACK</c></seeguide>,
      which replaced the old
      <seeguide marker="#UNLINK"><c>UNLINK</c></seeguide>
      signal. The old <seeguide marker="#LINK"><c>LINK</c></seeguide>
      signal is still sent in order to set up a link, but handled
      differently upon reception.
    </p>

    <p>
      In order to set up a link, a <c>LINK</c> signal is sent, from
      the process initiating the operation, to the process that it
      wants to link to. In order to remove a link, an
      <c>UNLINK_ID</c> signal is sent, from the process initiating
      the operation, to the linked process. The receiver of an
      <c>UNLINK_ID</c> signal responds with an <c>UNLINK_ID_ACK</c>
      signal. Upon reception of an <c>UNLINK_ID</c> signal, the
      corresponding <c>UNLINK_ID_ACK</c> signal <em>must</em> be
      sent before any other signals are sent to the sender of the
      <c>UNLINK_ID</c> signal. Together with
      <seeguide marker="system/reference_manual:processes#signal-delivery">the
      signal ordering guarantee</seeguide> of Erlang this makes it
      possible for the sender of the <c>UNLINK_ID</c> signal to know
      the order of other signals which is essential for the protocol.
      The <c>UNLINK_ID_ACK</c> signal should contain the same
      <c>Id</c> as the <c>Id</c> contained in the <c>UNLINK_ID</c>
      signal being acknowledged.
    </p>

    <p>
      Processes also need to maintain process local information about
      links. The state of this process local information is changed
      when the signals above are sent and received. This process
      local information also determines if a signal should be sent
      when a process calls
      <seemfa marker="erlang#link/1"><c>link/1</c></seemfa> or
      <seemfa marker="erlang#unlink/1"><c>unlink/1</c></seemfa>.
      A <c>LINK</c> signal is only sent if there does not currently
      exist an active link between the processes according to the
      process local information and an <c>UNLINK_ID</c> signal is
      only sent if there currently exists an active link between the
      processes according to the process local information.
    </p>

    <p>
      The process local information about a link contains:
    </p>
    <taglist>
      <tag>Pid</tag>
      <item>
	Process identifier of the linked process.
      </item>
      <tag>Active Flag</tag>
      <item>
	If set, the link is active and the process will react on
	<seeguide marker="system/reference_manual:processes#receiving_exit_signals">incoming
	exit signals</seeguide> issued due to the link. If not set,
	the link is inactive and incoming exit signals, issued due
	to the link, will be ignored. That is, the processes are
	considered as <em>not</em> linked.
      </item>
      <tag>Unlink Id</tag>
      <item>
	Identifier of an outstanding unlink operation. That is,
	an unlink operation that has not yet been acknowledged.
	This information is only used when the active flag is not
	set.
      </item>
    </taglist>

    <p>
      A process is only considered linked to another process
      if it has process local information about the link
      containing the process identifier of the other process and
      with the active flag set.
    </p>

    <p>
      The process local information about a link is updated as
      follows:
    </p>
    <taglist>
      <tag>A <c>LINK</c> signal is sent</tag>
      <item>
	Link information is created if not already existing. The
	active flag is set, and unlink id is cleared. That is,
	if we had an outstanding unlink operation we will ignore
	the result of that operation and enable the link.
      </item>
      <tag>A <c>LINK</c> signal is received</tag>
      <item>
	If no link information already exists, it is created, the
	active flag is set and unlink id is cleared. If the link
	information already exists, the signal is silently ignored,
	regardless of whether the active flag is set or not.
	That is, if we have an outstanding unlink operation we will
	<em>not</em> activate the link. In this scenario, the sender
	of the <c>LINK</c> signal has not yet sent an
	<c>UNLINK_ID_ACK</c> signal corresponding to our
	<c>UNLINK_ID</c> signal which means that it will receive
	our <c>UNLINK_ID</c> signal after it sent its
	<c>LINK</c> signal. This in turn means that both processes
	in the end will agree that there is no link between them.
      </item>
      <tag>An <c>UNLINK_ID</c> signal is sent</tag>
      <item>
	Link information already exists and the active flag is set
	(otherwise the signal would not be sent). The active flag
	is unset, and the unlink id of the signal is saved in the
	link information.
      </item>
      <tag>An <c>UNLINK_ID</c> signal is received</tag>
      <item>
	If the active flag is set, information about the link
	is removed. If the active flag is not set (that is, we have
	an outstanding unlink operation), the information about the
	link is left unchanged.
      </item>
      <tag>An <c>UNLINK_ID_ACK</c> signal is sent</tag>
      <item>
	This is done when an <c>UNLINK_ID</c> signal is received and
	causes no further changes of the link information.
      </item>
      <tag>An <c>UNLINK_ID_ACK</c> signal is received</tag>
      <item>
	If information about the link exists, the active flag is not
	set, and the unlink id in the link information equals the
	<c>Id</c> in the signal, the link information is removed;
	otherwise, the signal is ignored.
      </item>
    </taglist>

    <p>
      When a process receives an exit signal due to a link, the
      process will first react to the exit signal if the link
      is active and then remove the process local information about
      the link.
    </p>
    <p>
      In case the connection is lost between two nodes, exit signals
      with exit reason <c>noconnection</c> are sent to all processes
      with links over the connection. This will cause all process
      local information about links over the connection to be
      removed.
    </p>
    <p>
      Exactly the same link protocol is also used internally on an
      Erlang node. The signals however have different formats since
      they do not have to be sent over the wire.
    </p>

  </section>
  </section>

</chapter>
