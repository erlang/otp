<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>1996</year><year>2018</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>

    <title>erlang</title>
    <prepared></prepared>
    <docno></docno>
    <date></date>
    <rev></rev>
    <file>erlang.xml</file>
  </header>
  <module since="">erlang</module>
  <modulesummary>The Erlang BIFs.</modulesummary>
  <description>
    <p>By convention, most Built-In Functions (BIFs) are included
      in this module. Some of the BIFs are viewed more
      or less as part of the Erlang programming language and are
      <em>auto-imported</em>. Thus, it is not necessary to specify the
      module name. For example, the calls <c>atom_to_list(erlang)</c>
      and <c>erlang:atom_to_list(erlang)</c> are identical.</p>

    <p>Auto-imported BIFs are listed without module prefix.
      BIFs listed with module prefix are not auto-imported.</p>

    <p>BIFs can fail for various reasons. All BIFs fail with
      reason <c>badarg</c> if they are called with arguments of an
      incorrect type. The other reasons are described in the
      description of each individual BIF.</p>

    <p>Some BIFs can be used in guard tests and are marked with
      "Allowed in guard tests".</p>
  </description>

  <datatypes>
    <datatype>
      <name name="ext_binary"/>
      <desc>
        <p>A binary data object, structured according to
          the Erlang external term format.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="iovec"/>
      <desc>
        <p>A list of binaries. This datatype is useful to use
          together with <seealso marker="erl_nif#enif_inspect_iovec">
          <c>enif_inspect_iovec</c></seealso>.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="message_queue_data"></name>
      <desc>
        <p>See <seealso marker="#process_flag_message_queue_data">
          <c>process_flag(message_queue_data, MQD)</c></seealso>.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="timestamp"></name>
      <desc>
        <p>See <seealso marker="#timestamp/0">
          <c>erlang:timestamp/0</c></seealso>.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="time_unit"></name>
      <desc>
        <marker id="type_time_unit"/>
        <p>Supported time unit representations:</p>
        <taglist>
          <tag><c>PartsPerSecond :: integer() >= 1</c></tag>
          <item>
            <p>Time unit expressed in parts per second. That is,
              the time unit equals <c>1/PartsPerSecond</c> second.</p>
          </item>
          <tag><c>second</c></tag>
          <item>
            <p>Symbolic representation of the time unit
              represented by the integer <c>1</c>.</p>
          </item>
          <tag><c>millisecond</c></tag>
          <item>
            <p>Symbolic representation of the time unit
              represented by the integer <c>1000</c>.</p>
          </item>
          <tag><c>microsecond</c></tag>
          <item>
            <p>Symbolic representation of the time unit
              represented by the integer <c>1000000</c>.</p>
          </item>
          <tag><c>nanosecond</c></tag>
          <item>
            <p>Symbolic representation of the time unit
              represented by the integer <c>1000000000</c>.</p>
          </item>
          <tag><c>native</c></tag>
          <item>
            <p>Symbolic representation of the native time unit
              used by the Erlang runtime system.</p>
            <p>The <c>native</c> time unit is determined at
              runtime system start, and remains the same until
              the runtime system terminates. If a runtime system
              is stopped and then started again (even on the same
              machine), the <c>native</c> time unit of the new
              runtime system instance can differ from the
              <c>native</c> time unit of the old runtime system
              instance.</p>
            <p>One can get an approximation of the <c>native</c>
              time unit by calling
              <seealso marker="#convert_time_unit/3">
              <c>erlang:convert_time_unit(1, second, native)</c></seealso>.
              The result equals the number
              of whole <c>native</c> time units per second. If
              the number of <c>native</c> time units per second does not
              add up to a whole number, the result is rounded downwards.</p>
            <note>
              <p>The value of the <c>native</c> time unit gives
                you more or less no information about the
                quality of time values. It sets a limit for the
                <seealso marker="time_correction#Time_Resolution">
                resolution</seealso> and for the
                <seealso marker="time_correction#Time_Precision">
                precision</seealso> of time values,
                but it gives no information about the
                <seealso marker="time_correction#Time_Accuracy">
                accuracy</seealso> of time values. The resolution of
                the <c>native</c> time unit and the resolution of time
                values can differ significantly.</p>
            </note>
          </item>
          <tag><c>perf_counter</c></tag>
          <item>
            <p>Symbolic representation of the performance counter
              time unit used by the Erlang runtime system.</p>
            <p>The <c>perf_counter</c> time unit behaves much in the same way
              as the <c>native</c> time unit. That is, it can differ between
              runtime restarts. To get values of this type, call
              <seealso marker="kernel:os#perf_counter/0">
              <c>os:perf_counter/0</c></seealso>.</p>
          </item>
	  <tag><seealso marker="#type_deprecated_time_unit"><c>deprecated_time_unit()</c></seealso></tag>
	  <item><p>
	    Deprecated symbolic representations kept for backwards-compatibility.
	  </p></item>
        </taglist>
        <p>The <c>time_unit/0</c> type can be extended.
          To convert time values between time units, use
          <seealso marker="#convert_time_unit/3">
          <c>erlang:convert_time_unit/3</c></seealso>.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="deprecated_time_unit"></name>
      <desc><marker id="type_deprecated_time_unit"/>
	<p>The <seealso marker="#type_time_unit"><c>time_unit()</c></seealso>
	type also consist of the following <em>deprecated</em> symbolic
	time units:</p>
	<taglist>
	  <tag><c>seconds</c></tag>
	  <item><p>Same as <seealso marker="#type_time_unit"><c>second</c></seealso>.</p></item>

	  <tag><c>milli_seconds</c></tag>
	  <item><p>Same as <seealso marker="#type_time_unit"><c>millisecond</c></seealso>.</p></item>

	  <tag><c>micro_seconds</c></tag>
	  <item><p>Same as <seealso marker="#type_time_unit"><c>microsecond</c></seealso>.</p></item>

	  <tag><c>nano_seconds</c></tag>
	  <item><p>Same as <seealso marker="#type_time_unit"><c>nanosecond</c></seealso>.</p></item>
	</taglist>
      </desc>
    </datatype>

    <datatype>
      <name name="dist_handle"></name>
      <desc>
        <p>An opaque handle identifing a distribution channel.</p>
      </desc>
    </datatype>

    <datatype>
      <name name="nif_resource"></name>
      <desc>
        <p>An opaque handle identifing a
	<seealso marker="erl_nif#resource_objects">NIF resource object
	</seealso>.</p>
      </desc>
    </datatype>

  </datatypes>

  <funcs>
    <func>
      <name name="abs" arity="1" clause_i="1" since=""/>
      <name name="abs" arity="1" clause_i="2" since=""/>
      <fsummary>Arithmetical absolute value.</fsummary>
      <desc>
        <p>Returns an integer or float that is the arithmetical
          absolute value of <c><anno>Float</anno></c> or
          <c><anno>Int</anno></c>, for example:</p>
        <pre>
> <input>abs(-3.33).</input>
3.33
> <input>abs(-3).</input>
3</pre>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="adler32" arity="1" since=""/>
      <fsummary>Compute adler32 checksum.</fsummary>
      <desc>
        <p>Computes and returns the adler32 checksum for
          <c><anno>Data</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="adler32" arity="2" since=""/>
      <fsummary>Compute adler32 checksum.</fsummary>
      <desc>
        <p>Continues computing the adler32 checksum by combining 
          the previous checksum, <c><anno>OldAdler</anno></c>, with
          the checksum of <c><anno>Data</anno></c>.</p>
        <p>The following code:</p>
        <code>
X = erlang:adler32(Data1),
Y = erlang:adler32(X,Data2).</code>
        <p>assigns the same value to <c>Y</c> as this:</p>
        <code>
Y = erlang:adler32([Data1,Data2]).</code>
      </desc>
    </func>

    <func>
      <name name="adler32_combine" arity="3" since=""/>
      <fsummary>Combine two adler32 checksums.</fsummary>
      <desc>
        <p>Combines two previously computed adler32 checksums.
          This computation requires the size of the data object for
          the second checksum to be known.</p>
        <p>The following code:</p>
        <code>
Y = erlang:adler32(Data1),
Z = erlang:adler32(Y,Data2).</code>
        <p>assigns the same value to <c>Z</c> as this:</p>
        <code>
X = erlang:adler32(Data1),
Y = erlang:adler32(Data2),
Z = erlang:adler32_combine(X,Y,iolist_size(Data2)).</code>
      </desc>
    </func>

    <func>
      <name name="append_element" arity="2" since=""/>
      <fsummary>Append an extra element to a tuple.</fsummary>
      <desc>
        <p>Returns a new tuple that has one element more than
          <c><anno>Tuple1</anno></c>, and contains the elements in
          <c><anno>Tuple1</anno></c>
          followed by <c><anno>Term</anno></c> as the last element.
          Semantically equivalent to
          <c>list_to_tuple(tuple_to_list(<anno>Tuple1</anno>) ++
          [<anno>Term</anno>])</c>, but much faster. Example:</p>
        <pre>
> <input>erlang:append_element({one, two}, three).</input>
{one,two,three}</pre>
      </desc>
    </func>

    <func>
      <name name="apply" arity="2" since=""/>
      <fsummary>Apply a function to an argument list.</fsummary>
      <desc>
        <p>Calls a fun, passing the elements in <c><anno>Args</anno></c>
          as arguments.</p>
        <p>If the number of elements in the arguments are known at
          compile time, the call is better written as
          <c><anno>Fun</anno>(Arg1, Arg2, ... ArgN)</c>.</p>
        <warning>
          <p>Earlier, <c><anno>Fun</anno></c> could also be specified as
            <c>{Module, Function}</c>, equivalent to
            <c>apply(Module, Function, Args)</c>. <em>This use is
            deprecated and will stop working in a future release.</em></p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="apply" arity="3" since=""/>
      <fsummary>Apply a function to an argument list.</fsummary>
      <desc>
        <p>Returns the result of applying <c>Function</c> in
          <c><anno>Module</anno></c> to <c><anno>Args</anno></c>.
          The applied function must
          be exported from <c>Module</c>. The arity of the function is
          the length of <c>Args</c>. Example:</p>
        <pre>
> <input>apply(lists, reverse, [[a, b, c]]).</input>
[c,b,a]
> <input>apply(erlang, atom_to_list, ['Erlang']).</input>
"Erlang"</pre>
        <p>If the number of arguments are known at compile time,
          the call is better written as
          <c><anno>Module</anno>:<anno>Function</anno>(Arg1, Arg2, ...,
          ArgN)</c>.</p>
        <p>Failure: <seealso marker="kernel:error_handler#undefined_function/3">
          <c>error_handler:undefined_function/3</c></seealso> is called
          if the applied function is not exported. The error handler
          can be redefined (see
          <seealso marker="#process_flag/2"><c>process_flag/2</c></seealso>).
          If <c>error_handler</c> is undefined, or if the user has
          redefined the default <c>error_handler</c> so the replacement
          module is undefined, an error with reason <c>undef</c>
          is generated.</p>
      </desc>
    </func>

    <func>
      <name name="atom_to_binary" arity="2" since=""/>
      <fsummary>Return the binary representation of an atom.</fsummary>
      <desc>
        <p>Returns a binary corresponding to the text
          representation of <c><anno>Atom</anno></c>.
          If <c><anno>Encoding</anno></c>
          is <c>latin1</c>, one byte exists for each character
          in the text representation. If <c><anno>Encoding</anno></c> is
          <c>utf8</c> or
          <c>unicode</c>, the characters are encoded using UTF-8 where
          characters may require multiple bytes.</p>
        <note>
          <p>As from Erlang/OTP 20, atoms can contain any Unicode character
            and <c>atom_to_binary(<anno>Atom</anno>, latin1)</c> may fail if the
            text representation for <c><anno>Atom</anno></c> contains a Unicode
            character &gt; 255.</p>
        </note>
        <p>Example:</p>
        <pre>
> <input>atom_to_binary('Erlang', latin1).</input>
&lt;&lt;"Erlang"&gt;&gt;</pre>
      </desc>
    </func>

    <func>
      <name name="atom_to_list" arity="1" since=""/>
      <fsummary>Text representation of an atom.</fsummary>
      <desc>
        <p>Returns a string corresponding to the text
          representation of <c><anno>Atom</anno></c>, for example:</p>
        <pre>
> <input>atom_to_list('Erlang').</input>
"Erlang"</pre>
      </desc>
    </func>

    <func>
      <name name="binary_part" arity="2" since="OTP R14B"/>
      <fsummary>Extract a part of a binary.</fsummary>
      <desc>
      <p>Extracts the part of the binary described by
        <c><anno>PosLen</anno></c>.</p>
      <p>Negative length can be used to extract bytes at the end
        of a binary, for example:</p>
<code>
1> Bin = &lt;&lt;1,2,3,4,5,6,7,8,9,10&gt;&gt;.
2> binary_part(Bin,{byte_size(Bin), -5}).
&lt;&lt;6,7,8,9,10&gt;&gt;</code>
      <p>Failure: <c>badarg</c> if <c><anno>PosLen</anno></c> in any way
        references outside the binary.</p>
      <p><c><anno>Start</anno></c> is zero-based, that is:</p>
<code>
1> Bin = &lt;&lt;1,2,3&gt;&gt;
2> binary_part(Bin,{0,2}).
&lt;&lt;1,2&gt;&gt;</code>
      <p>For details about the <c><anno>PosLen</anno></c> semantics, see
        <seealso marker="stdlib:binary"><c>binary(3)</c></seealso>.</p>
      <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="binary_part" arity="3" since="OTP R14B"/>
      <fsummary>Extract a part of a binary.</fsummary>
      <desc>
      <p>The same as <c>binary_part(<anno>Subject</anno>,
        {<anno>Start</anno>, <anno>Length</anno>})</c>.</p>
      <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="binary_to_atom" arity="2" since=""/>
      <fsummary>Convert from text representation to an atom.</fsummary>
      <desc>
        <p>Returns the atom whose text representation is
          <c><anno>Binary</anno></c>.
          If <c><anno>Encoding</anno></c> is <c>latin1</c>, no
          translation of bytes in the binary is done.
          If <c><anno>Encoding</anno></c>
          is <c>utf8</c> or <c>unicode</c>, the binary must contain
          valid UTF-8 sequences.</p>
        <note>
          <p>As from Erlang/OTP 20, <c>binary_to_atom(<anno>Binary</anno>, utf8)</c>
            is capable of encoding any Unicode character. Earlier versions would
            fail if the binary contained Unicode characters &gt; 255.
            For more information about Unicode support in atoms, see the
            <seealso marker="erl_ext_dist#utf8_atoms">note on UTF-8
            encoded atoms</seealso>
            in section "External Term Format" in the User's Guide.</p>
        </note>
        <p>Examples:</p>
        <pre>
> <input>binary_to_atom(&lt;&lt;"Erlang"&gt;&gt;, latin1).</input>
'Erlang'
> <input>binary_to_atom(&lt;&lt;1024/utf8&gt;&gt;, utf8).</input>
'Ð€'</pre>
      </desc>
    </func>

    <func>
      <name name="binary_to_existing_atom" arity="2" since=""/>
      <fsummary>Convert from text representation to an atom.</fsummary>
      <desc>
        <p>As
          <seealso marker="#binary_to_atom/2"><c>binary_to_atom/2</c></seealso>,
          but the atom must exist.</p>
        <p>Failure: <c>badarg</c> if the atom does not exist.</p>
	<note>
	  <p>Note that the compiler may optimize away atoms. For
	  example, the compiler will rewrite
	  <c>atom_to_list(some_atom)</c> to <c>"some_atom"</c>. If
	  that expression is the only mention of the atom
	  <c>some_atom</c> in the containing module, the atom will not
	  be created when the module is loaded, and a subsequent call
	  to <c>binary_to_existing_atom(&lt;&lt;"some_atom"&gt;&gt;, utf8)</c>
	  will fail.</p>
	</note>
      </desc>
    </func>

    <func>
      <name name="binary_to_float" arity="1" since="OTP R16B"/>
      <fsummary>Convert from text representation to a float.</fsummary>
      <desc>
        <p>Returns the float whose text representation is
          <c><anno>Binary</anno></c>, for example:</p>
        <pre>
> <input>binary_to_float(&lt;&lt;"2.2017764e+0">>).</input>
2.2017764</pre>
        <p>Failure: <c>badarg</c> if <c><anno>Binary</anno></c> contains a bad
          representation of a float.</p>
      </desc>
    </func>

    <func>
      <name name="binary_to_integer" arity="1" since="OTP R16B"/>
      <fsummary>Convert from text representation to an integer.</fsummary>
      <desc>
        <p>Returns an integer whose text representation is
          <c><anno>Binary</anno></c>, for example:</p>
        <pre>
> <input>binary_to_integer(&lt;&lt;"123"&gt;&gt;).</input>
123</pre>
        <p>Failure: <c>badarg</c> if <c><anno>Binary</anno></c> contains a bad
          representation of an integer.</p>
      </desc>
    </func>

    <func>
      <name name="binary_to_integer" arity="2" since="OTP R16B"/>
      <fsummary>Convert from text representation to an integer.</fsummary>
      <desc>
        <p>Returns an integer whose text representation in base
          <c><anno>Base</anno></c> is <c><anno>Binary</anno></c>, for
          example:</p>
        <pre>
> <input>binary_to_integer(&lt;&lt;"3FF"&gt;&gt;, 16).</input>
1023</pre>
        <p>Failure: <c>badarg</c> if <c><anno>Binary</anno></c> contains a bad
          representation of an integer.</p>
      </desc>
    </func>

    <func>
      <name name="binary_to_list" arity="1" since=""/>
      <fsummary>Convert a binary to a list.</fsummary>
      <desc>
        <p>Returns a list of integers corresponding to the bytes of
          <c><anno>Binary</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="binary_to_list" arity="3" since=""/>
      <fsummary>Convert part of a binary to a list.</fsummary>
      <type_desc variable="Start">1..byte_size(<c><anno>Binary</anno></c>)
      </type_desc>
      <desc>
        <p>As <c>binary_to_list/1</c>, but returns a list of integers
          corresponding to the bytes from position <c><anno>Start</anno></c> to
          position <c><anno>Stop</anno></c> in <c><anno>Binary</anno></c>.
          The positions in the
          binary are numbered starting from 1.</p>
        <note>
          <p><em>The one-based indexing for binaries used by
            this function is deprecated.</em> New code is to use
            <seealso marker="stdlib:binary#bin_to_list/3">
            <c>binary:bin_to_list/3</c></seealso>
            in STDLIB instead. All functions in module
            <c>binary</c> consistently use zero-based indexing.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="binary_to_term" arity="1" since=""/>
      <fsummary>Decode an Erlang external term format binary.</fsummary>
      <desc>
        <p>Returns an Erlang term that is the result of decoding
          binary object <c><anno>Binary</anno></c>, which must be encoded
          according to the <seealso marker="erts:erl_ext_dist">
          Erlang external term format</seealso>.</p>
        <pre>
> <input>Bin = term_to_binary(hello).</input>
&lt;&lt;131,100,0,5,104,101,108,108,111>>
> <input>hello = binary_to_term(Bin).</input>
hello
</pre>
        <warning>
          <p>When decoding binaries from untrusted sources,
            consider using <c>binary_to_term/2</c> to prevent Denial
            of Service attacks.</p>
        </warning>
        <p>See also
          <seealso marker="#term_to_binary/1"><c>term_to_binary/1</c></seealso>
          and <seealso marker="#binary_to_term/2">
          <c>binary_to_term/2</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="binary_to_term" arity="2" since="OTP R13B04"/>
      <fsummary>Decode an Erlang external term format binary.</fsummary>
      <desc>
        <p>As <c>binary_to_term/1</c>, but takes these options:</p>
        <taglist>
          <tag><c>safe</c></tag>
          <item>
            <p>Use this option when receiving binaries from an untrusted
              source.</p>
            <p>When enabled, it prevents decoding data that can be used to
              attack the Erlang system. In the event of receiving unsafe
              data, decoding fails with a <c>badarg</c> error.</p>
            <p>This prevents creation of new atoms directly,
              creation of new atoms indirectly (as they are embedded in
              certain structures, such as process identifiers,
              refs, and funs), and
              creation of new external function references.
              None of those resources are garbage collected, so unchecked
              creation of them can exhaust available memory.</p>
        <pre>
> <input>binary_to_term(&lt;&lt;131,100,0,5,"hello">>, [safe]).</input>
** exception error: bad argument
> <input>hello.</input>
hello
> <input>binary_to_term(&lt;&lt;131,100,0,5,"hello">>, [safe]).</input>
hello
</pre>
          </item>
          <tag><c>used</c></tag>
          <item>
	    <p>Changes the return value to <c>{Term, Used}</c> where <c>Used</c>
	    is the number of bytes actually read from <c>Binary</c>.</p>
        <pre>
> <input>Input = &lt;&lt;131,100,0,5,"hello","world">>.</input>
&lt;&lt;131,100,0,5,104,101,108,108,111,119,111,114,108,100>>
> <input>{Term, Used} = binary_to_term(Input, [used]).</input>
{hello, 9}
> <input>split_binary(Input, Used).</input>
{&lt;&lt;131,100,0,5,104,101,108,108,111>>, &lt;&lt;"world">>}
</pre>
          </item>
        </taglist>
        <p>Failure: <c>badarg</c> if <c>safe</c> is specified and unsafe
          data is decoded.</p>
        <p>See also
          <seealso marker="#term_to_binary/1"><c>term_to_binary/1</c></seealso>,
          <seealso marker="#binary_to_term/1">
          <c>binary_to_term/1</c></seealso>, and
          <seealso marker="#list_to_existing_atom/1">
          <c>list_to_existing_atom/1</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="bit_size" arity="1" since=""/>
      <fsummary>Return the size of a bitstring.</fsummary>
      <desc>
        <p>Returns an integer that is the size in bits of
          <c><anno>Bitstring</anno></c>, for example:</p>
        <pre>
> <input>bit_size(&lt;&lt;433:16,3:3&gt;&gt;).</input>
19
> <input>bit_size(&lt;&lt;1,2,3&gt;&gt;).</input>
24</pre>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="bitstring_to_list" arity="1" since=""/>
      <fsummary>Convert a bitstring to a list.</fsummary>
      <desc>
        <p>Returns a list of integers corresponding to the bytes of
          <c><anno>Bitstring</anno></c>. If the number of bits in the binary
          is not divisible by 8, the last element of the list is a bitstring
          containing the remaining 1-7 bits.</p>
      </desc>
    </func>

    <func>
      <name name="bump_reductions" arity="1" since=""/>
      <fsummary>Increment the reduction counter.</fsummary>
      <desc>
        <p>This implementation-dependent function increments
          the reduction counter for the calling process. In the Beam
          emulator, the reduction counter is normally incremented by
          one for each function and BIF call. A context switch is
          forced when the counter reaches the maximum number of
          reductions for a process (2000 reductions in Erlang/OTP R12B).</p>
        <warning>
          <p>This BIF can be removed in a future version of the Beam
            machine without prior warning. It is unlikely to be
            implemented in other Erlang implementations.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="byte_size" arity="1" since=""/>
      <fsummary>Return the size of a bitstring (or binary).</fsummary>
      <desc>
        <p>Returns an integer that is the number of bytes needed to
          contain <c><anno>Bitstring</anno></c>. That is, if the number of bits
          in <c><anno>Bitstring</anno></c> is not divisible by 8, the resulting
          number of bytes is rounded <em>up</em>. Examples:</p>
        <pre>
> <input>byte_size(&lt;&lt;433:16,3:3&gt;&gt;).</input>
3
> <input>byte_size(&lt;&lt;1,2,3&gt;&gt;).</input>
3</pre>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="cancel_timer" arity="1" since=""/>
      <fsummary>Cancel a timer.</fsummary>
      <desc>
        <p>Cancels a timer. The same as calling
          <seealso marker="#cancel_timer/2">
          <c>erlang:cancel_timer(TimerRef, [])</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="cancel_timer" arity="2" since="OTP 18.0"/>
      <fsummary>Cancel a timer.</fsummary>
      <desc>
        <p>Cancels a timer that has been created by
          <seealso marker="#start_timer/4">
          <c>erlang:start_timer</c></seealso> or
          <seealso marker="#send_after/4"><c>erlang:send_after</c></seealso>.
          <c><anno>TimerRef</anno></c> identifies the timer, and
          was returned by the BIF that created the timer.</p>
        <p><c><anno>Option</anno></c>s:</p>
        <taglist>
          <tag><c>{async, Async}</c></tag>
          <item>
            <p>Asynchronous request for cancellation. <c>Async</c>
              defaults to <c>false</c>, which causes the
              cancellation to be performed synchronously. When
              <c>Async</c> is set to <c>true</c>, the cancel
              operation is performed asynchronously. That is,
              <c>cancel_timer()</c> sends an asynchronous
              request for cancellation to the timer service that
              manages the timer, and then returns <c>ok</c>.</p>
          </item>
          <tag><c>{info, Info}</c></tag>
          <item>
            <p>Requests information about the <c><anno>Result</anno></c>
              of the cancellation. <c>Info</c> defaults to <c>true</c>,
              which means the <c><anno>Result</anno></c> is
              given. When <c>Info</c> is set to <c>false</c>, no
              information about the result of the cancellation
              is given.</p>
            <list type="bulleted">
              <item>
                <p>When <c>Async</c> is <c>false</c>:
                  if <c>Info</c> is <c>true</c>, the <c>Result</c> is
                  returned by <c>erlang:cancel_timer()</c>. otherwise
                  <c>ok</c> is returned.</p>
              </item>
              <item>
                <p>When <c>Async</c> is <c>true</c>:
                  if <c>Info</c> is <c>true</c>, a message on the form
                  <c>{cancel_timer, <anno>TimerRef</anno>,
                  <anno>Result</anno>}</c> is sent to the
                  caller of <c>erlang:cancel_timer()</c> when the
                  cancellation operation has been performed, otherwise
                  no message is sent.</p>
              </item>
            </list>
           </item>
         </taglist>
        <p>More <c><anno>Option</anno></c>s may be added in the future.</p>
        <p>If <c><anno>Result</anno></c> is an integer, it represents
          the time in milliseconds left until the canceled timer would
          have expired.</p>
        <p>If <c><anno>Result</anno></c> is <c>false</c>, a
          timer corresponding to <c><anno>TimerRef</anno></c> could not
          be found. This can be either because the timer had expired,
          already had been canceled, or because <c><anno>TimerRef</anno></c>
          never corresponded to a timer. Even if the timer had expired,
          it does not tell you if the time-out message has
          arrived at its destination yet.</p>
        <note>
          <p>The timer service that manages the timer can be co-located
            with another scheduler than the scheduler that the calling
            process is executing on. If so, communication
            with the timer service takes much longer time than if it
            is located locally. If the calling process is in critical
            path, and can do other things while waiting for the result
            of this operation, or is not interested in the result of
            the operation, you want to use option <c>{async, true}</c>.
            If using option <c>{async, false}</c>, the calling
            process blocks until the operation has been performed.</p>
        </note>
        <p>See also
          <seealso marker="#send_after/4"><c>erlang:send_after/4</c></seealso>,
          <seealso marker="#start_timer/4">
          <c>erlang:start_timer/4</c></seealso>, and
          <seealso marker="#read_timer/2">
          <c>erlang:read_timer/2</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="ceil" arity="1" since="OTP 20.0"/>
      <fsummary>Returns the smallest integer not less than the argument</fsummary>
      <desc>
        <p>Returns the smallest integer not less than
	<c><anno>Number</anno></c>.
        For example:</p>
        <pre>
> <input>ceil(5.5).</input>
6</pre>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>
    <func>
      <name name="check_old_code" arity="1" since="OTP R14B04"/>
      <fsummary>Check if a module has old code.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Module</anno></c> has old code,
          otherwise <c>false</c>.</p>
        <p>See also <seealso marker="kernel:code">
          <c>code(3)</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="check_process_code" arity="2" since=""/>
      <fsummary>Check if a process executes old code for a module.</fsummary>
      <desc>
        <p>The same as
          <seealso marker="#check_process_code/3">
          <c>check_process_code(<anno>Pid</anno>, <anno>Module</anno>, [])</c>
          </seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="check_process_code" arity="3" since="OTP 17.0"/>
      <fsummary>Check if a process executes old code for a module.</fsummary>
      <desc>
        <p>Checks if the node local process identified by
          <c><anno>Pid</anno></c>
          executes old code for <c><anno>Module</anno></c>.</p>
        <p><c><anno>Option</anno></c>s:</p>
        <taglist>
          <tag><c>{allow_gc, boolean()}</c></tag>
          <item>
            <p>Determines if garbage collection is allowed when performing
            the operation. If <c>{allow_gc, false}</c> is passed, and
            a garbage collection is needed to determine the
            result of the operation, the operation is aborted (see
            information on <c><anno>CheckResult</anno></c> below).
            The default is to allow garbage collection, that is,
            <c>{allow_gc, true}</c>.</p>
          </item>
          <tag><c>{async, RequestId}</c></tag>
          <item>
            <p>The function <c>check_process_code/3</c> returns
            the value <c>async</c> immediately after the request
            has been sent. When the request has been processed, the
            process that called this function is passed a
            message on the form <c>{check_process_code, <anno>RequestId</anno>,
            <anno>CheckResult</anno>}</c>.</p>
          </item>
        </taglist>
        <p>If <c><anno>Pid</anno></c> equals <c>self()</c>, and
          no <c>async</c> option has been passed, the operation
          is performed at once. Otherwise a request for
          the operation is sent to the process identified by
          <c><anno>Pid</anno></c>, and is handled when
          appropriate. If no <c>async</c> option has been passed,
          the caller blocks until <c><anno>CheckResult</anno></c>
          is available and can be returned.</p>
        <p><c><anno>CheckResult</anno></c> informs about the result of
          the request as follows:</p>
        <taglist>
          <tag><c>true</c></tag>
          <item>
            <p>The process identified by <c><anno>Pid</anno></c>
            executes old code for <c><anno>Module</anno></c>.
            That is, the current call of the process executes old
            code for this module, or the process has references
            to old code for this module, or the process contains
            funs that references old code for this module.</p>
          </item>
          <tag><c>false</c></tag>
          <item>
            <p>The process identified by <c><anno>Pid</anno></c> does
            not execute old code for <c><anno>Module</anno></c>.</p>
          </item>
          <tag><c>aborted</c></tag>
          <item>
            <p>The operation was aborted, as the process needed to
            be garbage collected to determine the operation result,
            and the operation was requested
            by passing option <c>{allow_gc, false}</c>.</p>
          </item>
        </taglist>
	<note>
	<p>
	  Up until ERTS version 8.*, the check process code operation
	  checks for all types of references to the old code. That is,
	  direct references (e.g. return addresses on the process
	  stack), indirect references (<c>fun</c>s in process
	  context), and references to literals in the code.
	</p>
	<p>
	  As of ERTS version 9.0, the check process code operation
	  only checks for direct references to the code. Indirect
	  references via <c>fun</c>s will be ignored. If such
	  <c>fun</c>s exist and are used after a purge of the old
	  code, an exception will be raised upon usage (same as
	  the case when the <c>fun</c> is received by the process
	  after the purge). Literals will be taken care of (copied)
	  at a  later stage. This behavior can as of ERTS version
	  8.1 be enabled when
	  <seealso marker="doc/installation_guide:INSTALL#Advanced-configuration-and-build-of-ErlangOTP_Configuring">building OTP</seealso>,
	  and will automatically be enabled if dirty scheduler
	  support is enabled.
	</p>
	</note>
        <p>See also <seealso marker="kernel:code">
          <c>code(3)</c></seealso>.</p>
        <p>Failures:</p>
        <taglist>
          <tag><c>badarg</c></tag>
          <item>If <c><anno>Pid</anno></c> is not a node local process
            identifier.
          </item>
          <tag><c>badarg</c></tag>
          <item>If <c><anno>Module</anno></c> is not an atom.
          </item>
          <tag><c>badarg</c></tag>
          <item>If <c><anno>OptionList</anno></c> is an invalid list of options.
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="convert_time_unit" arity="3" since="OTP 18.0"/>
      <fsummary>Convert time unit of a time value.</fsummary>
      <desc>
        <p>Converts the <c><anno>Time</anno></c> value of time unit
          <c><anno>FromUnit</anno></c> to the corresponding
          <c><anno>ConvertedTime</anno></c> value of time unit
          <c><anno>ToUnit</anno></c>. The result is rounded
          using the floor function.</p>
        <warning>
          <p>You can lose accuracy and precision when converting
            between time units. To minimize such loss, collect all
            data at <c>native</c> time unit and do the conversion on the end
            result.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="crc32" arity="1" since=""/>
      <fsummary>Compute crc32 (IEEE 802.3) checksum.</fsummary>
      <desc>
        <p>Computes and returns the crc32 (IEEE 802.3 style) checksum
          for <c><anno>Data</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="crc32" arity="2" since=""/>
      <fsummary>Compute crc32 (IEEE 802.3) checksum.</fsummary>
      <desc>
        <p>Continues computing the crc32 checksum by combining
          the previous checksum, <c><anno>OldCrc</anno></c>, with the checksum
          of <c><anno>Data</anno></c>.</p>
        <p>The following code:</p>
        <code>
X = erlang:crc32(Data1),
Y = erlang:crc32(X,Data2).</code>
        <p>assigns the same value to <c>Y</c> as this:</p>
        <code>
Y = erlang:crc32([Data1,Data2]).</code>
      </desc>
    </func>

    <func>
      <name name="crc32_combine" arity="3" since=""/>
      <fsummary>Combine two crc32 (IEEE 802.3) checksums.</fsummary>
      <desc>
        <p>Combines two previously computed crc32 checksums.
          This computation requires the size of the data object for
          the second checksum to be known.</p>
        <p>The following code:</p>
        <code>
Y = erlang:crc32(Data1),
Z = erlang:crc32(Y,Data2).</code>
        <p>assigns the same value to <c>Z</c> as this:</p>
	<code>
X = erlang:crc32(Data1),
Y = erlang:crc32(Data2),
Z = erlang:crc32_combine(X,Y,iolist_size(Data2)).</code>
      </desc>
    </func>

    <func>
      <name name="date" arity="0" since=""/>
      <fsummary>Current date.</fsummary>
      <desc>
        <p>Returns the current date as <c>{Year, Month, Day}</c>.</p>
        <p>The time zone and Daylight Saving Time correction depend on
          the underlying OS. Example:</p>
        <pre>
> <input>date().</input>
{1995,2,19}</pre>
      </desc>
    </func>

    <func>
      <name name="decode_packet" arity="3" since=""/>
      <fsummary>Extract a protocol packet from a binary.</fsummary>
      <desc>
        <p>Decodes the binary <c><anno>Bin</anno></c> according to the packet
          protocol specified by <c><anno>Type</anno></c>. Similar to the packet
          handling done by sockets with option
          <c>{packet,<anno>Type</anno>}.</c></p>
        <p>If an entire packet is contained in <c><anno>Bin</anno></c>, it is
          returned together with the remainder of the binary as
          <c>{ok,<anno>Packet</anno>,<anno>Rest</anno>}</c>.</p>
        <p>If <c><anno>Bin</anno></c> does not contain the entire packet,
          <c>{more,<anno>Length</anno>}</c> is returned.
          <c><anno>Length</anno></c> is either the
          expected <em>total size</em> of the packet, or <c>undefined</c>
          if the expected packet size is unknown. <c>decode_packet</c>
          can then be called again with more data added.</p>
        <p>If the packet does not conform to the protocol format,
          <c>{error,<anno>Reason</anno>}</c> is returned.</p>
        <p><c>Type</c>s:</p>
        <taglist>
          <tag><c>raw | 0</c></tag>
          <item>
            <p>No packet handling is done. The entire binary is
              returned unless it is empty.</p>
          </item>
          <tag><c>1 | 2 | 4</c></tag>
          <item>
            <p>Packets consist of a header specifying the number of
              bytes in the packet, followed by that number of bytes.
              The length of the header can be one, two, or four bytes;
              the order of the bytes is big-endian. The header
              is stripped off when the packet is returned.</p>
          </item>
          <tag><c>line</c></tag>
          <item>
            <p>A packet is a line-terminated by a delimiter byte,
              default is the latin-1 newline character. The delimiter
              byte is included in the returned packet unless the line
              was truncated according to option <c>line_length</c>.</p>
          </item>
          <tag><c>asn1 | cdr | sunrm | fcgi | tpkt</c></tag>
          <item>
            <p>The header is <em>not</em> stripped off.</p>
            <p>The meanings of the packet types are as follows:</p>
            <taglist>     
              <tag><c>asn1</c> - ASN.1 BER</tag><item></item>
              <tag><c>sunrm</c> - Sun's RPC encoding</tag><item></item>
              <tag><c>cdr</c> - CORBA (GIOP 1.1)</tag><item></item>
              <tag><c>fcgi</c> - Fast CGI</tag><item></item>
              <tag><c>tpkt</c> - TPKT format [RFC1006]</tag><item></item>
            </taglist>
          </item>
          <tag><c>http | httph | http_bin | httph_bin</c></tag>
          <item>
            <p>The Hypertext Transfer Protocol. The packets
              are returned with the format according to
              <c><anno>HttpPacket</anno></c> described earlier.
              A packet is either a
              request, a response, a header, or an end of header
              mark. Invalid lines are returned as
              <c><anno>HttpError</anno></c>.</p>
            <p>Recognized request methods and header fields are returned
              as atoms. Others are returned as strings. Strings of
              unrecognized header fields are formatted with only
              capital letters first and after hyphen characters, for
              example, <c>"Sec-Websocket-Key"</c>.</p>
            <p>The protocol type <c>http</c> is only to be used for
              the first line when an <c><anno>HttpRequest</anno></c> or an
              <c><anno>HttpResponse</anno></c> is expected.
              The following calls are to use <c>httph</c> to get
              <c><anno>HttpHeader</anno></c>s until
              <c>http_eoh</c> is returned, which marks the end of the
              headers and the beginning of any following message body.</p> 
            <p>The variants <c>http_bin</c> and <c>httph_bin</c> return
              strings (<c>HttpString</c>) as binaries instead of lists.</p>
          </item>
        </taglist>
        <p>Options:</p>
        <taglist>
          <tag><c>{packet_size, integer() >= 0}</c></tag>
          <item><p>Sets the maximum allowed size of the packet body.
            If the packet header indicates that the length of the
            packet is longer than the maximum allowed length, the
            packet is considered invalid. Defaults to 0, which means
            no size limit.</p>
          </item>
          <tag><c>{line_length, integer() >= 0}</c></tag>
          <item>
            <p>For packet type <c>line</c>, lines longer than
              the indicated length are truncated.</p>
            <p>Option <c>line_length</c> also applies to <c>http*</c>
              packet types as an alias for option <c>packet_size</c>
              if <c>packet_size</c> itself is not set. This use is
              only intended for backward compatibility.</p>
          </item>
          <tag><c>{line_delimiter, 0 =&lt; byte() =&lt; 255}</c></tag>
          <item><p>For packet type <c>line</c>, sets the delimiting byte.
            Default is the latin-1 character <c>$\n</c>.</p>
          </item>
        </taglist>
        <p>Examples:</p>
        <pre>
> <input>erlang:decode_packet(1,&lt;&lt;3,"abcd"&gt;&gt;,[]).</input>
{ok,&lt;&lt;"abc"&gt;&gt;,&lt;&lt;"d"&gt;&gt;}
> <input>erlang:decode_packet(1,&lt;&lt;5,"abcd"&gt;&gt;,[]).</input>
{more,6}</pre>
      </desc>
    </func>

    <func>
      <name name="delete_element" arity="2" since="OTP R16B"/>
      <fsummary>Delete element at index in a tuple.</fsummary>
      <type_desc variable="Index">1..tuple_size(<anno>Tuple1</anno>)</type_desc>
      <desc>
        <p>Returns a new tuple with element at <c><anno>Index</anno></c>
          removed from tuple <c><anno>Tuple1</anno></c>, for example:</p>
        <pre>
> <input>erlang:delete_element(2, {one, two, three}).</input>
{one,three}</pre>
      </desc>
    </func>

    <func>
      <name name="delete_module" arity="1" since=""/>
      <fsummary>Make the current code for a module old.</fsummary>
      <desc>
        <p>Makes the current code for <c><anno>Module</anno></c> become old
          code and deletes all references for this module from the export table.
          Returns <c>undefined</c> if the module does not exist,
          otherwise <c>true</c>.</p>
        <warning>
          <p>This BIF is intended for the code server (see
            <seealso marker="kernel:code"><c>code(3)</c></seealso>)
            and is not to be used elsewhere.</p>
        </warning>
        <p>Failure: <c>badarg</c> if there already is an old version of
          <c>Module</c>.</p>
      </desc>
    </func>

    <func>
      <name name="demonitor" arity="1" since=""/>
      <fsummary>Stop monitoring.</fsummary>
      <desc>
        <p>If <c><anno>MonitorRef</anno></c> is a reference that the
          calling process obtained by calling
          <seealso marker="#monitor/2"><c>monitor/2</c></seealso>,
          this monitoring is turned off. If the monitoring is already
          turned off, nothing happens.</p>
        <p>Once <c>demonitor(<anno>MonitorRef</anno>)</c> has returned, it is
          guaranteed that no <c>{'DOWN',
          <anno>MonitorRef</anno>, _, _, _}</c> message,
          because of the monitor, will be placed in the caller message queue
          in the future. However, a <c>{'DOWN',
          <anno>MonitorRef</anno>, _, _, _}</c> message
          can have been placed in the caller message queue before
          the call. It is therefore usually advisable
          to remove such a <c>'DOWN'</c> message from the message queue
          after monitoring has been stopped.
          <seealso marker="#demonitor/2">
          <c>demonitor(<anno>MonitorRef</anno>, [flush])</c></seealso>
          can be used instead of <c>demonitor(<anno>MonitorRef</anno>)</c>
          if this cleanup is wanted.</p>
        <note>
          <p>Before Erlang/OTP R11B (ERTS 5.5) <c>demonitor/1</c>
            behaved completely asynchronously, that is, the monitor was active
            until the "demonitor signal" reached the monitored entity. This
            had one undesirable effect. You could never know when
            you were guaranteed <em>not</em> to receive a <c>DOWN</c> message
            because of the monitor.</p>
          <p>The current behavior can be viewed as two combined operations:
            asynchronously send a "demonitor signal" to the monitored entity
            and ignore any future results of the monitor.</p>
        </note>
        <p>Failure: It is an error if <c><anno>MonitorRef</anno></c> refers to a
          monitoring started by another process. Not all such cases are
          cheap to check. If checking is cheap, the call fails with
          <c>badarg</c>, for example if <c><anno>MonitorRef</anno></c> is a
          remote reference.</p>
      </desc>
    </func>

    <func>
      <name name="demonitor" arity="2" since=""/>
      <fsummary>Stop monitoring.</fsummary>
      <desc>
        <p>The returned value is <c>true</c> unless <c>info</c> is part
          of <c><anno>OptionList</anno></c>.</p>
        <p><c>demonitor(<anno>MonitorRef</anno>, [])</c> is equivalent to
          <seealso marker="#demonitor/1">
          <c>demonitor(<anno>MonitorRef</anno>)</c></seealso>.</p>
        <p><c><anno>Option</anno></c>s:</p>
        <taglist>
          <tag><c>flush</c></tag>
          <item>
            <p>Removes (one) <c>{_,
              <anno>MonitorRef</anno>, _, _, _}</c> message,
              if there is one, from the caller message queue after
              monitoring has been stopped.</p>
            <p>Calling <c>demonitor(<anno>MonitorRef</anno>, [flush])</c>
              is equivalent to the following, but more efficient:</p>
            <code type="none">
demonitor(MonitorRef),
receive
    {_, MonitorRef, _, _, _} ->
        true
after 0 ->
        true
end</code>
          </item>
          <tag><c>info</c></tag>
          <item>
            <p>The returned value is one of the following:</p>
            <taglist>
              <tag><c>true</c></tag>
              <item><p>The monitor was found and removed. In this case,
                no <c>'DOWN'</c> message corresponding to this
                monitor has been delivered and will not be delivered.</p>
              </item>
              <tag><c>false</c></tag>
              <item><p>The monitor was not found and could not be removed.
                This probably because someone already has placed a
                <c>'DOWN'</c> message corresponding to this monitor
                in the caller message queue.</p>
              </item>
            </taglist>
            <p>If option <c>info</c> is combined with option <c>flush</c>,
              <c>false</c> is returned if a flush was needed,
              otherwise <c>true</c>.</p>
          </item>
        </taglist>
        <note>
          <p>More options can be added in a future release.</p>
        </note>
        <p>Failures:</p>
        <taglist>
          <tag><c>badarg</c></tag>
          <item>If <c><anno>OptionList</anno></c> is not a list.
          </item>
          <tag><c>badarg</c></tag>
          <item>If <c><anno>Option</anno></c> is an invalid option.
          </item>
          <tag><c>badarg</c></tag>
          <item>The same failure as for
            <seealso marker="#demonitor/1"><c>demonitor/1</c></seealso>.
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="disconnect_node" arity="1" since=""/>
      <fsummary>Force the disconnection of a node.</fsummary>
      <desc>
        <p>Forces the disconnection of a node. This appears to
          the node <c><anno>Node</anno></c> as if the local node has crashed.
          This BIF is mainly used in the Erlang network authentication
          protocols.</p>
        <p>Returns <c>true</c> if disconnection succeeds,
          otherwise <c>false</c>. If the local node is not alive,
          <c>ignored</c> is returned.</p>
      </desc>
    </func>

    <func>
      <name name="display" arity="1" since=""/>
      <fsummary>Print a term on standard output.</fsummary>
      <desc>
        <p>Prints a text representation of <c><anno>Term</anno></c> on the
          standard output.</p>
        <warning>
          <p>This BIF is intended for debugging only.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="dist_ctrl_get_data" arity="1" since="OTP 21.0"/>
      <fsummary>Get distribution channel data to pass to another node.</fsummary>
      <desc>
        <p>
	  Get distribution channel data from the local node that is
	  to be passed to the remote node. The distribution channel
	  is identified by <c><anno>DHandle</anno></c>. If no data
	  is available, the atom <c>none</c> is returned. One
	  can request to be informed by a message when more
	  data is available by calling
	  <seealso marker="erlang#dist_ctrl_get_data_notification/1"><c>erlang:dist_ctrl_get_data_notification(DHandle)</c></seealso>.
	</p>
	<p>The returned value when there are data available depends
	on the value of the <c>get_size</c> option configured on the
	distribution channel identified by <c><anno>DHandle</anno></c>.
	For more information see the documentation of the <c>get_size</c>
	option for the
	<seealso marker="#dist_ctrl_set_opt/3"><c>erlang:dist_ctrl_set_opt/3</c></seealso>
	function.</p>
	<note><p>
	  Only the process registered as distribution
	  controller for the distribution channel identified by
	  <c><anno>DHandle</anno></c> is allowed to call this
	  function.
	</p></note>
	<p>
	  This function is used when implementing an alternative
	  distribution carrier using processes as distribution
	  controllers. <c><anno>DHandle</anno></c> is retrived
	  via the callback
	  <seealso marker="erts:alt_dist#hs_data_f_handshake_complete"><c>f_handshake_complete</c></seealso>.
	  More information can be found in the documentation of
	  <seealso marker="erts:alt_dist#distribution_module">ERTS
	  User's Guide âžœ How to implement an Alternative Carrier
	  for the Erlang Distribution âžœ Distribution Module</seealso>.
	</p>
      </desc>
    </func>

    <func>
      <name name="dist_ctrl_get_opt" arity="2" clause_i="1" since="OTP 22.0"/>
      <fsummary>Get value of the get_size option on a distribution channel</fsummary>
      <desc>
	<p>Returns the value of the <c>get_size</c> option on the distribution channel
	identified by <c><anno>DHandle</anno></c>. For more information see the
	documentation of the <c>get_size</c> option for the
	<seealso marker="#dist_ctrl_set_opt/3"><c>erlang:dist_ctrl_set_opt/3</c></seealso>
	function.</p>
	<note><p>
	  Only the process registered as distribution
	  controller for the distribution channel identified by
	  <c><anno>DHandle</anno></c> is allowed to call this
	  function.
	</p></note>
	<p>
	  This function is used when implementing an alternative
	  distribution carrier using processes as distribution
	  controllers. <c><anno>DHandle</anno></c> is retrived
	  via the callback
	  <seealso marker="erts:alt_dist#hs_data_f_handshake_complete"><c>f_handshake_complete</c></seealso>.
	  More information can be found in the documentation of
	  <seealso marker="erts:alt_dist#distribution_module">ERTS
	  User's Guide âžœ How to implement an Alternative Carrier
	  for the Erlang Distribution âžœ Distribution Module</seealso>.
	</p>
      </desc>
    </func>

    <func>
      <name name="dist_ctrl_get_data_notification" arity="1" since="OTP 21.0"/>
      <fsummary>Request notification about available outgoing distribution channel data.</fsummary>
      <desc>
        <p>
	  Request notification when more data is available to
	  fetch using
	  <seealso marker="erlang#dist_ctrl_get_data/1"><c>erlang:dist_ctrl_get_data(DHandle)</c></seealso>
	  for the distribution channel identified by
	  <c><anno>DHandle</anno></c>. When more data is present,
	  the caller will be sent the message <c>dist_data</c>.
	  Once a <c>dist_data</c> messages has been sent, no
	  more <c>dist_data</c> messages will be sent until
	  the <c>dist_ctrl_get_data_notification/1</c> function has been called
	  again.
	</p>
	<note><p>
	  Only the process registered as distribution
	  controller for the distribution channel identified by
	  <c><anno>DHandle</anno></c> is allowed to call this
	  function.
	</p></note>
	<p>
	  This function is used when implementing an alternative
	  distribution carrier using processes as distribution
	  controllers. <c><anno>DHandle</anno></c> is retrived
	  via the callback
	  <seealso marker="erts:alt_dist#hs_data_f_handshake_complete"><c>f_handshake_complete</c></seealso>.
	  More information can be found in the documentation of
	  <seealso marker="erts:alt_dist#distribution_module">ERTS
	  User's Guide âžœ How to implement an Alternative Carrier
	  for the Erlang Distribution âžœ Distribution Module</seealso>.
	</p>
      </desc>
    </func>

    <func>
      <name name="dist_ctrl_input_handler" arity="2" since="OTP 21.0"/>
      <fsummary>Register distribution channel input handler process.</fsummary>
      <desc>
        <p>
	  Register an alternate input handler process for the
	  distribution channel identified by <c><anno>DHandle</anno></c>.
	  Once this function has been called, <c><anno>InputHandler</anno></c>
	  is the only process allowed to call
	  <seealso marker="erlang#dist_ctrl_put_data/2"><c>erlang:dist_ctrl_put_data(DHandle, Data)</c></seealso>
	  with the <c><anno>DHandle</anno></c> identifing this distribution
	  channel.
	</p>
	<note><p>
	  Only the process registered as distribution
	  controller for the distribution channel identified by
	  <c><anno>DHandle</anno></c> is allowed to call this
	  function.
	</p></note>
	<p>
	  This function is used when implementing an alternative
	  distribution carrier using processes as distribution
	  controllers. <c><anno>DHandle</anno></c> is retrived
	  via the callback
	  <seealso marker="erts:alt_dist#hs_data_f_handshake_complete"><c>f_handshake_complete</c></seealso>.
	  More information can be found in the documentation of
	  <seealso marker="erts:alt_dist#distribution_module">ERTS
	  User's Guide âžœ How to implement an Alternative Carrier
	  for the Erlang Distribution âžœ Distribution Module</seealso>.
	</p>
      </desc>
    </func>

    <func>
      <name name="dist_ctrl_put_data" arity="2" since="OTP 21.0"/>
      <fsummary>Pass data into the VM from a distribution channel.</fsummary>
      <desc>
        <p>
	  Deliver distribution channel data from a remote node to the
	  local node.
	</p>
	<note><p>
	  Only the process registered as distribution
	  controller for the distribution channel identified by
	  <c><anno>DHandle</anno></c> is allowed to call this
	  function unless an alternate input handler process
	  has been registered using
	  <seealso marker="erlang#dist_ctrl_input_handler/2"><c>erlang:dist_ctrl_input_handler(DHandle, InputHandler)</c></seealso>.
	  If an alternate input handler has been registered, only
	  the registered input handler process is allowed to call
	  this function.
	</p></note>
	<p>
	  This function is used when implementing an alternative
	  distribution carrier using processes as distribution
	  controllers. <c><anno>DHandle</anno></c> is retrived
	  via the callback
	  <seealso marker="erts:alt_dist#hs_data_f_handshake_complete"><c>f_handshake_complete</c></seealso>.
	  More information can be found in the documentation of
	  <seealso marker="erts:alt_dist#distribution_module">ERTS
	  User's Guide âžœ How to implement an Alternative Carrier
	  for the Erlang Distribution âžœ Distribution Module</seealso>.
	</p>
      </desc>
    </func>

    <func>
      <name name="dist_ctrl_set_opt" arity="3" clause_i="1" since="OTP 22.0"/>
      <fsummary>Set value of the get_size option on a distribution channel</fsummary>
      <desc>
        <p>Sets the value of the <c>get_size</c> option on the distribution channel
	identified by <c><anno>DHandle</anno></c>. This option controls the return
	value of calls to
	<seealso marker="#dist_ctrl_get_data/1">erlang:dist_ctrl_get_data(<anno>DHandle</anno>)</seealso>
	where <c><anno>DHandle</anno></c> equals <c><anno>DHandle</anno></c> used
	when setting this option.
	When the <c>get_size</c> option is:</p>
	<taglist>
	  <tag><c>false</c></tag>
	  <item>
	    and there are distribution data available, a call to
	    <c>erlang:dist_ctrl_get_data(<anno>DHandle</anno>)</c>
	    will just return <c>Data</c> to pass over the channel.
	    This is the default value of the <c>get_size</c> option.
	  </item>
	  <tag><c>true</c></tag>
	  <item>
	    and there are distribution data available, a call to
	    <c>erlang:dist_ctrl_get_data(<anno>DHandle</anno>)</c>
	    will return <c>Data</c> to pass over the channel as well as
	    the <c>Size</c> of <c>Data</c> in bytes. This is returned as
	    a tuple on the form <c>{Size, Data}</c>.
	  </item>
	</taglist>
	<p>All options are set to default when a channel is closed.</p>
	<note><p>
	  Only the process registered as distribution
	  controller for the distribution channel identified by
	  <c><anno>DHandle</anno></c> is allowed to call this
	  function.
	</p></note>
	<p>
	  This function is used when implementing an alternative
	  distribution carrier using processes as distribution
	  controllers. <c><anno>DHandle</anno></c> is retrived
	  via the callback
	  <seealso marker="erts:alt_dist#hs_data_f_handshake_complete"><c>f_handshake_complete</c></seealso>.
	  More information can be found in the documentation of
	  <seealso marker="erts:alt_dist#distribution_module">ERTS
	  User's Guide âžœ How to implement an Alternative Carrier
	  for the Erlang Distribution âžœ Distribution Module</seealso>.
	</p>
      </desc>
    </func>
    
    <func>
      <name name="element" arity="2" since=""/>
      <fsummary>Return the Nth element of a tuple.</fsummary>
      <type_desc variable="N">1..tuple_size(<anno>Tuple</anno>)</type_desc>
      <desc>
        <p>Returns the <c><anno>N</anno></c>th element (numbering from 1) of
          <c><anno>Tuple</anno></c>, for example:</p>
        <pre>
> <input>element(2, {a, b, c}).</input>
b</pre>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="erase" arity="0" since=""/>
      <fsummary>Return and delete the process dictionary.</fsummary>
      <desc>
        <p>Returns the process dictionary and deletes it, for
          example:</p>
        <pre>
> <input>put(key1, {1, 2, 3}),</input>
<input>put(key2, [a, b, c]),</input>
<input>erase().</input>
[{key1,{1,2,3}},{key2,[a,b,c]}]</pre>
      </desc>
    </func>

    <func>
      <name name="erase" arity="1" since=""/>
      <fsummary>Return and delete a value from the process dictionary.
      </fsummary>
      <desc>
        <p>Returns the value <c><anno>Val</anno></c> associated with
          <c><anno>Key</anno></c> and deletes it from the process dictionary.
          Returns <c>undefined</c> if no value is associated with
          <c><anno>Key</anno></c>. Example:</p>
        <pre>
> <input>put(key1, {merry, lambs, are, playing}),</input>
<input>X = erase(key1),</input>
<input>{X, erase(key1)}.</input>
{{merry,lambs,are,playing},undefined}</pre>
      </desc>
    </func>

    <func>
      <name name="error" arity="1" since=""/>
      <fsummary>Stop execution with a specified reason.</fsummary>
      <desc>
        <p>Stops the execution of the calling process with the reason
          <c><anno>Reason</anno></c>, where <c><anno>Reason</anno></c>
          is any term. The exit reason is
          <c>{<anno>Reason</anno>, Where}</c>, where <c>Where</c>
          is a list of the functions most recently called (the current
          function first). As evaluating this function causes
          the process to terminate, it has no return value. Example:</p>
        <pre>
> <input>catch error(foobar).</input>
{'EXIT',{foobar,[{shell,apply_fun,3,
                        [{file,"shell.erl"},{line,906}]},
                 {erl_eval,do_apply,6,[{file,"erl_eval.erl"},{line,677}]},
                 {erl_eval,expr,5,[{file,"erl_eval.erl"},{line,430}]},
                 {shell,exprs,7,[{file,"shell.erl"},{line,687}]},
                 {shell,eval_exprs,7,[{file,"shell.erl"},{line,642}]},
                 {shell,eval_loop,3,[{file,"shell.erl"},{line,627}]}]}}
</pre>
      </desc>
    </func>

    <func>
      <name name="error" arity="2" since=""/>
      <fsummary>Stop execution with a specified reason.</fsummary>
      <desc>
        <p>Stops the execution of the calling process with the reason
          <c><anno>Reason</anno></c>, where <c><anno>Reason</anno></c>
          is any term. The exit reason is
          <c>{<anno>Reason</anno>, Where}</c>, where <c>Where</c>
          is a list of the functions most recently called (the current
          function first). <c><anno>Args</anno></c> is expected to be the
          list of arguments for the current function; in Beam it is used
          to provide the arguments for the current function in
          the term <c>Where</c>. As evaluating this function causes
          the process to terminate, it has no return value.</p>
      </desc>
    </func>

    <func>
      <name name="exit" arity="1" since=""/>
      <fsummary>Stop execution with a specified reason.</fsummary>
      <desc>
        <p>Stops the execution of the calling process with exit reason
          <c><anno>Reason</anno></c>, where <c><anno>Reason</anno></c>
          is any term. As
          evaluating this function causes the process to terminate, it
          has no return value. Example:</p>
        <pre>
> <input>exit(foobar).</input>
** exception exit: foobar
> <input>catch exit(foobar).</input>
{'EXIT',foobar}</pre>
      </desc>
    </func>

    <func>
      <name name="exit" arity="2" since=""/>
      <fsummary>Send an exit signal to a process or a port.</fsummary>
      <desc>
        <p>Sends an exit signal with exit reason <c><anno>Reason</anno></c> to
          the process or port identified by <c><anno>Pid</anno></c>.</p>
        <p>The following behavior applies if <c><anno>Reason</anno></c>
          is any term, except <c>normal</c> or <c>kill</c>:</p>
        <list type="bulleted">
          <item><p>If <c><anno>Pid</anno></c> is not trapping exits,
            <c><anno>Pid</anno></c>
            itself exits with exit reason <c><anno>Reason</anno></c>.</p>
          </item>
          <item><p>If <c><anno>Pid</anno></c> is trapping exits, the exit
            signal is transformed into a message
            <c>{'EXIT', From, <anno>Reason</anno>}</c>
            and delivered to the message queue of <c><anno>Pid</anno></c>.</p>
          </item>
          <item><p><c>From</c> is the process identifier of the process
            that sent the exit signal. See also
            <seealso marker="#process_flag/2">
            <c>process_flag/2</c></seealso>.</p>
          </item>
        </list>
        <p>If <c><anno>Reason</anno></c> is the atom <c>normal</c>,
          <c><anno>Pid</anno></c>
          does not exit. If it is trapping exits, the exit signal is
          transformed into a message <c>{'EXIT', From, normal}</c>
          and delivered to its message queue.</p>
        <p>If <c><anno>Reason</anno></c> is the atom <c>kill</c>,
          that is, if <c>exit(<anno>Pid</anno>, kill)</c> is called,
          an untrappable exit signal is sent to <c><anno>Pid</anno></c>,
          which unconditionally exits with exit reason <c>killed</c>.</p>
      </desc>
    </func>

    <func>
      <name name="external_size" arity="1" since="OTP R14B04"/>
      <fsummary>Calculate the maximum size for a term encoded in the Erlang
        external term format.</fsummary>
      <desc>
        <p>Calculates, without doing the encoding, the maximum byte size for
          a term encoded in the Erlang external term format. The following
          condition applies always:</p>
          <pre>
> <input>Size1 = byte_size(term_to_binary(<anno>Term</anno>)),</input>
> <input>Size2 = erlang:external_size(<anno>Term</anno>),</input>
> <input>true = Size1 =&lt; Size2.</input>
true</pre>
        <p>This is equivalent to a call to:</p>
<code>
erlang:external_size(<anno>Term</anno>, [])</code>
      </desc>
    </func>

    <func>
      <name name="external_size" arity="2" since="OTP R14B04"/>
      <fsummary>Calculate the maximum size for a term encoded in the Erlang
        external term format.</fsummary>
      <desc>
        <p>Calculates, without doing the encoding, the maximum byte size for
          a term encoded in the Erlang external term format. The following
          condition applies always:</p>
          <pre>
> <input>Size1 = byte_size(term_to_binary(<anno>Term</anno>, <anno>Options</anno>)),</input>
> <input>Size2 = erlang:external_size(<anno>Term</anno>, <anno>Options</anno>),</input>
> <input>true = Size1 =&lt; Size2.</input>
true</pre>
        <p>Option <c>{minor_version, <anno>Version</anno>}</c> specifies how
          floats are encoded. For a detailed description, see
          <seealso marker="#term_to_binary/2">
          <c>term_to_binary/2</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="float" arity="1" since=""/>
      <fsummary>Convert a number to a float.</fsummary>
      <desc>
        <p>Returns a float by converting <c><anno>Number</anno></c> to a float,
          for example:</p>
        <pre>
> <input>float(55).</input>
55.0</pre>
        <p>Allowed in guard tests.</p>
        <note>
          <p>If used on the top level in a guard, it tests whether the
            argument is a floating point number; for clarity, use
            <seealso marker="#is_float/1"><c>is_float/1</c></seealso>
            instead.</p>
          <p>When <c>float/1</c> is used in an expression in a guard,
            such as '<c>float(A) == 4.0</c>', it converts a number as
            described earlier.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="float_to_binary" arity="1" since="OTP R16B"/>
      <fsummary>Text representation of a float.</fsummary>
      <desc>
        <p>The same as
          <c>float_to_binary(<anno>Float</anno>,[{scientific,20}])</c>.</p>
      </desc>
    </func>

    <func>
      <name name="float_to_binary" arity="2" since="OTP R16B"/>
      <fsummary>Text representation of a float formatted using specified
        options.</fsummary>
      <desc>
        <p>Returns a binary corresponding to the text
          representation of <c><anno>Float</anno></c> using fixed decimal 
          point formatting. <c><anno>Options</anno></c> behaves in the same
          way as <seealso marker="#float_to_list/2">
          <c>float_to_list/2</c></seealso>. Examples:</p>
        <pre>
> <input>float_to_binary(7.12, [{decimals, 4}]).</input>
&lt;&lt;"7.1200">>
> <input>float_to_binary(7.12, [{decimals, 4}, compact]).</input>
&lt;&lt;"7.12">></pre>
      </desc>
    </func>

    <func>
      <name name="float_to_list" arity="1" since=""/>
      <fsummary>Text representation of a float.</fsummary>
      <desc>
        <p>The same as
          <c>float_to_list(<anno>Float</anno>,[{scientific,20}])</c>.</p>
      </desc>
    </func>

    <func>
      <name name="float_to_list" arity="2" since="OTP R16B"/>
      <fsummary>Text representation of a float formatted using specified
        options.</fsummary>
      <desc>
        <p>Returns a string corresponding to the text representation
          of <c>Float</c> using fixed decimal point formatting.</p>
        <p>Available options:</p>
        <list type="bulleted">
          <item><p>If option <c>decimals</c> is specified, the returned value
            contains at most <c>Decimals</c> number of digits past the
            decimal point. If the number does not fit in the internal
            static buffer of 256 bytes, the function throws <c>badarg</c>.</p>
          </item>
          <item><p>If option <c>compact</c> is specified, the trailing zeros
            at the end of the list are truncated. This option is only
            meaningful together with option <c>decimals</c>.</p>
          </item>
          <item><p>If option <c>scientific</c> is specified, the float is
            formatted using scientific notation with <c>Decimals</c>
            digits of precision.</p>
          </item>
          <item><p>If <c>Options</c> is <c>[]</c>, the function behaves as
            <seealso marker="#float_to_list/1">
            <c>float_to_list/1</c></seealso>.</p>
          </item>
        </list>
        <p>Examples:</p>
        <pre>
> <input>float_to_list(7.12, [{decimals, 4}]).</input>
"7.1200"
> <input>float_to_list(7.12, [{decimals, 4}, compact]).</input>
"7.12"</pre>
      </desc>
    </func>

    <func>
      <name name="floor" arity="1" since="OTP 20.0"/>
      <fsummary>Returns the largest integer not greater than the argument</fsummary>
      <desc>
        <p>Returns the largest integer not greater than
	<c><anno>Number</anno></c>.
        For example:</p>
        <pre>
> <input>floor(-10.5).</input>
-11</pre>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="fun_info" arity="1" since=""/>
      <fsummary>Information about a fun.</fsummary>
      <desc>
        <p>Returns a list with information about the fun
          <c><anno>Fun</anno></c>. Each list element is a tuple. The order
          of the tuples is undefined, and more tuples can be added in a
          future release.</p>
        <warning>
          <p>This BIF is mainly intended for debugging, but it can
            sometimes be useful in library functions that need
            to verify, for example, the arity of a fun.</p>
        </warning>
        <p>Two types of funs have slightly different semantics:</p>
        <list type="bulleted">
          <item><p>A fun created by <c>fun M:F/A</c> is called an
            <em>external</em> fun. Calling it will always call the
            function <c>F</c> with arity <c>A</c> in the latest code for
            module <c>M</c>. Notice that module <c>M</c> does not even
            need to be loaded when the fun <c>fun M:F/A</c> is created.</p>
          </item>
          <item><p>All other funs are called <em>local</em>. When a local fun
            is called, the same version of the code that created the fun
            is called (even if a newer version of the module has been
            loaded).</p>
          </item>
        </list>
        <p>The following elements are always present in the list
          for both local and external funs:</p>
        <taglist>
          <tag><c>{type, Type}</c></tag>
          <item>
            <p><c>Type</c> is <c>local</c> or <c>external</c>.</p>
          </item>
          <tag><c>{module, Module}</c></tag>
          <item>
            <p><c>Module</c> (an atom) is the module name.</p>
            <p>If <c>Fun</c> is a local fun, <c>Module</c> is the module
              in which the fun is defined.</p>
            <p>If <c>Fun</c> is an external fun, <c>Module</c> is the
              module that the fun refers to.</p>
          </item>
          <tag><c>{name, Name}</c></tag>
          <item>
            <p><c>Name</c> (an atom) is a function name.</p>
            <p>If <c>Fun</c> is a local fun, <c>Name</c> is the name
              of the local function that implements the fun.
              (This name was generated by the compiler, and is
              only of informational use. As it is a local function, it
              cannot be called directly.)
              If no code is currently loaded for the fun, <c>[]</c>
              is returned instead of an atom.</p>
            <p>If <c>Fun</c> is an external fun, <c>Name</c> is the name
              of the exported function that the fun refers to.</p>
          </item>
          <tag><c>{arity, Arity}</c></tag>
          <item>
            <p><c>Arity</c> is the number of arguments that the fun
              is to be called with.</p>
          </item>
          <tag><c>{env, Env}</c></tag>
          <item>
            <p><c>Env</c> (a list) is the environment or free variables
              for the fun. For external funs, the returned list is
              always empty.</p>
          </item>
        </taglist>
        <p>The following elements are only present in the list if
          <c>Fun</c> is local:</p>
        <taglist>
          <tag><c>{pid, Pid}</c></tag>
          <item>
            <p><c>Pid</c> is the process identifier of the process
              that originally created the fun.</p>
            <p>It might point to the <c>init</c> process if the
              <c>Fun</c> was statically allocated when module was
              loaded (this optimisation is performed for local
              functions that do not capture the enviornment).</p>
          </item>
          <tag><c>{index, Index}</c></tag>
          <item>
            <p><c>Index</c> (an integer) is an index into the module
              fun table.</p>
          </item>
          <tag><c>{new_index, Index}</c></tag>
          <item>
            <p><c>Index</c> (an integer) is an index into the module
              fun table.</p>
          </item>
          <tag><c>{new_uniq, Uniq}</c></tag>
          <item>
            <p><c>Uniq</c> (a binary) is a unique value for this fun. It
              is calculated from the compiled code for the entire module.</p>
          </item>
          <tag><c>{uniq, Uniq}</c></tag>
          <item>
            <p><c>Uniq</c> (an integer) is a unique value for this fun.
              As from Erlang/OTP R15, this integer is calculated from the
              compiled code for the entire module. Before Erlang/OTP R15, this
              integer was based on only the body of the fun.</p>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="fun_info" arity="2" since=""/>
      <fsummary>Information about a fun.</fsummary>
      <type name="fun_info_item"/>
      <desc>
        <p>Returns information about <c><anno>Fun</anno></c> as specified by
          <c><anno>Item</anno></c>, in the form
          <c>{<anno>Item</anno>,<anno>Info</anno>}</c>.</p>
        <p>For any fun, <c><anno>Item</anno></c> can be any of the atoms
          <c>module</c>, <c>name</c>, <c>arity</c>, <c>env</c>, or
          <c>type</c>.</p>
        <p>For a local fun, <c><anno>Item</anno></c> can also be any of the
          atoms <c>index</c>, <c>new_index</c>, <c>new_uniq</c>,
          <c>uniq</c>, and <c>pid</c>. For an external fun, the value
          of any of these items is always the atom <c>undefined</c>.</p>
        <p>See
          <seealso marker="#fun_info/1"><c>erlang:fun_info/1</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="fun_to_list" arity="1" since=""/>
      <fsummary>Text representation of a fun.</fsummary>
      <desc>
        <p>Returns a string corresponding to the text
          representation of <c><anno>Fun</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="function_exported" arity="3" since=""/>
      <fsummary>Check if a function is exported and loaded.</fsummary>
      <desc>
        <p>Returns <c>true</c> if the module <c><anno>Module</anno></c> is
          loaded and contains an exported function
          <c><anno>Function</anno>/<anno>Arity</anno></c>,
          or if there is a BIF (a built-in function implemented in C)
          with the specified name, otherwise returns <c>false</c>.</p>
        <note>
          <p>This function used to return <c>false</c> for BIFs
            before Erlang/OTP 18.0.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="garbage_collect" arity="0" since=""/>
      <fsummary>Force an immediate garbage collection of the calling process.
      </fsummary>
      <desc>
        <p>Forces an immediate garbage collection of the
          executing process. The function is not to be used unless
          it has been noticed (or there are good reasons to suspect)
          that the spontaneous garbage collection will occur too late
          or not at all.</p>
        <warning>
          <p>Improper use can seriously degrade system performance.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="garbage_collect" arity="1" since=""/>
      <fsummary>Garbage collect a process.</fsummary>
      <desc>
        <p>The same as
          <seealso marker="#garbage_collect/2">
          <c>garbage_collect(<anno>Pid</anno>, [])</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="garbage_collect" arity="2" since="OTP 17.0"/>
      <fsummary>Garbage collect a process.</fsummary>
      <desc>
        <p>Garbage collects the node local process identified by
          <c><anno>Pid</anno></c>.</p>
        <p><c><anno>Option</anno></c>:</p>
        <taglist>
          <tag><c>{async, RequestId}</c></tag>
          <item>The function <c>garbage_collect/2</c> returns
            the value <c>async</c> immediately after the request
            has been sent. When the request has been processed, the
            process that called this function is passed a message on
            the form <c>{garbage_collect,
            <anno>RequestId</anno>, <anno>GCResult</anno>}</c>.
          </item>

          <tag><c>{type, 'major' | 'minor'}</c></tag>
          <item>Triggers garbage collection of requested type. Default value is
            <c>'major'</c>, which would trigger a fullsweep GC.
            The option <c>'minor'</c> is considered a hint and may lead to
            either minor or major GC run.</item>
        </taglist>
        <p>If <c><anno>Pid</anno></c> equals <c>self()</c>, and
          no <c>async</c> option has been passed, the garbage
          collection is performed at once, that is, the same as calling
          <seealso marker="#garbage_collect/0">
          <c>garbage_collect/0</c></seealso>.
          Otherwise a request for garbage collection
          is sent to the process identified by <c><anno>Pid</anno></c>,
          and will be handled when appropriate. If no <c>async</c>
          option has been passed, the caller blocks until
          <c><anno>GCResult</anno></c> is available and can be returned.</p>
        <p><c><anno>GCResult</anno></c> informs about the result of
          the garbage collection request as follows:</p>
        <taglist>
          <tag><c>true</c></tag>
          <item>
            The process identified by <c><anno>Pid</anno></c> has
            been garbage collected.
          </item>
          <tag><c>false</c></tag>
          <item>
            No garbage collection was performed, as
            the process identified by <c><anno>Pid</anno></c>
            terminated before the request could be satisfied.
          </item>
        </taglist>
        <p>Notice that the same caveats apply as for
          <seealso marker="#garbage_collect/0">
          <c>garbage_collect/0</c></seealso>.</p>
        <p>Failures:</p>
        <taglist>
          <tag><c>badarg</c></tag>
          <item>
            If <c><anno>Pid</anno></c> is not a node local process identifier.
          </item>
          <tag><c>badarg</c></tag>
          <item>
            If <c><anno>OptionList</anno></c> is an invalid list of options.
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="get" arity="0" since=""/>
      <fsummary>Return the process dictionary.</fsummary>
      <desc>
        <p>Returns the process dictionary as a list of
          <c>{<anno>Key</anno>, <anno>Val</anno>}</c> tuples, for example:</p>
        <pre>
> <input>put(key1, merry),</input>
<input>put(key2, lambs),</input>
<input>put(key3, {are, playing}),</input>
<input>get().</input>
[{key1,merry},{key2,lambs},{key3,{are,playing}}]</pre>
      </desc>
    </func>

    <func>
      <name name="get" arity="1" since=""/>
      <fsummary>Return a value from the process dictionary.</fsummary>
      <desc>
        <p>Returns the value <c><anno>Val</anno></c> associated with
          <c><anno>Key</anno></c> in the process dictionary, or <c>undefined</c>
          if <c><anno>Key</anno></c> does not exist. Example:</p>
        <pre>
> <input>put(key1, merry),</input>
<input>put(key2, lambs),</input>
<input>put({any, [valid, term]}, {are, playing}),</input>
<input>get({any, [valid, term]}).</input>
{are,playing}</pre>
      </desc>
    </func>

    <func>
      <name name="get_cookie" arity="0" since=""/>
      <fsummary>Get the magic cookie of the local node.</fsummary>
      <desc>
        <p>Returns the magic cookie of the local node if the node is
          alive, otherwise the atom <c>nocookie</c>.</p>
      </desc>
    </func>

    <func>
      <name name="get_keys" arity="0" since="OTP 18.0"/>
      <fsummary>Return a list of all keys from the process dictionary.
      </fsummary>
      <desc>
        <p>Returns a list of all keys present in the process dictionary,
          for example:</p>
        <pre>
> <input>put(dog, {animal,1}),</input>
<input>put(cow, {animal,2}),</input>
<input>put(lamb, {animal,3}),</input>
<input>get_keys().</input>
[dog,cow,lamb]</pre>
      </desc>
    </func>

    <func>
      <name name="get_keys" arity="1" since=""/>
      <fsummary>Return a list of keys from the process dictionary.</fsummary>
      <desc>
        <p>Returns a list of keys that are associated with the value
          <c><anno>Val</anno></c> in the process dictionary, for example:</p>
        <pre>
> <input>put(mary, {1, 2}),</input>
<input>put(had, {1, 2}),</input>
<input>put(a, {1, 2}),</input>
<input>put(little, {1, 2}),</input>
<input>put(dog, {1, 3}),</input>
<input>put(lamb, {1, 2}),</input>
<input>get_keys({1, 2}).</input>
[mary,had,a,little,lamb]</pre>
      </desc>
    </func>

    <func>
      <name name="get_stacktrace" arity="0" since=""/>
      <fsummary>Get the call stack back-trace of the last exception.</fsummary>
      <type name="stack_item"/>
      <desc>
	<warning><p><c>erlang:get_stacktrace/0</c> is deprecated and will stop working
	in a future release.</p></warning>
      <p>Instead of using <c>erlang:get_stacktrace/0</c> to retrieve
      the call stack back-trace, use the following syntax:</p>
<pre>
try Expr
catch
  Class:Reason:Stacktrace ->
   {Class,Reason,Stacktrace}
end</pre>
        <p><c>erlang:get_stacktrace/0</c> retrieves the call stack back-trace
        (<em>stacktrace</em>) for an exception that has just been
        caught in the calling process as a list of
        <c>{<anno>Module</anno>,<anno>Function</anno>,<anno>Arity</anno>,<anno>Location</anno>}</c>
        tuples. Field <c><anno>Arity</anno></c> in the first tuple can
        be the argument list of that function call instead of an arity
        integer, depending on the exception.</p>
        <p>If there has not been any exceptions in a process, the
          stacktrace is <c>[]</c>. After a code change for the process,
          the stacktrace can also be reset to <c>[]</c>.</p>
        <p>The stacktrace is the same data as operator <c>catch</c>
          returns, for example:</p>
        <pre>
{'EXIT',{badarg,Stacktrace}} = catch abs(x)</pre>
        <p><c><anno>Location</anno></c> is a (possibly empty) list
          of two-tuples that
          can indicate the location in the source code of the function.
          The first element is an atom describing the type of
          information in the second element. The following
          items can occur:</p>
        <taglist>
          <tag><c>file</c></tag>
          <item>The second element of the tuple is a string (list of
            characters) representing the filename of the source file
            of the function.
          </item>
          <tag><c>line</c></tag>
          <item>The second element of the tuple is the line number
            (an integer &gt; 0) in the source file
            where the exception occurred or the function was called.
          </item>
        </taglist>
        <warning><p>Developers should rely on stacktrace entries only for
          debugging purposes.</p>
          <p>The VM performs tail call optimization, which
          does not add new entries to the stacktrace, and also limits stacktraces
          to a certain depth. Furthermore, compiler options, optimizations and
          future changes may add or remove stacktrace entries, causing any code
          that expects the stacktrace to be in a certain order or contain specific
          items to fail.</p>
          <p>The only exception to this rule is <c>error:undef</c> which
          guarantees to include the <anno>Module</anno>, <anno>Function</anno> and <anno>Arity</anno>
          of the attempted function as the first stacktrace entry.</p>
        </warning>	
        <p>See also
          <seealso marker="#error/1"><c>error/1</c></seealso> and
          <seealso marker="#error/2"><c>error/2</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="group_leader" arity="0" since=""/>
      <fsummary>Get the group leader for the calling process.</fsummary>
      <desc>
        <p>Returns the process identifier of the group leader for the
          process evaluating the function.</p>
        <p>Every process is a member of some process group and all
          groups have a <em>group leader</em>. All I/O from the group
          is channeled to the group leader. When a new process is
          spawned, it gets the same group leader as the spawning
          process. Initially, at system startup, <c>init</c> is both
          its own group leader and the group leader of all processes.</p>
      </desc>
    </func>

    <func>
      <name name="group_leader" arity="2" since=""/>
      <fsummary>Set the group leader for a process.</fsummary>
      <desc>
        <p>Sets the group leader of <c><anno>Pid</anno></c>
          to <c><anno>GroupLeader</anno></c>.
          Typically, this is used when a process started from a
          certain shell is to have another group leader than
          <c>init</c>.</p>
        <p>The group leader should be rarely changed in
          applications with a supervision tree, because OTP
          assumes the group leader of their processes is
          their application master.</p>
        <p>See also
          <seealso marker="#group_leader/0"><c>group_leader/0</c></seealso>
          and <seealso marker="doc/design_principles:applications#stopping">OTP
          design principles</seealso> related to starting and stopping
          applications.</p>
      </desc>
    </func>

    <func>
      <name name="halt" arity="0" since=""/>
      <fsummary>Halt the Erlang runtime system and indicate normal exit to
        the calling environment.</fsummary>
      <desc>
        <p>The same as
          <seealso marker="#halt/2"><c>halt(0, [])</c></seealso>. Example:</p>
        <pre>
> <input>halt().</input>
os_prompt%</pre>
      </desc>
    </func>

    <func>
      <name name="halt" arity="1" since=""/>
      <fsummary>Halt the Erlang runtime system.</fsummary>
      <desc>
        <p>The same as <seealso marker="#halt/2">
          <c>halt(<anno>Status</anno>, [])</c></seealso>. Example:</p>
        <pre>
> <input>halt(17).</input>
os_prompt% <input>echo $?</input>
17
os_prompt%</pre>
      </desc>
    </func>

    <func>
      <name name="halt" arity="2" since="OTP R15B01"/>
      <fsummary>Halt the Erlang runtime system.</fsummary>
      <desc>
        <p><c><anno>Status</anno></c> must be a non-negative integer, a string,
          or the atom <c>abort</c>.
          Halts the Erlang runtime system. Has no return value.
          Depending on <c><anno>Status</anno></c>, the following occurs:</p>
        <taglist>
          <tag>integer()</tag>
          <item>The runtime system exits with integer value
            <c><anno>Status</anno></c>
            as status code to the calling environment (OS).
	    <note>
	      <p>On many platforms, the OS supports only status
	      codes 0-255. A too large status code is truncated by clearing
	      the high bits.</p>
	    </note>
          </item>
          <tag>string()</tag>
          <item>An Erlang crash dump is produced with <c><anno>Status</anno></c>
            as slogan. Then the runtime system exits with status code <c>1</c>.
	    The string will be truncated if longer than 200 characters.
	    <note>
	      <p>Before ERTS 9.1 (OTP-20.1) only code points in the range 0-255
	         was accepted in the string. Now any unicode string is valid.</p>
	    </note>
          </item>
          <tag><c>abort</c></tag>
          <item>The runtime system aborts producing a core dump, if that is
            enabled in the OS.
          </item>
        </taglist>
        <p>For integer <c><anno>Status</anno></c>, the Erlang runtime system
          closes all ports and allows async threads to finish their
          operations before exiting. To exit without such flushing, use
          <c><anno>Option</anno></c> as <c>{flush,false}</c>.</p>
        <p>For statuses <c>string()</c> and <c>abort</c>, option
          <c>flush</c> is ignored and flushing is <em>not</em> done.</p>
      </desc>
    </func>

    <func>
      <name name="hd" arity="1" since=""/>
      <fsummary>Head of a list.</fsummary>
      <desc>
        <p>Returns the head of <c><anno>List</anno></c>, that is,
          the first element, for example:</p>
        <pre>
> <input>hd([1,2,3,4,5]).</input>
1</pre>
        <p>Allowed in guard tests.</p>
        <p>Failure: <c>badarg</c> if <c><anno>List</anno></c> is the empty
          list <c>[]</c>.</p>
      </desc>
    </func>

    <func>
      <name name="hibernate" arity="3" since=""/>
      <fsummary>Hibernate a process until a message is sent to it.</fsummary>
      <desc>
        <p>Puts the calling process into a wait state where its memory
          allocation has been reduced as much as possible. This is
          useful if the process does not expect to receive any messages
          soon.</p>
        <p>The process is awaken when a message is sent to it, and control
          resumes in <c><anno>Module</anno>:<anno>Function</anno></c> with
          the arguments specified by <c><anno>Args</anno></c> with the call
          stack emptied, meaning that the process terminates when that
          function returns. Thus <c>erlang:hibernate/3</c> never
          returns to its caller.</p>
        <p>If the process has any message in its message queue,
          the process is awakened immediately in the same way as
          described earlier.</p>
        <p>In more technical terms, <c>erlang:hibernate/3</c>
          discards the call stack for the process,
          and then garbage collects the process. After this,
          all live data is in one continuous heap. The heap
          is then shrunken to the exact same size as the live data
          that it holds (even if that size is less than the minimum
          heap size for the process).</p>
        <p>If the size of the live data in the process is less than
          the minimum heap size, the first garbage collection occurring
          after the process is awakened ensures that the heap
          size is changed to a size not smaller than the minimum heap
          size.</p>
        <p>Notice that emptying the call stack means that any surrounding
          <c>catch</c> is removed and must be re-inserted after
          hibernation. One effect of this is that processes started
          using <c>proc_lib</c> (also indirectly, such as
          <c>gen_server</c> processes), are to use
          <seealso marker="stdlib:proc_lib#hibernate/3">
          <c>proc_lib:hibernate/3</c></seealso>
          instead, to ensure that the exception handler continues to work
          when the process wakes up.</p>
      </desc>
    </func>

    <func>
      <name name="insert_element" arity="3" since="OTP R16B"/>
      <fsummary>Insert an element at index in a tuple.</fsummary>
      <type_desc variable="Index">1..tuple_size(<anno>Tuple1</anno>)
        + 1</type_desc>
      <desc>
        <p>Returns a new tuple with element <c><anno>Term</anno></c>
          inserted at position
          <c><anno>Index</anno></c> in tuple <c><anno>Tuple1</anno></c>.
          All elements from position <c><anno>Index</anno></c> and upwards are
          pushed one step higher in the new tuple <c><anno>Tuple2</anno></c>.
          Example:</p>
        <pre>
> <input>erlang:insert_element(2, {one, two, three}, new).</input>
{one,new,two,three}</pre>
      </desc>
    </func>

    <func>
      <name name="integer_to_binary" arity="1" since="OTP R16B"/>
      <fsummary>Text representation of an integer.</fsummary>
      <desc>
        <p>Returns a binary corresponding to the text
          representation of <c><anno>Integer</anno></c>, for example:</p>
        <pre>
> <input>integer_to_binary(77).</input>
&lt;&lt;"77">></pre>
      </desc>
    </func>

    <func>
      <name name="integer_to_binary" arity="2" since="OTP R16B"/>
      <fsummary>Text representation of an integer.</fsummary>
      <desc>
        <p>Returns a binary corresponding to the text
          representation of <c><anno>Integer</anno></c> in base
          <c><anno>Base</anno></c>, for example:</p>
        <pre>
> <input>integer_to_binary(1023, 16).</input>
&lt;&lt;"3FF">></pre>
      </desc>
    </func>

    <func>
      <name name="integer_to_list" arity="1" since=""/>
      <fsummary>Text representation of an integer.</fsummary>
      <desc>
        <p>Returns a string corresponding to the text
          representation of <c><anno>Integer</anno></c>, for example:</p>
        <pre>
> <input>integer_to_list(77).</input>
"77"</pre>
      </desc>
    </func>

    <func>
      <name name="integer_to_list" arity="2" since=""/>
      <fsummary>Text representation of an integer.</fsummary>
      <desc>
        <p>Returns a string corresponding to the text
          representation of <c><anno>Integer</anno></c> in base
          <c><anno>Base</anno></c>, for example:</p>
        <pre>
> <input>integer_to_list(1023, 16).</input>
"3FF"</pre>
      </desc>
    </func>

    <func>
      <name name="iolist_size" arity="1" since=""/>
      <fsummary>Size of an iolist.</fsummary>
      <desc>
        <p>Returns an integer, that is the size in bytes,
          of the binary that would be the result of
          <c>iolist_to_binary(<anno>Item</anno>)</c>, for example:</p>
        <pre>
> <input>iolist_size([1,2|&lt;&lt;3,4>>]).</input>
4</pre>
      </desc>
    </func>

    <func>
      <name name="iolist_to_binary" arity="1" since=""/>
      <fsummary>Convert an iolist to a binary.</fsummary>
      <desc>
        <p>Returns a binary that is made from the integers and
          binaries in <c><anno>IoListOrBinary</anno></c>, for example:</p>
        <pre>
> <input>Bin1 = &lt;&lt;1,2,3&gt;&gt;.</input>
&lt;&lt;1,2,3&gt;&gt;
> <input>Bin2 = &lt;&lt;4,5&gt;&gt;.</input>
&lt;&lt;4,5&gt;&gt;
> <input>Bin3 = &lt;&lt;6&gt;&gt;.</input>
&lt;&lt;6&gt;&gt;
> <input>iolist_to_binary([Bin1,1,[2,3,Bin2],4|Bin3]).</input>
&lt;&lt;1,2,3,1,2,3,4,5,4,6&gt;&gt;</pre>
      </desc>
    </func>

    <func>
      <name name="iolist_to_iovec" arity="1" since="OTP 20.1"/>
      <fsummary>Converts an iolist to a iovec.</fsummary>
      <desc>
        <p>Returns an iovec that is made from the integers and binaries in
          <c><anno>IoListOrBinary</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="is_alive" arity="0" since=""/>
      <fsummary>Check whether the local node is alive.</fsummary>
      <desc>
        <p>Returns <c>true</c> if the local node is alive (that is, if
          the node can be part of a distributed system), otherwise
          <c>false</c>.</p>
      </desc>
    </func>

    <func>
      <name name="is_atom" arity="1" since=""/>
      <fsummary>Check whether a term is an atom.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is an atom,
          otherwise <c>false</c>.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="is_binary" arity="1" since=""/>
      <fsummary>Check whether a term is a binary.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is a binary,
          otherwise <c>false</c>.</p>
        <p>A binary always contains a complete number of bytes.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="is_bitstring" arity="1" since=""/>
      <fsummary>Check whether a term is a bitstring.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is a
          bitstring (including a binary), otherwise <c>false</c>.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="is_boolean" arity="1" since=""/>
      <fsummary>Check whether a term is a boolean.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is the
          atom <c>true</c> or the atom <c>false</c> (that is, a boolean).
          Otherwise returns <c>false</c>.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="is_builtin" arity="3" since=""/>
      <fsummary>Check if a function is a BIF implemented in C.</fsummary>
      <desc>
        <p>This BIF is useful for builders of cross-reference tools.</p>
        <p>Returns <c>true</c> if
          <c><anno>Module</anno>:<anno>Function</anno>/<anno>Arity</anno></c>
          is a BIF implemented in C, otherwise <c>false</c>.</p>
      </desc>
    </func>

    <func>
      <name name="is_float" arity="1" since=""/>
      <fsummary>Check whether a term is a float.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is a floating point
          number, otherwise <c>false</c>.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="is_function" arity="1" since=""/>
      <fsummary>Check whether a term is a fun.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is a fun, otherwise
          <c>false</c>.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="is_function" arity="2" since=""/>
      <fsummary>Check whether a term is a fun with a specified given arity.
      </fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is a fun that can be
          applied with <c><anno>Arity</anno></c> number of arguments, otherwise
          <c>false</c>.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="is_integer" arity="1" since=""/>
      <fsummary>Check whether a term is an integer.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is an integer,
          otherwise <c>false</c>.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="is_list" arity="1" since=""/>
      <fsummary>Check whether a term is a list.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is a list with
          zero or more elements, otherwise <c>false</c>.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="is_map" arity="1" since="OTP 17.0"/>
      <fsummary>Check whether a term is a map.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is a map,
          otherwise <c>false</c>.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="is_map_key" arity="2" since="OTP 21.0"/>
      <fsummary></fsummary>
      <desc>
        <p>Returns <c>true</c> if map <c><anno>Map</anno></c> contains
          <c><anno>Key</anno></c> and returns <c>false</c> if it does not
          contain the <c><anno>Key</anno></c>.</p>
        <p>The call fails with a <c>{badmap,Map}</c> exception if
          <c><anno>Map</anno></c> is not a map.</p>
        <p><em>Example:</em></p>
        <code type="none">
> Map = #{"42" => value}.
#{"42" => value}
> is_map_key("42",Map).
true
> is_map_key(value,Map).
false</code>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="is_number" arity="1" since=""/>
      <fsummary>Check whether a term is a number.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is an integer or a
          floating point number. Otherwise returns <c>false</c>.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="is_pid" arity="1" since=""/>
      <fsummary>Check whether a term is a process identifier.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is a process
          identifier, otherwise <c>false</c>.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="is_port" arity="1" since=""/>
      <fsummary>Check whether a term is a port.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is a port identifier,
          otherwise <c>false</c>.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="is_process_alive" arity="1" since=""/>
      <fsummary>Check whether a process is alive.</fsummary>
      <desc>
        <p><c><anno>Pid</anno></c> must refer to a process at the local
          node.</p>
        <p>Returns <c>true</c> if the process exists and is alive, that
          is, is not exiting and has not exited. Otherwise returns
          <c>false</c>.</p>
      </desc>
    </func>

    <func>
      <name name="is_record" arity="2" since=""/>
      <fsummary>Check whether a term appears to be a record.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is a tuple and its
          first element is <c><anno>RecordTag</anno></c>.
          Otherwise returns <c>false</c>.</p>
        <note>
          <p>Normally the compiler treats calls to <c>is_record/2</c>
            especially. It emits code to verify that <c><anno>Term</anno></c>
            is a tuple, that its first element is
            <c><anno>RecordTag</anno></c>, and that the
            size is correct. However, if <c><anno>RecordTag</anno></c> is
            not a literal atom, the BIF <c>is_record/2</c> is called
            instead and the size of the tuple is not verified.</p>
        </note>
        <p>Allowed in guard tests, if <c><anno>RecordTag</anno></c> is
          a literal atom.</p>
      </desc>
    </func>

    <func>
      <name name="is_record" arity="3" since=""/>
      <fsummary>Check whether a term appears to be a record.</fsummary>
      <desc>
        <p><c><anno>RecordTag</anno></c> must be an atom.</p>
        <p>Returns <c>true</c> if
          <c><anno>Term</anno></c> is a tuple,
          its first element is <c><anno>RecordTag</anno></c>,
          and its size is <c><anno>Size</anno></c>.
          Otherwise returns <c>false</c>.</p>
        <p>Allowed in guard tests if <c><anno>RecordTag</anno></c> is
          a literal atom and <c>Size</c> is a literal integer.</p>
        <note>
          <p>This BIF is documented for completeness. Usually
            <c>is_record/2</c> is to be used.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="is_reference" arity="1" since=""/>
      <fsummary>Check whether a term is a reference.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is a reference,
          otherwise <c>false</c>.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="is_tuple" arity="1" since=""/>
      <fsummary>Check whether a term is a tuple.</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c><anno>Term</anno></c> is a tuple,
          otherwise <c>false</c>.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="length" arity="1" since=""/>
      <fsummary>Length of a list.</fsummary>
      <desc>
        <p>Returns the length of <c><anno>List</anno></c>, for example:</p>
        <pre>
> <input>length([1,2,3,4,5,6,7,8,9]).</input>
9</pre>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="link" arity="1" since=""/>
      <fsummary>Create a link to another process (or port).</fsummary>
      <desc>
        <p>Creates a link between the calling process and another
          process (or port) <c><anno>PidOrPort</anno></c>, if there is
          not such a link
          already. If a process attempts to create a link to itself,
          nothing is done. Returns <c>true</c>.</p>
        <p>If <c><anno>PidOrPort</anno></c> does not exist, the behavior
          of the BIF
          depends on if the calling process is trapping exits or not (see
          <seealso marker="#process_flag/2">
          <c>process_flag/2</c></seealso>):</p>
        <list type="bulleted">
          <item><p>If the calling process is not trapping exits, and
            checking <c><anno>PidOrPort</anno></c> is cheap
            (that is, if <c><anno>PidOrPort</anno></c>
            is local), <c>link/1</c> fails with reason <c>noproc</c>.</p></item>
          <item><p>Otherwise, if the calling process is trapping exits,
            and/or <c><anno>PidOrPort</anno></c> is remote, <c>link/1</c>
            returns <c>true</c>, but an exit signal with reason <c>noproc</c>
            is sent to the calling process.</p></item>
        </list>
      </desc>
    </func>

    <func>
      <name name="list_to_atom" arity="1" since=""/>
      <fsummary>Convert from text representation to an atom.</fsummary>
      <desc>
        <p>Returns the atom whose text representation is
          <c><anno>String</anno></c>.</p>
        <p>As from Erlang/OTP 20, <c><anno>String</anno></c> may contain
          any Unicode character. Earlier versions allowed only ISO-latin-1
          characters as the implementation did not allow Unicode characters
          above 255. For more information on Unicode support in atoms, see
          <seealso marker="erl_ext_dist#utf8_atoms">note on UTF-8
          encoded atoms</seealso>
          in section "External Term Format" in the User's Guide.</p>
        <p>Example:</p>
        <pre>
> <input>list_to_atom("Erlang").</input>
'Erlang'</pre>
      </desc>
    </func>

    <func>
      <name name="list_to_binary" arity="1" since=""/>
      <fsummary>Convert a list to a binary.</fsummary>
      <desc>
        <p>Returns a binary that is made from the integers and
          binaries in <c><anno>IoList</anno></c>, for example:</p>
        <pre>
> <input>Bin1 = &lt;&lt;1,2,3&gt;&gt;.</input>
&lt;&lt;1,2,3&gt;&gt;
> <input>Bin2 = &lt;&lt;4,5&gt;&gt;.</input>
&lt;&lt;4,5&gt;&gt;
> <input>Bin3 = &lt;&lt;6&gt;&gt;.</input>
&lt;&lt;6&gt;&gt;
> <input>list_to_binary([Bin1,1,[2,3,Bin2],4|Bin3]).</input>
&lt;&lt;1,2,3,1,2,3,4,5,4,6&gt;&gt;</pre>
      </desc>
    </func>

    <func>
      <name name="list_to_bitstring" arity="1" since=""/>
      <fsummary>Convert a list to a bitstring.</fsummary>
      <type name="bitstring_list"/>
      <desc>
        <p>Returns a bitstring that is made from the integers and
          bitstrings in <c><anno>BitstringList</anno></c>. (The last tail in
          <c><anno>BitstringList</anno></c> is allowed to be a bitstring.)
          Example:</p>
        <pre>
> <input>Bin1 = &lt;&lt;1,2,3&gt;&gt;.</input>
&lt;&lt;1,2,3&gt;&gt;
> <input>Bin2 = &lt;&lt;4,5&gt;&gt;.</input>
&lt;&lt;4,5&gt;&gt;
> <input>Bin3 = &lt;&lt;6,7:4&gt;&gt;.</input>
&lt;&lt;6,7:4&gt;&gt;
> <input>list_to_bitstring([Bin1,1,[2,3,Bin2],4|Bin3]).</input>
&lt;&lt;1,2,3,1,2,3,4,5,4,6,7:4&gt;&gt;</pre>
      </desc>
    </func>

    <func>
      <name name="list_to_existing_atom" arity="1" since=""/>
      <fsummary>Convert from text representation to an atom.</fsummary>
      <desc>
        <p>Returns the atom whose text representation is
          <c><anno>String</anno></c>,
          but only if there already exists such atom.</p>
        <p>Failure: <c>badarg</c> if there does not already exist an atom
          whose text representation is <c><anno>String</anno></c>.</p>
	<note>
	  <p>Note that the compiler may optimize away atoms. For
	  example, the compiler will rewrite
	  <c>atom_to_list(some_atom)</c> to <c>"some_atom"</c>. If
	  that expression is the only mention of the atom
	  <c>some_atom</c> in the containing module, the atom will not
	  be created when the module is loaded, and a subsequent call
	  to <c>list_to_existing_atom("some_atom")</c> will fail.</p>
	</note>
      </desc>
    </func>

    <func>
      <name name="list_to_float" arity="1" since=""/>
      <fsummary>Convert from text representation to a float.</fsummary>
      <desc>
        <p>Returns the float whose text representation is
          <c><anno>String</anno></c>, for example:</p>
        <pre>
> <input>list_to_float("2.2017764e+0").</input>
2.2017764</pre>
        <p>Failure: <c>badarg</c> if <c><anno>String</anno></c> contains a bad
          representation of a float.</p>
      </desc>
    </func>

    <func>
      <name name="list_to_integer" arity="1" since=""/>
      <fsummary>Convert from text representation to an integer.</fsummary>
      <desc>
        <p>Returns an integer whose text representation is
          <c><anno>String</anno></c>, for example:</p>
        <pre>
> <input>list_to_integer("123").</input>
123</pre>
        <p>Failure: <c>badarg</c> if <c><anno>String</anno></c> contains a bad
          representation of an integer.</p>
      </desc>
    </func>

    <func>
      <name name="list_to_integer" arity="2" since=""/>
      <fsummary>Convert from text representation to an integer.</fsummary>
      <desc>
        <p>Returns an integer whose text representation in base
          <c><anno>Base</anno></c> is <c><anno>String</anno></c>,
          for example:</p>
        <pre>
> <input>list_to_integer("3FF", 16).</input>
1023</pre>
        <p>Failure: <c>badarg</c> if <c><anno>String</anno></c> contains a bad
          representation of an integer.</p>
      </desc>
    </func>

    <func>
      <name name="list_to_pid" arity="1" since=""/>
      <fsummary>Convert from text representation to a pid.</fsummary>
      <desc>
        <p>Returns a process identifier whose text representation is a 
          <c><anno>String</anno></c>, for example:</p>
        <pre>
> <input>list_to_pid("&lt;0.4.1>").</input>
&lt;0.4.1></pre>
        <p>Failure: <c>badarg</c> if <c><anno>String</anno></c> contains a bad
          representation of a process identifier.</p>
        <warning>
          <p>This BIF is intended for debugging and is not to be used
            in application programs.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="list_to_port" arity="1" since="OTP 20.0"/>
      <fsummary>Convert from text representation to a port.</fsummary>
      <desc>
        <p>Returns a port identifier whose text representation is a
          <c><anno>String</anno></c>, for example:</p>
        <pre>
> <input>list_to_port("#Port&lt;0.4>").</input>
#Port&lt;0.4></pre>
        <p>Failure: <c>badarg</c> if <c><anno>String</anno></c> contains a bad
          representation of a port identifier.</p>
        <warning>
          <p>This BIF is intended for debugging and is not to be used
            in application programs.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="list_to_ref" arity="1" since="OTP 20.0"/>
      <fsummary>Convert from text representation to a ref.</fsummary>
      <desc>
        <p>Returns a reference whose text representation is a
          <c><anno>String</anno></c>, for example:</p>
        <pre>
> <input>list_to_ref("#Ref&lt;0.4192537678.4073193475.71181>").</input>
#Ref&lt;0.4192537678.4073193475.71181></pre>
        <p>Failure: <c>badarg</c> if <c><anno>String</anno></c> contains a bad
          representation of a reference.</p>
        <warning>
          <p>This BIF is intended for debugging and is not to be used
            in application programs.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="list_to_tuple" arity="1" since=""/>
      <fsummary>Convert a list to a tuple.</fsummary>
      <desc>
        <p>Returns a tuple corresponding to <c><anno>List</anno></c>,
          for example</p>
        <pre>
> <input>list_to_tuple([share, ['Ericsson_B', 163]]).</input>
{share, ['Ericsson_B', 163]}</pre>
        <p><c><anno>List</anno></c> can contain any Erlang terms.</p>
      </desc>
    </func>

    <func>
      <name name="load_module" arity="2" since=""/>
      <fsummary>Load object code for a module.</fsummary>
      <desc>
        <p>If <c><anno>Binary</anno></c> contains the object code for module
          <c><anno>Module</anno></c>, this BIF loads that object code. If
          the code for module <c><anno>Module</anno></c> already exists, all
          export references are replaced so they point to the newly
          loaded code. The previously loaded code is kept in the system
          as old code, as there can still be processes executing
          that code.</p>
        <p>Returns either <c>{module, <anno>Module</anno>}</c>, or
          <c>{error, <anno>Reason</anno>}</c> if loading fails.
          <c><anno>Reason</anno></c> is one of the following:</p>
        <taglist>
          <tag><c>badfile</c></tag>
          <item>The object code in <c><anno>Binary</anno></c> has an
            incorrect format <em>or</em> the object code contains code
            for another module than <c><anno>Module</anno></c>.
          </item>
          <tag><c>not_purged</c></tag>
          <item><c><anno>Binary</anno></c> contains a module that cannot be
            loaded because old code for this module already exists.
          </item>
        </taglist>
        <warning>
          <p>This BIF is intended for the code server (see
            <seealso marker="kernel:code"><c>code(3)</c></seealso>)
            and is not to be used elsewhere.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="load_nif" arity="2" since=""/>
      <fsummary>Load NIF library.</fsummary>
      <desc>
        <p>Loads and links a dynamic library containing native
          implemented functions (NIFs) for a module. <c><anno>Path</anno></c>
          is a file path to the shareable object/dynamic library file minus
          the OS-dependent file extension (<c>.so</c> for Unix and
          <c>.dll</c> for Windows). Notice that on most OSs the library has
          to have a different name on disc when an upgrade of the nif is
          done. If the name is the same, but the contents differ, the
          old library may be loaded instead. For information on how to
          implement a NIF library, see
        <seealso marker="erl_nif"><c>erl_nif(3)</c></seealso>.</p>
        <p><c><anno>LoadInfo</anno></c> can be any term. It is passed on to
          the library as part of the initialization. A good practice is
          to include a module version number to support future code
          upgrade scenarios.</p>
        <p>The call to <c>load_nif/2</c> must be made
          <em>directly</em> from the Erlang code of the module that the
          NIF library belongs to. It returns either <c>ok</c>, or
          <c>{error,{<anno>Reason</anno>,Text}}</c> if loading fails.
          <c><anno>Reason</anno></c> is one of the following atoms
          while <c><anno>Text</anno></c> is a human readable string that
          can give more information about the failure:</p>
        <taglist>
          <tag><c>load_failed</c></tag>
          <item>The OS failed to load the NIF library.
          </item>
          <tag><c>bad_lib</c></tag>
          <item>The library did not fulfill the requirements as a NIF
            library of the calling module.
          </item>
          <tag><c>load | upgrade</c></tag>
          <item>The corresponding library callback was unsuccessful.
          </item>
          <tag><c>reload</c></tag>
          <item>A NIF library is already loaded for this module instance.
	    The previously deprecated <c>reload</c> feature was removed in OTP 20.
          </item>
          <tag><c>old_code</c></tag>
          <item>The call to <c>load_nif/2</c> was made from the old
            code of a module that has been upgraded; this is not
            allowed.
          </item>
	  <tag><c>notsup</c></tag>
          <item>Lack of support. Such as loading NIF library for a
	    HiPE compiled module.
	  </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="loaded" arity="0" since=""/>
      <fsummary>List all loaded modules.</fsummary>
      <desc>
        <p>Returns a list of all loaded Erlang modules (current and
          old code), including preloaded modules.</p>
        <p>See also <seealso marker="kernel:code">
          <c>code(3)</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="localtime" arity="0" since=""/>
      <fsummary>Current local date and time.</fsummary>
      <desc>
        <p>Returns the current local date and time,
          <c>{{Year, Month, Day}, {Hour, Minute, Second}}</c>,
          for example:</p>
        <pre>
> <input>erlang:localtime().</input>
{{1996,11,6},{14,45,17}}</pre>
        <p>The time zone and Daylight Saving Time correction depend
          on the underlying OS.</p>
      </desc>
    </func>

    <func>
      <name name="localtime_to_universaltime" arity="1" since=""/>
      <fsummary>Convert from local to Universal Time Coordinated (UTC) date
        and time.</fsummary>
      <desc>
        <p>Converts local date and time to Universal Time Coordinated
          (UTC), if supported by the underlying OS. Otherwise
          no conversion is done and <c><anno>Localtime</anno></c>
          is returned. Example:</p>
        <pre>
> <input>erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}).</input>
{{1996,11,6},{13,45,17}}</pre>
        <p>Failure: <c>badarg</c> if <c><anno>Localtime</anno></c> denotes an
          invalid date and time.</p>
      </desc>
    </func>

    <func>
      <name name="localtime_to_universaltime" arity="2" since=""/>
      <fsummary>Convert from local to Universal Time Coordinated (UTC) date
        and time.</fsummary>
      <desc>
        <p>Converts local date and time to Universal Time Coordinated
          (UTC) as <c>erlang:localtime_to_universaltime/1</c>,
          but the caller decides if Daylight Saving Time is active.</p>
        <p>If <c><anno>IsDst</anno> == true</c>, <c><anno>Localtime</anno></c>
          is during Daylight Saving Time, if <c><anno>IsDst</anno> == false</c>
          it is not. If <c><anno>IsDst</anno> == undefined</c>, the underlying
          OS can guess, which is the same as calling
          <c>erlang:localtime_to_universaltime(<anno>Localtime</anno>)</c>.</p>
        <p>Examples:</p>
        <pre>
> <input>erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, true).</input>
{{1996,11,6},{12,45,17}}
> <input>erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, false).</input>
{{1996,11,6},{13,45,17}}
> <input>erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, undefined).</input>
{{1996,11,6},{13,45,17}}</pre>
        <p>Failure: <c>badarg</c> if <c><anno>Localtime</anno></c> denotes an
          invalid date and time.</p>
      </desc>
    </func>

    <func>
      <name name="make_ref" arity="0" since=""/>
      <fsummary>Return a unique reference.</fsummary>
      <desc>
        <p>Returns a
          <seealso marker="doc/efficiency_guide:advanced#unique_references">
          unique reference</seealso>. The reference is unique among
          connected nodes.</p>
        <warning>
          <p>Known issue: When a node is restarted multiple
            times with the same node name, references created
            on a newer node can be mistaken for a reference
            created on an older node with the same node name.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="make_tuple" arity="2" since=""/>
      <fsummary>Create a new tuple of a specified arity.</fsummary>
      <desc>
        <p>Creates a new tuple of the specified <c><anno>Arity</anno></c>, where
          all elements are <c><anno>InitialValue</anno></c>, for example:</p>
        <pre>
> <input>erlang:make_tuple(4, []).</input>
{[],[],[],[]}</pre>
      </desc>
    </func>

    <func>
      <name name="make_tuple" arity="3" since=""/>
      <fsummary>Create a new tuple with specifed arity and contents.</fsummary>
      <desc>
        <p>Creates a tuple of size <c><anno>Arity</anno></c>, where each element
          has value <c><anno>DefaultValue</anno></c>, and then fills in
          values from <c><anno>InitList</anno></c>.
          Each list element in <c><anno>InitList</anno></c>
          must be a two-tuple, where the first element is a position in the
          newly created tuple and the second element is any term. If a
          position occurs more than once in the list, the term corresponding
          to the last occurrence is used. Example:</p>
        <pre>
> <input>erlang:make_tuple(5, [], [{2,ignored},{5,zz},{2,aa}]).</input>
{[],aa,[],[],zz}</pre>
      </desc>
    </func>

    <func>
      <name name="map_get" arity="2"  since="OTP 21.0"/>
      <fsummary>Extract a value from a map</fsummary>
      <desc>
        <p>Returns value <c><anno>Value</anno></c> associated with
          <c><anno>Key</anno></c> if <c><anno>Map</anno></c> contains
          <c><anno>Key</anno></c>.</p>
        <p>The call fails with a <c>{badmap,Map}</c> exception if
          <c><anno>Map</anno></c> is not a map, or with a <c>{badkey,Key}</c>
          exception if no value is associated with <c><anno>Key</anno></c>.</p>
        <p><em>Example:</em></p>
        <code type="none">
> Key = 1337,
  Map = #{42 => value_two,1337 => "value one","a" => 1},
  map_get(Key,Map).
"value one"</code>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="map_size" arity="1" since="OTP 17.0"/>
      <fsummary>Return the size of a map.</fsummary>
      <desc>
        <p>Returns an integer, which is the number of key-value pairs
          in <c><anno>Map</anno></c>, for example:</p>
        <pre>
> <input>map_size(#{a=>1, b=>2, c=>3}).</input>
3</pre>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="match_spec_test" arity="3" since="OTP 19.0"/>
      <fsummary>Test that a match specification works.</fsummary>
      <desc>
        <p>Tests a match specification used in calls to
          <seealso marker="stdlib:ets#select/2"><c>ets:select/2</c></seealso>
          and <seealso marker="#trace_pattern/3">
          <c>erlang:trace_pattern/3</c></seealso>.
          The function tests both a match specification for "syntactic"
          correctness and runs the match specification against the object. If
          the match specification contains errors, the tuple <c>{error,
          Errors}</c> is returned, where <c>Errors</c> is a list of natural
          language descriptions of what was wrong with the match
          specification.</p>
        <p>If <c><anno>Type</anno></c> is <c>table</c>, the object to match
          against is to be a tuple. The function then returns
          <c>{ok,Result,[],Warnings}</c>, where <c>Result</c> is what would
          have been the result in a real <c>ets:select/2</c> call, or
          <c>false</c> if the match specification does not match the object
          tuple.</p>
        <p>If <c><anno>Type</anno></c> is <c>trace</c>, the object to match
          against is to be a list. The function returns
          <c>{ok, Result, Flags, Warnings}</c>, where <c>Result</c> is one of
          the following:</p>
        <list type="bulleted">
          <item><c>true</c> if a trace message is to be emitted</item>
          <item><c>false</c> if a trace message is not to be emitted</item>
          <item>The message term to be appended to the trace message</item>
        </list>
        <p><c>Flags</c> is a list containing all the trace flags to be enabled,
          currently this is only <c>return_trace</c>.</p>
        <p>This is a useful debugging and test tool, especially when writing
          complicated match specifications.</p>
        <p>See also
          <seealso marker="stdlib:ets#test_ms/2"><c>ets:test_ms/2</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="max" arity="2" since=""/>
      <fsummary>Return the largest of two terms.</fsummary>
      <desc>
        <p>Returns the largest of <c><anno>Term1</anno></c> and
          <c><anno>Term2</anno></c>.
          If the terms are equal, <c><anno>Term1</anno></c> is returned.</p>
      </desc>
    </func>

    <func>
      <name name="md5" arity="1" since=""/>
      <fsummary>Compute an MD5 message digest.</fsummary>
      <desc>
        <p>Computes an MD5 message digest from <c><anno>Data</anno></c>, where
          the length of the digest is 128 bits (16 bytes).
          <c><anno>Data</anno></c>
          is a binary or a list of small integers and binaries.</p>
        <p>For more information about MD5, see
          <url href="https://www.ietf.org/rfc/rfc1321.txt">
          RFC 1321 - The MD5 Message-Digest Algorithm</url>.</p>
        <warning>
          <p>The MD5 Message-Digest Algorithm is <em>not</em> considered
            safe for code-signing or software-integrity purposes.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="md5_final" arity="1" since=""/>
      <fsummary>Finish the update of an MD5 context and return the computed
        MD5 message digest.</fsummary>
      <desc>
        <p>Finishes the update of an MD5 <c><anno>Context</anno></c> and returns
          the computed <c>MD5</c> message digest.</p>
      </desc>
    </func>

    <func>
      <name name="md5_init" arity="0" since=""/>
      <fsummary>Create an MD5 context.</fsummary>
      <desc>
        <p>Creates an MD5 context, to be used in the following calls to
          <c>md5_update/2</c>.</p>
      </desc>
    </func>

    <func>
      <name name="md5_update" arity="2" since=""/>
      <fsummary>Update an MD5 context with data and return a new context.
      </fsummary>
      <desc>
        <p>Update an MD5 <c><anno>Context</anno></c> with
          <c><anno>Data</anno></c> and returns a
          <c><anno>NewContext</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="memory" arity="0" since=""/>
      <fsummary>Information about dynamically allocated memory.</fsummary>
      <type name="memory_type"/>
      <desc>
        <p>Returns a list with information about memory
          dynamically allocated by the Erlang emulator. Each list
          element is a tuple <c>{Type, Size}</c>. The first element
          <c><anno>Type</anno></c> is an atom describing memory type. The second
          element <c><anno>Size</anno></c> is the memory size in bytes.</p>
        <p>Memory types:</p>
        <taglist>
          <tag><c>total</c></tag>
          <item>
            <p>The total amount of memory currently allocated. This is
              the same as the sum of the memory size for <c>processes</c>
              and <c>system</c>.</p>
          </item>
          <tag><c>processes</c></tag>
          <item>
            <p>The total amount of memory currently allocated for
              the Erlang processes.</p>
          </item>
          <tag><c>processes_used</c></tag>
          <item>
            <p>The total amount of memory currently used by the Erlang
              processes. This is part of the memory presented as
              <c>processes</c> memory.</p>
          </item>
          <tag><c>system</c></tag>
          <item>
            <p>The total amount of memory currently allocated for
              the emulator that is not directly related to any Erlang
              process. Memory presented as <c>processes</c> is not
              included in this memory. <seealso marker="tools:instrument">
              <c>instrument(3)</c></seealso> can be used to
              get a more detailed breakdown of what memory is part
              of this type.</p>
          </item>
          <tag><c>atom</c></tag>
          <item>
            <p>The total amount of memory currently allocated for atoms.
              This memory is part of the memory presented as
              <c>system</c> memory.</p>
          </item>
          <tag><c>atom_used</c></tag>
          <item>
            <p>The total amount of memory currently used for atoms.
              This memory is part of the memory presented as
              <c>atom</c> memory.</p>
          </item>
          <tag><c>binary</c></tag>
          <item>
            <p>The total amount of memory currently allocated for
              binaries. This memory is part of the memory presented
              as <c>system</c> memory.</p>
          </item>
          <tag><c>code</c></tag>
          <item>
            <p>The total amount of memory currently allocated for
              Erlang code. This memory is part of the memory presented
              as <c>system</c> memory.</p>
          </item>
          <tag><c>ets</c></tag>
          <item>
            <p>The total amount of memory currently allocated for ETS
              tables. This memory is part of the memory presented as
              <c>system</c> memory.</p>
          </item>
          <tag><c>low</c></tag>
          <item>
            <p>Only on 64-bit halfword emulator.
              The total amount of memory allocated in low memory areas
              that are restricted to &lt; 4 GB, although
              the system can have more memory.</p>
            <p>Can be removed in a future release of the halfword
              emulator.</p>
          </item>
          <tag><c>maximum</c></tag>
          <item>
            <p>The maximum total amount of memory allocated since
              the emulator was started. This tuple is only present
              when the emulator is run with instrumentation.</p>
            <p>For information on how to run the emulator with
              instrumentation, see
              <seealso marker="tools:instrument">
              <c>instrument(3)</c></seealso>
              and/or <seealso marker="erl"><c>erl(1)</c></seealso>.</p>
          </item>
        </taglist>
        <note>
          <p>The <c>system</c> value is not complete. Some allocated
            memory that is to be part of this value is not.</p>
          <p>When the emulator is run with instrumentation,
            the <c>system</c> value is more accurate, but memory
            directly allocated for <c>malloc</c> (and friends) is still
            not part of the <c>system</c> value. Direct calls to
            <c>malloc</c> are only done from OS-specific runtime
            libraries and perhaps from user-implemented Erlang drivers
            that do not use the memory allocation functions in
            the driver interface.</p>
          <p>As the <c>total</c> value is the sum of <c>processes</c>
            and <c>system</c>, the error in <c>system</c> propagates
            to the <c>total</c> value.</p>
          <p>The different amounts of memory that are summed are
            <em>not</em> gathered atomically, which introduces
            an error in the result.</p>
        </note>
        <p>The different values have the following relation to each
          other. Values beginning with an uppercase letter is not part
          of the result.</p>
        <code type="none">
total      = processes + system
processes  = processes_used + ProcessesNotUsed
system     = atom + binary + code + ets + OtherSystem
atom       = atom_used + AtomNotUsed
RealTotal  = processes + RealSystem
RealSystem = system + MissedSystem</code>
        <p>More tuples in the returned list can be added in a
          future release.</p>
        <note>
          <p>The <c>total</c> value is supposed to be the total amount
            of memory dynamically allocated by the emulator. Shared
            libraries, the code of the emulator itself, and
            the emulator stacks are not supposed to be included. That
            is, the <c>total</c> value is <em>not</em> supposed to be
            equal to the total size of all pages mapped to the emulator.</p>
          <p>Also, because of fragmentation and prereservation of
            memory areas, the size of the memory segments containing
            the dynamically allocated memory blocks can be much
            larger than the total size of the dynamically allocated
            memory blocks.</p>
        </note>
        <note>
          <p>As from ERTS 5.6.4, <c>erlang:memory/0</c> requires that
            all <seealso marker="erts:erts_alloc"><c>erts_alloc(3)</c></seealso>
            allocators are enabled (default behavior).</p>
        </note>
        <p>Failure: <c>notsup</c> if an
          <seealso marker="erts:erts_alloc"><c>erts_alloc(3)</c></seealso>
          allocator has been disabled.</p>
      </desc>
    </func>

    <func>
      <name name="memory" arity="1" clause_i="1" since=""/>
      <name name="memory" arity="1" clause_i="2" since=""/>
      <fsummary>Information about dynamically allocated memory.</fsummary>
      <type name="memory_type"/>
      <desc>
        <p>Returns the memory size in bytes allocated for memory of type
          <c><anno>Type</anno></c>. The argument can also be specified as a list
          of <c>memory_type()</c> atoms, in which case a corresponding list of
          <c>{memory_type(), Size :: integer >= 0}</c> tuples is returned.</p>
        <note>
          <p>As from ERTS 5.6.4,
            <c>erlang:memory/1</c> requires that
            all <seealso marker="erts_alloc"><c>erts_alloc(3)</c></seealso>
            allocators are enabled (default behavior).</p>
        </note>
        <p>Failures:</p>
        <taglist>
          <tag><c>badarg</c></tag>
          <item>
            If <c><anno>Type</anno></c> is not one of the memory types
            listed in the description of
            <seealso marker="#memory/0"><c>erlang:memory/0</c></seealso>.
          </item>
          <tag><c>badarg</c></tag>
          <item>
            If <c>maximum</c> is passed as <c><anno>Type</anno></c> and
            the emulator is not run in instrumented mode.
          </item>
          <tag><c>notsup</c></tag>
          <item>
            If an <seealso marker="erts_alloc"><c>erts_alloc(3)</c></seealso>
            allocator has been disabled.
          </item>
        </taglist>
        <p>See also
          <seealso marker="#memory/0"><c>erlang:memory/0</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="min" arity="2" since=""/>
      <fsummary>Return the smallest of two terms.</fsummary>
      <desc>
        <p>Returns the smallest of <c><anno>Term1</anno></c> and
          <c><anno>Term2</anno></c>.
          If the terms are equal, <c><anno>Term1</anno></c> is returned.</p>
      </desc>
    </func>

    <func>
      <name name="module_loaded" arity="1" since=""/>
      <fsummary>Check if a module is loaded.</fsummary>
      <desc>
        <p>Returns <c>true</c> if the module <c><anno>Module</anno></c>
          is loaded, otherwise <c>false</c>. It does not attempt to load
          the module.</p>
        <warning>
          <p>This BIF is intended for the code server (see
            <seealso marker="kernel:code"><c>code(3)</c></seealso>)
            and is not to be used elsewhere.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="monitor" arity="2" clause_i="1" since=""/>
      <name name="monitor" arity="2" clause_i="2" since="OTP 19.0"/>
      <name name="monitor" arity="2" clause_i="3" since="OTP 18.0"/>
      <fsummary>Start monitoring.</fsummary>
      <type name="registered_name"/>
      <type name="registered_process_identifier"/>
      <type name="monitor_process_identifier"/>
      <type name="monitor_port_identifier"/>
      <desc>
	<p>Sends a monitor request of type <c><anno>Type</anno></c> to the
	  entity identified by <c><anno>Item</anno></c>. If the monitored entity
          does not exist or it changes monitored state, the caller of
          <c>monitor/2</c> is notified by a message on the following format:</p>
        <code type="none">
{Tag, <anno>MonitorRef</anno>, <anno>Type</anno>, Object, Info}</code>
	<note>
          <p>The monitor request is an asynchronous signal. That is, it
	    takes time before the signal reaches its destination.</p>
        </note>

        <p><c><anno>Type</anno></c> can be one of the following atoms:
          <c>process</c>, <c>port</c> or <c>time_offset</c>.</p>

        <p>A <c>process</c> or <c>port</c> monitor is triggered only once,
          after that it is removed from both monitoring process and
          the monitored entity. Monitors are fired when the monitored process
          or port terminates, does not exist at the moment of creation,
          or if the connection to it is lost. If the connection to it is lost,
          we do not know if it still exists. The monitoring is also turned off
          when <seealso marker="#demonitor/1">demonitor/1</seealso> is
          called.</p>

        <p>A <c>process</c> or <c>port</c> monitor by name
          resolves the <c>RegisteredName</c> to <c>pid()</c> or <c>port()</c>
          only once at the moment of monitor instantiation, later changes to
          the name registration will not affect the existing monitor.</p>

        <p>When a <c>process</c> or <c>port</c> monitor is triggered,
          a <c>'DOWN'</c> message is sent that has the following pattern:</p>
          <code type="none">
{'DOWN', MonitorRef, Type, Object, Info}</code>

        <p>In the monitor message <c>MonitorRef</c> and <c>Type</c> are the
          same as described earlier, and:</p>
        <taglist>
          <tag><c>Object</c></tag>
          <item>
            <p>The monitored entity, which triggered the event. When monitoring
              a local process or port, <c>Object</c> will be equal to the
              <c>pid()</c> or <c>port()</c> that was being monitored. When
              monitoring process or port by name, <c>Object</c> will have format
              <c>{RegisteredName, Node}</c> where <c>RegisteredName</c> is the
              name which has been used with <c>monitor/2</c> call and
              <c>Node</c> is local or remote node name (for ports monitored by
              name, <c>Node</c> is always local node name).</p>
          </item>
          <tag><c>Info</c></tag>
          <item>
            <p>Either the exit reason of the process, <c>noproc</c>
              (process or port did not exist at the time of monitor creation),
              or <c>noconnection</c> (no connection to the node where the
              monitored process resides). </p></item>
        </taglist>

        <taglist>
        <tag>Monitoring a <marker id="monitor_process"/><c>process</c></tag>
        <item>
          <p>Creates monitor between the current process and another
            process identified by <c><anno>Item</anno></c>, which can be a
            <c>pid()</c> (local or remote), an atom <c>RegisteredName</c> or
            a tuple <c>{RegisteredName, Node}</c> for a registered process,
          located elsewhere.</p>

        <note><p>Before ERTS 10.0 (OTP 21.0), monitoring a process could fail with
	  <c>badarg</c> if the monitored process resided on a primitive node
	  (such as erl_interface or jinterface), where remote process monitoring
	  is not implemented.</p>
	  <p>Now, such a call to <c>monitor</c> will instead succeed and a
	  monitor is created. But the monitor will only supervise the
	  connection. That is, a <c>{'DOWN', _, process, _, noconnection}</c> is
	  the only message that may be received, as the primitive node have no
	  way of reporting the status of the monitored process.</p>
	</note>

        </item>

        <tag>Monitoring a <marker id="monitor_port"/><c>port</c></tag>
        <item>
          <p>Creates monitor between the current process and a port
            identified by <c><anno>Item</anno></c>, which can be a
            <c>port()</c> (only local), an atom <c>RegisteredName</c> or
            a tuple <c>{RegisteredName, Node}</c> for a registered port,
            located on this node. Note, that attempt to monitor a remote port
            will result in <c>badarg</c>.</p>
        </item>

        <tag>Monitoring a
          <marker id="monitor_time_offset"/><c>time_offset</c></tag>
	  <item>
	    <p>Monitors changes in
	      <seealso marker="#time_offset/0"><c>time offset</c></seealso>
	      between
	      <seealso marker="time_correction#Erlang_Monotonic_Time">Erlang
	      monotonic time</seealso> and
	      <seealso marker="time_correction#Erlang_System_Time">Erlang
	      system time</seealso>. One valid <c><anno>Item</anno></c>
              exists in combination with the
	      <c>time_offset <anno>Type</anno></c>, namely the atom
	      <c>clock_service</c>. Notice that the atom <c>clock_service</c> is
	      <em>not</em> the registered name of a process. In this
	      case it serves as an identifier of the runtime system internal
	      clock service at current runtime system instance.</p>

	    <p>The monitor is triggered when the time offset is changed.
	      This either if the time offset value is changed, or if the
	      offset is changed from preliminary to final during
	      <seealso marker="#system_flag_time_offset">finalization
	      of the time offset</seealso> when the
	      <seealso marker="time_correction#Single_Time_Warp_Mode">single
	      time warp mode</seealso> is used. When a change from preliminary
	      to final time offset is made, the monitor is triggered once
	      regardless of whether the time offset value was changed
	      or not.</p>

	    <p>If the runtime system is in
	      <seealso marker="time_correction#Multi_Time_Warp_Mode">multi
	      time warp mode</seealso>, the time offset is changed when
	      the runtime system detects that the
	      <seealso marker="time_correction#OS_System_Time">OS system
	      time</seealso> has changed. The runtime system does, however,
	      not detect this immediately when it occurs. A task checking
	      the time offset is scheduled to execute at least once a minute,
	      so under normal operation this is to be detected within a
	      minute, but during heavy load it can take longer time.</p>

	    <p>The monitor is <em>not</em> automatically removed
	      after it has been triggered. That is, repeated changes of
	      the time offset trigger the monitor repeatedly.</p>

            <p>When the monitor is triggered a <c>'CHANGE'</c> message is
	      sent to the monitoring process. A <c>'CHANGE'</c> message has
	      the following pattern:</p>
              <code type="none">
{'CHANGE', MonitorRef, Type, Item, NewTimeOffset}</code>
              <p>where <c>MonitorRef</c>, <c><anno>Type</anno></c>, and
	      <c><anno>Item</anno></c> are the same as described above, and
	      <c>NewTimeOffset</c> is the new time offset.</p>

	    <p>When the <c>'CHANGE'</c> message has been received you are
	      guaranteed not to retrieve the old time offset when calling
	      <seealso marker="#time_offset/0">
              <c>erlang:time_offset()</c></seealso>.
	      Notice that you can observe the change of the time offset
	      when calling <c>erlang:time_offset()</c> before you
	      get the <c>'CHANGE'</c> message.</p>
	  </item>
	</taglist>

	<p>Making several calls to <c>monitor/2</c> for the same
	  <c><anno>Item</anno></c> and/or <c><anno>Type</anno></c> is not
	  an error; it results in as many independent monitoring instances.</p>

	<p>The monitor functionality is expected to be extended. That is,
	  other <c><anno>Type</anno></c>s and <c><anno>Item</anno></c>s
	  are expected to be supported in a future release.</p>
        <note>
          <p>If or when <c>monitor/2</c> is extended, other
            possible values for <c>Tag</c>, <c>Object</c>, and
            <c>Info</c> in the monitor message will be introduced.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="monitor_node" arity="2" since=""/>
      <fsummary>Monitor the status of a node.</fsummary>
      <desc>
        <p>Monitor the status of the node <c><anno>Node</anno></c>.
          If <c><anno>Flag</anno></c>
          is <c>true</c>, monitoring is turned on. If <c><anno>Flag</anno></c>
          is <c>false</c>, monitoring is turned off.</p>
        <p>Making several calls to <c>monitor_node(Node, true)</c> for
          the same <c><anno>Node</anno></c> is not an error; it results
          in as many independent monitoring instances.</p>
        <p>If <c><anno>Node</anno></c> fails or does not exist, the message
          <c>{nodedown, Node}</c> is delivered to the process. If a
          process has made two calls to <c>monitor_node(Node, true)</c>
          and <c><anno>Node</anno></c> terminates, two <c>nodedown</c> messages
          are delivered to the process. If there is no connection to
          <c><anno>Node</anno></c>, an attempt is made to create one.
          If this fails, a <c>nodedown</c> message is delivered.</p>
        <p>Nodes connected through hidden connections can be monitored
          as any other nodes.</p>
        <p>Failure: <c>badarg</c> if the local node is not alive.</p>
      </desc>
    </func>

    <func>
      <name name="monitor_node" arity="3" since=""/>
      <fsummary>Monitor the status of a node.</fsummary>
      <desc>
        <p>Behaves as
          <seealso marker="#monitor_node/2"><c>monitor_node/2</c></seealso>
          except that it allows an
          extra option to be specified, namely <c>allow_passive_connect</c>.
          This option allows the BIF to wait the normal network connection
          time-out for the <em>monitored node</em> to connect itself,
          even if it cannot be actively connected from this node
          (that is, it is blocked). The state where this can be useful
          can only be achieved by using the Kernel option
          <c>dist_auto_connect once</c>. If that option is not
          used, option <c>allow_passive_connect</c> has no effect.</p>
        <note>
          <p>Option <c>allow_passive_connect</c> is used
            internally and is seldom needed in applications where the
            network topology and the Kernel options in effect
            are known in advance.</p>
        </note>
        <p>Failure: <c>badarg</c> if the local node is not alive or the
          option list is malformed.</p>
      </desc>
    </func>

    <func>
      <name name="monotonic_time" arity="0" since="OTP 18.0"/>
      <fsummary>Current Erlang monotonic time.</fsummary>
      <desc>
        <p>Returns the current
          <seealso marker="time_correction#Erlang_Monotonic_Time">Erlang
          monotonic time</seealso> in <c>native</c>
          <seealso marker="#type_time_unit">time unit</seealso>. This
          is a monotonically increasing time since some unspecified point in
          time.</p>
        <note>
          <p>This is a
            <seealso marker="time_correction#Monotonically_Increasing">
            monotonically increasing</seealso> time, but <em>not</em> a
            <seealso marker="time_correction#Strictly_Monotonically_Increasing">
            strictly monotonically increasing</seealso>
            time. That is, consecutive calls to
            <c>erlang:monotonic_time/0</c> can produce the same result.</p>
          <p>Different runtime system instances will use different unspecified
            points in time as base for their Erlang monotonic clocks.
            That is, it is <em>pointless</em> comparing monotonic times from
            different runtime system instances. Different runtime system
            instances can also place this unspecified point in time different
            relative runtime system start. It can be placed in the future (time
            at start is a negative value), the past (time at start is a
            positive value), or the runtime system start (time at start is
            zero). The monotonic time at runtime system start can be
            retrieved by calling
            <seealso marker="#system_info_start_time">
            <c>erlang:system_info(start_time)</c></seealso>.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="monotonic_time" arity="1" since="OTP 18.0"/>
      <fsummary>Current Erlang monotonic time.</fsummary>
      <desc>
        <p>Returns the current
          <seealso marker="time_correction#Erlang_Monotonic_Time">Erlang
          monotonic time</seealso> converted
          into the <c><anno>Unit</anno></c> passed as argument.</p>
        <p>Same as calling
          <seealso marker="#convert_time_unit/3">
          <c>erlang:convert_time_unit</c></seealso><c>(</c><seealso
          marker="#monotonic_time/0">
          <c>erlang:monotonic_time()</c></seealso><c>,
          native, <anno>Unit</anno>)</c>,
          however optimized for commonly used <c><anno>Unit</anno></c>s.</p>
      </desc>
    </func>

    <func>
      <name name="nif_error" arity="1" since="OTP R14B"/>
      <fsummary>Stop execution with a specified reason.</fsummary>
      <desc>
        <p>Works exactly like
         <seealso marker="#error/1"><c>error/1</c></seealso>, but
         Dialyzer thinks that this BIF will return an arbitrary
         term. When used in a stub function for a NIF to generate an
         exception when the NIF library is not loaded, Dialyzer
         does not generate false warnings.</p>
      </desc>
    </func>

    <func>
      <name name="nif_error" arity="2" since="OTP R14B"/>
      <fsummary>Stop execution with a specified reason.</fsummary>
      <desc>
        <p>Works exactly like
          <seealso marker="#error/2"><c>error/2</c></seealso>, but
          Dialyzer thinks that this BIF will return an arbitrary
          term. When used in a stub function for a NIF to generate an
          exception when the NIF library is not loaded, Dialyzer
          does not generate false warnings.</p>
      </desc>
    </func>

    <func>
      <name name="node" arity="0" since=""/>
      <fsummary>Name of the local node.</fsummary>
      <desc>
        <p>Returns the name of the local node. If the node is not alive,
          <c>nonode@nohost</c> is returned instead.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="node" arity="1" since=""/>
      <fsummary>At which node a pid, port, or reference originates.</fsummary>
      <desc>
        <p>Returns the node where <c><anno>Arg</anno></c> originates.
          <c><anno>Arg</anno></c> can
          be a process identifier, a reference, or a port.
          If the local node is not
          alive, <c>nonode@nohost</c> is returned.</p>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="nodes" arity="0" since=""/>
      <fsummary>All visible nodes in the system.</fsummary>
      <desc>
        <p>Returns a list of all visible nodes in the system, except
          the local node. Same as <c>nodes(visible)</c>.</p>
      </desc>
    </func>

    <func>
      <name name="nodes" arity="1" since=""/>
      <fsummary>All nodes of a certain type in the system.</fsummary>
      <desc>
        <p>Returns a list of nodes according to the argument specified.
          The returned result, when the argument is a list, is the list
          of nodes satisfying the disjunction(s) of the list elements.</p>
        <p><c><anno>NodeType</anno></c>s:</p>
        <taglist>
          <tag><c>visible</c></tag>
          <item>
            <p>Nodes connected to this node through normal connections.</p>
          </item>
          <tag><c>hidden</c></tag>
          <item>
            <p>Nodes connected to this node through hidden connections.</p>
          </item>
          <tag><c>connected</c></tag>
          <item>
            <p>All nodes connected to this node.</p>
          </item>
          <tag><c>this</c></tag>
          <item>
            <p>This node.</p>
          </item>
          <tag><c>known</c></tag>
          <item>
            <p>Nodes that are known to this node. That is, connected
              nodes and nodes referred to by process identifiers, port
              identifiers, and references located on this node.
              The set of known nodes is garbage collected. Notice that
              this garbage collection can be delayed. For more
              information, see
              <seealso marker="erlang#system_info_delayed_node_table_gc">
              <c>erlang:system_info(delayed_node_table_gc)</c></seealso>.</p>
          </item>
        </taglist>
        <p>Some equalities: <c>[node()] = nodes(this)</c>,
          <c>nodes(connected) = nodes([visible, hidden])</c>, and
          <c>nodes() = nodes(visible)</c>.</p>
      </desc>
    </func>

    <func>
      <name name="now" arity="0" since=""/>
      <fsummary>Elapsed time since 00:00 GMT.</fsummary>
      <type name="timestamp"/>
      <desc>
        <warning>
          <p><em>This function is deprecated. Do not use it.</em></p>
          <p>For more information, see section
            <seealso marker="time_correction">Time and Time Correction</seealso>
            in the User's Guide. Specifically, section
            <seealso marker="time_correction#Dos_and_Donts">
            Dos and Dont's</seealso> describes what to use instead of
            <c>erlang:now/0</c>.</p>
        </warning>
        <p>Returns the tuple <c>{MegaSecs, Secs, MicroSecs}</c>, which is
          the elapsed time since 00:00 GMT, January 1, 1970 (zero hour),
          if provided by the underlying OS.
          Otherwise some other point in time is chosen. It is also
          guaranteed that the following calls to this BIF return
          continuously increasing values. Hence, the return value from
          <c>erlang:now/0</c> can be used to generate unique time stamps.
          If it is called in a tight loop on a fast machine,
          the time of the node can become skewed.</p>
        <p>Can only be used to check the local time of day if
          the time-zone information of the underlying OS is
          properly configured.</p>
      </desc>
    </func>

    <func>
      <name name="open_port" arity="2" since=""/>
      <fsummary>Open a port.</fsummary>
      <desc>
        <p>Returns a port identifier as the result of opening a
          new Erlang port. A port can be seen as an external Erlang
          process.</p>
        <p>The name of the executable as well as the arguments
          specifed in <c>cd</c>, <c>env</c>, <c>args</c>, and <c>arg0</c> are
          subject to Unicode filename translation if the system is running
          in Unicode filename mode. To avoid
          translation or to force, for example UTF-8, supply the executable
          and/or arguments as a binary in the correct
          encoding. For details, see the module
          <seealso marker="kernel:file"><c>file(3)</c></seealso>, the
          function <seealso marker="kernel:file#native_name_encoding/0">
          <c>file:native_name_encoding/0</c></seealso> in Kernel, and
          the <seealso marker="stdlib:unicode_usage">
          <c>Using Unicode in Erlang</c></seealso> User's Guide.</p>
        <note>
          <p>The characters in the name (if specified as a list) can
            only be &gt; 255 if the Erlang virtual machine is started
            in Unicode filename translation mode. Otherwise the name
            of the executable is limited to the ISO Latin-1
            character set.</p>
        </note>
	<p><c><anno>PortName</anno></c>s:</p>
        <taglist>
          <tag><c>{spawn, <anno>Command</anno>}</c></tag>
          <item>
            <p>Starts an external program. <c><anno>Command</anno></c>
              is the name of the external program to be run.
              <c><anno>Command</anno></c>
              runs outside the Erlang work space unless an Erlang
              driver with the name <c><anno>Command</anno></c> is found.
              If found, that driver is started. A driver runs in the Erlang
              work space, which means that it is linked with the Erlang
              runtime system.</p>
            <p>For external programs, <c>PATH</c> is searched
              (or an equivalent method is used to find programs,
              depending on the OS). This is done by invoking
              the shell on certain platforms. The first space-separated
              token of the command is considered as the
              name of the executable (or driver). This (among other
              things) makes this option unsuitable for running
              programs with spaces in filenames or directory names.
              If spaces in executable filenames are desired, use
              <c>{spawn_executable, <anno>Command</anno>}</c> instead.</p>
          </item>
          <tag><c>{spawn_driver, <anno>Command</anno>}</c></tag>
          <item>
            <p>Works like <c>{spawn, <anno>Command</anno>}</c>, but demands
              the first (space-separated) token of the command to be the name
              of a loaded driver. If no driver with that name is loaded, a
              <c>badarg</c> error is raised.</p>
          </item>
          <tag><c>{spawn_executable, <anno>FileName</anno>}</c></tag>
          <item>
            <p>Works like <c>{spawn, <anno>FileName</anno>}</c>, but only runs
              external executables. <c><anno>FileName</anno></c> in its whole
              is used as the name of the executable, including any spaces.
              If arguments are to be passed, the
              <c><anno>PortSettings</anno></c>
              <c>args</c> and <c>arg0</c> can be used.</p>
            <p>The shell is usually not invoked to start the
              program, it is executed directly. <c>PATH</c> (or
              equivalent) is not searched. To find a program
              in <c>PATH</c> to execute, use
              <seealso marker="kernel:os#find_executable/1">
              <c>os:find_executable/1</c></seealso>.</p>
            <p>Only if a shell script or <c>.bat</c> file is
              executed, the appropriate command interpreter is
              invoked implicitly, but there is still no
              command-argument expansion or implicit <c>PATH</c> search.</p>
            <p>If <c><anno>FileName</anno></c> cannot be run, an error
              exception is raised, with the POSIX error code as the reason.
              The error reason can differ between OSs.
              Typically the error <c>enoent</c> is raised when an
              attempt is made to run a program that is not found and
              <c>eacces</c> is raised when the specified file is not
              executable.</p>
          </item>
          <tag><c>{fd, <anno>In</anno>, <anno>Out</anno>}</c></tag>
          <item>
            <p>Allows an Erlang process to access any currently opened
              file descriptors used by Erlang. The file descriptor
              <c><anno>In</anno></c> can be used for standard input, and the
              file descriptor <c><anno>Out</anno></c> for standard output.
              It is only used for various servers in the Erlang OS (<c>shell</c>
              and <c>user</c>). Hence, its use is limited.</p>
          </item>
        </taglist>
        <p><c><anno>PortSettings</anno></c> is a list of settings for the port.
          The valid settings are as follows:</p>
        <taglist>
          <tag><c>{packet, <anno>N</anno>}</c></tag>
          <item>
            <p>Messages are preceded by their length, sent in
              <c><anno>N</anno></c>
              bytes, with the most significant byte first. The valid values
              for <c>N</c> are 1, 2, and 4.</p>
          </item>
          <tag><c>stream</c></tag>
          <item>
            <p>Output messages are sent without packet lengths. A
              user-defined protocol must be used between the Erlang
              process and the external object.</p>
          </item>
          <tag><c>{line, <anno>L</anno>}</c></tag>
          <item>
            <p>Messages are delivered on a per line basis. Each line
              (delimited by the OS-dependent newline sequence) is
              delivered in a single message. The message data format
              is <c>{Flag, Line}</c>, where <c>Flag</c> is
              <c>eol</c> or <c>noeol</c>, and <c>Line</c> is the
              data delivered (without the newline sequence).</p>
            <p><c><anno>L</anno></c> specifies the maximum line length in bytes.
              Lines longer than this are delivered in more than one
              message, with <c>Flag</c> set to <c>noeol</c> for all
              but the last message. If end of file is encountered
              anywhere else than immediately following a newline
              sequence, the last line is also delivered with
              <c>Flag</c> set to <c>noeol</c>. Otherwise
              lines are delivered with <c>Flag</c> set to <c>eol</c>.</p>
            <p>The <c>{packet, <anno>N</anno>}</c> and <c>{line,
              <anno>L</anno>}</c> settings are mutually exclusive.</p>
          </item>
          <tag><c>{cd, <anno>Dir</anno>}</c></tag>
          <item>
            <p>Only valid for <c>{spawn, <anno>Command</anno>}</c> and
              <c>{spawn_executable, <anno>FileName</anno>}</c>.
              The external program starts using <c><anno>Dir</anno></c> as its
              working directory. <c><anno>Dir</anno></c> must be a string.</p>
          </item>
          <tag><c>{env, <anno>Env</anno>}</c></tag>
          <item>
	    <p>
	      Types:<br/>
	      &nbsp;&nbsp;<c><anno>Name</anno> = </c><seealso marker="kernel:os#type-env_var_name"><c>os:env_var_name()</c></seealso><br/>
	      &nbsp;&nbsp;<c><anno>Val</anno> = </c><seealso marker="kernel:os#type-env_var_value"><c>os:env_var_value()</c></seealso><c> | false</c><br/>
	      &nbsp;&nbsp;<c>Env = [{<anno>Name</anno>, <anno>Val</anno>}]</c>
	    </p>
            <p>Only valid for <c>{spawn, <anno>Command</anno>}</c>, and
              <c>{spawn_executable, <anno>FileName</anno>}</c>.
              The environment of the started process is extended using
              the environment specifications in <c><anno>Env</anno></c>.</p>
            <p><c><anno>Env</anno></c> is to be a list of tuples
              <c>{<anno>Name</anno>, <anno>Val</anno>}</c>,
              where <c><anno>Name</anno></c> is the name of an
              environment variable, and <c><anno>Val</anno></c> is the
              value it is to have in the spawned
              port process. Both <c><anno>Name</anno></c> and
              <c><anno>Val</anno></c> must be strings. The one
              exception is <c><anno>Val</anno></c> being the atom
              <c>false</c> (in analogy with
              <seealso marker="kernel:os#getenv/1"><c>os:getenv/1</c></seealso>,
              which removes the environment variable.
	    </p>
	    <p>
	      For information about encoding requirements, see documentation
	      of the types for <c><anno>Name</anno></c> and
	      <c><anno>Val</anno></c>.
	    </p>
          </item>
          <tag><c>{args, [ string() | binary() ]}</c></tag>
          <item>
            <p>Only valid for <c>{spawn_executable, <anno>FileName</anno>}</c>
              and specifies arguments to the executable. Each argument
              is specified as a separate string and (on Unix) eventually
              ends up as one element each in the argument vector. On
              other platforms, a similar behavior is mimicked.</p>
            <p>The arguments are not expanded by the shell before
              they are supplied to the executable. Most notably this
              means that file wildcard expansion does not occur.
              To expand wildcards for the arguments, use
              <seealso marker="stdlib:filelib#wildcard/1">
              <c>filelib:wildcard/1</c></seealso>.
              Notice that even if
              the program is a Unix shell script, meaning that the
              shell ultimately is invoked, wildcard expansion
              does not occur, and the script is provided with the
              untouched arguments. On Windows, wildcard expansion
              is always up to the program itself, therefore this is
              not an issue.</p>
            <p>The executable name (also known as <c>argv[0]</c>)
              is not to be specified in this list. The proper executable name
              is automatically used as <c>argv[0]</c>, where applicable.</p>
            <p>If you explicitly want to set the
              program name in the argument vector, option <c>arg0</c>
              can be used.</p>
          </item>
          <tag><c>{arg0, string() | binary()}</c></tag>
          <item>
            <p>Only valid for <c>{spawn_executable, <anno>FileName</anno>}</c>
              and explicitly specifies the program name argument when
              running an executable. This can in some circumstances,
              on some OSs, be desirable. How the program
              responds to this is highly system-dependent and no specific
              effect is guaranteed.</p>
          </item> 
          <tag><c>exit_status</c></tag>
          <item>
            <p>Only valid for <c>{spawn, <anno>Command</anno>}</c>, where
              <c><anno>Command</anno></c> refers to an external program, and
              for <c>{spawn_executable, <anno>FileName</anno>}</c>.</p>
            <p>When the external process connected to the port exits, a
              message of the form <c>{Port,{exit_status,Status}}</c> is
              sent to the connected process, where <c>Status</c> is the
              exit status of the external process. If the program
              aborts on Unix, the same convention is used as the shells
              do (that is, 128+signal).</p>
            <p>If option <c>eof</c> is specified also, the messages <c>eof</c>
              and <c>exit_status</c> appear in an unspecified order.</p>
            <p>If the port program closes its <c>stdout</c> without exiting,
              option <c>exit_status</c> does not work.</p>
          </item>
          <tag><c>use_stdio</c></tag>
          <item>
            <p>Only valid for <c>{spawn, <anno>Command</anno>}</c> and
              <c>{spawn_executable, <anno>FileName</anno>}</c>. It
              allows the standard input and output (file descriptors 0
              and 1) of the spawned (Unix) process for communication
              with Erlang.</p>
          </item>
          <tag><c>nouse_stdio</c></tag>
          <item>
            <p>The opposite of <c>use_stdio</c>. It uses file descriptors
              3 and 4 for communication with Erlang.</p>
          </item>
          <tag><c>stderr_to_stdout</c></tag>
          <item>
            <p>Affects ports to external programs. The executed program
              gets its standard error file redirected to its standard
              output file. <c>stderr_to_stdout</c> and
              <c>nouse_stdio</c> are mutually exclusive.</p>
          </item>
          <tag><c>overlapped_io</c></tag>
          <item>
            <p>Affects ports to external programs on Windows only. The
              standard input and standard output handles of the port program
              are, if this option is supplied, opened with flag
              <c>FILE_FLAG_OVERLAPPED</c>, so that the port program can
              (and must) do
              overlapped I/O on its standard handles. This is not normally
              the case for simple port programs, but an option of value for the
              experienced Windows programmer. <em>On all other platforms, this
              option is silently discarded.</em></p>
          </item>
          <tag><c>in</c></tag>
          <item>
            <p>The port can only be used for input.</p>
          </item>
          <tag><c>out</c></tag>
          <item>
            <p>The port can only be used for output.</p>
          </item>
          <tag><c>binary</c></tag>
          <item>
            <p>All I/O from the port is binary data objects as opposed
              to lists of bytes.</p>
          </item>
          <tag><c>eof</c></tag>
          <item>
            <p>The port is not closed at the end of the file and does not
              produce an exit signal. Instead, it remains open and
              a <c>{Port, eof}</c> message is sent to the process
              holding the port.</p>
          </item>
          <tag><c>hide</c></tag>
          <item>
            <p>When running on Windows, suppresses creation of a new
              console window when spawning the port program.
              (This option has no effect on other platforms.)</p>
          </item>
          <tag><c>{parallelism, Boolean}</c></tag>
          <item>
            <marker id="open_port_parallelism"></marker>
            <p>Sets scheduler hint for port parallelism. If set to
              <c>true</c>, the virtual machine schedules port tasks;
              when doing so, it improves parallelism in the system. If set
              to <c>false</c>, the virtual machine tries to
              perform port tasks immediately, improving latency at the
              expense of parallelism. The default can be set at system startup
              by passing command-line argument
              <seealso marker="erl#+spp"><c>+spp</c></seealso> to
              <c>erl(1)</c>.</p>
          </item>
        </taglist>
        <p>Default is <c>stream</c> for all port types and
          <c>use_stdio</c> for spawned ports.</p>
        <p>Failure: if the port cannot be opened, the exit reason is
          <c>badarg</c>, <c>system_limit</c>, or the POSIX error code that
          most closely describes the error, or <c>einval</c> if no POSIX
          code is appropriate:</p>
        <taglist>
          <tag><c>badarg</c></tag>
          <item>Bad input arguments to <c>open_port</c>.
          </item>
          <tag><c>system_limit</c></tag>
          <item>All available ports in the Erlang emulator are in use.
          </item>
          <tag><c>enomem</c></tag>
          <item>Not enough memory to create the port.
          </item>
          <tag><c>eagain</c></tag>
          <item>No more available OS processes.
          </item>
          <tag><c>enametoolong</c></tag>
          <item>Too long external command.
          </item>
          <tag><c>emfile</c></tag>
          <item>No more available file descriptors (for the
            OS process that the Erlang emulator runs in).
          </item>
          <tag><c>enfile</c></tag>
          <item>Full file table (for the entire OS).
          </item>
          <tag><c>eacces</c></tag>
          <item><c>Command</c> specified in <c>{spawn_executable, Command}</c>
            does not point out an executable file.
          </item>
          <tag><c>enoent</c></tag>
          <item><c><anno>FileName</anno></c> specified in
            <c>{spawn_executable, <anno>FileName</anno>}</c>
            does not point out an existing file.
          </item>
        </taglist>
        <p>During use of a port opened using <c>{spawn, Name}</c>,
          <c>{spawn_driver, Name}</c>, or <c>{spawn_executable, Name}</c>,
          errors arising when sending messages to it are reported to
          the owning process using signals of the form
          <c>{'EXIT', Port, PosixCode}</c>. For the possible values of
          <c>PosixCode</c>, see
          <seealso marker="kernel:file"><c>file(3)</c></seealso>.</p>
        <p>The maximum number of ports that can be open at the same
          time can be configured by passing command-line flag
          <seealso marker="erl#max_ports"><c>+Q</c></seealso> to
          <c>erl(1)</c>.</p>
      </desc>
    </func>

    <func>
      <name name="phash" arity="2" since=""/>
      <fsummary>Portable hash function.</fsummary>
      <type_desc variable="Range">Range = 1..2^32, Hash = 1..Range</type_desc>
      <desc>
        <p>Portable hash function that gives the same hash for
          the same Erlang term regardless of machine architecture and
          ERTS version (the BIF was introduced in ERTS 4.9.1.1).
          The function returns a hash value for
          <c><anno>Term</anno></c> within the range
          <c>1..<anno>Range</anno></c>. The maximum value for
          <c><anno>Range</anno></c> is 2^32.</p>
      </desc>
    </func>

    <func>
      <name name="phash2" arity="1" since=""/>
      <name name="phash2" arity="2" since=""/>
      <fsummary>Portable hash function.</fsummary>
      <type_desc variable="Range">1..2^32</type_desc>
      <type_desc variable="Hash">0..Range-1</type_desc>
      <desc>
        <p>Portable hash function that gives the same hash for
          the same Erlang term regardless of machine architecture and
          ERTS version (the BIF was introduced in ERTS 5.2).
          The function returns a hash value for
          <c><anno>Term</anno></c> within the range
          <c>0..<anno>Range</anno>-1</c>. The maximum value for
          <c><anno>Range</anno></c> is 2^32. When without argument
          <c><anno>Range</anno></c>, a value in the range
          0..2^27-1 is returned.</p>
        <p>This BIF is always to be used for hashing terms. It
          distributes small integers better than <c>phash/2</c>, and
          it is faster for bignums and binaries.</p>
        <p>Notice that the range <c>0..<anno>Range</anno>-1</c> is
          different from the range of <c>phash/2</c>, which is
          <c>1..<anno>Range</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="pid_to_list" arity="1" since=""/>
      <fsummary>Text representation of a pid.</fsummary>
      <desc>
        <p>Returns a string corresponding to the text
          representation of <c><anno>Pid</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="port_call" arity="3" since=""/>
      <fsummary>Perform a synchronous call to a port with term data.</fsummary>
      <desc>
        <p>Performs a synchronous call to a port. The meaning of
          <c><anno>Operation</anno></c> and <c><anno>Data</anno></c>
          depends on the port, that is,
          on the port driver. Not all port drivers support this feature.</p>
        <p><c><anno>Port</anno></c> is a port identifier,
          referring to a driver.</p>
        <p><c><anno>Operation</anno></c> is an integer, which is passed on to
          the driver.</p>
        <p><c><anno>Data</anno></c> is any Erlang term. This data is converted
          to binary term format and sent to the port.</p>
        <p>Returns a term from the driver. The meaning of the returned
          data also depends on the port driver.</p>
        <p>Failures:</p>
        <taglist>
          <tag><c>badarg</c></tag>
          <item>
            If <c><anno>Port</anno></c> is not an identifier of an open port,
            or the registered name of an open port. If the calling
            process was previously linked to the closed port,
            identified by <c><anno>Port</anno></c>, the exit signal
            from the port is guaranteed to be delivered before this
            <c>badarg</c> exception occurs.
            </item>
          <tag><c>badarg</c></tag>
          <item>
            If <c><anno>Operation</anno></c> does not fit in a 32-bit integer.
          </item>
          <tag><c>badarg</c></tag>
          <item>
            If the port driver does not support synchronous control operations.
          </item>
          <tag><c>badarg</c></tag>
          <item>
            <p>If the port driver so decides for any reason (probably
            something wrong with <c><anno>Operation</anno></c>
            or <c><anno>Data</anno></c>).</p>
	    <warning>
	      <p>Do not call <c>port_call</c> with an unknown
	      <c><anno>Port</anno></c> identifier and expect <c>badarg</c>
	      exception. Any undefined behavior is possible (including node
	      crash) depending on how the port driver interprets the supplied
	      arguments.</p>
	    </warning>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="port_close" arity="1" since=""/>
      <fsummary>Close an open port.</fsummary>
      <desc>
        <p>Closes an open port. Roughly the same as <c><anno>Port</anno> !
          {self(), close}</c> except for the error behavior
          (see below), being synchronous, and that the port does
          <em>not</em> reply with <c>{Port, closed}</c>. Any process can
          close a port with <c>port_close/1</c>, not only the port owner
          (the connected process). If the calling process is linked to
          the port identified by <c><anno>Port</anno></c>, the exit
          signal from the port is guaranteed to be delivered before
          <c>port_close/1</c> returns.</p> 
        <p>For comparison: <c><anno>Port</anno> ! {self(), close}</c>
          only fails with <c>badarg</c> if <c><anno>Port</anno></c> does
          not refer to a port or a process. If <c><anno>Port</anno></c>
          is a closed port, nothing happens. If <c><anno>Port</anno></c>
          is an open port and the calling process is the port owner,
          the port replies with <c>{Port, closed}</c> when all buffers
          have been flushed and the port really closes. If the calling
          process is not the port owner, the <em>port owner</em> fails
          with <c>badsig</c>.</p> 
        <p>Notice that any process can close a port using
          <c><anno>Port</anno> ! {PortOwner, close}</c> as if it itself was
          the port owner, but the reply always goes to the port owner.</p>
        <p>As from Erlang/OTP R16,
          <c><anno>Port</anno> ! {PortOwner, close}</c> is truly
          asynchronous. Notice that this operation has always been
          documented as an asynchronous operation, while the underlying
          implementation has been synchronous. <c>port_close/1</c> is
          however still fully synchronous because of its error behavior.</p>
        <p>Failure: <c>badarg</c> if <c><anno>Port</anno></c> is not an
          identifier of an open port, or the registered name of an open port.
          If the calling process was previously linked to the closed
          port, identified by <c><anno>Port</anno></c>, the exit
          signal from the port is guaranteed to be delivered before
          this <c>badarg</c> exception occurs.</p>
      </desc>
    </func>

    <func>
      <name name="port_command" arity="2" since=""/>
      <fsummary>Send data to a port.</fsummary>
      <desc>
        <p>Sends data to a port. Same as
          <c><anno>Port</anno> ! {PortOwner, {command, Data}}</c> except for
          the error behavior and being synchronous (see below). Any process
          can send data to a port with <c>port_command/2</c>, not only the
          port owner (the connected process).</p>
        <p>For comparison: <c><anno>Port</anno> ! {PortOwner, {command,
          Data}}</c> only fails with <c>badarg</c> if <c><anno>Port</anno></c>
          does not refer to a port or a process. If <c><anno>Port</anno></c> is
          a closed port, the data message disappears 
          without a sound. If <c><anno>Port</anno></c> is open and the calling
          process is not the port owner, the <em>port owner</em> fails
          with <c>badsig</c>. The port owner fails with <c>badsig</c>
          also if <c><anno>Data</anno></c> is an invalid I/O list.</p>
        <p>Notice that any process can send to a port using
          <c><anno>Port</anno> ! {PortOwner, {command, <anno>Data</anno>}}</c>
          as if it itself was the port owner.</p>
        <p>If the port is busy, the calling process is suspended
          until the port is not busy any more.</p>
        <p>As from Erlang/OTP R16,
          <c><anno>Port</anno> ! {PortOwner, {command, Data}}</c>
          is truly asynchronous. Notice that this operation has always been
          documented as an asynchronous operation, while the underlying
          implementation has been synchronous. <c>port_command/2</c> is
          however still fully synchronous because of its error behavior.</p>
        <p>Failures:</p>
        <taglist>
          <tag><c>badarg</c></tag>
          <item>
            <p>If <c><anno>Port</anno></c> is not an identifier of an open
              port, or the registered name of an open port. If the
              calling process was previously linked to the closed port,
              identified by <c><anno>Port</anno></c>, the exit signal
              from the port is guaranteed to be delivered before this
              <c>badarg</c> exception occurs.</p>
          </item>
          <tag><c>badarg</c></tag>
          <item>
            <p>If <c><anno>Data</anno></c> is an invalid I/O list.</p>
          </item>
        </taglist>
	<warning>
	  <p>Do not send data to an unknown port. Any undefined behavior is
	  possible (including node crash) depending on how the port driver
	  interprets the data.</p>
	</warning>
      </desc>
    </func>

    <func>
      <name name="port_command" arity="3" since=""/>
      <fsummary>Send data to a port.</fsummary>
      <desc>
        <p>Sends data to a port. <c>port_command(Port, Data, [])</c>
          equals <c>port_command(Port, Data)</c>.</p>
        <p>If the port command is aborted, <c>false</c> is returned,
          otherwise <c>true</c>.</p>
        <p>If the port is busy, the calling process is suspended
          until the port is not busy anymore.</p>
        <p><c><anno>Option</anno></c>s:</p>
        <taglist>
          <tag><c>force</c></tag>
          <item>The calling process is not suspended if the port is
            busy, instead the port command is forced through. The
            call fails with a <c>notsup</c> exception if the
            driver of the port does not support this. For more
            information, see driver flag
            <seealso marker="driver_entry#driver_flags">
            <c>![CDATA[ERL_DRV_FLAG_SOFT_BUSY]]</c></seealso>.
          </item>
          <tag><c>nosuspend</c></tag>
          <item>The calling process is not suspended if the port is
            busy, instead the port command is aborted and
            <c>false</c> is returned. 
          </item>
        </taglist>
        <note>
          <p>More options can be added in a future release.</p>
        </note>
        <p>Failures:</p>
        <taglist>
          <tag><c>badarg</c></tag>
          <item>
            If <c><anno>Port</anno></c> is not an identifier of an open
            port, or the registered name of an open port. If the
            calling process was previously linked to the closed port,
            identified by <c><anno>Port</anno></c>, the exit signal
            from the port is guaranteed to be delivered before this
            <c>badarg</c> exception occurs.
          </item>
          <tag><c>badarg</c></tag>
          <item>
            If <c><anno>Data</anno></c> is an invalid I/O list.
          </item>
          <tag><c>badarg</c></tag>
          <item>
          If <c><anno>OptionList</anno></c> is an invalid option list.
          </item>
          <tag><c>notsup</c></tag>
          <item>
            If option <c>force</c> has been passed, but the
            driver of the port does not allow forcing through
            a busy port.
          </item>
        </taglist>
	<warning>
	  <p>Do not send data to an unknown port. Any undefined behavior is
	  possible (including node crash) depending on how the port driver
	  interprets the data.</p>
	</warning>
      </desc>
    </func>

    <func>
      <name name="port_connect" arity="2" since=""/>
      <fsummary>Set the owner of a port.</fsummary>
      <desc>
        <p>Sets the port owner (the connected port) to <c><anno>Pid</anno></c>.
          Roughly the same as
          <c><anno>Port</anno> ! {Owner, {connect, <anno>Pid</anno>}}</c>
          except for the following:</p>
        <list type="bulleted">
          <item>
            <p>The error behavior differs, see below.</p>
          </item>
          <item>
            <p>The port does <em>not</em> reply with
              <c>{Port,connected}</c>.</p>
          </item>
          <item>
            <p><c>port_connect/1</c> is synchronous, see below.</p>
          </item>
          <item>
            <p>The new port owner gets linked to the port.</p>
          </item>
        </list>
        <p>The old port owner stays linked to the port and must call
          <c>unlink(Port)</c> if this is not desired. Any process can
          set the port owner to be any process with
          <c>port_connect/2</c>.</p>
        <p>For comparison:
          <c><anno>Port</anno> ! {self(), {connect, <anno>Pid</anno>}}</c>
          only fails with <c>badarg</c> if <c><anno>Port</anno></c>
          does not refer to a port or a process. If
          <c><anno>Port</anno></c> is a closed port, nothing happens.
          If <c><anno>Port</anno></c>
          is an open port and the calling process is the port owner,
          the port replies with <c>{Port, connected}</c> to the old
          port owner. Notice that the old port owner is still linked to
          the port, while the new is not. If <c><anno>Port</anno></c> is an open
          port and the calling process is not the port owner,
          the <em>port owner</em> fails with <c>badsig</c>. The port
          owner fails with <c>badsig</c> also if <c><anno>Pid</anno></c> is not
          an existing local process identifier.</p>
        <p>Notice that any process can set the port owner using
          <c><anno>Port</anno> ! {PortOwner, {connect, <anno>Pid</anno>}}</c>
          as if it itself was the port owner, but the reply always goes to
          the port owner.</p>
        <p>As from Erlang/OTP R16,
          <c><anno>Port</anno> ! {PortOwner, {connect, <anno>Pid</anno>}}</c>
          is truly asynchronous. Notice that this operation has always been
          documented as an asynchronous operation, while the underlying
          implementation has been synchronous. <c>port_connect/2</c> is
          however still fully synchronous because of its error behavior.</p>
        <p>Failures:</p>
        <taglist>
          <tag><c>badarg</c></tag>
          <item>
            If <c><anno>Port</anno></c> is not an identifier of an open port,
            or the registered name of an open port. If the calling
            process was previously linked to the closed port,
            identified by <c><anno>Port</anno></c>, the exit signal
            from the port is guaranteed to be delivered before this
            <c>badarg</c> exception occurs.
          </item>
          <tag><c>badarg</c></tag>
          <item>If the process identified by <c>Pid</c> is not an existing
            local process.</item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="port_control" arity="3" since=""/>
      <fsummary>Perform a synchronous control operation on a port.</fsummary>
      <desc>
        <p>Performs a synchronous control operation on a port.
          The meaning of <c><anno>Operation</anno></c> and
          <c><anno>Data</anno></c> depends on
          the port, that is, on the port driver. Not all port drivers
          support this control feature.</p>
        <p>Returns a list of integers in the range 0..255, or a
          binary, depending on the port driver. The meaning of
          the returned data also depends on the port driver.</p>
        <p>Failures:</p>
        <taglist>
          <tag><c>badarg</c></tag>
          <item>
            If <c><anno>Port</anno></c> is not an open port or the registered
            name of an open port.
          </item>
          <tag><c>badarg</c></tag>
          <item>
            If <c><anno>Operation</anno></c> cannot fit in a 32-bit integer.
          </item>
          <tag><c>badarg</c></tag>
          <item>
            If the port driver does not support synchronous control operations.
          </item>
          <tag><c>badarg</c></tag>
          <item>
            If the port driver so decides for any reason (probably
            something wrong with <c><anno>Operation</anno></c> or
            <c><anno>Data</anno></c>).
	    <warning>
	      <p>Do not call <c>port_control/3</c> with an unknown
	      <c><anno>Port</anno></c> identifier and expect <c>badarg</c>
	      exception. Any undefined behavior is possible (including node
	      crash) depending on how the port driver interprets the supplied
	      arguments.</p>
	    </warning>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="port_info" arity="1" since=""/>
      <fsummary>Information about a port.</fsummary>
      <desc>
        <p>Returns a list containing tuples with information about
          <c><anno>Port</anno></c>, or <c>undefined</c> if the port is not open.
          The order of the tuples is undefined, and all the
          tuples are not mandatory.
          If the port is closed and the calling process
          was previously linked to the port, the exit signal from the
          port is guaranteed to be delivered before <c>port_info/1</c>
          returns <c>undefined</c>.</p>
        <p>The result contains information about the following
          <c>Item</c>s:</p>
        <list type="bulleted">
          <item><c>registered_name</c> (if the port has a registered
            name)</item>
          <item><c>id</c></item>
          <item><c>connected</c></item>
          <item><c>links</c></item>
          <item><c>name</c></item>
          <item><c>input</c></item>
          <item><c>output</c></item>
        </list>
        <p>For more information about the different <c>Item</c>s, see
          <seealso marker="#port_info/2"><c>port_info/2</c></seealso>.</p>
        <p>Failure: <c>badarg</c> if <c>Port</c> is not a local port
          identifier, or an atom.</p>
      </desc>
    </func>

    <func>
      <name name="port_info" arity="2" clause_i="1" since=""/>
      <fsummary>Information about the connected process of a port.</fsummary>
      <desc>
        <p><c><anno>Pid</anno></c> is the process identifier of the process
          connected to the port.</p>
        <p>If the port identified by <c><anno>Port</anno></c> is not open,
          <c>undefined</c> is returned. If the port is closed and the
          calling process was previously linked to the port, the exit
          signal from the port is guaranteed to be delivered before
          <c>port_info/2</c> returns <c>undefined</c>.</p>
        <p>Failure: <c>badarg</c> if <c><anno>Port</anno></c> is not a local
          port identifier, or an atom.</p>
      </desc>
    </func>

    <func>
      <name name="port_info" arity="2" clause_i="2" since=""/>
      <fsummary>Information about the internal index of a port.</fsummary>
      <desc>
        <p><c><anno>Index</anno></c> is the internal index of the port. This
          index can be used to separate ports.</p>
        <p>If the port identified by <c><anno>Port</anno></c> is not open,
          <c>undefined</c> is returned. If the port is closed and the
          calling process was previously linked to the port, the exit
          signal from the port is guaranteed to be delivered before
          <c>port_info/2</c> returns <c>undefined</c>.</p>
        <p>Failure: <c>badarg</c> if <c><anno>Port</anno></c> is not a local
          port identifier, or an atom.</p>
      </desc>
    </func>

    <func>
      <name name="port_info" arity="2" clause_i="3" since=""/>
      <fsummary>Information about the input of a port.</fsummary>
      <desc>
        <p><c><anno>Bytes</anno></c> is the total number of bytes
          read from the port.</p>
        <p>If the port identified by <c><anno>Port</anno></c> is not open,
          <c>undefined</c> is returned. If the port is closed and the
          calling process was previously linked to the port, the exit
          signal from the port is guaranteed to be delivered before
          <c>port_info/2</c> returns <c>undefined</c>.</p>
        <p>Failure: <c>badarg</c> if <c><anno>Port</anno></c> is not a local
          port identifier, or an atom.</p>
      </desc>
    </func>

    <func>
      <name name="port_info" arity="2" clause_i="4" since=""/>
      <fsummary>Information about the links of a port.</fsummary>
      <desc>
        <p><c><anno>Pids</anno></c> is a list of the process identifiers
          of the processes that the port is linked to.</p>
        <p>If the port identified by <c><anno>Port</anno></c> is not open,
          <c>undefined</c> is returned. If the port is closed and the
          calling process was previously linked to the port, the exit
          signal from the port is guaranteed to be delivered before
          <c>port_info/2</c> returns <c>undefined</c>.</p>
        <p>Failure: <c>badarg</c> if <c><anno>Port</anno></c> is not a local
          port identifier, or an atom.</p>
      </desc>
    </func>

    <func>
      <name name="port_info" arity="2" clause_i="5" since="OTP R16B"/>
      <fsummary>Information about the locking of a port.</fsummary>
      <desc>
        <p><c><anno>Locking</anno></c> is one of the following:</p>
        <list type="bulleted">
          <item><c>port_level</c> (port-specific locking)</item>
          <item><c>driver_level</c> (driver-specific locking)</item>
        </list>
        <p>Notice that these results are highly implementation-specific
          and can change in a future release.</p>
        <p>If the port identified by <c><anno>Port</anno></c> is not open,
          <c>undefined</c> is returned. If the port is closed and the
          calling process was previously linked to the port, the exit
          signal from the port is guaranteed to be delivered before
          <c>port_info/2</c> returns <c>undefined</c>.</p>
        <p>Failure: <c>badarg</c> if <c><anno>Port</anno></c> is not a local
          port identifier, or an atom.</p>
      </desc>
    </func>

    <func>
      <name name="port_info" arity="2" clause_i="6" since="OTP R16B"/>
      <fsummary>Information about the memory size of a port.</fsummary>
      <desc>
        <marker id="port_info_memory"/>
        <p><c><anno>Bytes</anno></c> is the total number of
          bytes allocated for this port by the runtime system. The
          port itself can have allocated memory that is not
          included in <c><anno>Bytes</anno></c>.</p>
        <p>If the port identified by <c><anno>Port</anno></c> is not open,
          <c>undefined</c> is returned. If the port is closed and the
          calling process was previously linked to the port, the exit
          signal from the port is guaranteed to be delivered before
          <c>port_info/2</c> returns <c>undefined</c>.</p>
        <p>Failure: <c>badarg</c> if <c><anno>Port</anno></c> is not a local
          port identifier, or an atom.</p>
      </desc>
    </func>

    <func>
      <name name="port_info" arity="2" clause_i="7" since="OTP R16B"/>
      <fsummary>Information about the monitors of a port.</fsummary>
      <desc>
        <p><c><anno>Monitors</anno></c> represent processes monitored by
          this port.</p>
        <p>If the port identified by <c><anno>Port</anno></c> is not open,
          <c>undefined</c> is returned. If the port is closed and the
          calling process was previously linked to the port, the exit
          signal from the port is guaranteed to be delivered before
          <c>port_info/2</c> returns <c>undefined</c>.</p>
        <p>Failure: <c>badarg</c> if <c><anno>Port</anno></c> is not a local
          port identifier, or an atom.</p>
      </desc>
    </func>

    <func>
      <name name="port_info" arity="2" clause_i="8" since="OTP 19.0"/>
      <fsummary>Which processes are monitoring this port.</fsummary>
      <desc>
        <p>Returns list of pids that are monitoring given port at the
          moment.</p>
        <p>If the port identified by <c><anno>Port</anno></c> is not open,
          <c>undefined</c> is returned. If the port is closed and the
          calling process was previously linked to the port, the exit
          signal from the port is guaranteed to be delivered before
          <c>port_info/2</c> returns <c>undefined</c>.</p>
        <p>Failure: <c>badarg</c> if <c><anno>Port</anno></c> is not a local
          port identifier, or an atom.</p>
      </desc>
    </func>

    <func>
      <name name="port_info" arity="2" clause_i="9" since=""/>
      <fsummary>Information about the name of a port.</fsummary>
      <desc>
        <p><c><anno>Name</anno></c> is the command name set by
          <seealso marker="#open_port/2"><c>open_port/2</c></seealso>.</p>
        <p>If the port identified by <c><anno>Port</anno></c> is not open,
          <c>undefined</c> is returned. If the port is closed and the
          calling process was previously linked to the port, the exit
          signal from the port is guaranteed to be delivered before
          <c>port_info/2</c> returns <c>undefined</c>.</p>
        <p>Failure: <c>badarg</c> if <c><anno>Port</anno></c> is not a local
          port identifier, or an atom.</p>
      </desc>
    </func>

    <func>
      <name name="port_info" arity="2" clause_i="10" since="OTP R16B"/>
      <fsummary>Information about the OS pid of a port.</fsummary>
      <desc>
        <p><c><anno>OsPid</anno></c> is the process identifier (or equivalent)
          of an OS process created with
          <seealso marker="#open_port/2"><c>open_port({spawn | spawn_executable,
          Command}, Options)</c></seealso>. If the port is not the result of
          spawning an OS process, the value is <c>undefined</c>.</p>
        <p>If the port identified by <c><anno>Port</anno></c> is not open,
          <c>undefined</c> is returned. If the port is closed and the
          calling process was previously linked to the port, the exit
          signal from the port is guaranteed to be delivered before
          <c>port_info/2</c> returns <c>undefined</c>.</p>
        <p>Failure: <c>badarg</c> if <c><anno>Port</anno></c> is not a local
          port identifier, or an atom.</p>
      </desc>
    </func>

    <func>
      <name name="port_info" arity="2" clause_i="11" since=""/>
      <fsummary>Information about the output of a port.</fsummary>
      <desc>
        <p><c><anno>Bytes</anno></c> is the total number of bytes written
          to the port from Erlang processes using
          <seealso marker="#port_command/2"><c>port_command/2</c></seealso>,
          <seealso marker="#port_command/3"><c>port_command/3</c></seealso>,
          or <c><anno>Port</anno> ! {Owner, {command, Data}</c>.</p>
        <p>If the port identified by <c><anno>Port</anno></c> is not open,
          <c>undefined</c> is returned. If the port is closed and the
          calling process was previously linked to the port, the exit
          signal from the port is guaranteed to be delivered before
          <c>port_info/2</c> returns <c>undefined</c>.</p>
        <p>Failure: <c>badarg</c> if <c><anno>Port</anno></c> is not a local
          port identifier, or an atom.</p>
      </desc>
    </func>

    <func>
      <name name="port_info" arity="2" clause_i="12" since="OTP R16B"/>
      <fsummary>Information about the parallelism hint of a port.</fsummary>
      <desc>
        <p><c><anno>Boolean</anno></c> corresponds to the port parallelism
          hint used by this port. For more information, see option
          <seealso marker="#open_port_parallelism"><c>parallelism</c></seealso>
          of <seealso marker="#open_port/2"><c>open_port/2</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="port_info" arity="2" clause_i="13" since="OTP R16B"/>
      <fsummary>Information about the queue size of a port.</fsummary>
      <desc>
        <p><c><anno>Bytes</anno></c> is the total number
          of bytes queued by the port using the ERTS driver queue
          implementation.</p>
        <p>If the port identified by <c><anno>Port</anno></c> is not open,
          <c>undefined</c> is returned. If the port is closed and the
          calling process was previously linked to the port, the exit
          signal from the port is guaranteed to be delivered before
          <c>port_info/2</c> returns <c>undefined</c>.</p>
        <p>Failure: <c>badarg</c> if <c><anno>Port</anno></c> is not a local
          port identifier, or an atom.</p>
      </desc>
    </func>

    <func>
      <name name="port_info" arity="2" clause_i="14" since=""/>
      <fsummary>Information about the registered name of a port.</fsummary>
      <desc>
        <p><c><anno>RegisteredName</anno></c> is the registered name of
          the port. If the port has no registered name, <c>[]</c> is
          returned.</p>
        <p>If the port identified by <c><anno>Port</anno></c> is not open,
          <c>undefined</c> is returned. If the port is closed and the
          calling process was previously linked to the port, the exit
          signal from the port is guaranteed to be delivered before
          <c>port_info/2</c> returns <c>undefined</c>.</p>
        <p>Failure: <c>badarg</c> if <c><anno>Port</anno></c> is not a local
          port identifier, or an atom.</p>
      </desc>
    </func>

    <func>
      <name name="port_to_list" arity="1" since=""/>
      <fsummary>Text representation of a port identifier.</fsummary>
      <desc>
        <p>Returns a string corresponding to the text
          representation of the port identifier <c><anno>Port</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="ports" arity="0" since=""/>
      <fsummary>List all existing ports.</fsummary>
      <desc>
        <p>Returns a list of port identifiers corresponding to all the
          ports existing on the local node.</p>
        <p>Notice that an exiting port exists, but is not open.</p>
      </desc>
    </func>

    <func>
      <name name="pre_loaded" arity="0" since=""/>
      <fsummary>List all preloaded modules.</fsummary>
      <desc>
        <p>Returns a list of Erlang modules that are preloaded in
          the system. As all loading of code is done through the file
          system, the file system must have been loaded previously.
          Hence, at least the module <c>init</c> must be preloaded.</p>
      </desc>
    </func>

    <func>
      <name name="process_display" arity="2" since=""/>
      <fsummary>Write information about a local process on standard error.
      </fsummary>
      <desc>
        <p>Writes information about the local process <c><anno>Pid</anno></c> on
          standard error. The only allowed value for the atom
          <c><anno>Type</anno></c> is <c>backtrace</c>, which shows the contents
          of the call stack, including information about the call chain, with
          the current function printed first. The format of the output
          is not further defined.</p>
      </desc>
    </func>

    <func>
      <name name="process_flag" arity="2" clause_i="1" since=""/>
      <fsummary>Set process flag trap_exit for the calling process.</fsummary>
      <desc>
        <p>When <c>trap_exit</c> is set to <c>true</c>, exit signals
          arriving to a process are converted to <c>{'EXIT', From, Reason}</c>
          messages, which can be received as ordinary
          messages. If <c>trap_exit</c> is set to <c>false</c>, the
          process exits if it receives an exit signal other than
          <c>normal</c> and the exit signal is propagated to its
          linked processes. Application processes are normally
          not to trap exits.</p>
        <p>Returns the old value of the flag.</p>
        <p>See also <seealso marker="#exit/2"><c>exit/2</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="process_flag" arity="2" clause_i="2" since=""/>
      <fsummary>Set process flag error_handler for the calling process.
      </fsummary>
      <desc>
        <p>Used by a process to redefine the error handler
          for undefined function calls and undefined registered
          processes. Inexperienced users are not to use this flag,
          as code auto-loading depends on the correct
          operation of the error handling module.</p>
        <p>Returns the old value of the flag.</p>
      </desc>
    </func>

    <func>
      <name name="process_flag" arity="2" clause_i="3"
	    anchor="process_flag_min_heap_size" since=""/>
      <fsummary>Set process flag min_heap_size for the calling process.
      </fsummary>
      <desc>
        <p>Changes the minimum heap size for the calling process.</p>
        <p>Returns the old value of the flag.</p>
      </desc>
    </func>

    <func>
      <name name="process_flag" arity="2" clause_i="4" since="OTP R13B04"/>
      <fsummary>Set process flag min_bin_vheap_size for the calling process.
      </fsummary>
      <desc>
        <p>Changes the minimum binary virtual heap size for the calling
          process.</p>
        <p>Returns the old value of the flag.</p>
      </desc>
    </func>

    <func>
      <name name="process_flag" arity="2" clause_i="5"
	    anchor="process_flag_max_heap_size" since="OTP 19.0"/>
      <fsummary>Set process flag max_heap_size for the calling process.
      </fsummary>
      <type name="max_heap_size"/>
      <desc>
        <p>This flag sets the maximum heap size for the calling process.
          If <c><anno>MaxHeapSize</anno></c> is an integer, the system default
          values for <c>kill</c> and <c>error_logger</c> are used.
        </p>
        <taglist>
          <tag><c>size</c></tag>
          <item>
            <p>The maximum size in words of the process. If set to zero, the
              heap size limit is disabled. <c>badarg</c> is be thrown if the
              value is smaller than <seealso marker="#process_flag_min_heap_size">
              <c>min_heap_size</c></seealso>. The size check is only done when
              a garbage collection is triggered.</p>
            <p><c>size</c> is the entire heap of the process when garbage collection
              is triggered. This includes all generational heaps, the process stack, 
              any <seealso marker="#process_flag_message_queue_data">
              messages that are considered to be part of the heap</seealso>, and any
              extra memory that the garbage collector needs during collection.</p>
            <p><c>size</c> is the same as can be retrieved using
              <seealso marker="#process_info_total_heap_size">
                <c>erlang:process_info(Pid, total_heap_size)</c></seealso>,
              or by adding <c>heap_block_size</c>, <c>old_heap_block_size</c>
              and <c>mbuf_size</c> from <seealso marker="#process_info_garbage_collection_info">
                <c>erlang:process_info(Pid, garbage_collection_info)</c></seealso>.</p>
          </item>
          <tag><c>kill</c></tag>
          <item>
            <p>When set to <c>true</c>, the runtime system sends an
              untrappable exit signal with reason <c>kill</c> to the process
              if the maximum heap size is reached. The garbage collection
              that triggered the <c>kill</c> is not completed, instead the
              process exits as soon as possible. When set to <c>false</c>,
              no exit signal is sent to the process, instead it continues
              executing.</p>
            <p>If <c>kill</c> is not defined in the map,
              the system default will be used. The default system default
              is <c>true</c>. It can be changed by either option
              <seealso marker="erl#+hmaxk">+hmaxk</seealso> in <c>erl(1)</c>,
              or <seealso marker="#system_flag_max_heap_size">
              <c>erlang:system_flag(max_heap_size, MaxHeapSize)</c></seealso>.</p>
          </item>
          <tag><c>error_logger</c></tag>
          <item>
            <p>When set to <c>true</c>, the runtime system logs an
              error event via <seealso marker="kernel:logger">
              <c>logger</c></seealso>,
              containing details about the process when the maximum
              heap size is reached. One log event is sent
              each time the limit is reached.</p>
            <p>If <c>error_logger</c> is not defined in the map, the system
              default is used. The default system default is <c>true</c>.
              It can be changed by either the option
              <seealso marker="erl#+hmaxel">+hmaxel</seealso> int <c>erl(1)</c>,
              or <seealso marker="#system_flag_max_heap_size">
              <c>erlang:system_flag(max_heap_size, MaxHeapSize)</c></seealso>.</p>
          </item>
        </taglist>
        <p>The heap size of a process is quite hard to predict, especially the
          amount of memory that is used during the garbage collection. When
          contemplating using this option, it is recommended to first run
          it in production with <c>kill</c> set to <c>false</c> and inspect
          the log events to see what the normal peak sizes
          of the processes in the system is and then tune the value
          accordingly.
        </p>
      </desc>
    </func>

    <func>
      <name name="process_flag" arity="2" clause_i="6"
	    anchor="process_flag_message_queue_data" since="OTP 19.0"/>
      <fsummary>Set process flag message_queue_data for the calling process.
      </fsummary>
      <type name="message_queue_data"/>
      <desc>
        <p>This flag determines how messages in the message queue
          are stored, as follows:</p>
        <taglist>
          <tag><c>off_heap</c></tag>
          <item>
            <p><em>All</em> messages in the message queue will be stored
              outside of the process heap. This implies that <em>no</em>
              messages in the message queue will be part of a garbage
              collection of the process.</p>
          </item>
          <tag><c>on_heap</c></tag>
          <item>
            <p>All messages in the message queue will eventually be
              placed on heap. They can however temporarily be stored
              off heap. This is how messages always have been stored
              up until ERTS 8.0.</p>
          </item>
        </taglist>
        <p>The default <c>message_queue_data</c> process flag is determined
          by command-line argument <seealso marker="erl#+hmqd">
          <c>+hmqd</c></seealso> in <c>erl(1)</c>.</p>
        <p>If the process potentially can get many messages in its queue,
          you are advised to set the flag to <c>off_heap</c>. This
          because a garbage collection with many messages placed on
          the heap can become extremely expensive and the process can
          consume large amounts of memory. Performance of the
          actual message passing is however generally better when not
          using flag <c>off_heap</c>.</p>
        <p>When changing this flag messages will be moved. This work
          has been initiated but not completed when this function
          call returns.</p>
        <p>Returns the old value of the flag.</p>
      </desc>
    </func>

    <func>
      <name name="process_flag" arity="2" clause_i="7"
	    anchor="process_flag_priority" since=""/>
      <fsummary>Set process flag priority for the calling process.</fsummary>
      <type name="priority_level"/>
      <desc>
        <p>
          Sets the process priority. <c><anno>Level</anno></c> is an atom.
          Four priority levels exist: <c>low</c>,
          <c>normal</c>, <c>high</c>, and <c>max</c>. Default
          is <c>normal</c>.</p>
        <note>
          <p>Priority level <c>max</c> is reserved for internal use in
          the Erlang runtime system, and is <em>not</em> to be used
          by others.</p>
        </note>
        <p>Internally in each priority level, processes are scheduled
          in a round robin fashion.</p>
        <p>Execution of processes on priority <c>normal</c> and
          <c>low</c> are interleaved. Processes on priority
          <c>low</c> are selected for execution less
          frequently than processes on priority <c>normal</c>.</p>
        <p>When runnable processes on priority <c>high</c> exist,
          no processes on priority <c>low</c> or <c>normal</c> are
          selected for execution. Notice however that this does
          <em>not</em> mean that no processes on priority <c>low</c>
          or <c>normal</c> can run when processes
          are running on priority <c>high</c>. When using multiple
          schedulers, more processes can be running
          in parallel than processes on priority <c>high</c>. That is,
          a <c>low</c> and a <c>high</c> priority process can
          execute at the same time.</p>
        <p>When runnable processes on priority <c>max</c> exist,
          no processes on priority <c>low</c>, <c>normal</c>, or
          <c>high</c> are selected for execution. As with priority
          <c>high</c>, processes on lower priorities can
          execute in parallel with processes on priority <c>max</c>.</p>
        <p>Scheduling is pre-emptive. Regardless of priority, a process
          is pre-empted when it has consumed more than a certain number
          of reductions since the last time it was selected for
          execution.</p>
        <note>
          <p>Do not depend on the scheduling
          to remain exactly as it is today. Scheduling is likely to be
          changed in a future release to use available processor cores better.</p>
        </note>
        <p>There is <em>no</em> automatic mechanism for
          avoiding priority inversion, such as priority inheritance
          or priority ceilings. When using priorities,
          take this into account and handle such scenarios by
          yourself.</p>
        <p>Making calls from a <c>high</c> priority process into code
          that you has no control over can cause the <c>high</c>
          priority process to wait for a process with lower
          priority. That is, effectively decreasing the priority of the
          <c>high</c> priority process during the call. Even if this
          is not the case with one version of the code that you have no
          control over, it can be the case in a future
          version of it. This can, for example, occur if a
          <c>high</c> priority process triggers code loading, as
          the code server runs on priority <c>normal</c>.</p>
        <p>Other priorities than <c>normal</c> are normally not needed.
          When other priorities are used, use them with care,
          <em>especially</em> priority <c>high</c>. A
          process on priority <c>high</c> is only
          to perform work for short periods. Busy looping for
          long periods in a <c>high</c> priority process causes
          most likely problems, as important OTP servers
          run on priority <c>normal</c>.</p>
        <p>Returns the old value of the flag.</p>
      </desc>
    </func>

    <func>
      <name name="process_flag" arity="2" clause_i="8" since=""/>
      <fsummary>Set process flag save_calls for the calling process.</fsummary>
      <desc>
        <p><c><anno>N</anno></c> must be an integer in the interval 0..10000.
          If <c><anno>N</anno></c> &gt; 0, call saving is made
          active for the
          process. This means that information about the <c><anno>N</anno></c>
          most recent global function calls, BIF calls, sends, and
          receives made by the process are saved in a list, which
          can be retrieved with
          <c>process_info(Pid, last_calls)</c>. A global function
          call is one in which the module of the function is
          explicitly mentioned. Only a fixed amount of information
          is saved, as follows:</p>
        <list type="bulleted">
          <item><p>A tuple <c>{Module, Function, Arity}</c> for
            function calls</p></item>
          <item><p>The atoms <c>send</c>, <c>'receive'</c>, and
            <c>timeout</c> for sends and receives (<c>'receive'</c>
            when a message is received and <c>timeout</c> when a
            receive times out)</p></item>
        </list>
        <p>If <c>N</c> = 0,
          call saving is disabled for the process, which is the
          default. Whenever the size of the call saving list is set,
          its contents are reset.</p>
        <p>Returns the old value of the flag.</p>
      </desc>
    </func>

    <func>
      <name name="process_flag" arity="2" clause_i="9" since=""/>
      <fsummary>Set process flag sensitive for the calling process.</fsummary>
      <desc>
        <p>Sets or clears flag <c>sensitive</c> for the current process.
          When a process has been marked as sensitive by calling
          <c>process_flag(sensitive, true)</c>, features in the runtime
          system that can be used for examining the data or inner working
          of the process are silently disabled.</p>
        <p>Features that are disabled include (but are not limited to)
          the following:</p>
        <list type="bulleted">
          <item><p>Tracing. Trace flags can still be set for the process,
            but no trace messages of any kind are generated. (If flag
            <c>sensitive</c> is turned off, trace messages are again
            generated if any trace flags are set.)</p></item>
          <item><p>Sequential tracing. The sequential trace token is
            propagated as usual, but no sequential trace messages are
            generated.</p></item>
        </list>
        <p><c>process_info/1,2</c> cannot be used to read out the
          message queue or the process dictionary (both are returned
          as empty lists).</p>
        <p>Stack back-traces cannot be displayed for the process.</p>
        <p>In crash dumps, the stack, messages, and the process dictionary
          are omitted.</p>
        <p>If <c>{save_calls,N}</c> has been set for the process, no
          function calls are saved to the call saving list.
          (The call saving list is not cleared. Also, send, receive,
          and time-out events are still added to the list.)</p>
        <p>Returns the old value of the flag.</p>
      </desc>
    </func>

    <func>
      <name name="process_flag" arity="3" since=""/>
      <fsummary>Set process flags for a process.</fsummary>
      <desc>
        <p>Sets certain flags for the process <c><anno>Pid</anno></c>,
          in the same manner as
          <seealso marker="#process_flag/2"><c>process_flag/2</c></seealso>.
          Returns the old value of the flag. The valid values for
          <c><anno>Flag</anno></c> are only a subset of those allowed in
          <c>process_flag/2</c>, namely <c>save_calls</c>.</p>
        <p>Failure: <c>badarg</c> if <c><anno>Pid</anno></c>
          is not a local process.</p>
      </desc>
    </func>

    <func>
      <name name="process_info" arity="1" since=""/>
      <fsummary>Information about a process.</fsummary>
      <type name="process_info_result_item"/>
      <type name="priority_level"/>
      <type name="stack_item"/>
      <type name="max_heap_size"/>
      <type name="message_queue_data"/>
      <desc>
        <p>Returns a list containing <c><anno>InfoTuple</anno></c>s with
          miscellaneous information about the process identified by
          <c>Pid</c>, or <c>undefined</c> if the process is not alive.</p>
        <p>The order of the <c><anno>InfoTuple</anno></c>s is undefined and
          all <c><anno>InfoTuple</anno></c>s are not mandatory.
          The <c><anno>InfoTuple</anno></c>s
          part of the result can be changed without prior notice.</p>
        <p>The <c><anno>InfoTuple</anno></c>s with the following items
          are part of the result:</p>
        <list type="bulleted">
          <item><c>current_function</c></item>
          <item><c>initial_call</c></item>
          <item><c>status</c></item>
          <item><c>message_queue_len</c></item>
          <item><c>links</c></item>
          <item><c>dictionary</c></item>
          <item><c>trap_exit</c></item>
          <item><c>error_handler</c></item>
          <item><c>priority</c></item>
          <item><c>group_leader</c></item>
          <item><c>total_heap_size</c></item>
          <item><c>heap_size</c></item>
          <item><c>stack_size</c></item>
          <item><c>reductions</c></item>
          <item><c>garbage_collection</c></item>
        </list>
        <p>If the process identified by <c><anno>Pid</anno></c> has a
          registered name,
          also an <c><anno>InfoTuple</anno></c> with item <c>registered_name</c>
          is included.</p>
        <p>For information about specific <c><anno>InfoTuple</anno></c>s, see
          <seealso marker="#process_info/2"><c>process_info/2</c></seealso>.</p>
        <warning>
          <p>This BIF is intended for <em>debugging only</em>. For
            all other purposes, use <seealso marker="#process_info/2">
            <c>process_info/2</c></seealso>.</p>
        </warning>
        <p>Failure: <c>badarg</c> if <c><anno>Pid</anno></c> is not a
          local process.</p>
      </desc>
    </func>

    <func>
      <name name="process_info" arity="2" clause_i="1" since=""/>
      <name name="process_info" arity="2" clause_i="2" since=""/>
      <fsummary>Information about a process.</fsummary>
      <type name="process_info_item"/>
      <type name="process_info_result_item"/>
      <type name="stack_item"/>
      <type name="priority_level"/>
      <type name="max_heap_size"/>
      <type name="message_queue_data"/>
      <desc>
        <p>Returns information about the process identified by
          <c><anno>Pid</anno></c>, as specified by
          <c><anno>Item</anno></c> or <c><anno>ItemList</anno></c>.
          Returns <c>undefined</c> if the process is not alive.</p>
        <p>If the process is alive and a single <c><anno>Item</anno></c>
          is specified, the returned value is the corresponding
          <c><anno>InfoTuple</anno></c>, unless <c>Item =:= registered_name</c>
          and the process has no registered name. In this case,
          <c>[]</c> is returned. This strange behavior is because of
          historical reasons, and is kept for backward compatibility.</p>
        <p>If <c><anno>ItemList</anno></c> is specified, the result is
          <c><anno>InfoTupleList</anno></c>.
          The <c><anno>InfoTuple</anno></c>s in
          <c><anno>InfoTupleList</anno></c> are included with the corresponding
          <c><anno>Item</anno></c>s in the same order as the
          <c><anno>Item</anno></c>s were included
          in <c><anno>ItemList</anno></c>. Valid <c><anno>Item</anno></c>s can
          be included multiple times in <c><anno>ItemList</anno></c>.</p>
        <note>
          <p>If <c>registered_name</c> is part of <c><anno>ItemList</anno></c>
            and the process has no name registered, a
            <c>{registered_name, []}</c>, <c><anno>InfoTuple</anno></c>
            <em>will</em> be included in the resulting
            <c><anno>InfoTupleList</anno></c>. This
            behavior is different when a single
            <c>Item =:= registered_name</c> is specified, and when
            <c>process_info/1</c> is used.</p>
        </note>
        <p>Valid <c><anno>InfoTuple</anno></c>s with corresponding
          <c><anno>Item</anno></c>s:</p>
        <taglist>
          <tag><c>{backtrace, <anno>Bin</anno>}</c></tag>
          <item>
            <p>Binary <c><anno>Bin</anno></c> contains the same information
              as the output from
              <c>erlang:process_display(<anno>Pid</anno>, backtrace)</c>. Use
              <c>binary_to_list/1</c> to obtain the string of characters
              from the binary.</p>
          </item>
          <tag><c>{binary, <anno>BinInfo</anno>}</c></tag>
          <item>
            <p><c><anno>BinInfo</anno></c> is a list containing miscellaneous
              information about binaries on the heap of this
              process.
              This <c><anno>InfoTuple</anno></c> can be changed or
              removed without prior notice. In the current implementation
              <c><anno>BinInfo</anno></c> is a list of tuples. The tuples
              contain; <c>BinaryId</c>, <c>BinarySize</c>, <c>BinaryRefcCount</c>.</p>
            <p>The message queue is on the heap depending on the
              process flag <seealso marker="#process_flag_message_queue_data">
            <c>message_queue_data</c></seealso>.</p>
          </item>
          <tag><c>{catchlevel, <anno>CatchLevel</anno>}</c></tag>
          <item>
            <p><c><anno>CatchLevel</anno></c> is the number of currently active
              catches in this process. This <c><anno>InfoTuple</anno></c> can be
              changed or removed without prior notice.</p>
          </item>
          <tag><c>{current_function, {<anno>Module</anno>,
            <anno>Function</anno>, Arity} | undefined}</c></tag>
          <item>
            <p><c><anno>Module</anno></c>, <c><anno>Function</anno></c>,
              <c><anno>Arity</anno></c> is
              the current function call of the process. The value
              <c>undefined</c> can be returned if the process is
              currently executing native compiled code.</p>
          </item>
          <tag><c>{current_location, {<anno>Module</anno>,
            <anno>Function</anno>, <anno>Arity</anno>,
            <anno>Location</anno>}}</c></tag>
          <item>
            <p><c><anno>Module</anno></c>, <c><anno>Function</anno></c>,
              <c><anno>Arity</anno></c> is
              the current function call of the process.
              <c><anno>Location</anno></c> is a list of two-tuples describing
              the location in the source code.</p>
          </item>
          <tag><c>{current_stacktrace, <anno>Stack</anno>}</c></tag>
          <item>
            <p>Returns the current call stack back-trace (<em>stacktrace</em>)
              of the process. The stack has the same format as returned by
              <seealso marker="#get_stacktrace/0">
              <c>erlang:get_stacktrace/0</c></seealso>. The depth of the
              stacktrace is truncated according to the <c>backtrace_depth</c>
              system flag setting.</p>
          </item>
          <tag><c>{dictionary, <anno>Dictionary</anno>}</c></tag>
          <item>
            <p><c><anno>Dictionary</anno></c> is the process dictionary.</p>
          </item>
          <tag><c>{error_handler, <anno>Module</anno>}</c></tag>
          <item>
            <p><c><anno>Module</anno></c> is the error handler module used by
              the process (for undefined function calls, for example).</p>
          </item>
          <tag><c>{garbage_collection, <anno>GCInfo</anno>}</c></tag>
          <item>
            <p><c><anno>GCInfo</anno></c> is a list containing miscellaneous
              information about garbage collection for this process.
              The content of <c><anno>GCInfo</anno></c> can be changed without
              prior notice.</p>
          </item>
          <tag>
            <marker id="process_info_garbage_collection_info"/>
            <c>{garbage_collection_info, <anno>GCInfo</anno>}</c>
          </tag>
          <item>
            <p><c><anno>GCInfo</anno></c> is a list containing miscellaneous
              detailed information about garbage collection for this process.
              The content of <c><anno>GCInfo</anno></c> can be changed without
              prior notice. For details about the meaning of each item, see
              <seealso marker="#gc_minor_start"><c>gc_minor_start</c></seealso>
              in <seealso marker="#trace/3"><c>erlang:trace/3</c></seealso>.</p>
          </item>
          <tag><c>{group_leader, <anno>GroupLeader</anno>}</c></tag>
          <item>
            <p><c><anno>GroupLeader</anno></c> is the group leader for the I/O
              of the process.</p>
          </item>
          <tag><c>{heap_size, <anno>Size</anno>}</c></tag>
          <item>
            <p><c><anno>Size</anno></c> is the size in words of the youngest
              heap generation of the process. This generation includes
              the process stack. This information is highly
              implementation-dependent, and can change if the
              implementation changes.</p>
          </item>
          <tag><c>{initial_call, {<anno>Module</anno>, <anno>Function</anno>,
            <anno>Arity</anno>}}</c></tag>
          <item>
            <p><c><anno>Module</anno></c>, <c><anno>Function</anno></c>,
              <c><anno>Arity</anno></c> is
              the initial function call with which the process was
              spawned.</p>
          </item>
          <tag><c>{links, <anno>PidsAndPorts</anno>}</c></tag>
          <item>
            <p><c><anno>PidsAndPorts</anno></c> is a list of process identifiers
              and port identifiers, with processes or ports to which the process
              has a link.</p>
          </item>
          <tag><c>{last_calls, false|Calls}</c></tag>
          <item>
            <p>The value is <c>false</c> if call saving is not active
              for the process (see <seealso marker="#process_flag/3">
              <c>process_flag/3</c></seealso>).
              If call saving is active, a list is returned, in which
              the last element is the most recent called.</p>
          </item>
          <tag><c>{memory, <anno>Size</anno>}</c></tag>
          <item>
            <marker id="process_info_memory"/>
            <p><c><anno>Size</anno></c> is the size in bytes of the process.
              This includes call stack, heap, and internal structures.</p>
          </item>
          <tag><c>{message_queue_len, <anno>MessageQueueLen</anno>}</c></tag>
          <item>
            <p><c><anno>MessageQueueLen</anno></c> is the number of messages
              currently in the message queue of the process. This is the
              length of the list <c><anno>MessageQueue</anno></c> returned as
              the information item <c>messages</c> (see below).</p>
          </item>
          <tag><c>{messages, <anno>MessageQueue</anno>}</c></tag>
          <item>
            <p><c><anno>MessageQueue</anno></c> is a list of the messages to
              the process, which have not yet been processed.</p>
          </item>
          <tag><c>{min_heap_size, <anno>MinHeapSize</anno>}</c></tag>
          <item>
            <p><c><anno>MinHeapSize</anno></c> is the minimum heap size
              for the process.</p>
          </item>
          <tag><c>{min_bin_vheap_size, <anno>MinBinVHeapSize</anno>}</c></tag>
          <item>
            <p><c><anno>MinBinVHeapSize</anno></c> is the minimum binary virtual
              heap size for the process.</p>
          </item>
          <tag><c>{monitored_by, <anno>MonitoredBy</anno>}</c></tag>
          <item>
            <p>A list of identifiers for all the processes, ports and NIF
	    resources, that are monitoring the process.</p>
          </item>
          <tag><c>{monitors, <anno>Monitors</anno>}</c></tag>
          <item>
            <p>A list of monitors (started by <c>monitor/2</c>)
              that are active for the process. For a local process
              monitor or a remote process monitor by a process
              identifier, the list consists of:</p>
              <taglist>
                <tag><c>{process, <anno>Pid</anno>}</c></tag>
                <item>Process is monitored by pid.</item>
                <tag><c>{process, {<anno>RegName</anno>, <anno>Node</anno>}}</c></tag>
                <item>Local or remote process is monitored by name.</item>
                <tag><c>{port, PortId}</c></tag>
                <item>Local port is monitored by port id.</item>
                <tag><c>{port, {<anno>RegName</anno>, <anno>Node</anno>}}</c></tag>
                <item>Local port is monitored by name. Please note, that
                  remote port monitors are not supported, so <c>Node</c> will
                  always be the local node name.</item>
              </taglist>
          </item>
          <tag><c>{message_queue_data, <anno>MQD</anno>}</c></tag>
          <item>
            <p>Returns the current state of process flag
              <c>message_queue_data</c>. <c><anno>MQD</anno></c> is either
              <c>off_heap</c> or <c>on_heap</c>. For more
              information, see the documentation of
              <seealso marker="#process_flag_message_queue_data">
              <c>process_flag(message_queue_data, MQD)</c></seealso>.</p>
          </item>
          <tag><c>{priority, <anno>Level</anno>}</c></tag>
          <item>
            <p><c><anno>Level</anno></c> is the current priority level for
              the process. For more information on priorities, see
              <seealso marker="#process_flag_priority">
              <c>process_flag(priority, Level)</c></seealso>.</p>
          </item>
          <tag><c>{reductions, <anno>Number</anno>}</c></tag>
          <item>
            <p><c><anno>Number</anno></c> is the number of reductions executed
              by the process.</p>
          </item>
          <tag><c>{registered_name, <anno>Atom</anno>}</c></tag>
          <item>
            <p><c><anno>Atom</anno></c> is the registered process name.
              If the process has no registered name, this tuple is not
              present in the list.</p>
          </item>
          <tag><c>{sequential_trace_token, [] |
            <anno>SequentialTraceToken</anno>}</c></tag>
          <item>
            <p><c><anno>SequentialTraceToken</anno></c> is the sequential trace
              token for the process. This <c><anno>InfoTuple</anno></c> can be
              changed or removed without prior notice.</p>
          </item>
          <tag><c>{stack_size, <anno>Size</anno>}</c></tag>
          <item>
            <p><c><anno>Size</anno></c> is the stack size, in words,
              of the process.</p>
          </item>
          <tag><c>{status, <anno>Status</anno>}</c></tag>
          <item>
            <p><c><anno>Status</anno></c> is the status of the process and is
              one of the following:</p>
            <list type="bulleted">
              <item><c>exiting</c></item>
              <item><c>garbage_collecting</c></item>
              <item><c>waiting</c> (for a message)</item>
              <item><c>running</c></item>
              <item><c>runnable</c> (ready to run, but another process is
                running)</item>
              <item><c>suspended</c> (suspended on a "busy" port
                or by the BIF <c>erlang:suspend_process/1,2</c>)</item>
            </list>
          </item>
          <tag><c>{suspending, <anno>SuspendeeList</anno>}</c></tag>
          <item>
            <p><c><anno>SuspendeeList</anno></c> is a list of
              <c>{<anno>Suspendee</anno>, <anno>ActiveSuspendCount</anno>,
              <anno>OutstandingSuspendCount</anno>}</c> tuples.
              <c><anno>Suspendee</anno></c> is the process identifier of a
              process that has been, or is to be,
              suspended by the process identified by <c><anno>Pid</anno></c>
              through the BIF <seealso marker="#suspend_process/2">
              <c>erlang:suspend_process/2</c></seealso> or
              <seealso marker="#suspend_process/1">
              <c>erlang:suspend_process/1</c></seealso>.</p>
            <p><c><anno>ActiveSuspendCount</anno></c> is the number of
              times <c><anno>Suspendee</anno></c> has been suspended by
              <c><anno>Pid</anno></c>.
              <c><anno>OutstandingSuspendCount</anno></c> is the number of not
              yet completed suspend requests sent by <c><anno>Pid</anno></c>,
              that is:</p>
            <list type="bulleted">
              <item>
                <p>If <c><anno>ActiveSuspendCount</anno> =/= 0</c>,
                  <c><anno>Suspendee</anno></c> is
                  currently in the suspended state.</p>
              </item>
              <item>
                <p>If <c><anno>OutstandingSuspendCount</anno> =/= 0</c>,
                  option <c>asynchronous</c> of <c>erlang:suspend_process/2</c>
                  has been used and the suspendee has not yet been
                  suspended by <c><anno>Pid</anno></c>.</p>
              </item>
            </list>
            <p>Notice that <c><anno>ActiveSuspendCount</anno></c> and
              <c><anno>OutstandingSuspendCount</anno></c> are not the
              total suspend count on <c><anno>Suspendee</anno></c>,
              only the parts contributed by <c><anno>Pid</anno></c>.</p>
          </item>
          <tag>
            <marker id="process_info_total_heap_size"/>
            <c>{total_heap_size, <anno>Size</anno>}</c>
          </tag>
          <item>
            <p><c><anno>Size</anno></c> is the total size, in words, of all heap
              fragments of the process. This includes the process stack and
              any unreceived messages that are considered to be part of the
              heap.</p>
          </item>
          <tag><c>{trace, <anno>InternalTraceFlags</anno>}</c></tag>
          <item>
            <p><c><anno>InternalTraceFlags</anno></c> is an integer
              representing the internal trace flag for this process.
              This <c><anno>InfoTuple</anno></c>
              can be changed or removed without prior notice.</p>
          </item>
          <tag><c>{trap_exit, <anno>Boolean</anno>}</c></tag>
          <item>
            <p><c><anno>Boolean</anno></c> is <c>true</c> if the process
              is trapping exits, otherwise <c>false</c>.</p>
          </item>
        </taglist>
        <p>Notice that not all implementations support all
          these <c><anno>Item</anno></c>s.</p>
        <p>Failures:</p>
        <taglist>
          <tag><c>badarg</c></tag>
          <item>If <c><anno>Pid</anno></c> is not a local process.</item>
          <tag><c>badarg</c></tag>
          <item>If <c><anno>Item</anno></c> is an invalid item.</item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="processes" arity="0" since=""/>
      <fsummary>All processes.</fsummary>
      <desc>
        <p>Returns a list of process identifiers corresponding to
          all the processes currently existing on the local node.</p>
        <p>Notice that an exiting process exists, but is not alive.
          That is, <c>is_process_alive/1</c> returns <c>false</c>
          for an exiting process, but its process identifier is part
          of the result returned from <c>processes/0</c>.</p>
        <p>Example:</p>
        <pre>
> <input>processes().</input>
[&lt;0.0.0&gt;,&lt;0.2.0&gt;,&lt;0.4.0&gt;,&lt;0.5.0&gt;,&lt;0.7.0&gt;,&lt;0.8.0&gt;]</pre>
      </desc>
    </func>

    <func>
      <name name="purge_module" arity="1" since=""/>
      <fsummary>Remove old code for a module.</fsummary>
      <desc>
        <p>Removes old code for <c><anno>Module</anno></c>.
          Before this BIF is used,
          <seealso marker="#check_process_code/2">
          <c>check_process_code/2</c></seealso>is to be called to check
          that no processes execute old code in the module.</p>
        <warning>
          <p>This BIF is intended for the code server (see
            <seealso marker="kernel:code"><c>code(3)</c></seealso>)
            and is not to be used elsewhere.</p>
        </warning>
        <note>
          <p>As from ERTS 8.0 (Erlang/OTP 19), any lingering processes
            that still execute the old code is killed by this function.
            In earlier versions, such incorrect use could cause much
            more fatal failures, like emulator crash.</p>
        </note>
        <p>Failure: <c>badarg</c> if there is no old code for
          <c><anno>Module</anno></c>.</p>
      </desc>
    </func>

    <func>
      <name name="put" arity="2" since=""/>
      <fsummary>Add a new value to the process dictionary.</fsummary>
      <desc>
        <p>Adds a new <c><anno>Key</anno></c> to the process dictionary,
          associated with the value <c><anno>Val</anno></c>, and returns
          <c>undefined</c>. If <c><anno>Key</anno></c> exists, the old
          value is deleted and replaced by <c><anno>Val</anno></c>, and
          the function returns the old value. Example:</p>
        <pre>
> <input>X = put(name, walrus), Y = put(name, carpenter),</input>
<input>Z = get(name),</input>
<input>{X, Y, Z}.</input>
{undefined,walrus,carpenter}</pre>
        <note>
          <p>The values stored when <c>put</c> is evaluated within
            the scope of a <c>catch</c> are not retracted if a
            <c>throw</c> is evaluated, or if an error occurs.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="raise" arity="3" since=""/>
      <fsummary>Stop execution with an exception of specified class, reason,
        and call stack backtrace.</fsummary>
      <type name="raise_stacktrace"/>
      <desc>
        <p>Stops the execution of the calling process with an
          exception of the specified class, reason, and call stack backtrace
          (<em>stacktrace</em>).</p>
        <p><c><anno>Class</anno></c> is <c>error</c>, <c>exit</c>, or
          <c>throw</c>. So, if it were not for the stacktrace,
          <c>erlang:raise(<anno>Class</anno>, <anno>Reason</anno>,
          <anno>Stacktrace</anno>)</c> is equivalent to
          <c>erlang:<anno>Class</anno>(<anno>Reason</anno>)</c>.</p>
        <p><c><anno>Reason</anno></c> is any term.
          <c><anno>Stacktrace</anno></c> is a list as
          returned from <c>get_stacktrace()</c>, that is, a list of
          four-tuples <c>{Module, Function, Arity | Args,
          Location}</c>, where <c>Module</c> and <c>Function</c>
          are atoms, and the third element is an integer arity or an
          argument list. The stacktrace can also contain <c>{Fun,
          Args, Location}</c> tuples, where <c>Fun</c> is a local
          fun and <c>Args</c> is an argument list.</p>
        <p>Element <c>Location</c> at the end is optional.
          Omitting it is equivalent to specifying an empty list.</p>
        <p>The stacktrace is used as the exception stacktrace for the
          calling process; it is truncated to the current
          maximum stacktrace depth.</p>
        <p>As evaluating this function causes the process to
          terminate, it has no return value unless the arguments are
          invalid, in which case the function <em>returns the error
          reason</em> <c>badarg</c>. If you want to be
          sure not to return, you can call
          <c>error(erlang:raise(<anno>Class</anno>, <anno>Reason</anno>,
          <anno>Stacktrace</anno>))</c>
          and hope to distinguish exceptions later.</p>
      </desc>
    </func>

    <func>
      <name name="read_timer" arity="1" since=""/>
      <fsummary>Read the state of a timer.</fsummary>
      <desc>
        <p>Reads the state of a timer. The same as calling
          <seealso marker="#read_timer/2"><c>erlang:read_timer(TimerRef,
          [])</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="read_timer" arity="2" since="OTP 18.0"/>
      <fsummary>Read the state of a timer.</fsummary>
      <desc>
        <p>Reads the state of a timer that has been created by either
          <seealso marker="#start_timer/4"><c>erlang:start_timer</c></seealso>
          or <seealso marker="#send_after/4"><c>erlang:send_after</c></seealso>.
          <c><anno>TimerRef</anno></c> identifies the timer, and
          was returned by the BIF that created the timer.</p>
        <p><c><anno>Option</anno>s</c>:</p>
        <taglist>
        <tag><c>{async, Async}</c></tag>
          <item>
            <p>Asynchronous request for state information. <c>Async</c>
              defaults to <c>false</c>, which causes the operation
              to be performed synchronously. In this case, the <c>Result</c>
              is returned by <c>erlang:read_timer</c>. When
              <c>Async</c> is <c>true</c>, <c>erlang:read_timer</c>
              sends an asynchronous request for the state information
              to the timer service that manages the timer, and then returns
              <c>ok</c>. A message on the format <c>{read_timer,
              <anno>TimerRef</anno>, <anno>Result</anno>}</c> is
              sent to the caller of <c>erlang:read_timer</c> when the
              operation has been processed.</p>
          </item>
        </taglist>
        <p>More <c><anno>Option</anno></c>s can be added in the future.</p>
        <p>If <c><anno>Result</anno></c> is an integer, it represents the
          time in milliseconds left until the timer expires.</p>
        <p>If <c><anno>Result</anno></c> is <c>false</c>, a
          timer corresponding to <c><anno>TimerRef</anno></c> could not
          be found. This because the timer had expired,
          or been canceled, or because <c><anno>TimerRef</anno></c>
          never has corresponded to a timer. Even if the timer has expired,
          it does not tell you whether or not the time-out message has
          arrived at its destination yet.</p>
        <note>
          <p>The timer service that manages the timer can be co-located
            with another scheduler than the scheduler that the calling
            process is executing on. If so, communication
            with the timer service takes much longer time than if it
            is located locally. If the calling process is in a critical
            path, and can do other things while waiting for the result
            of this operation, you want to use option <c>{async, true}</c>.
            If using option <c>{async, false}</c>, the calling
            process is blocked until the operation has been performed.</p>
         </note>
        <p>See also 
          <seealso marker="#send_after/4"><c>erlang:send_after/4</c></seealso>,
          <seealso marker="#start_timer/4">
          <c>erlang:start_timer/4</c></seealso>, and
          <seealso marker="#cancel_timer/2">
          <c>erlang:cancel_timer/2</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="ref_to_list" arity="1" since=""/>
      <fsummary>Text representation of a reference.</fsummary>
      <desc>
        <p>Returns a string corresponding to the text
          representation of <c><anno>Ref</anno></c>.</p>
        <warning>
          <p>This BIF is intended for debugging and is not to be used
            in application programs.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="register" arity="2" since=""/>
      <fsummary>Register a name for a pid (or port).</fsummary>
      <desc>
        <p>Associates the name <c><anno>RegName</anno></c> with a process
          identifier (pid) or a port identifier.
          <c><anno>RegName</anno></c>, which must be an atom, can be used
          instead of the pid or port identifier in send operator
          (<c><anno>RegName</anno> ! Message</c>). Example:</p>
        <pre>
> <input>register(db, Pid).</input>
true</pre>
        <p>Failures:</p>
        <taglist>
          <tag><c>badarg</c></tag>
            <item>If <c><anno>PidOrPort</anno></c> is not an existing local
              process or port.</item>
          <tag><c>badarg</c></tag>
            <item>If <c><anno>RegName</anno></c> is already in use.</item>
          <tag><c>badarg</c></tag>
            <item>If the process or port is already registered
              (already has a name).</item>
          <tag><c>badarg</c></tag>
            <item>If <c><anno>RegName</anno></c> is the atom
              <c>undefined</c>.</item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="registered" arity="0" since=""/>
      <fsummary>All registered names.</fsummary>
      <desc>
        <p>Returns a list of names that have been registered using
          <seealso marker="#register/2"><c>register/2</c></seealso>, for
          example:</p>
        <pre>
> <input>registered().</input>
[code_server, file_server, init, user, my_db]</pre>
      </desc>
    </func>

    <func>
      <name name="resume_process" arity="1" since=""/>
      <fsummary>Resume a suspended process.</fsummary>
      <desc>
        <p>Decreases the suspend count on the process identified by
          <c><anno>Suspendee</anno></c>. <c><anno>Suspendee</anno></c>
          is previously to have been suspended through
          <seealso marker="#suspend_process/2">
          <c>erlang:suspend_process/2</c></seealso> or
          <seealso marker="#suspend_process/1">
          <c>erlang:suspend_process/1</c></seealso>
          by the process calling
          <c>erlang:resume_process(<anno>Suspendee</anno>)</c>. When the
          suspend count on <c><anno>Suspendee</anno></c> reaches zero,
          <c><anno>Suspendee</anno></c> is resumed, that is, its state
          is changed from suspended into the state it had before it was
          suspended.</p>
        <warning>
          <p>This BIF is intended for debugging only.</p>
        </warning>
        <p>Failures:</p>
        <taglist>
          <tag><c>badarg</c></tag>
          <item>
            If <c><anno>Suspendee</anno></c> is not a process identifier.
          </item>
          <tag><c>badarg</c></tag>
          <item>
            If the process calling <c>erlang:resume_process/1</c> had
            not previously increased the suspend count on the process
            identified by <c><anno>Suspendee</anno></c>.
          </item>
          <tag><c>badarg</c></tag>
          <item>
            If the process identified by <c><anno>Suspendee</anno></c>
            is not alive.
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="round" arity="1" since=""/>
      <fsummary>Return an integer by rounding a number.</fsummary>
      <desc>
        <p>Returns an integer by rounding <c><anno>Number</anno></c>,
          for example:</p>
        <pre>
<input>round(5.5).</input>
6</pre>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="self" arity="0" since=""/>
      <fsummary>Return pid of the calling process.</fsummary>
      <desc>
        <p>Returns the process identifier of the calling process, for
          example:</p>
        <pre>
> <input>self().</input>
&lt;0.26.0></pre>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="send" arity="2" since=""/>
      <fsummary>Send a message.</fsummary>
      <type name="dst"/>
      <desc>
        <p>Sends a message and returns <c><anno>Msg</anno></c>. This
        is the same as using the <seealso marker="doc/reference_manual:expressions#send">
	send operator</seealso>:
	<c><anno>Dest</anno> ! <anno>Msg</anno></c>.</p>
        <p><c><anno>Dest</anno></c> can be a remote or local process identifier,
          a (local) port, a locally registered name, or a tuple
          <c>{<anno>RegName</anno>, <anno>Node</anno>}</c>
        for a registered name at another node.</p>
	<p>The function fails with a <c>badarg</c> run-time error if
	<c><anno>Dest</anno></c> is an atom name, but this name is not
	registered. This is the only case when <c>send</c> fails for an
	unreachable destination <c><anno>Dest</anno></c> (of correct type).</p>
      </desc>
    </func>

    <func>
      <name name="send" arity="3" since=""/>
      <fsummary>Send a message conditionally.</fsummary>
      <type name="dst"/>
      <desc>
        <p>Either sends a message and returns <c>ok</c>, or does not send
          the message but returns something else (see below).
          Otherwise the same as
          <seealso marker="#send/2"><c>erlang:send/2</c></seealso>.
          For more detailed explanation and warnings, see
          <seealso marker="#send_nosuspend/2">
          <c>erlang:send_nosuspend/2,3</c></seealso>.</p>
        <p>Options:</p>
        <taglist>
          <tag><c>nosuspend</c></tag>
          <item>If the sender would have to be suspended to do the send,
            <c>nosuspend</c> is returned instead.
          </item>
          <tag><c>noconnect</c></tag>
          <item>
            If the destination node would have to be auto-connected
             to do the send, <c>noconnect</c> is returned
             instead.
          </item>
        </taglist>
        <warning>
          <p>As with <c>erlang:send_nosuspend/2,3</c>: use with extreme
            care.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="send_after" arity="3" since=""/>
      <fsummary>Start a timer.</fsummary>
      <desc>
        <p>Starts a timer. The same as calling
          <seealso marker="#send_after/4">
          <c>erlang:send_after(<anno>Time</anno>, <anno>Dest</anno>,
          <anno>Msg</anno>, [])</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="send_after" arity="4" since="OTP 18.0"/>
      <fsummary>Start a timer.</fsummary>
      <desc>
        <p>Starts a timer. When the timer expires, the message
          <c><anno>Msg</anno></c> is sent to the process
          identified by <c><anno>Dest</anno></c>. Apart from
          the format of the time-out message, this function works exactly as
          <seealso marker="#start_timer/4">
          <c>erlang:start_timer/4</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="send_nosuspend" arity="2" since=""/>
      <fsummary>Try to send a message without ever blocking.</fsummary>
      <type name="dst"/>
      <desc>
        <p>The same as
          <seealso marker="#send/3"><c>erlang:send(<anno>Dest</anno>,
          <anno>Msg</anno>, [nosuspend])</c></seealso>,
          but returns <c>true</c> if
          the message was sent and <c>false</c> if the message was not
          sent because the sender would have had to be suspended.</p>
        <p>This function is intended for send operations to an
          unreliable remote node without ever blocking the sending
          (Erlang) process. If the connection to the remote node
          (usually not a real Erlang node, but a node written in C or
          Java) is overloaded, this function <em>does not send the message</em>
          and returns <c>false</c>.</p>
        <p>The same occurs if <c><anno>Dest</anno></c> refers to a local port
          that is busy. For all other destinations (allowed for the ordinary
          send operator <c>'!'</c>), this function sends the message and
          returns <c>true</c>.</p>
        <p>This function is only to be used in rare circumstances
          where a process communicates with Erlang nodes that can
          disappear without any trace, causing the TCP buffers and
          the drivers queue to be over-full before the node is
          shut down (because of tick time-outs) by <c>net_kernel</c>.
          The normal reaction to take when this occurs is some kind of
          premature shutdown of the other node.</p>
        <p>Notice that ignoring the return value from this function would
          result in an <em>unreliable</em> message passing, which is
          contradictory to the Erlang programming model. The message is
          <em>not</em> sent if this function returns <c>false</c>.</p>
        <p>In many systems, transient states of
          overloaded queues are normal. Although this function
          returns <c>false</c> does not mean that the other
          node is guaranteed to be non-responsive, it could be a
          temporary overload. Also, a return value of <c>true</c> does
          only mean that the message can be sent on the (TCP) channel
          without blocking; the message is not guaranteed to
          arrive at the remote node. For a disconnected
          non-responsive node, the return value is <c>true</c> (mimics
          the behavior of operator <c>!</c>). The expected
          behavior and the actions to take when the function
          returns <c>false</c> are application- and hardware-specific.</p>
        <warning>
          <p>Use with extreme care.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="send_nosuspend" arity="3" since=""/>
      <fsummary>Try to send a message without ever blocking.</fsummary>
      <type name="dst"/>
      <desc>
        <p>The same as
          <seealso marker="#send/3"><c>erlang:send(<anno>Dest</anno>,
          <anno>Msg</anno>, [nosuspend | <anno>Options</anno>])</c></seealso>,
          but with a Boolean return value.</p>
        <p>This function behaves like
          <seealso marker="#send_nosuspend/2">
          <c>erlang:send_nosuspend/2</c></seealso>,
          but takes a third parameter, a list of options.
          The only option is <c>noconnect</c>, which
          makes the function return <c>false</c> if
          the remote node is not currently reachable by the local
          node. The normal behavior is to try to connect to the node,
          which can stall the process during a short period. The use of
          option <c>noconnect</c> makes it possible to be
          sure not to get the slightest delay when
          sending to a remote process. This is especially useful when
          communicating with nodes that expect to always be
          the connecting part (that is, nodes written in C or Java).</p>
        <p>Whenever the function returns <c>false</c> (either when a
          suspend would occur or when <c>noconnect</c> was specified and
          the node was not already connected), the message is guaranteed
          <em>not</em> to have been sent.</p>
        <warning>
          <p>Use with extreme care.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="set_cookie" arity="2" since=""/>
      <fsummary>Set the magic cookie of a node.</fsummary>
      <desc>
        <p>Sets the magic cookie of <c><anno>Node</anno></c> to the atom
          <c><anno>Cookie</anno></c>. If <c><anno>Node</anno></c> is the
          local node, the function
          also sets the cookie of all other unknown nodes to
          <c><anno>Cookie</anno></c> (see section
          <seealso marker="doc/reference_manual:distributed">
          Distributed Erlang</seealso>
          in the Erlang Reference Manual in System Documentation).</p>
        <p>Failure: <c>function_clause</c> if the local node is not
          alive.</p>
      </desc>
    </func>

    <func>
      <name name="setelement" arity="3" since=""/>
      <fsummary>Set the Nth element of a tuple.</fsummary>
      <type_desc variable="Index">1..tuple_size(<anno>Tuple1</anno></type_desc>
      <desc>
        <p>Returns a tuple that is a copy of argument
          <c><anno>Tuple1</anno></c>
          with the element specified by integer argument
          <c><anno>Index</anno></c>
          (the first element is the element with index 1) replaced by
          argument <c><anno>Value</anno></c>, for example:</p>
        <pre>
> <input>setelement(2, {10, green, bottles}, red).</input>
{10,red,bottles}</pre>
      </desc>
    </func>

    <func>
      <name name="size" arity="1" since=""/>
      <fsummary>Size of a tuple or binary.</fsummary>
      <desc>
        <p>Returns the number of elements in a tuple or the number of
          bytes in a binary or bitstring, for example:</p>
        <pre>
> <input>size({morni, mulle, bwange}).</input>
3
> <input>size(&lt;&lt;11, 22, 33&gt;&gt;).</input>
3</pre>
        <p>For bitstrings, the number of whole bytes is returned.
          That is, if the number of bits
          in the bitstring is not divisible by 8, the resulting
          number of bytes is rounded <em>down</em>.</p>
        <p>Allowed in guard tests.</p>
        <p>See also
          <seealso marker="#tuple_size/1"><c>tuple_size/1</c></seealso>,
          <seealso marker="#byte_size/1"><c>byte_size/1</c></seealso>, and
          <seealso marker="#bit_size/1"><c>bit_size/1</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="spawn" arity="1" since=""/>
      <fsummary>Create a new process with a fun as entry point.</fsummary>
      <desc>
        <p>Returns the process identifier of a new process started by the
          application of <c><anno>Fun</anno></c> to the empty list
          <c>[]</c>. Otherwise
          works like <seealso marker="#spawn/3"><c>spawn/3</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="spawn" arity="2" since=""/>
      <fsummary>Create a new process with a fun as entry point on a specified
        node.</fsummary>
      <desc>
        <p>Returns the process identifier of a new process started
          by the application of <c><anno>Fun</anno></c> to the
          empty list <c>[]</c> on <c><anno>Node</anno></c>. If
          <c><anno>Node</anno></c> does not exist, a useless pid is
          returned. Otherwise works like
          <seealso marker="#spawn/3"><c>spawn/3</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="spawn" arity="3" since=""/>
      <fsummary>Create a new process with a function as entry point.</fsummary>
      <desc>
        <p>Returns the process identifier of a new process started by
          the application of <c><anno>Module</anno>:<anno>Function</anno></c>
          to <c><anno>Args</anno></c>.</p>
        <p><c>error_handler:undefined_function(<anno>Module</anno>,
          <anno>Function</anno>, <anno>Args</anno>)</c>
          is evaluated by the new process if
          <c><anno>Module</anno>:<anno>Function</anno>/Arity</c>
          does not exist (where <c>Arity</c> is the length of
          <c><anno>Args</anno></c>). The error handler
          can be redefined (see
          <seealso marker="#process_flag/2"><c>process_flag/2</c></seealso>).
          If <c>error_handler</c> is undefined, or the user has
          redefined the default <c>error_handler</c> and its replacement is
          undefined, a failure with reason <c>undef</c> occurs.</p>
        <p>Example:</p>
        <pre>
> <input>spawn(speed, regulator, [high_speed, thin_cut]).</input>
&lt;0.13.1></pre>
      </desc>
    </func>

    <func>
      <name name="spawn" arity="4" since=""/>
      <fsummary>Create a new process with a function as entry point on a
        specified node.</fsummary>
      <desc>
        <p>Returns the process identifier (pid) of a new process started
          by the application
          of <c><anno>Module</anno>:<anno>Function</anno></c>
          to <c><anno>Args</anno></c> on <c><anno>Node</anno></c>. If
          <c><anno>Node</anno></c> does not exist, a useless pid is returned.
          Otherwise works like
          <seealso marker="#spawn/3"><c>spawn/3</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="spawn_link" arity="1" since=""/>
      <fsummary>Create and link to a new process with a fun as entry point.
      </fsummary>
      <desc>
        <p>Returns the process identifier of a new process started by
          the application of <c><anno>Fun</anno></c> to the empty list
          <c>[]</c>. A link is created between
          the calling process and the new process, atomically.
          Otherwise works like
          <seealso marker="#spawn/3"><c>spawn/3</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="spawn_link" arity="2" since=""/>
      <fsummary>Create and link to a new process with a fun as entry point on
        a specified node.</fsummary>
      <desc>
        <p>Returns the process identifier (pid) of a new process started
          by the application of <c><anno>Fun</anno></c> to the empty
          list <c>[]</c> on <c><anno>Node</anno></c>. A link is
          created between the calling process and the new process,
          atomically. If <c><anno>Node</anno></c> does not exist,
          a useless pid is returned and an exit signal with
          reason <c>noconnection</c> is sent to the calling
          process. Otherwise works like <seealso marker="#spawn/3">
          <c>spawn/3</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="spawn_link" arity="3" since=""/>
      <fsummary>Create and link to a new process with a function as entry point.
      </fsummary>
      <desc>
        <p>Returns the process identifier of a new process started by
          the application of <c><anno>Module</anno>:<anno>Function</anno></c>
          to <c><anno>Args</anno></c>. A link is created
          between the calling process and the new process, atomically.
          Otherwise works like
          <seealso marker="#spawn/3"><c>spawn/3</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="spawn_link" arity="4" since=""/>
      <fsummary>Create and link to a new process with a function as entry point
        on a specified node.</fsummary>
      <desc>
        <p>Returns the process identifier (pid) of a new process
          started by the application
          of <c><anno>Module</anno>:<anno>Function</anno></c>
          to <c><anno>Args</anno></c> on <c><anno>Node</anno></c>. A
          link is created between the calling process and the new
          process, atomically. If <c><anno>Node</anno></c> does
          not exist, a useless pid is returned and an exit signal with
          reason <c>noconnection</c> is sent to the calling
          process. Otherwise works like <seealso marker="#spawn/3">
          <c>spawn/3</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="spawn_monitor" arity="1" since=""/>
      <fsummary>Create and monitor a new process with a fun as entry point.
      </fsummary>
      <desc>
        <p>Returns the process identifier of a new process, started by
          the application of <c><anno>Fun</anno></c> to the empty list
          <c>[]</c>,
          and a reference for a monitor created to the new process.
          Otherwise works like
          <seealso marker="#spawn/3"><c>spawn/3</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="spawn_monitor" arity="3" since=""/>
      <fsummary>Create and monitor a new process with a function as entry point.
      </fsummary>
      <desc>
        <p>A new process is started by the application
          of <c><anno>Module</anno>:<anno>Function</anno></c>
          to <c><anno>Args</anno></c>. The process is
          monitored at the same time. Returns the process identifier
          and a reference for the monitor. Otherwise works like
          <seealso marker="#spawn/3"><c>spawn/3</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="spawn_opt" arity="2" since=""/>
      <fsummary>Create a new process with a fun as entry point.</fsummary>
      <type name="priority_level"/>
      <type name="max_heap_size"/>
      <type name="message_queue_data"/>
      <type name="spawn_opt_option"/>
      <desc>
        <p>Returns the process identifier (pid) of a new process
          started by the application of <c><anno>Fun</anno></c>
          to the empty list <c>[]</c>. Otherwise works like
          <seealso marker="#spawn_opt/4"><c>spawn_opt/4</c></seealso>.</p>
        <p>If option <c>monitor</c> is specified, the newly created
          process is monitored, and both the pid and reference for
          the monitor are returned.</p>
      </desc>
    </func>

    <func>
      <name name="spawn_opt" arity="3" since=""/>
      <fsummary>Create a new process with a fun as entry point on a specified
        node.</fsummary>
      <type name="priority_level"/>
      <type name="max_heap_size"/>
      <type name="message_queue_data"/>
      <type name="spawn_opt_option"/>
      <desc>
        <p>Returns the process identifier (pid) of a new process started
          by the application of <c><anno>Fun</anno></c> to the
          empty list <c>[]</c> on <c><anno>Node</anno></c>. If
          <c><anno>Node</anno></c> does not exist, a useless pid is
          returned. Otherwise works like
          <seealso marker="#spawn_opt/4"><c>spawn_opt/4</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="spawn_opt" arity="4" since=""/>
      <fsummary>Create a new process with a function as entry point.</fsummary>
      <type name="priority_level"/>
      <type name="max_heap_size"/>
      <type name="message_queue_data"/>
      <type name="spawn_opt_option"/>
      <desc>
        <p>Works as
          <seealso marker="#spawn/3"><c>spawn/3</c></seealso>, except that an
          extra option list is specified when creating the process.</p>
        <p>If option <c>monitor</c> is specified, the newly created
          process is monitored, and both the pid and reference for
          the monitor are returned.</p>
        <p>Options:</p>
        <taglist>
          <tag><c>link</c></tag>
          <item>
            <p>Sets a link to the parent process (like
              <seealso marker="#spawn_link/3"><c>spawn_link/3</c></seealso>
              does).</p>
          </item>
          <tag><c>monitor</c></tag>
          <item>
            <p>Monitors the new process (like
              <seealso marker="#monitor/2"><c>monitor/2</c></seealso> does).</p>
          </item>
          <tag><c>{priority, <anno>Level</anno>}</c></tag>
          <item>
            <p>Sets the priority of the new process. Equivalent to
              executing <seealso marker="#process_flag_priority">
              <c>process_flag(priority, <anno>Level</anno>)</c></seealso>
              in the start function of the new process,
              except that the priority is set before the process is
              selected for execution for the first time. For more
              information on priorities, see
              <seealso marker="#process_flag_priority">
              <c>process_flag(priority, <anno>Level</anno>)</c></seealso>.</p>
          </item>
          <tag><c>{fullsweep_after, <anno>Number</anno>}</c></tag>
          <item>
            <p>Useful only for performance tuning. Do not use this
              option unless you
              know that there is problem with execution times or
              memory consumption, and ensure
              that the option improves matters.</p>
            <p>The Erlang runtime system uses a generational garbage
              collection scheme, using an "old heap" for data that has
              survived at least one garbage collection. When there is
              no more room on the old heap, a fullsweep garbage
              collection is done.</p>
            <p>Option <c>fullsweep_after</c> makes it possible to
              specify the maximum number of generational collections
              before forcing a fullsweep, even if there is room on
              the old heap. Setting the number to zero
              disables the general collection algorithm, that is,
              all live data is copied at every garbage collection.</p>
            <p>A few cases when it can be useful to change
              <c>fullsweep_after</c>:</p>
            <list type="bulleted">
              <item><p>If binaries that are no longer used are to be
                thrown away as soon as possible. (Set
                <c><anno>Number</anno></c> to zero.)</p>
              </item>
              <item><p>A process that mostly have short-lived data is
                fullsweeped seldom or never, that is, the old heap
                contains mostly garbage. To ensure a fullsweep
                occasionally, set <c><anno>Number</anno></c> to a
                suitable value, such as 10 or 20.</p>
              </item>
              <item>In embedded systems with a limited amount of RAM
              and no virtual memory, you might want to preserve memory
              by setting <c><anno>Number</anno></c> to zero.
              (The value can be set globally, see
              <seealso marker="#system_flag/2">
              <c>erlang:system_flag/2</c></seealso>.)
              </item>
            </list>
          </item>
          <tag><c>{min_heap_size, <anno>Size</anno>}</c></tag>
          <item>
            <p>Useful only for performance tuning. Do not use this
              option unless you know that there is problem with
              execution times or memory consumption, and
              ensure that the option improves matters.</p>
            <p>Gives a minimum heap size, in words. Setting this value
              higher than the system default can speed up some
              processes because less garbage collection is done.
              However, setting a too high value can waste memory and
              slow down the system because of worse data locality.
              Therefore, use this option only for
              fine-tuning an application and to measure the execution
              time with various <c><anno>Size</anno></c> values.</p>
          </item>
          <tag><c>{min_bin_vheap_size, <anno>VSize</anno>}</c></tag>
          <item>
            <p>Useful only for performance tuning. Do not use this
              option unless you know that there is problem with
              execution times or memory consumption, and
              ensure that the option improves matters.</p>
            <p>Gives a minimum binary virtual heap size, in words.
              Setting this value
              higher than the system default can speed up some
              processes because less garbage collection is done.
              However, setting a too high value can waste memory.
              Therefore, use this option only for
              fine-tuning an application and to measure the execution
              time with various <c><anno>VSize</anno></c> values.</p>
          </item>
          <tag><c>{max_heap_size, <anno>Size</anno>}</c></tag>
          <item>
            <p>Sets the <c>max_heap_size</c> process flag. The default
              <c>max_heap_size</c> is determined by command-line argument
              <seealso marker="erl#+hmax"><c>+hmax</c></seealso>
              in <c>erl(1)</c>. For more information, see the
              documentation of <seealso marker="#process_flag_max_heap_size">
              <c>process_flag(max_heap_size, <anno>Size</anno>)</c></seealso>.
            </p>
          </item>
          <tag><c>{message_queue_data, <anno>MQD</anno>}</c></tag>
          <item>
            <p>Sets the state of the <c>message_queue_data</c> process
              flag. <c><anno>MQD</anno></c> is to be either <c>off_heap</c>
              or <c>on_heap</c>. The default
              <c>message_queue_data</c> process flag is determined by
              command-line argument <seealso marker="erl#+hmqd">
              <c>+hmqd</c></seealso> in <c>erl(1)</c>.
              For more information, see the documentation of
              <seealso marker="#process_flag_message_queue_data">
              <c>process_flag(message_queue_data,
              <anno>MQD</anno>)</c></seealso>.</p>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="spawn_opt" arity="5" since=""/>
      <fsummary>Create a new process with a function as entry point on a
        specified node.</fsummary>
      <type name="priority_level"/>
      <type name="max_heap_size"/>
      <type name="message_queue_data"/>
      <type name="spawn_opt_option"/>
      <desc>
        <p>Returns the process identifier (pid) of a new process started
          by the application
          of <c><anno>Module</anno>:<anno>Function</anno></c> to
          <c><anno>Args</anno></c> on <c><anno>Node</anno></c>. If
          <c><anno>Node</anno></c> does not exist, a useless pid is returned.
          Otherwise works like
          <seealso marker="#spawn_opt/4"><c>spawn_opt/4</c></seealso>.</p>
        <note>
          <p>Option <c>monitor</c> is not supported by
            <c>spawn_opt/5</c>.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="split_binary" arity="2" since=""/>
      <fsummary>Split a binary into two.</fsummary>
      <type_desc variable="Pos">0..byte_size(Bin)</type_desc>
      <desc>
        <p>Returns a tuple containing the binaries that are the result
          of splitting <c><anno>Bin</anno></c> into two parts at
          position <c><anno>Pos</anno></c>.
          This is not a destructive operation. After the operation,
          there are three binaries altogether. Example:</p>
        <pre>
> <input>B = list_to_binary("0123456789").</input>
&lt;&lt;"0123456789">>
> <input>byte_size(B).</input>
10
> <input>{B1, B2} = split_binary(B,3).</input>
{&lt;&lt;"012">>,&lt;&lt;"3456789">>}
> <input>byte_size(B1).</input>
3
> <input>byte_size(B2).</input>
7</pre>
      </desc>
    </func>

    <func>
      <name name="start_timer" arity="3" since=""/>
      <fsummary>Start a timer.</fsummary>
      <desc>
        <p>Starts a timer. The same as calling
          <seealso marker="#start_timer/4">
          <c>erlang:start_timer(<anno>Time</anno>,
          <anno>Dest</anno>, <anno>Msg</anno>, [])</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="start_timer" arity="4" since="OTP 18.0"/>
      <fsummary>Start a timer.</fsummary>
      <desc>
        <p>Starts a timer. When the timer expires, the message
          <c>{timeout, <anno>TimerRef</anno>, <anno>Msg</anno>}</c>
          is sent to the process identified by <c><anno>Dest</anno></c>.</p>
        <p><c><anno>Option</anno></c>s:</p>
        <taglist>
          <tag><c>{abs, false}</c></tag>
          <item>
            <p>This is the default. It means the
              <c><anno>Time</anno></c> value is interpreted
              as a time in milliseconds <em>relative</em> current
              <seealso marker="time_correction#Erlang_Monotonic_Time">Erlang
              monotonic time</seealso>.</p>
          </item>
          <tag><c>{abs, true}</c></tag>
          <item>
            <p>Absolute <c><anno>Time</anno></c> value. The
              <c><anno>Time</anno></c> value is interpreted as an
              absolute Erlang monotonic time in milliseconds.</p>
          </item>
        </taglist>
        <p>More <c><anno>Option</anno></c>s can be added in the future.</p>
        <p>The absolute point in time, the timer is set to expire on,
          must be in the interval
          <c>[</c><seealso marker="#system_info_start_time">
          <c>erlang:system_info(start_time)</c></seealso><c>,
          </c><seealso marker="#system_info_end_time">
          <c>erlang:system_info(end_time)</c></seealso><c>]</c>.
          If a relative time is specified, the <c><anno>Time</anno></c>
          value is not allowed to be negative.</p>
        <p>If <c><anno>Dest</anno></c> is a <c>pid()</c>, it must
          be a <c>pid()</c> of a process created on the current
          runtime system instance. This process has either terminated
          or not. If <c><anno>Dest</anno></c> is an
          <c>atom()</c>, it is interpreted as the name of a
          locally registered process. The process referred to by the
          name is looked up at the time of timer expiration. No error
          is returned if the name does not refer to a process.</p>
        <p>If <c><anno>Dest</anno></c> is a <c>pid()</c>, the timer is
          automatically canceled if the process referred to by the
          <c>pid()</c> is not alive, or if the process exits. This
          feature was introduced in ERTS 5.4.11. Notice that
          timers are not automatically canceled when
          <c><anno>Dest</anno></c> is an <c>atom()</c>.</p>
        <p>See also
          <seealso marker="#send_after/4"><c>erlang:send_after/4</c></seealso>,
          <seealso marker="#cancel_timer/2">
          <c>erlang:cancel_timer/2</c></seealso>, and
          <seealso marker="#read_timer/2">
          <c>erlang:read_timer/2</c></seealso>.</p>
        <p>Failure: <c>badarg</c> if the arguments do not satisfy
          the requirements specified here.</p>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="1"
	    anchor="statistics_active_tasks" since="OTP 18.3"/>
      <fsummary>Information about active processes and ports.</fsummary>
      <desc>
        <p>Returns the same as
	<seealso marker="#statistics_active_tasks_all">
        <c>statistics(active_tasks_all)</c></seealso>
	with the exception that no information about the dirty
	IO run queue and its associated schedulers is part of
	the result. That is, only tasks that are expected to be
	CPU bound are part of the result.</p>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="2"
	    anchor="statistics_active_tasks_all" since="OTP 20.0"/>
      <fsummary>Information about active processes and ports.</fsummary>
      <desc>
        <p>Returns a list where each element represents the amount
          of active processes and ports on each run queue and its
          associated schedulers. That is, the number of processes and
          ports that are ready to run, or are currently running.
	  Values for normal run queues and their associated schedulers
	  are located first in the resulting list. The first element
	  corresponds to scheduler number 1 and so on. If support for
	  dirty schedulers exist, an element with the value for the
	  dirty CPU run queue and its associated dirty CPU schedulers
	  follow and then as last element the value for the the dirty
	  IO run queue and its associated dirty IO schedulers follow.
	  The information is <em>not</em> gathered atomically. That is,
	  the result is not necessarily a consistent snapshot of the
	  state, but instead quite efficiently gathered.</p>
	<note><p>Each normal scheduler has one run queue that it
	manages. If dirty schedulers schedulers are supported, all
	dirty CPU schedulers share one run queue, and all dirty IO
	schedulers share one run queue. That is, we have multiple
	normal run queues, one dirty CPU run queue and one dirty
	IO run queue. Work can <em>not</em> migrate between the
	different types of run queues. Only work in normal run
	queues can migrate to other normal run queues. This has
	to be taken into account when evaluating the result.</p></note>
        <p>See also
          <seealso marker="#statistics_total_active_tasks">
          <c>statistics(total_active_tasks)</c></seealso>,
          <seealso marker="#statistics_run_queue_lengths">
          <c>statistics(run_queue_lengths)</c></seealso>,
          <seealso marker="#statistics_run_queue_lengths_all">
          <c>statistics(run_queue_lengths_all)</c></seealso>,
          <seealso marker="#statistics_total_run_queue_lengths">
          <c>statistics(total_run_queue_lengths)</c></seealso>, and
          <seealso marker="#statistics_total_run_queue_lengths_all">
          <c>statistics(total_run_queue_lengths_all)</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="3" since=""/>
      <fsummary>Information about context switches.</fsummary>
      <desc>
        <p>Returns the total number of context switches since the
          system started.</p>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="4"
	    anchor="statistics_exact_reductions" since=""/>
      <fsummary>Information about exact reductions.</fsummary>
      <desc>
        <p>Returns the number of exact reductions.</p>
        <note>
          <p><c>statistics(exact_reductions)</c> is
            a more expensive operation than
            <seealso marker="#statistics_reductions">
            statistics(reductions)</seealso>.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="5" since=""/>
      <fsummary>Information about garbage collection.</fsummary>
      <desc>
        <p>Returns information about garbage collection, for example:</p>
        <pre>
> <input>statistics(garbage_collection).</input>
{85,23961,0}</pre>
        <p>This information can be invalid for some implementations.</p>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="6" since=""/>
      <fsummary>Information about I/O.</fsummary>
      <desc>
        <p>Returns <c><anno>Input</anno></c>,
          which is the total number of bytes
          received through ports, and <c><anno>Output</anno></c>,
          which is the total number of bytes output to ports.</p>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="7"
	    anchor="statistics_microstate_accounting" since="OTP 19.0"/>
      <fsummary>Information about microstate accounting.</fsummary>
      <desc>
        <p>Microstate accounting can be used to measure how much time the Erlang
          runtime system spends doing various tasks. It is designed to be as
          lightweight as possible, but some overhead exists when this
          is enabled. Microstate accounting is meant to be a profiling tool
          to help finding performance bottlenecks.
          To <c>start</c>/<c>stop</c>/<c>reset</c> microstate accounting, use
          system flag <seealso marker="#system_flag_microstate_accounting">
          <c>microstate_accounting</c></seealso>.</p>
        <p><c>statistics(microstate_accounting)</c> returns a list of maps
          representing some of the OS threads within ERTS. Each map
          contains <c>type</c> and <c>id</c> fields that can be used to
          identify what
          thread it is, and also a counters field that contains data about how
          much time has been spent in the various states.</p>
        <p>Example:</p>
        <pre>
> <input>erlang:statistics(microstate_accounting).</input>
[#{counters => #{aux => 1899182914,
                 check_io => 2605863602,
                 emulator => 45731880463,
                 gc => 1512206910,
                 other => 5421338456,
                 port => 221631,
                 sleep => 5150294100},
   id => 1,
   type => scheduler}|...]</pre>
        <p>The time unit is the same as returned by
          <seealso marker="kernel:os#perf_counter/0">
          <c>os:perf_counter/0</c></seealso>.
          So, to convert it to milliseconds, you can do something like this:</p>
        <pre>
lists:map(
  fun(#{ counters := Cnt } = M) ->
          MsCnt = maps:map(fun(_K, PerfCount) ->
                                   erlang:convert_time_unit(PerfCount, perf_counter, 1000)
                           end, Cnt),
         M#{ counters := MsCnt }
  end, erlang:statistics(microstate_accounting)).</pre>
        <p>Notice that these values are not guaranteed to be
          the exact time spent in each state. This is because of various
          optimisation done to keep the overhead as small as possible.</p>
        <p><c><anno>MSAcc_Thread_Type</anno></c>s:</p>
        <taglist>
          <tag><c>scheduler</c></tag>
          <item>The main execution threads that do most of the work. See
            <seealso marker="erts:erl#+S">erl +S</seealso> for more details.</item>
          <tag><c>dirty_cpu_scheduler</c></tag>
          <item>The threads for long running cpu intensive work. See
            <seealso marker="erts:erl#+SDcpu">erl +SDcpu</seealso> for more details.</item>
          <tag><c>dirty_io_scheduler</c></tag>
          <item>The threads for long running I/O work. See
            <seealso marker="erts:erl#+SDio">erl +SDio</seealso> for more details.</item>
          <tag><c>async</c></tag>
          <item>Async threads are used by various linked-in drivers (mainly the
            file drivers) do offload non-CPU intensive work. See
            <seealso marker="erts:erl#async_thread_pool_size">erl +A</seealso> for more details.</item>
          <tag><c>aux</c></tag>
          <item>Takes care of any work that is not
            specifically assigned to a scheduler.</item>
          <tag><c>poll</c></tag>
          <item>Does the IO polling for the emulator. See
            <seealso marker="erts:erl#+IOt">erl +IOt</seealso> for more details.</item>
        </taglist>
        <p>The following <c><anno>MSAcc_Thread_State</anno></c>s are available.
          All states are exclusive, meaning that a thread cannot be in two
          states at once. So, if you add the numbers of all counters in a
          thread, you get the total runtime for that thread.</p>
        <taglist>
          <tag><c>aux</c></tag>
          <item>Time spent handling auxiliary jobs.</item>
          <tag><c>check_io</c></tag>
          <item>Time spent checking for new I/O events.</item>
          <tag><c>emulator</c></tag>
          <item>Time spent executing Erlang processes.</item>
          <tag><c>gc</c></tag>
          <item>Time spent doing garbage collection. When extra states are
            enabled this is the time spent doing non-fullsweep garbage
            collections.</item>
          <tag><c>other</c></tag>
          <item>Time spent doing unaccounted things.</item>
          <tag><c>port</c></tag>
          <item>Time spent executing ports.</item>
          <tag><c>sleep</c></tag>
          <item>Time spent sleeping.</item>
        </taglist>
        <p>More fine-grained <c><anno>MSAcc_Thread_State</anno></c>s can
          be added through configure (such as
          <c>./configure --with-microstate-accounting=extra</c>).
          Enabling these states causes performance degradation when
          microstate accounting is turned off and increases the overhead when
          it is turned on.</p>
        <taglist>
          <tag><c>alloc</c></tag>
          <item>Time spent managing memory. Without extra states this time is
            spread out over all other states.</item>
          <tag><c>bif</c></tag>
          <item>Time spent in BIFs. Without extra states this time is part of
            the <c>emulator</c> state.</item>
          <tag><c>busy_wait</c></tag>
          <item>Time spent busy waiting. This is also the state where a
            scheduler no longer reports that it is active when using
            <seealso marker="#statistics_scheduler_wall_time">
            <c>statistics(scheduler_wall_time)</c></seealso>. So, if you add
            all other states but this and sleep, and then divide that by all
            time in the thread, you should get something very similar to the
            <c>scheduler_wall_time</c> fraction. Without extra states this
            time is part of the <c>other</c> state.</item>
          <tag><c>ets</c></tag>
          <item>Time spent executing ETS BIFs. Without extra states
            this time is part of the <c>emulator</c> state.</item>
          <tag><c>gc_full</c></tag>
          <item>Time spent doing fullsweep garbage collection. Without extra
            states this time is part of the <c>gc</c> state.</item>
          <tag><c>nif</c></tag>
          <item>Time spent in NIFs. Without extra states this time is part of
            the <c>emulator</c> state.</item>
          <tag><c>send</c></tag>
          <item>Time spent sending messages (processes only). Without extra
            states this time is part of the <c>emulator</c> state.</item>
          <tag><c>timers</c></tag>
          <item>Time spent managing timers. Without extra states this time is
            part of the <c>other</c> state.</item>
        </taglist>
        <p>The utility module
          <seealso marker="runtime_tools:msacc"><c>msacc(3)</c></seealso>
          can be used to more easily analyse these statistics.</p>
        <p>Returns <c>undefined</c> if system flag
          <seealso marker="#system_flag_microstate_accounting">
          <c>microstate_accounting</c></seealso> is turned off.</p>
        <p>The list of thread information is unsorted and can appear in
          different order between calls.</p>
        <note>
          <p>The threads and states are subject to change without any
            prior notice.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="8"
	    anchor="statistics_reductions" since=""/>
      <fsummary>Information about reductions.</fsummary>
      <desc>
        <p>Returns information about reductions, for example:</p>
        <pre>
> <input>statistics(reductions).</input>
{2046,11}</pre>
        <note><p>As from ERTS 5.5 (Erlang/OTP R11B),
          this value does not include reductions performed in current
          time slices of currently scheduled processes. If an
          exact value is wanted, use
          <seealso marker="#statistics_exact_reductions">
          <c>statistics(exact_reductions)</c></seealso>.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="9"
	    anchor="statistics_run_queue" since=""/>
      <fsummary>Information about the run-queues.</fsummary>
      <desc>
        <p>Returns the total length of all normal run-queues. That is, the number
          of processes and ports that are ready to run on all available
          normal run-queues. Dirty run queues are not part of the
	  result. The information is gathered atomically. That
          is, the result is a consistent snapshot of the state, but
          this operation is much more expensive compared to
          <seealso marker="#statistics_total_run_queue_lengths">
          <c>statistics(total_run_queue_lengths)</c></seealso>,
          especially when a large amount of schedulers is used.</p>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="10"
	    anchor="statistics_run_queue_lengths" since="OTP 18.3"/>
      <fsummary>Information about the run-queue lengths.</fsummary>
      <desc>
        <p>Returns the same as
	<seealso marker="#statistics_run_queue_lengths_all">
        <c>statistics(run_queue_lengths_all)</c></seealso>
	with the exception that no information about the dirty
	IO run queue is part of the result. That is, only
	run queues with work that is expected to be CPU bound
	is part of the result.</p>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="11"
	    anchor="statistics_run_queue_lengths_all" since="OTP 20.0"/>
      <fsummary>Information about the run-queue lengths.</fsummary>
      <desc>
        <p>Returns a list where each element represents the amount
          of processes and ports ready to run for each run queue.
	  Values for normal run queues are located first in the
	  resulting list. The first element corresponds to the
	  normal run queue of scheduler number 1 and so on. If
	  support for dirty schedulers exist, values for the dirty
	  CPU run queue and the dirty IO run queue follow (in that
	  order) at the end. The information is <em>not</em>
	  gathered atomically. That is, the result is not
	  necessarily a consistent snapshot of the state, but
	  instead quite efficiently gathered.</p>
	<note><p>Each normal scheduler has one run queue that it
	manages. If dirty schedulers schedulers are supported, all
	dirty CPU schedulers share one run queue, and all dirty IO
	schedulers share one run queue. That is, we have multiple
	normal run queues, one dirty CPU run queue and one dirty
	IO run queue. Work can <em>not</em> migrate between the
	different types of run queues. Only work in normal run
	queues can migrate to other normal run queues. This has
	to be taken into account when evaluating the result.</p></note>
        <p>See also
          <seealso marker="#statistics_run_queue_lengths">
          <c>statistics(run_queue_lengths)</c></seealso>,
          <seealso marker="#statistics_total_run_queue_lengths_all">
          <c>statistics(total_run_queue_lengths_all)</c></seealso>,
          <seealso marker="#statistics_total_run_queue_lengths">
          <c>statistics(total_run_queue_lengths)</c></seealso>,
          <seealso marker="#statistics_active_tasks">
          <c>statistics(active_tasks)</c></seealso>,
          <seealso marker="#statistics_active_tasks_all">
          <c>statistics(active_tasks_all)</c></seealso>, and
          <seealso marker="#statistics_total_active_tasks">
          <c>statistics(total_active_tasks)</c></seealso>,
          <seealso marker="#statistics_total_active_tasks_all">
          <c>statistics(total_active_tasks_all)</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="12" since=""/>
      <fsummary>Information about runtime.</fsummary>
      <desc>
        <p>Returns information about runtime, in milliseconds.</p>
        <p>This is the sum of the runtime for all threads
          in the Erlang runtime system and can therefore be greater
          than the wall clock time.</p>
          <warning><p>This value might wrap due to limitations in the
          underlying functionality provided by the operating system
          that is used.</p></warning>
        <p>Example:</p>
        <pre>
> <input>statistics(runtime).</input>
{1690,1620}</pre>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="13"
	    anchor="statistics_scheduler_wall_time" since="OTP R15B01"/>
      <fsummary>Information about each schedulers work time.</fsummary>
      <desc>
        <p>Returns a list of tuples with
          <c>{<anno>SchedulerId</anno>, <anno>ActiveTime</anno>,
          <anno>TotalTime</anno>}</c>, where
          <c><anno>SchedulerId</anno></c> is an integer ID of the scheduler,
          <c><anno>ActiveTime</anno></c> is
          the duration the scheduler has been busy, and
          <c><anno>TotalTime</anno></c> is the total time duration since
          <seealso marker="#system_flag_scheduler_wall_time">
          <c>scheduler_wall_time</c></seealso>
          activation for the specific scheduler. Note that
	  activation time can differ significantly between
	  schedulers. Currently dirty schedulers are activated
	  at system start while normal schedulers are activated
	  some time after the <c>scheduler_wall_time</c>
	  functionality is enabled. The time unit is undefined
	  and can be subject to change between releases, OSs,
	  and system restarts. <c>scheduler_wall_time</c> is only
	  to be used to calculate relative values for scheduler
	  utilization. <c><anno>ActiveTime</anno></c> can never
	  exceed <c><anno>TotalTime</anno></c>.</p>
        <p>The definition of a busy scheduler is when it is not idle
          and is not scheduling (selecting) a process or port,
          that is:</p>
        <list type="bulleted">
          <item>Executing process code</item>
          <item>Executing linked-in driver or NIF code</item>
          <item>Executing BIFs, or any other runtime handling</item>
          <item>Garbage collecting</item>
          <item>Handling any other memory management</item>
        </list>
        <p>Notice that a scheduler can also be busy even if the
          OS has scheduled out the scheduler thread.</p>
        <p>Returns <c>undefined</c> if system flag
          <seealso marker="#system_flag_scheduler_wall_time">
          <c>scheduler_wall_time</c></seealso> is turned off.</p>
        <p>The list of scheduler information is unsorted and can
          appear in different order between calls.</p>
	<p>As of ERTS version 9.0, also dirty CPU schedulers will
	be included in the result. That is, all scheduler threads
	that are expected to handle CPU bound work. If you also
	want information about dirty I/O schedulers, use
	<seealso marker="#statistics_scheduler_wall_time_all">
        <c>statistics(scheduler_wall_time_all)</c></seealso>
	instead.</p>
	
	<p>Normal schedulers will have scheduler identifiers in
	the range <c>1 =&lt; <anno>SchedulerId</anno> =&lt;
	</c><seealso marker="#system_info_schedulers">
        <c>erlang:system_info(schedulers)</c></seealso>.
	Dirty CPU schedulers will have scheduler identifiers in
	the range <c>erlang:system_info(schedulers) &lt;
	<anno>SchedulerId</anno> =&lt; erlang:system_info(schedulers)
	+
	</c><seealso marker="#system_info_dirty_cpu_schedulers">
        <c>erlang:system_info(dirty_cpu_schedulers)</c></seealso>.
	</p>
	<note><p>The different types of schedulers handle
	specific types of jobs. Every job is assigned to a specific
	scheduler type. Jobs can migrate between different schedulers
	of the same type, but never between schedulers of different
	types. This fact has to be taken under consideration when
	evaluating the result returned.</p></note>
        <p>Using <c>scheduler_wall_time</c> to calculate
          scheduler utilization:</p>
        <pre>
> <input>erlang:system_flag(scheduler_wall_time, true).</input>
false
> <input>Ts0 = lists:sort(erlang:statistics(scheduler_wall_time)), ok.</input>
ok</pre>
        <p>Some time later the user takes another snapshot and calculates
          scheduler utilization per scheduler, for example:</p>
        <pre>
> <input>Ts1 = lists:sort(erlang:statistics(scheduler_wall_time)), ok.</input>
ok
> <input>lists:map(fun({{I, A0, T0}, {I, A1, T1}}) ->
	{I, (A1 - A0)/(T1 - T0)} end, lists:zip(Ts0,Ts1)).</input>
[{1,0.9743474730177548},
 {2,0.9744843782751444},
 {3,0.9995902361669045},
 {4,0.9738012596572161},
 {5,0.9717956667018103},
 {6,0.9739235846420741},
 {7,0.973237033077876},
 {8,0.9741297293248656}]</pre>
        <p>Using the same snapshots to calculate a total
          scheduler utilization:</p>
        <pre>
> <input>{A, T} = lists:foldl(fun({{_, A0, T0}, {_, A1, T1}}, {Ai,Ti}) ->
	{Ai + (A1 - A0), Ti + (T1 - T0)} end, {0, 0}, lists:zip(Ts0,Ts1)),
	TotalSchedulerUtilization = A/T.</input>
0.9769136803764825</pre>
        <p>Total scheduler utilization will equal <c>1.0</c> when
	all schedulers have been active all the time between the
	two measurements.</p>
	<p>Another (probably more) useful value is to calculate
	total scheduler utilization weighted against maximum amount
	of available CPU time:</p>
        <pre>
> <input>WeightedSchedulerUtilization = (TotalSchedulerUtilization
                                  * (erlang:system_info(schedulers)
                                     + erlang:system_info(dirty_cpu_schedulers)))
                                 / erlang:system_info(logical_processors_available).</input>
0.9769136803764825</pre>
        <p>This weighted scheduler utilization will reach <c>1.0</c>
	when schedulers are active the same amount of time as
	maximum available CPU time. If more schedulers exist
	than available logical processors, this value may
	be greater than <c>1.0</c>.</p>
	<p>As of ERTS version 9.0, the Erlang runtime system
        will as default have more schedulers than logical processors.
        This due to the dirty schedulers.</p>
        <note>
          <p><c>scheduler_wall_time</c> is by default disabled. To
            enable it, use
            <c>erlang:system_flag(scheduler_wall_time, true)</c>.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="14"
	    anchor="statistics_scheduler_wall_time_all" since="OTP 20.0"/>
      <fsummary>Information about each schedulers work time.</fsummary>
      <desc>
	<p>The same as
	<seealso marker="#statistics_scheduler_wall_time"><c>statistics(scheduler_wall_time)</c></seealso>,
	except that it also include information about all dirty I/O
	schedulers.</p>
	<p>Dirty IO schedulers will have scheduler identifiers in
	the range
	<seealso marker="#system_info_schedulers">
          <c>erlang:system_info(schedulers)</c></seealso><c>
	+
	</c><seealso marker="#system_info_dirty_cpu_schedulers">
        <c>erlang:system_info(dirty_cpu_schedulers)</c></seealso><c> &lt;
	<anno>SchedulerId</anno> =&lt; erlang:system_info(schedulers)
	+ erlang:system_info(dirty_cpu_schedulers)
	+
	</c><seealso marker="#system_info_dirty_io_schedulers">
        <c>erlang:system_info(dirty_io_schedulers)</c></seealso>.</p>
	<note><p>Note that work executing on dirty I/O schedulers
	are expected to mainly wait for I/O. That is, when you
	get high scheduler utilization on dirty I/O schedulers,
	CPU utilization is <em>not</em> expected to be high due to
	this work.</p></note>
      </desc>
    </func>
    <func>
      <name name="statistics" arity="1" clause_i="15"
	    anchor="statistics_total_active_tasks" since="OTP 18.3"/>
      <fsummary>Information about active processes and ports.</fsummary>
      <desc>
        <p>The same as calling
	<c>lists:sum(</c><seealso marker="#statistics_active_tasks"><c>statistics(active_tasks)</c></seealso><c>)</c>,
	but more efficient.</p>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="16"
	    anchor="statistics_total_active_tasks_all" since="OTP 20.0"/>
      <fsummary>Information about active processes and ports.</fsummary>
      <desc>
        <p>The same as calling
	<c>lists:sum(</c><seealso marker="#statistics_active_tasks_all"><c>statistics(active_tasks_all)</c></seealso><c>)</c>,
	but more efficient.</p>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="17"
	    anchor="statistics_total_run_queue_lengths" since="OTP 18.3"/>
      <fsummary>Information about the run-queue lengths.</fsummary>
      <desc>
        <p>The same as calling
	<c>lists:sum(</c><seealso marker="#statistics_run_queue_lengths"><c>statistics(run_queue_lengths)</c></seealso><c>)</c>,
	but more efficient.</p>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="18"
	    anchor="statistics_total_run_queue_lengths_all" since="OTP 20.0"/>
      <fsummary>Information about the run-queue lengths.</fsummary>
      <desc>
        <p>The same as calling
	<c>lists:sum(</c><seealso marker="#statistics_run_queue_lengths_all"><c>statistics(run_queue_lengths_all)</c></seealso><c>)</c>,
	but more efficient.</p>
      </desc>
    </func>

    <func>
      <name name="statistics" arity="1" clause_i="19" since=""/>
      <fsummary>Information about wall clock.</fsummary>
      <desc>
        <p>Returns information about wall clock. <c>wall_clock</c> can
          be used in the same manner as
          <c>runtime</c>, except that real time is measured as
          opposed to runtime or CPU time.</p>
      </desc>
    </func>

    <func>
      <name name="suspend_process" arity="1" since=""/>
      <fsummary>Suspend a process.</fsummary>
      <desc>
        <p>Suspends the process identified by
          <c><anno>Suspendee</anno></c>. The same as calling
          <seealso marker="#suspend_process/2">
          <c>erlang:suspend_process(<anno>Suspendee</anno>,
          [])</c></seealso>.</p>
        <warning>
          <p>This BIF is intended for debugging only.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name name="suspend_process" arity="2" since=""/>
      <fsummary>Suspend a process.</fsummary>
      <desc>
        <p>Increases the suspend count on the process identified by
          <c><anno>Suspendee</anno></c> and puts it in the suspended
          state if it is not
          already in that state. A suspended process is not
          scheduled for execution until the process has been resumed.</p>
        <p>A process can be suspended by multiple processes and can
          be suspended multiple times by a single process. A suspended
          process does not leave the suspended state until its suspend 
          count reaches zero. The suspend count of
          <c><anno>Suspendee</anno></c> is decreased when
          <seealso marker="#resume_process/1">
          <c>erlang:resume_process(<anno>Suspendee</anno>)</c></seealso>
          is called by the same process that called
          <c>erlang:suspend_process(<anno>Suspendee</anno>)</c>.
          All increased suspend
          counts on other processes acquired by a process are automatically
          decreased when the process terminates.</p>
        <p>Options (<c><anno>Opt</anno></c>s):</p>
        <taglist>
          <tag><c>asynchronous</c></tag>
          <item>
            <p>A suspend request is sent to the process identified by
              <c><anno>Suspendee</anno></c>. <c><anno>Suspendee</anno></c>
              eventually suspends
              unless it is resumed before it could suspend. The caller
              of <c>erlang:suspend_process/2</c> returns immediately,
              regardless of whether <c><anno>Suspendee</anno></c> has
              suspended yet or not. The point in time when
              <c><anno>Suspendee</anno></c> suspends cannot be deduced
              from other events in the system. It is only guaranteed that
              <c><anno>Suspendee</anno></c> <em>eventually</em> suspends
              (unless it
              is resumed). If no <c>asynchronous</c> options has
              been passed, the caller of <c>erlang:suspend_process/2</c> is
              blocked until <c><anno>Suspendee</anno></c> has suspended.</p>
          </item>
          <tag><c>{asynchronous, ReplyTag}</c></tag>
          <item>
            <p>A suspend request is sent to the process identified by
              <c><anno>Suspendee</anno></c>. When the suspend request
	      has been processed, a reply message is sent to the caller
	      of this function. The reply is on the form <c>{ReplyTag,
	      State}</c> where <c>State</c> is either:</p>
	      <taglist>
		<tag><c>exited</c></tag>
		<item>
		  <p>
		    <c><anno>Suspendee</anno></c> has exited.
		  </p>
		</item>
		<tag><c>suspended</c></tag>
		<item>
		  <p>
		    <c><anno>Suspendee</anno></c> is now suspended.
		  </p>
		</item>
		<tag><c>not_suspended</c></tag>
		<item>
		  <p>
		    <c><anno>Suspendee</anno></c> is not suspended.
		    This can only happen when the process that
		    issued this request, have called
		    <c>resume_process(<anno>Suspendee</anno>)</c>
		    before getting the reply.
		  </p>
		</item>
	      </taglist>
	      <p>
		Appart from the reply message, the <c>{asynchronous,
		ReplyTag}</c> option behaves exactly the same as the
		<c>asynchronous</c> option without reply tag.
	      </p>
          </item>
          <tag><c>unless_suspending</c></tag>
          <item>
            <p>The process identified by <c><anno>Suspendee</anno></c> is
              suspended unless the calling process already is suspending
              <c><anno>Suspendee</anno></c>.
              If <c>unless_suspending</c> is combined
              with option <c>asynchronous</c>, a suspend request is
              sent unless the calling process already is suspending
              <c><anno>Suspendee</anno></c> or if a suspend request
              already has been sent and is in transit. If the calling
              process already is suspending <c><anno>Suspendee</anno></c>,
              or if combined with option <c>asynchronous</c>
              and a send request already is in transit,
              <c>false</c> is returned and the suspend count on
              <c><anno>Suspendee</anno></c> remains unchanged.</p>
          </item>
        </taglist>
        <p>If the suspend count on the process identified by
          <c><anno>Suspendee</anno></c> is increased, <c>true</c>
          is returned, otherwise <c>false</c>.</p>
        <warning>
          <p>This BIF is intended for debugging only.</p>
        </warning>
	<warning>
	  <p>You can easily create deadlocks if processes suspends
	  each other (directly or in circles). In ERTS versions prior
	  to ERTS version 10.0, the runtime system prevented such
	  deadlocks, but this prevention has now been removed due
	  to performance reasons.</p>
	</warning>
        <p>Failures:</p>
        <taglist>
          <tag><c>badarg</c></tag>
          <item>
            If <c><anno>Suspendee</anno></c> is not a process identifier.
          </item>
          <tag><c>badarg</c></tag>
          <item>
            If the process identified by <c><anno>Suspendee</anno></c>
            is the same process
            as the process calling <c>erlang:suspend_process/2</c>.
          </item>
          <tag><c>badarg</c></tag>
          <item>
            If the process identified by <c><anno>Suspendee</anno></c>
            is not alive.
          </item>
          <tag><c>badarg</c></tag>
          <item>
            If the process identified by <c><anno>Suspendee</anno></c>
            resides on another node.
          </item>
          <tag><c>badarg</c></tag>
          <item>
            If <c><anno>OptList</anno></c> is not a proper list of valid
            <c><anno>Opt</anno></c>s.
          </item>
          <tag><c>system_limit</c></tag>
          <item>
            If the process identified by <c><anno>Suspendee</anno></c>
            has been suspended
            more times by the calling process than can be represented by the
            currently used internal data structures. The system limit is
            &gt; 2,000,000,000 suspends and will never be lower.
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="system_flag" arity="2" clause_i="1" since=""/>
      <fsummary>Set system flag <c>backtrace_depth</c>.</fsummary>
      <desc>
        <p>Sets the maximum depth of call stack back-traces in the
          exit reason element of <c>'EXIT'</c> tuples. The flag
          also limits the stacktrace depth returned by <c>process_info</c>
          item <c>current_stacktrace.</c></p>
        <p>Returns the old value of the flag.</p>
      </desc>
    </func>

    <func>
      <name name="system_flag" arity="2" clause_i="2"
	    anchor="system_flag_cpu_topology" since=""/>
      <fsummary>Set system flag <c>cpu_topology</c>.</fsummary>
      <type name="cpu_topology"/>
      <type name="level_entry"/>
      <type name="level_tag"/>
      <type name="sub_level"/>
      <type name="info_list"/>
      <desc>
        <warning>
          <p>
            <em>This argument is deprecated.</em>
            Instead of using this argument, use command-line argument
            <seealso marker="erts:erl#+sct"><c>+sct</c></seealso> in
            <c>erl(1)</c>.</p>
          <p>When this argument is removed, a final CPU topology
            to use is determined at emulator boot time.</p>
        </warning>
        <p>Sets the user-defined <c><anno>CpuTopology</anno></c>.
          The user-defined
          CPU topology overrides any automatically detected
          CPU topology. By passing <c>undefined</c> as
          <c><anno>CpuTopology</anno></c>,
          the system reverts to the CPU topology automatically
          detected. The returned value equals the value returned
          from <c>erlang:system_info(cpu_topology)</c> before the
          change was made.</p>
        <p>Returns the old value of the flag.</p>
        <p>The CPU topology is used when binding schedulers to logical
          processors. If schedulers are already bound when the CPU
          topology is changed, the schedulers are sent a request
          to rebind according to the new CPU topology.</p>
        <p>The user-defined CPU topology can also be set by passing
          command-line argument
          <seealso marker="erts:erl#+sct"><c>+sct</c></seealso> to
          <c>erl(1)</c>.</p>
        <p>For information on type <c><anno>CpuTopology</anno></c>
          and more, see
          <seealso marker="#system_info_cpu_topology">
          <c>erlang:system_info(cpu_topology)</c></seealso>
          as well as command-line flags
          <seealso marker="erts:erl#+sct"><c>+sct</c></seealso> and
          <seealso marker="erts:erl#+sbt"><c>+sbt</c></seealso> in
          <c>erl(1)</c>.</p>
      </desc>
    </func>

    <func>
      <name name="system_flag" arity="2" clause_i="3"
	    anchor="system_flag_dirty_cpu_schedulers_online" since="OTP 17.0"/>
      <fsummary>Set system_flag_dirty_cpu_schedulers_online.</fsummary>
      <desc>
        <p>
          Sets the number of dirty CPU schedulers online. Range is
          <c><![CDATA[1 <= DirtyCPUSchedulersOnline <= N]]></c>, where <c>N</c>
          is the smallest of the return values of
          <c>erlang:system_info(dirty_cpu_schedulers)</c> and
          <c>erlang:system_info(schedulers_online)</c>.</p>
        <p>Returns the old value of the flag.</p>
        <p>The number of dirty CPU schedulers online can change if the
          number of schedulers online changes. For example, if 12
          schedulers and 6 dirty CPU schedulers are online, and
          <c>system_flag/2</c> is used to set the number of
          schedulers online to 6, then the number of dirty CPU
          schedulers online is automatically decreased by half as well,
          down to 3. Similarly, the number of dirty CPU schedulers
          online increases proportionally to increases in the number of
          schedulers online.</p>
        <p>For more information, see
          <seealso marker="#system_info_dirty_cpu_schedulers">
          <c>erlang:system_info(dirty_cpu_schedulers)</c></seealso> and
          <seealso marker="#system_info_dirty_cpu_schedulers_online">
          <c>erlang:system_info(dirty_cpu_schedulers_online)</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="system_flag" arity="2" clause_i="4" since="OTP 20.2.3"/>
      <fsummary>Set system flag for erts_alloc.</fsummary>
      <desc>
        <p>Sets system flags for
	<seealso marker="erts:erts_alloc"><c>erts_alloc(3)</c></seealso>.
        <c><anno>Alloc</anno></c> is the allocator to affect, for example
	<c>binary_alloc</c>. <c><anno>F</anno></c> is the flag to change and
	<c><anno>V</anno></c> is the new value.</p>
	<p>Only a subset of all <c>erts_alloc</c> flags can be changed
	at run time. This subset is currently only the flag
	<seealso marker="erts:erts_alloc#M_sbct"><c>sbct</c></seealso>.</p>
        <p>Returns <c>ok</c> if the flag was set or <c>notsup</c> if not
	supported by <c>erts_alloc</c>.</p>
      </desc>
    </func>

    <func>
      <name name="system_flag" arity="2" clause_i="5" since=""/>
      <fsummary>Set system flag fullsweep_after.</fsummary>
      <desc>
        <p>Sets system flag <c>fullsweep_after</c>.
          <c><anno>Number</anno></c> is a non-negative integer indicating
          how many times generational garbage collections can be
          done without forcing a fullsweep collection. The value
          applies to new processes, while processes already running are
          not affected.</p>
        <p>Returns the old value of the flag.</p>
        <p>In low-memory systems (especially without virtual
          memory), setting the value to <c>0</c> can help to conserve
          memory.</p>
        <p>This value can also be set through (OS)
          environment variable <c>ERL_FULLSWEEP_AFTER</c>.</p>
      </desc>
    </func>

    <func>
      <name name="system_flag" arity="2" clause_i="6"
	    anchor="system_flag_microstate_accounting" since="OTP 19.0"/>
      <fsummary>Set system flag microstate_accounting.</fsummary>
      <desc>
        <p>
          Turns on/off microstate accounting measurements. When passing reset,
          all counters are reset to 0.</p>
        <p>For more information see
          <seealso marker="#statistics_microstate_accounting">
          <c>statistics(microstate_accounting)</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="system_flag" arity="2" clause_i="7" since=""/>
      <fsummary>Set system flag min_heap_size.</fsummary>
      <desc>
        <p>Sets the default minimum heap size for processes. The size
          is specified in words. The new <c>min_heap_size</c> effects
          only processes spawned after the change of
          <c>min_heap_size</c> has been made. <c>min_heap_size</c>
          can be set for individual processes by using
          <seealso marker="#spawn_opt/4"><c>spawn_opt/4</c></seealso> or
          <seealso marker="#process_flag/2"><c>process_flag/2</c></seealso>.</p>
        <p>Returns the old value of the flag.</p>
      </desc>
    </func>

    <func>
      <name name="system_flag" arity="2" clause_i="8" since="OTP R13B04"/>
      <fsummary>Set system flag min_bin_vheap_size.</fsummary>
      <desc>
        <p>Sets the default minimum binary virtual heap size for
          processes. The size is specified in words.
          The new <c>min_bin_vhheap_size</c> effects only
          processes spawned after the change of
          <c>min_bin_vheap_size</c> has been made.
          <c>min_bin_vheap_size</c> can be set for individual
          processes by using
          <seealso marker="#spawn_opt/4"><c>spawn_opt/2,3,4</c></seealso> or
          <seealso marker="#process_flag/2"><c>process_flag/2</c></seealso>.</p>
        <p>Returns the old value of the flag.</p>
      </desc>
    </func>

    <func>
      <name name="system_flag" arity="2" clause_i="9"
	    anchor="system_flag_max_heap_size" since="OTP 19.0"/>
      <fsummary>Set system flag max_heap_size.</fsummary>
      <type name="max_heap_size"/>
      <desc>
        <p>
          Sets the default maximum heap size settings for processes.
          The size is specified in words. The new <c>max_heap_size</c>
          effects only processes spawned efter the change has been made.
          <c>max_heap_size</c> can be set for individual processes using
          <seealso marker="#spawn_opt/4"><c>spawn_opt/2,3,4</c></seealso> or
          <seealso marker="#process_flag_max_heap_size">
          <c>process_flag/2</c></seealso>.</p>
        <p>Returns the old value of the flag.</p>
      </desc>
    </func>

    <func>
      <name name="system_flag" arity="2" clause_i="10"
	    anchor="system_flag_multi_scheduling" since=""/>
      <fsummary>Set system flag multi_scheduling.</fsummary>
      <desc>
        <p>
          If multi-scheduling is enabled, more than one scheduler
          thread is used by the emulator. Multi-scheduling can be
          blocked in two different ways. Either all schedulers but
          one is blocked, or all <em>normal</em> schedulers but
          one is blocked. When only normal schedulers are blocked,
          dirty schedulers are free to continue to schedule
          processes.</p>
        <p>If <c><anno>BlockState</anno> =:= block</c>, multi-scheduling is
          blocked. That is, one and only one scheduler thread will
          execute. If <c><anno>BlockState</anno> =:= unblock</c> and no one
          else blocks multi-scheduling, and this process has
          blocked only once, multi-scheduling is unblocked.</p>
        <p>If <c><anno>BlockState</anno> =:= block_normal</c>, normal
          multi-scheduling is blocked. That is, only one normal scheduler
          thread will execute, but multiple dirty schedulers can execute.
          If <c><anno>BlockState</anno> =:= unblock_normal</c> and no one
          else blocks normal multi-scheduling, and this process has
          blocked only once, normal multi-scheduling is unblocked.</p>
        <p>One process can block multi-scheduling and normal
          multi-scheduling multiple times. If a process has blocked
          multiple times, it must unblock exactly as many times as it
          has blocked before it has released its multi-scheduling
          block. If a process that has blocked multi-scheduling or normal
          multi-scheduling exits, it automatically releases its blocking
          of multi-scheduling and normal multi-scheduling.</p>
        <p>The return values are <c>disabled</c>, <c>blocked</c>,
          <c>blocked_normal</c>, or <c>enabled</c>. The returned value
          describes the state just after the call to
          <c>erlang:system_flag(multi_scheduling, <anno>BlockState</anno>)</c>
          has been made. For information about the return values, see
          <seealso marker="#system_info_multi_scheduling">
          <c>erlang:system_info(multi_scheduling)</c></seealso>.</p>
        <note><p>Blocking of multi-scheduling and normal multi-scheduling
          is normally not needed. If you feel that you need to use these
          features, consider it a few more times again. Blocking
          multi-scheduling is only to be used as a last resort, as it is
          most likely a <em>very inefficient</em> way to solve the problem.</p>
        </note>
        <p>See also
          <seealso marker="#system_info_multi_scheduling">
          <c>erlang:system_info(multi_scheduling)</c></seealso>,
          <seealso marker="#system_info_normal_multi_scheduling_blockers">
          <c>erlang:system_info(normal_multi_scheduling_blockers)</c></seealso>,
          <seealso marker="#system_info_multi_scheduling_blockers">
          <c>erlang:system_info(multi_scheduling_blockers)</c></seealso>, and
          <seealso marker="#system_info_schedulers">
          <c>erlang:system_info(schedulers)</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="system_flag" arity="2" clause_i="11"
	    anchor="system_flag_scheduler_bind_type" since=""/>
      <fsummary>Set system flag scheduler_bind_type.</fsummary>
      <type name="scheduler_bind_type"/>
      <desc>
        <warning>
          <p>
            <em>This argument is deprecated.</em>
            Instead of using this argument, use command-line argument
            <seealso marker="erts:erl#+sbt"><c>+sbt</c></seealso> in
            <c>erl(1)</c>. When this argument is removed, a final scheduler bind
            type to use is determined at emulator boot time.</p>
        </warning>
        <p>Controls if and how schedulers are bound to logical
          processors.</p>
        <p>When <c>erlang:system_flag(scheduler_bind_type, <anno>How</anno>)</c>
          is called, an asynchronous signal is sent to all schedulers
          online, causing them to try to bind or unbind as requested.</p>
        <note><p>If a scheduler fails to bind, this is often silently
          ignored, as it is not always possible to verify valid
          logical processor identifiers. If an error is reported,
          an error event is logged. To verify that the
          schedulers have bound as requested, call
          <seealso marker="#system_info_scheduler_bindings">
          <c>erlang:system_info(scheduler_bindings)</c></seealso>.</p>
        </note>
        <p>Schedulers can be bound on newer Linux,
          Solaris, FreeBSD, and Windows systems, but more systems will be
          supported in future releases.</p>
        <p>In order for the runtime system to be able to bind schedulers,
          the CPU topology must be known. If the runtime system fails
          to detect the CPU topology automatically, it can be defined.
          For more information on how to define the CPU topology, see
          command-line flag <seealso marker="erts:erl#+sct">
          <c>+sct</c></seealso> in <c>erl(1)</c>.</p>
        <p>The runtime system does by default <em>not</em> bind schedulers
          to logical processors.</p>
        <note><p>If the Erlang runtime system is the only OS
          process binding threads to logical processors, this
          improves the performance of the runtime system. However,
          if other OS processes (for example, another Erlang
          runtime system) also bind threads to logical processors,
          there can be a performance penalty instead. Sometimes this
          performance penalty can be severe. If so, it is recommended
          to not bind the schedulers.</p>
        </note>
        <p>Schedulers can be bound in different ways. Argument
          <c><anno>How</anno></c> determines how schedulers are
          bound and can be any of the following:</p>
        <taglist>
          <tag><c>unbound</c></tag>
          <item>Same as command-line argument
          <seealso marker="erts:erl#+sbt"><c>+sbt u</c></seealso> in
            <c>erl(1)</c>.
          </item>
          <tag><c>no_spread</c></tag>
          <item>Same as command-line argument
          <seealso marker="erts:erl#+sbt"><c>+sbt ns</c></seealso>
            in <c>erl(1)</c>.
          </item>
          <tag><c>thread_spread</c></tag>
          <item>Same as command-line argument
          <seealso marker="erts:erl#+sbt"><c>+sbt ts</c></seealso>
            in <c>erl(1)</c>.
          </item>
          <tag><c>processor_spread</c></tag>
          <item>Same as command-line argument
          <seealso marker="erts:erl#+sbt"><c>+sbt ps</c></seealso>
          in <c>erl(1)</c>.
          </item>
          <tag><c>spread</c></tag>
          <item>Same as command-line argument
          <seealso marker="erts:erl#+sbt"><c>+sbt s</c></seealso>
            in <c>erl(1)</c>.
          </item>
          <tag><c>no_node_thread_spread</c></tag>
          <item>Same as command-line argument
          <seealso marker="erts:erl#+sbt"><c>+sbt nnts</c></seealso>
            in <c>erl(1)</c>.
          </item>
          <tag><c>no_node_processor_spread</c></tag>
          <item>Same as command-line argument
          <seealso marker="erts:erl#+sbt"><c>+sbt nnps</c></seealso>
            in <c>erl(1)</c>.
          </item>
          <tag><c>thread_no_node_processor_spread</c></tag>
          <item>Same as command-line argument
          <seealso marker="erts:erl#+sbt"><c>+sbt tnnps</c></seealso>
            in <c>erl(1)</c>.
          </item>
          <tag><c>default_bind</c></tag>
          <item>Same as command-line argument
          <seealso marker="erts:erl#+sbt"><c>+sbt db</c></seealso>
            in <c>erl(1)</c>.
          </item>
        </taglist>
        <p>The returned value equals <c><anno>How</anno></c> before flag
           <c>scheduler_bind_type</c> was changed.</p>
        <p>Failures:</p>
        <taglist>
          <tag><c>notsup</c></tag>
          <item>If binding of schedulers is not supported.
          </item>
          <tag><c>badarg</c></tag>
          <item>If <c><anno>How</anno></c> is not one of the documented
            alternatives.
          </item>
          <tag><c>badarg</c></tag>
          <item>If CPU topology information is unavailable.
          </item>
        </taglist>
        <p>The scheduler bind type can also be set by passing command-line
          argument <seealso marker="erts:erl#+sbt">
          <c>+sbt</c></seealso> to <c>erl(1)</c>.</p>
        <p>For more information, see
          <seealso marker="#system_info_scheduler_bind_type">
          <c>erlang:system_info(scheduler_bind_type)</c></seealso>,
          <seealso marker="#system_info_scheduler_bindings">
          <c>erlang:system_info(scheduler_bindings)</c></seealso>,
          as well as command-line flags
          <seealso marker="erts:erl#+sbt"><c>+sbt</c></seealso>
          and <seealso marker="erts:erl#+sct"><c>+sct</c></seealso>
          in <c>erl(1)</c>.</p>
      </desc>
    </func>

    <func>
      <name name="system_flag" arity="2" clause_i="12"
	    anchor="system_flag_scheduler_wall_time" since="OTP R15B01"/>
      <fsummary>Set system flag scheduler_wall_time.</fsummary>
      <desc>
        <p>
          Turns on or off scheduler wall time measurements.</p>
        <p>For more information, see
          <seealso marker="#statistics_scheduler_wall_time">
          <c>statistics(scheduler_wall_time)</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="system_flag" arity="2" clause_i="13"
	    anchor="system_flag_schedulers_online" since=""/>
      <fsummary>Set system flag schedulers_online.</fsummary>
      <desc>
        <p>
          Sets the number of schedulers online. Range is
          <c><![CDATA[1 <= SchedulersOnline <=
          erlang:system_info(schedulers)]]></c>.</p>
        <p>Returns the old value of the flag.</p>
        <p>If the emulator was built with support for
          <seealso marker="#system_flag_dirty_cpu_schedulers_online">
          dirty schedulers</seealso>,
          changing the number of schedulers online can also change the
          number of dirty CPU schedulers online. For example, if 12
          schedulers and 6 dirty CPU schedulers are online, and
          <c>system_flag/2</c> is used to set the number of schedulers
          online to 6, then the number of dirty CPU schedulers online
          is automatically decreased by half as well, down to 3.
          Similarly, the number of dirty CPU schedulers online increases
          proportionally to increases in the number of schedulers online.</p>
        <p>For more information, see
          <seealso marker="#system_info_schedulers">
          <c>erlang:system_info(schedulers)</c></seealso> and
          <seealso marker="#system_info_schedulers_online">
          <c>erlang:system_info(schedulers_online)</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="system_flag" arity="2" clause_i="14" since="OTP 21.3"/>
      <fsummary>Set system logger process.</fsummary>
      <desc>
        <p>Sets the process that will receive the logging
        messages generated by ERTS. If set to <c>undefined</c>,
        all logging messages generated by ERTS will be dropped.
        The messages will be in the format:</p>
        <code>
{log,Level,Format,ArgList,Metadata} where

Level = atom(),
Format = string(),
ArgList = list(term()),
Metadata = #{ pid => pid(),
   group_leader => pid(),
   time := logger:timestamp(),
   error_logger := #{ emulator := true, tag := atom() }
        </code>
        <p>If the <c>system_logger</c> process dies,
        this flag will be reset to <c>logger</c>.</p>
        <p>The default is the process named <c>logger</c>.</p>
        <p>Returns the old value of the flag.</p>
        <note><p>This function is designed to be used by the
        KERNEL <seealso marker="kernel:logger"><c>logger</c></seealso>.
        Be careful if you change it to something else as
        log messages may be lost. If you want to intercept
        emulator log messages, do it by adding a specialized handler
        to the KERNEL logger.</p></note>
      </desc>
    </func>

    <func>
      <name name="system_flag" arity="2" clause_i="15" since=""/>
      <fsummary>Set system flag trace_control_word.</fsummary>
      <desc>
        <p>Sets the value of the node trace control word to
          <c><anno>TCW</anno></c>, which is to be an unsigned integer.
          For more information, see function
          <seealso marker="erts:match_spec#set_tcw"><c>set_tcw</c></seealso>
          in section "Match Specifications in Erlang" in the
          User's Guide.</p>
        <p>Returns the old value of the flag.</p>
      </desc>
    </func>

    <func>
      <name name="system_flag" arity="2" clause_i="16"
	    anchor="system_flag_time_offset" since="OTP 18.0"/>
      <fsummary>Finalize the time offset.</fsummary>
      <desc>
        <p>
          Finalizes the <seealso marker="#time_offset/0">time offset</seealso>
          when <seealso marker="time_correction#Single_Time_Warp_Mode">single
          time warp mode</seealso> is used. If another time warp mode
          is used, the time offset state is left unchanged.</p>
        <p>Returns the old state identifier, that is:</p>
        <list>
          <item><p>If <c>preliminary</c> is returned, finalization was
            performed and the time offset is now final.</p>
          </item>
          <item><p>If <c>final</c> is returned, the time offset was
            already in the final state. This either because another
            <c>erlang:system_flag(time_offset, finalize)</c> call or
            because <seealso marker="time_correction#No_Time_Warp_Mode">no
            time warp mode</seealso> is used.</p>
          </item>
          <item><p>If <c>volatile</c> is returned, the time offset
            cannot be finalized because
            <seealso marker="time_correction#Multi_Time_Warp_Mode">multi-time
            warp mode</seealso> is used.</p>
          </item>
        </list>
      </desc>
    </func>

    <func>
      <name name="system_info" arity="1" clause_i="76" since=""/>
      <fsummary>System info overview.</fsummary>
      <desc>
        <p>Returns information about the current system.
        The documentation of this function is broken into the following
        sections in order to make it easier to navigate.</p>
        <taglist>
          <tag><seealso marker="#system_info_allocator">
          <c>Memory Allocation</c></seealso></tag>
          <item>
            <p>
              <seealso marker="#system_info_allocated_areas"><c>allocated_areas</c></seealso>,
              <seealso marker="#system_info_allocator"><c>allocator</c></seealso>,
              <seealso marker="#system_info_alloc_util_allocators"><c>alloc_util_allocators</c></seealso>,
              <seealso marker="#system_info_allocator_sizes"><c>allocator_sizes</c></seealso>,
              <seealso marker="#system_info_elib_malloc"><c>elib_malloc</c></seealso>
            </p>
          </item>
          <tag><seealso marker="#system_info_cpu_topology">
           <c>CPU Topology</c></seealso></tag>
           <item>
             <p>
               <seealso marker="#system_info_cpu_topology"><c>cpu_topology</c></seealso>,
               <seealso marker="#system_info_logical_processors"><c>logical_processors</c></seealso>,
               <seealso marker="#system_info_update_cpu_info"><c>update_cpu_info</c></seealso>
             </p>
           </item>
          <tag><seealso marker="#system_info_process">
           <c>Process Information</c></seealso></tag>
          <item>
            <p>
              <seealso marker="#system_info_fullsweep_after"><c>fullsweep_after</c></seealso>,
              <seealso marker="#system_info_garbage_collection"><c>garbage_collection</c></seealso>,
              <seealso marker="#system_info_heap_sizes"><c>heap_sizes</c></seealso>,
              <seealso marker="#system_info_heap_type"><c>heap_type</c></seealso>,
              <seealso marker="#system_info_max_heap_size"><c>max_heap_size</c></seealso>,
              <seealso marker="#system_info_message_queue_data"><c>message_queue_data</c></seealso>,
              <seealso marker="#system_info_min_heap_size"><c>min_heap_size</c></seealso>,
              <seealso marker="#system_info_min_bin_vheap_size"><c>min_bin_vheap_size</c></seealso>,
              <seealso marker="#system_info_procs"><c>procs</c></seealso>
            </p>
          </item>
          <tag><seealso marker="#system_info_limits">
           <c>System Limits</c></seealso></tag>
          <item>
            <p>
              <seealso marker="#system_info_atom_count"><c>atom_count</c></seealso>,
              <seealso marker="#system_info_atom_limit"><c>atom_limit</c></seealso>,
              <seealso marker="#system_info_ets_count"><c>ets_count</c></seealso>,
              <seealso marker="#system_info_ets_limit"><c>ets_limit</c></seealso>,
              <seealso marker="#system_info_port_count"><c>port_count</c></seealso>,
              <seealso marker="#system_info_port_limit"><c>port_limit</c></seealso>,
              <seealso marker="#system_info_process_count"><c>process_count</c></seealso>,
              <seealso marker="#system_info_process_limit"><c>process_limit</c></seealso>
            </p>
          </item>
          <tag><seealso marker="#system_info_time">
           <c>System Time</c></seealso></tag>
          <item>
            <p>
              <seealso marker="#system_info_end_time"><c>end_time</c></seealso>,
              <seealso marker="#system_info_os_monotonic_time_source"><c>os_monotonic_time_source</c></seealso>,
              <seealso marker="#system_info_os_system_time_source"><c>os_system_time_source</c></seealso>,
              <seealso marker="#system_info_start_time"><c>start_time</c></seealso>,
              <seealso marker="#system_info_time_correction"><c>time_correction</c></seealso>,
              <seealso marker="#system_info_time_offset"><c>time_offset</c></seealso>,
              <seealso marker="#system_info_time_warp_mode"><c>time_warp_mode</c></seealso>,
              <seealso marker="#system_info_tolerant_timeofday"><c>tolerant_timeofday</c></seealso>
            </p>
          </item>
          <tag><seealso marker="#system_info_scheduler">
           <c>Scheduler Information</c></seealso></tag>
          <item>
            <p>
              <seealso marker="#system_info_dirty_cpu_schedulers"><c>dirty_cpu_schedulers</c></seealso>,
              <seealso marker="#system_info_dirty_cpu_schedulers_online"><c>dirty_cpu_schedulers_online</c></seealso>,
              <seealso marker="#system_info_dirty_io_schedulers"><c>dirty_io_schedulers</c></seealso>,
              <seealso marker="#system_info_multi_scheduling"><c>multi_scheduling</c></seealso>,
              <seealso marker="#system_info_multi_scheduling_blockers"><c>multi_scheduling_blockers</c></seealso>,
              <seealso marker="#system_info_normal_multi_scheduling_blockers"><c>normal_multi_scheduling_blockers</c></seealso>,
              <seealso marker="#system_info_scheduler_bind_type"><c>scheduler_bind_type</c></seealso>,
              <seealso marker="#system_info_scheduler_bindings"><c>scheduler_bindings</c></seealso>,
              <seealso marker="#system_info_scheduler_id"><c>scheduler_id</c></seealso>,
              <seealso marker="#system_info_schedulers"><c>schedulers</c></seealso>,
              <seealso marker="#system_info_smp_support"><c>smp_support</c></seealso>,
              <seealso marker="#system_info_threads"><c>threads</c></seealso>,
              <seealso marker="#system_info_thread_pool_size"><c>thread_pool_size</c></seealso>
            </p>
          </item>
          <tag><seealso marker="#system_info_dist">
          <c>Distribution Information</c></seealso></tag>
          <item>
            <p>
              <seealso marker="#system_info_creation"><c>creation</c></seealso>,
              <seealso marker="#system_info_delayed_node_table_gc"><c>delayed_node_table_gc</c></seealso>,
              <seealso marker="#system_info_dist"><c>dist</c></seealso>,
              <seealso marker="#system_info_dist_buf_busy_limit"><c>dist_buf_busy_limit</c></seealso>,
              <seealso marker="#system_info_dist_ctrl"><c>dist_ctrl</c></seealso>
            </p>
          </item>
          <tag><seealso marker="#system_info_misc">
           <c>System Information</c></seealso></tag>
          <item>
            <p>
              <seealso marker="#system_info_build_type"><c>build_type</c></seealso>,
              <seealso marker="#system_info_c_compiler_used"><c>c_compiler_used</c></seealso>,
              <seealso marker="#system_info_check_io"><c>check_io</c></seealso>,
              <seealso marker="#system_info_compat_rel"><c>compat_rel</c></seealso>,
              <seealso marker="#system_info_debug_compiled"><c>debug_compiled</c></seealso>,
              <seealso marker="#system_info_driver_version"><c>driver_version</c></seealso>,
              <seealso marker="#system_info_dynamic_trace"><c>dynamic_trace</c></seealso>,
              <seealso marker="#system_info_dynamic_trace_probes"><c>dynamic_trace_probes</c></seealso>,
              <seealso marker="#system_info_info"><c>info</c></seealso>,
              <seealso marker="#system_info_kernel_poll"><c>kernel_poll</c></seealso>,
              <seealso marker="#system_info_loaded"><c>loaded</c></seealso>,
              <seealso marker="#system_info_machine"><c>machine</c></seealso>,
              <seealso marker="#system_info_modified_timing_level"><c>modified_timing_level</c></seealso>,
              <seealso marker="#system_info_nif_version"><c>nif_version</c></seealso>,
              <seealso marker="#system_info_otp_release"><c>otp_release</c></seealso>,
              <seealso marker="#system_info_port_parallelism"><c>port_parallelism</c></seealso>,
              <seealso marker="#system_info_system_architecture"><c>system_architecture</c></seealso>,
              <seealso marker="#system_info_system_logger"><c>system_logger</c></seealso>,
              <seealso marker="#system_info_system_version"><c>system_version</c></seealso>,
              <seealso marker="#system_info_trace_control_word"><c>trace_control_word</c></seealso>,
              <seealso marker="#system_info_version"><c>version</c></seealso>,
              <seealso marker="#system_info_wordsize"><c>wordsize</c></seealso>
            </p>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="system_info" arity="1" clause_i="1"
	    anchor="system_info_allocator" since=""/>   <!-- allocated_areas -->
      <name name="system_info" arity="1" clause_i="2" since=""/>   <!-- allocator -->
      <name name="system_info" arity="1" clause_i="3" since=""/>   <!-- {allocator, _} -->
      <name name="system_info" arity="1" clause_i="4" since=""/>   <!-- alloc_util_allocators -->
      <name name="system_info" arity="1" clause_i="5" since=""/>   <!-- {allocator_sizes, _} -->
      <name name="system_info" arity="1" clause_i="27" since=""/>  <!-- elib_malloc -->
      <fsummary>Information about the system allocators.</fsummary>
      <type variable="Allocator" name_i="2"/>
      <type variable="Version" name_i="2"/>
      <type variable="Features" name_i="2"/>
      <type variable="Settings" name_i="2"/>
      <type variable="Alloc" name_i="3"/>
      <desc>
        <marker id="system_info_allocator_tags"></marker>
        <p>Returns various information about the memory allocators
          of the current system (emulator) as specified by
          <c><anno>Item</anno></c>:</p>
        <marker id="system_info_allocated_areas"></marker>
        <taglist>
          <tag><marker id="system_info_allocated_areas"/>
            <c>allocated_areas</c></tag>
          <item>
            <p>Returns a list of tuples with information about
              miscellaneous allocated memory areas.</p>
            <p>Each tuple contains an atom describing the type of
              memory as first element and the amount of allocated
              memory in bytes as second element. When information
              about allocated and used memory is present, also a
              third element is present, containing the amount of
              used memory in bytes.</p>
            <p><c>erlang:system_info(allocated_areas)</c> is intended
              for debugging, and the content is highly
              implementation-dependent. The content of the results
              therefore changes when needed without prior notice.</p>
            <p>Notice that the sum of these values is <em>not</em>
              the total amount of memory allocated by the emulator.
              Some values are part of other values, and some memory
              areas are not part of the result. For information about
              the total amount of memory allocated by the emulator, see
              <seealso marker="#memory/0">
              <c>erlang:memory/0,1</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_allocator"/>
            <c>allocator</c></tag>
          <item>
            <p>Returns <c>{<anno>Allocator</anno>, <anno>Version</anno>,
              <anno>Features</anno>, <anno>Settings</anno></c>, where:</p>
            <list type="bulleted">
              <item>
                <p><c><anno>Allocator</anno></c> corresponds to the
                  <c>malloc()</c> implementation used. If
                  <c><anno>Allocator</anno></c> equals
                  <c>undefined</c>, the <c>malloc()</c> implementation
                  used cannot be identified. <c>glibc</c> can be
                  identified.</p>
              </item>
              <item>
                <p><c><anno>Version</anno></c> is a list of integers
                  (but not a string) representing the version of
                  the <c>malloc()</c> implementation used.</p>
              </item>
              <item>
                <p><c><anno>Features</anno></c> is a list of atoms
                  representing the allocation features used.</p>
              </item>
              <item>
                <p><c><anno>Settings</anno></c> is a list of subsystems,
                  their configurable parameters, and used values. Settings
                  can differ between different combinations of
                  platforms, allocators, and allocation features.
                  Memory sizes are given in bytes.</p>
              </item>
            </list>
            <p>See also "System Flags Effecting erts_alloc" in
              <seealso marker="erts:erts_alloc#flags">
              <c>erts_alloc(3)</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_allocator_tuple"></marker>
            <c>{allocator, <anno>Alloc</anno>}</c></tag>
          <item>
            <p>Returns information about the specified allocator.
              As from ERTS 5.6.1, the return value is a list
              of <c>{instance, InstanceNo, InstanceInfo}</c> tuples,
              where <c>InstanceInfo</c> contains information about
              a specific instance of the allocator.
              If <c><anno>Alloc</anno></c> is not a
              recognized allocator, <c>undefined</c> is returned.
              If <c><anno>Alloc</anno></c> is disabled,
              <c>false</c> is returned.</p>
            <p>Notice that the information returned is highly
              implementation-dependent and can be changed or removed
              at any time without prior notice. It was initially
              intended as a tool when developing new allocators, but
              as it can be of interest for others it has been
              briefly documented.</p>
            <p>The recognized allocators are listed in
              <seealso marker="erts:erts_alloc"><c>erts_alloc(3)</c></seealso>.
              Information about super carriers can be obtained from
              ERTS 8.0 with <c>{allocator, erts_mmap}</c> or from
              ERTS 5.10.4; the returned list when calling with
              <c>{allocator, mseg_alloc}</c> also includes an
              <c>{erts_mmap, _}</c> tuple as one element in the list.</p>
            <p>After reading the <c>erts_alloc(3)</c> documentation,
              the returned information
              more or less speaks for itself, but it can be worth
              explaining some things. Call counts are presented by two
              values, the first value is giga calls, and the second
              value is calls. <c>mbcs</c> and <c>sbcs</c> denote
              multi-block carriers, and single-block carriers,
              respectively. Sizes are presented in bytes. When a
              size is not presented, it is the amount of something.
              Sizes and amounts are often presented by three values:</p>
            <list type="bulleted">
              <item>The first is the current value.</item>
              <item>The second is the maximum value since the last call
                to <c>erlang:system_info({allocator, Alloc})</c>.</item>
              <item>The third is the maximum value since the emulator
                was started.</item>
            </list>
            <p>If only one value is present, it is the current value.
              <c>fix_alloc</c> memory block types are presented by two
              values. The first value is the memory pool size and
              the second value is the used memory size.</p>
          </item>
          <tag><marker id="system_info_alloc_util_allocators"/>
            <c>alloc_util_allocators</c></tag>
          <item>
            <p>Returns a list of the names of all allocators using
              the ERTS internal <c>alloc_util</c> framework
              as atoms. For more information, see section
              <seealso marker="erts:erts_alloc#alloc_util">The
              alloc_util framework</seealso>
              in <c>erts_alloc(3)</c>.</p>
          </item>
          <tag><marker id="system_info_allocator_sizes"/>
            <c>{allocator_sizes, <anno>Alloc</anno>}</c></tag>
          <item>
            <p>Returns various size information for the specified
              allocator. The information returned is a subset of the
              information returned by
              <seealso marker="#system_info_allocator_tuple">
              <c>erlang:system_info({allocator,
              <anno>Alloc</anno>})</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_elib_malloc"/>
            <c>elib_malloc</c></tag>
          <item>
            <p>This option will be removed in a future release.
              The return value will always be <c>false</c>, as the
              <c>elib_malloc</c> allocator has been removed.</p>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="system_info" arity="1" clause_i="12"
	    anchor="system_info_cpu_topology" since=""/>           <!-- cpu_topology -->
      <name name="system_info" arity="1" clause_i="13" since=""/>  <!-- {cpu_topology, _} -->
      <name name="system_info" arity="1" clause_i="38" since=""/>  <!-- logical_processors -->
      <name name="system_info" arity="1" clause_i="74" since="OTP R14B"/>  <!-- update_cpu_info -->
      <fsummary>Information about the CPU topology of the system.</fsummary>
      <type name="cpu_topology"/>
      <type name="level_entry"/>
      <type_desc name="cpu_topology">
        All <c><anno>LevelEntry</anno></c>s of a list
        must contain the same <c><anno>LevelTag</anno></c>, except
        on the top level where both <c>node</c> and
        <c>processor</c> <c><anno>LevelTag</anno></c>s can coexist.
      </type_desc>
      <type_desc name="level_entry">
        <c>{<anno>LevelTag</anno>,
        <anno>SubLevel</anno>} == {<anno>LevelTag</anno>, [],
        <anno>SubLevel</anno>}</c>
      </type_desc>
      <type name="level_tag"/>
      <type_desc name="level_tag">
        More <c><anno>LevelTag</anno></c>s can be introduced in a
        future release.
      </type_desc>
      <type name="sub_level"/>
      <type name="info_list"/>
      <type_desc name="info_list">
        The <c>info_list()</c> can be extended in a future release.
      </type_desc>
      <desc>
        <marker id="system_info_cpu_topology_tags"></marker>
        <p>Returns various information about the CPU topology of
          the current system (emulator) as specified by
          <c><anno>Item</anno></c>:</p>
        <taglist>
          <tag><marker id="system_info_cpu_topology"/>
            <c>cpu_topology</c></tag>
          <item>
            <p>Returns the <c><anno>CpuTopology</anno></c> currently used by
              the emulator. The CPU topology is used when binding schedulers
              to logical processors. The CPU topology used is the
              <seealso marker="erlang#system_info_cpu_topology_defined">
              user-defined CPU topology</seealso>,
              if such exists, otherwise the
              <seealso marker="erlang#system_info_cpu_topology_detected">
              automatically detected CPU topology</seealso>,
              if such exists. If no CPU topology
              exists, <c>undefined</c> is returned.</p>
            <p><c>node</c> refers to Non-Uniform Memory Access (NUMA)
              nodes. <c>thread</c> refers to hardware threads
              (for example, Intel hyper-threads).</p>
            <p>A level in term <c><anno>CpuTopology</anno></c> can be
              omitted if only one entry exists and
              <c><anno>InfoList</anno></c> is empty.</p>
            <p><c>thread</c> can only be a sublevel to <c>core</c>.
              <c>core</c> can be a sublevel to <c>processor</c>
              or <c>node</c>. <c>processor</c> can be on the
              top level or a sublevel to <c>node</c>. <c>node</c>
              can be on the top level or a sublevel to
              <c>processor</c>. That is, NUMA nodes can be processor
              internal or processor external. A CPU topology can
              consist of a mix of processor internal and external
              NUMA nodes, as long as each logical CPU belongs to
              <em>one</em> NUMA node. Cache hierarchy is not part of
              the <c><anno>CpuTopology</anno></c> type, but will be in a
              future release. Other things can also make it into the CPU
              topology in a future release. So, expect the
              <c><anno>CpuTopology</anno></c> type to change.</p>
          </item>
          <tag><c>{cpu_topology, defined}</c></tag>
          <item>
            <marker id="system_info_cpu_topology_defined"></marker>
            <p>Returns the user-defined <c><anno>CpuTopology</anno></c>.
              For more information, see command-line flag
              <seealso marker="erts:erl#+sct"><c>+sct</c></seealso> in
              <c>erl(1)</c> and argument
              <seealso marker="#system_info_cpu_topology">
              <c>cpu_topology</c></seealso>.</p>
          </item>
          <tag><c>{cpu_topology, detected}</c></tag>
          <item>
            <marker id="system_info_cpu_topology_detected"></marker>
            <p>Returns the automatically detected
              <c><anno>CpuTopology</anno>y</c>. The
              emulator detects the CPU topology on some newer
              Linux, Solaris, FreeBSD, and Windows systems.
              On Windows system with more than 32 logical processors,
              the CPU topology is not detected.</p>
            <p>For more information, see argument
              <seealso marker="#system_info_cpu_topology">
              <c>cpu_topology</c></seealso>.</p>
          </item>
          <tag><c>{cpu_topology, used}</c></tag>
          <item>
            <p>Returns <c><anno>CpuTopology</anno></c> used by the emulator.
              For more information, see argument
              <seealso marker="#system_info_cpu_topology">
              <c>cpu_topology</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_logical_processors"/>
            <c>logical_processors</c></tag>
          <item>
            <p>Returns the detected number of logical processors configured
              in the system. The return value is either an integer, or
              the atom <c>unknown</c> if the emulator cannot
              detect the configured logical processors.</p>
          </item>
          <tag><marker id="system_info_logical_processors_available"/>
            <c>logical_processors_available</c></tag>
          <item>
            <p>Returns the detected number of logical processors available
              to the Erlang runtime system. The return value is either an
              integer, or the atom <c>unknown</c> if the emulator
              cannot detect the available logical processors. The number
              of available logical processors is less than or equal to
              the number of <seealso marker="#system_info_logical_processors_online">
              logical processors online</seealso>.</p>
          </item>
          <tag><marker id="system_info_logical_processors_online"/>
            <c>logical_processors_online</c></tag>
          <item>
            <p>Returns the detected number of logical processors online on
              the system. The return value is either an integer,
              or the atom <c>unknown</c> if the emulator cannot
              detect logical processors online. The number of logical
              processors online is less than or equal to the number of
              <seealso marker="#system_info_logical_processors">logical processors
              configured</seealso>.</p>
          </item>
          <tag><marker id="system_info_update_cpu_info"/>
            <c>update_cpu_info</c></tag>
          <item>
            <p>The runtime system rereads the CPU information available
              and updates its internally stored information about the
              <seealso marker="#system_info_cpu_topology_detected">detected
              CPU topology</seealso> and the number of logical processors
              <seealso marker="#system_info_logical_processors">configured</seealso>,
              <seealso marker="#system_info_logical_processors_online">online</seealso>,
              and <seealso marker="#system_info_logical_processors_available">
              available</seealso>.</p>
            <p>If the CPU information has changed since the last time
              it was read, the atom <c>changed</c> is returned, otherwise
              the atom <c>unchanged</c>. If the CPU information has changed,
              you probably want to
              <seealso marker="#system_flag_schedulers_online">adjust the
              number of schedulers online</seealso>. You typically want
              to have as many schedulers online as
              <seealso marker="#system_info_logical_processors_available">logical
              processors available</seealso>.</p>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="system_info" arity="1" clause_i="31"
	    anchor="system_info_process" since=""/>  <!-- fullsweep_after -->
      <name name="system_info" arity="1" clause_i="32" since=""/>  <!-- garbage_collection -->
      <name name="system_info" arity="1" clause_i="33" since=""/>  <!-- heap_sizes -->
      <name name="system_info" arity="1" clause_i="34" since=""/>  <!-- heap_type -->
      <name name="system_info" arity="1" clause_i="40" since="OTP 19.0"/>  <!-- max_heap_size -->
      <name name="system_info" arity="1" clause_i="41" since="OTP 19.0"/>  <!-- message_queue_data -->
      <name name="system_info" arity="1" clause_i="42" since="OTP R13B04"/>  <!-- min_heap_size -->
      <name name="system_info" arity="1" clause_i="43" since="OTP R13B04"/>  <!-- min_bin_vheap_size -->
      <name name="system_info" arity="1" clause_i="57" since=""/>  <!-- procs -->
      <fsummary>Information about the default process heap settings.</fsummary>
      <type name="message_queue_data"/>
      <type name="max_heap_size"/>
      <desc>
        <marker id="system_info_process_tags"/>
        <p>Returns information about the default process heap settings:</p>
        <taglist>
          <tag><marker id="system_info_fullsweep_after"/>
            <c>fullsweep_after</c></tag>
          <item>
            <p>Returns <c>{fullsweep_after, integer() >= 0}</c>, which is
              the <c>fullsweep_after</c> garbage collection setting used
              by default. For more information, see
              <c>garbage_collection</c> described below.</p>
          </item>
          <tag><marker id="system_info_garbage_collection"/>
            <c>garbage_collection</c></tag>
          <item>
            <p>Returns a list describing the default garbage collection
              settings. A process spawned on the local node by a
              <c>spawn</c> or <c>spawn_link</c> uses these
              garbage collection settings. The default settings can be
              changed by using
              <seealso marker="#system_flag/2">
              <c>erlang:system_flag/2</c></seealso>.
              <seealso marker="#spawn_opt/4"><c>spawn_opt/2,3,4</c></seealso>
              can spawn a process that does not use the default
              settings.</p>
          </item>
          <tag><marker id="system_info_heap_sizes"/>
            <c>heap_sizes</c></tag>
          <item>
            <p>Returns a list of integers representing valid heap sizes 
              in words. All Erlang heaps are sized from sizes in this
              list.</p>
          </item>
          <tag><marker id="system_info_heap_type"/>
            <c>heap_type</c></tag>
          <item>
            <p>Returns the heap type used by the current emulator. One
              heap type exists:</p>
            <taglist>
              <tag><c>private</c></tag>
              <item>
                Each process has a heap reserved for its use and no
                references between heaps of different processes are
                allowed. Messages passed between processes are copied
                between heaps.
              </item>
            </taglist>
          </item>
          <tag><marker id="system_info_max_heap_size"/>
            <c>max_heap_size</c></tag>
          <item>
            <p>Returns <c>{max_heap_size, <anno>MaxHeapSize</anno>}</c>,
              where <c><anno>MaxHeapSize</anno></c> is the current
              system-wide maximum heap size settings for spawned processes.
              This setting can be set using the command-line flags
              <seealso marker="erl#+hmax"><c>+hmax</c></seealso>,
              <seealso marker="erl#+hmaxk"><c>+hmaxk</c></seealso> and
              <seealso marker="erl#+hmaxel"><c>+hmaxel</c></seealso> in
              <c>erl(1)</c>. It can also be changed at runtime using
              <seealso marker="#system_flag_max_heap_size">
              <c>erlang:system_flag(max_heap_size, MaxHeapSize)</c></seealso>.
              For more details about the <c>max_heap_size</c> process flag,
              see <seealso marker="#process_flag_max_heap_size">
              <c>process_flag(max_heap_size, MaxHeapSize)</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_message_queue_data"/>
            <c>message_queue_data</c></tag>
          <item>
            <p>Returns the default value of the <c>message_queue_data</c>
              process flag, which is either <c>off_heap</c> or <c>on_heap</c>.
              This default is set by command-line argument
              <seealso marker="erl#+hmqd"><c>+hmqd</c></seealso> in
              <c>erl(1)</c>. For more information on the
              <c>message_queue_data</c> process flag, see documentation of
              <seealso marker="#process_flag_message_queue_data">
              <c>process_flag(message_queue_data, MQD)</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_min_heap_size"/>
            <c>min_heap_size</c></tag>
          <item>
            <p>Returns <c>{min_heap_size, <anno>MinHeapSize</anno>}</c>,
              where <c><anno>MinHeapSize</anno></c> is the current
              system-wide minimum heap size for spawned processes.</p>
          </item>
          <tag><marker id="system_info_min_bin_vheap_size"/>
            <c>min_bin_vheap_size</c></tag>
          <item>
            <p>Returns <c>{min_bin_vheap_size,
              <anno>MinBinVHeapSize</anno>}</c>, where
              <c><anno>MinBinVHeapSize</anno></c> is the current system-wide
              minimum binary virtual heap size for spawned processes.</p>
          </item>
          <tag><marker id="system_info_procs"/>
            <c>procs</c></tag>
          <item>
            <p>Returns a binary containing a string of process and port
              information formatted as in Erlang crash dumps. For more
              information, see section <seealso marker="erts:crash_dump">
              How to interpret the Erlang crash dumps</seealso>
              in the User's Guide.</p>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="system_info" arity="1" clause_i="6" anchor="system_info_limits" since="OTP 20.0"/>   <!-- atom_count -->
      <name name="system_info" arity="1" clause_i="7" since="OTP 20.0"/>   <!-- atom_limit -->
      <name name="system_info" arity="1" clause_i="29" since="OTP 21.1"/>  <!-- ets_count -->
      <name name="system_info" arity="1" clause_i="30" since="OTP R16B03"/>  <!-- ets_limit -->
      <name name="system_info" arity="1" clause_i="53" since="OTP R16B"/>  <!-- port_count -->
      <name name="system_info" arity="1" clause_i="54" since="OTP R16B"/>  <!-- port_limit -->
      <name name="system_info" arity="1" clause_i="55" since=""/>  <!-- process_count -->
      <name name="system_info" arity="1" clause_i="56" since=""/>  <!-- process_limit -->
      <fsummary>Information about various system limits.</fsummary>
      <desc>
        <marker id="system_info_limits"/>
        <p>Returns information about the current system
        (emulator) limits as specified by <c><anno>Item</anno></c>:</p>
        <taglist>
          <tag><marker id="system_info_atom_count"/>
            <c>atom_count</c></tag>
          <item>
            <p>Returns the number of atoms currently existing at the
            local node. The value is given as an integer.</p>
          </item>
          <tag><marker id="system_info_atom_limit"/>
            <c>atom_limit</c></tag>
          <item>
            <p>Returns the maximum number of atoms allowed.
            This limit can be increased at startup by passing
            command-line flag
            <seealso marker="erts:erl#+t"><c>+t</c></seealso> to
            <c>erl(1)</c>.
            </p>
          </item>
          <tag><marker id="system_info_ets_count"/>
            <c>ets_count</c></tag>
          <item>
            <p>Returns the number of ETS tables currently existing at the
            local node.</p>
          </item>
          <tag><marker id="system_info_ets_limit"/>
            <c>ets_limit</c></tag>
          <item>
            <p>Returns the limit for number of ETS tables. This limit is
	    <seealso marker="stdlib:ets#max_ets_tables">partially obsolete</seealso>
	    and number of tables are only limited by available memory.</p>
          </item>
          <tag><marker id="system_info_port_count"/><c>port_count</c></tag>
          <item>
            <p>Returns the number of ports currently existing at the
              local node. The value is given as an integer. This is
              the same value as returned by
              <c>length(erlang:ports())</c>, but more efficient.</p>
          </item>
          <tag><marker id="system_info_port_limit"/>
            <c>port_limit</c></tag>
          <item>
            <p>Returns the maximum number of simultaneously existing
            ports at the local node as an integer. This limit can be
            configured at startup by using command-line flag
            <seealso marker="erl#+Q"><c>+Q</c></seealso> in <c>erl(1)</c>.</p>
          </item>
          <tag><marker id="system_info_process_count"/>
          <c>process_count</c></tag>
          <item>
            <p>Returns the number of processes currently existing at the
            local node. The value is given as an integer. This is
            the same value as returned by
            <c>length(processes())</c>, but more efficient.</p>
          </item>
          <tag><marker id="system_info_process_limit"/>
            <c>process_limit</c></tag>
          <item>
            <p>Returns the maximum number of simultaneously existing
            processes at the local node. The value is given as an
            integer. This limit can be configured at startup by using
            command-line flag <seealso marker="erl#+P"><c>+P</c></seealso>
            in <c>erl(1)</c>.</p>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="system_info" arity="1" clause_i="26"
	    anchor="system_info_time" since="OTP 18.0"/>  <!-- end_time -->
      <name name="system_info" arity="1" clause_i="50" since="OTP 18.0"/>  <!-- os_monotonic_time_source -->
      <name name="system_info" arity="1" clause_i="51" since="OTP 18.0"/>  <!-- os_system_time_source -->
      <name name="system_info" arity="1" clause_i="63" since="OTP 18.0"/>  <!-- start_time -->
      <name name="system_info" arity="1" clause_i="69" since="OTP 18.0"/>  <!-- time_correction -->
      <name name="system_info" arity="1" clause_i="70" since="OTP 18.0"/>  <!-- time_offset -->
      <name name="system_info" arity="1" clause_i="71" since="OTP 18.0"/>  <!-- time_warp_mode -->
      <name name="system_info" arity="1" clause_i="72" since="OTP 17.1"/>  <!-- tolerant_timeofday -->
      <fsummary>Information about system time.</fsummary>
      <desc>
        <marker id="system_info_time_tags"/>
        <p>Returns information about the current system
        (emulator) time as specified by <c><anno>Item</anno></c>:</p>
        <taglist>
          <tag><marker id="system_info_end_time"/><c>end_time</c></tag>
          <item>
            <p>The last <seealso marker="#monotonic_time/0">Erlang monotonic
            time</seealso> in <c>native</c>
            <seealso marker="#type_time_unit">time unit</seealso> that
            can be represented internally in the current Erlang runtime system
            instance. The time between the
            <seealso marker="#system_info_start_time">start time</seealso> and
            the end time is at least a quarter of a millennium.</p>
          </item>
          <tag><marker id="system_info_os_monotonic_time_source"/>
            <c>os_monotonic_time_source</c></tag>
          <item>
            <p>Returns a list containing information about the source of
              <seealso marker="erts:time_correction#OS_Monotonic_Time">OS
              monotonic time</seealso> that is used by the runtime system.</p>
            <p>If <c>[]</c> is returned, no OS monotonic time is
              available. The list contains two-tuples with <c>Key</c>s
              as first element, and <c>Value</c>s as second element. The
              order of these tuples is undefined. The following
              tuples can be part of the list, but more tuples can be
              introduced in the future:</p>
            <taglist>
              <tag><c>{function, Function}</c></tag>
              <item><p><c>Function</c> is the name of the function
                used. This tuple always exists if OS monotonic time is
                available to the runtime system.</p>
              </item>
              <tag><c>{clock_id, ClockId}</c></tag>
              <item><p>This tuple only exists if <c>Function</c>
                can be used with different clocks. <c>ClockId</c>
                corresponds to the clock identifier used when calling
                <c>Function</c>.</p>
              </item>
              <tag><c>{resolution, OsMonotonicTimeResolution}</c></tag>
              <item><p>Highest possible
                <seealso marker="time_correction#Time_Resolution">
                resolution</seealso>
                of current OS monotonic time source as parts per
                second. If no resolution information can be retrieved
                from the OS, <c>OsMonotonicTimeResolution</c> is
                set to the resolution of the time unit of
                <c>Function</c>s return value. That is, the actual
                resolution can be lower than
                <c>OsMonotonicTimeResolution</c>. Notice that
                the resolution does not say anything about the
                <seealso marker="time_correction#Time_Accuracy">
                accuracy</seealso> or whether the
                <seealso marker="time_correction#Time_Precision">
                precision</seealso> aligns with the resolution. You do,
                however, know that the precision is not better than
                <c>OsMonotonicTimeResolution</c>.</p>
              </item>
              <tag><c>{extended, Extended}</c></tag>
              <item><p><c>Extended</c> equals <c>yes</c> if
                the range of time values has been extended;
                otherwise <c>Extended</c> equals <c>no</c>. The
                range must be extended if <c>Function</c>
                returns values that wrap fast. This typically
                is the case when the return value is a 32-bit value.</p>
              </item>
              <tag><c>{parallel, Parallel}</c></tag>
              <item><p><c>Parallel</c> equals <c>yes</c> if
                <c>Function</c> is called in parallel from multiple
                threads. If it is not called in parallel, because
                calls must be serialized, <c>Parallel</c> equals
                <c>no</c>.</p>
              </item>
              <tag><c>{time, OsMonotonicTime}</c></tag>
              <item><p><c>OsMonotonicTime</c> equals current OS
                monotonic time in <c>native</c>
                <seealso marker="#type_time_unit">time unit</seealso>.</p>
              </item>
            </taglist>
          </item>
          <tag><marker id="system_info_os_system_time_source"/>
            <c>os_system_time_source</c></tag>
          <item>
            <p>Returns a list containing information about the source of
              <seealso marker="erts:time_correction#OS_System_Time">OS
              system time</seealso> that is used by the runtime system.</p>
            <p>The list contains two-tuples with <c>Key</c>s
              as first element, and <c>Value</c>s as second element. The
              order of these tuples is undefined. The following
              tuples can be part of the list, but more tuples can be
              introduced in the future:</p>
            <taglist>
              <tag><c>{function, Function}</c></tag>
              <item><p><c>Function</c> is the name of the funcion used.</p>
              </item>
              <tag><c>{clock_id, ClockId}</c></tag>
              <item><p>Exists only if <c>Function</c>
                can be used with different clocks. <c>ClockId</c>
                corresponds to the clock identifier used when calling
                <c>Function</c>.</p>
              </item>
              <tag><c>{resolution, OsSystemTimeResolution}</c></tag>
              <item><p>Highest possible
                <seealso marker="time_correction#Time_Resolution">
                resolution</seealso>
                of current OS system time source as parts per
                second. If no resolution information can be retrieved
                from the OS, <c>OsSystemTimeResolution</c> is
                set to the resolution of the time unit of
                <c>Function</c>s return value. That is, the actual
                resolution can be lower than
                <c>OsSystemTimeResolution</c>. Notice that
                the resolution does not say anything about the
                <seealso marker="time_correction#Time_Accuracy">
                accuracy</seealso> or whether the
                <seealso marker="time_correction#Time_Precision">
                precision</seealso> do align with the resolution. You do,
                however, know that the precision is not better than
                <c>OsSystemTimeResolution</c>.</p>
              </item>
              <tag><c>{parallel, Parallel}</c></tag>
              <item><p><c>Parallel</c> equals <c>yes</c> if
                <c>Function</c> is called in parallel from multiple
                threads. If it is not called in parallel, because
                calls needs to be serialized, <c>Parallel</c> equals
                <c>no</c>.</p>
              </item>
              <tag><c>{time, OsSystemTime}</c></tag>
              <item><p><c>OsSystemTime</c> equals current OS
                system time in <c>native</c>
                <seealso marker="#type_time_unit">time unit</seealso>.</p>
              </item>
            </taglist>
          </item>
          <tag><marker id="system_info_start_time"/><c>start_time</c></tag>
          <item>
            <p>The <seealso marker="#monotonic_time/0">Erlang monotonic
              time</seealso> in <c>native</c>
              <seealso marker="#type_time_unit">time unit</seealso> at the
              time when current Erlang runtime system instance started.</p>
            <p>See also <seealso marker="#system_info_end_time">
              <c>erlang:system_info(end_time)</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_time_correction"/>
            <c>time_correction</c></tag>
          <item>
            <p>Returns a boolean value indicating whether
              <seealso marker="time_correction#Time_Correction">
              time correction</seealso> is enabled or not.</p>
          </item>
          <tag><marker id="system_info_time_offset"/>
            <c>time_offset</c></tag>
          <item>
            <p>Returns the state of the time offset:</p>
            <taglist>
              <tag><c>preliminary</c></tag>
              <item>
                <p>The time offset is preliminary, and will be changed
                  and finalized later. The preliminary time offset
                  is used during the preliminary phase of the
                  <seealso marker="time_correction#Single_Time_Warp_Mode">
                  single time warp mode</seealso>.</p>
              </item>
              <tag><c>final</c></tag>
              <item>
                <p>The time offset is final. This either because
                  <seealso marker="time_correction#No_Time_Warp_Mode">
                  no time warp mode</seealso> is used, or because the time
                  offset have been finalized when
                  <seealso marker="time_correction#Single_Time_Warp_Mode">
                  single time warp mode</seealso> is used.</p>
              </item>
              <tag><c>volatile</c></tag>
              <item>
                <p>The time offset is volatile. That is, it can
                  change at any time. This is because
                  <seealso marker="time_correction#Multi_Time_Warp_Mode">
                  multi-time warp mode</seealso> is used.</p>
              </item>
            </taglist>
          </item>
          <tag><marker id="system_info_time_warp_mode"/>
            <c>time_warp_mode</c></tag>
          <item>
            <p>Returns a value identifying the
              <seealso marker="time_correction#Time_Warp_Modes">
              time warp mode</seealso> that is used:</p>
            <taglist>
              <tag><c>no_time_warp</c></tag>
              <item>The <seealso marker="time_correction#No_Time_Warp_Mode">
                no time warp mode</seealso> is used.
              </item>
              <tag><c>single_time_warp</c></tag>
              <item>The <seealso marker="time_correction#Single_Time_Warp_Mode">
                single time warp mode</seealso> is used.
              </item>
              <tag><c>multi_time_warp</c></tag>
              <item>The <seealso marker="time_correction#Multi_Time_Warp_Mode">
                multi-time warp mode</seealso> is used.
              </item>
            </taglist>
          </item>
          <tag><marker id="system_info_tolerant_timeofday"/>
            <c>tolerant_timeofday</c></tag>
          <item>
            <p>Returns whether a pre ERTS 7.0 backwards compatible
              compensation for sudden changes of system time is <c>enabled</c>
              or <c>disabled</c>. Such compensation is <c>enabled</c> when the
              <seealso marker="#system_info_time_offset">time offset</seealso>
              is <c>final</c>, and
              <seealso marker="#system_info_time_correction">
              time correction</seealso> is enabled.</p>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="system_info" arity="1" clause_i="17"
	    anchor="system_info_scheduler" since="OTP 17.0"/>  <!-- dirty_cpu_schedulers -->
      <name name="system_info" arity="1" clause_i="18" since="OTP 17.0"/>  <!-- dirty_cpu_schedulers_online -->
      <name name="system_info" arity="1" clause_i="19" since="OTP 17.0"/>  <!-- dirty_io_schedulers -->
      <name name="system_info" arity="1" clause_i="45" since=""/>  <!-- multi_scheduling -->
      <name name="system_info" arity="1" clause_i="46" since=""/>  <!-- multi_scheduling_blockers -->
      <name name="system_info" arity="1" clause_i="49" since="OTP 19.0"/>  <!-- normal_multi_scheduling_blockers -->
      <name name="system_info" arity="1" clause_i="58" since=""/>  <!-- scheduler_bind_type -->
      <name name="system_info" arity="1" clause_i="59" since=""/>  <!-- scheduler_bindings -->
      <name name="system_info" arity="1" clause_i="60" since=""/>  <!-- scheduler_id -->
      <name name="system_info" arity="1" clause_i="61" since=""/>  <!-- schedulers -->
      <name name="system_info" arity="1" clause_i="62" since=""/>  <!-- smp_support -->
      <name name="system_info" arity="1" clause_i="67" since=""/>  <!-- threads -->
      <name name="system_info" arity="1" clause_i="68" since=""/>  <!-- thread_pool_size -->
      <fsummary>Information about system schedulers.</fsummary>
      <desc>
        <marker id="system_info_scheduler_tags"/>
        <p>Returns information about schedulers, scheduling and threads in the
          current system as specified by <c><anno>Item</anno></c>:</p>
        <taglist>
          <tag><marker id="system_info_dirty_cpu_schedulers"/>
            <c>dirty_cpu_schedulers</c></tag>
          <item>
            <p>Returns the number of dirty CPU scheduler threads used by
              the emulator. Dirty CPU schedulers execute CPU-bound
              native functions, such as NIFs, linked-in driver code,
              and BIFs that cannot be managed cleanly by the normal
              emulator schedulers.</p>
            <p>The number of dirty CPU scheduler threads is determined
              at emulator boot time and cannot be changed after that.
              However, the number of dirty CPU scheduler threads online
              can be changed at any time. The number of dirty CPU
              schedulers can be set at startup by passing
              command-line flag
              <seealso marker="erts:erl#+SDcpu"><c>+SDcpu</c></seealso> or
              <seealso marker="erts:erl#+SDPcpu"><c>+SDPcpu</c></seealso> in
              <c>erl(1)</c>.</p>
            <p>See also
              <seealso marker="#system_flag_dirty_cpu_schedulers_online">
              <c>erlang:system_flag(dirty_cpu_schedulers_online,
              DirtyCPUSchedulersOnline)</c></seealso>,
              <seealso marker="#system_info_dirty_cpu_schedulers_online">
              <c>erlang:system_info(dirty_cpu_schedulers_online)</c></seealso>,
              <seealso marker="#system_info_dirty_io_schedulers">
              <c>erlang:system_info(dirty_io_schedulers)</c></seealso>,
              <seealso marker="#system_info_schedulers">
              <c>erlang:system_info(schedulers)</c></seealso>,
              <seealso marker="#system_info_schedulers_online">
              <c>erlang:system_info(schedulers_online)</c></seealso>, and
              <seealso marker="#system_flag_schedulers_online">
              <c>erlang:system_flag(schedulers_online,
              SchedulersOnline)</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_dirty_cpu_schedulers_online"/>
            <c>dirty_cpu_schedulers_online</c></tag>
          <item>
            <p>Returns the number of dirty CPU schedulers online.
              The return value satisfies
              <c><![CDATA[1 <= DirtyCPUSchedulersOnline <= N]]></c>,
              where <c>N</c> is the smallest of the return values of
              <c>erlang:system_info(dirty_cpu_schedulers)</c> and
              <c>erlang:system_info(schedulers_online)</c>.</p>
            <p>The number of dirty CPU schedulers online can be set at
              startup by passing command-line flag
              <seealso marker="erts:erl#+SDcpu"><c>+SDcpu</c></seealso> in
              <c>erl(1)</c>.</p>
            <p>For more information, see
              <seealso marker="#system_info_dirty_cpu_schedulers">
              <c>erlang:system_info(dirty_cpu_schedulers)</c></seealso>,
              <seealso marker="#system_info_dirty_io_schedulers">
              <c>erlang:system_info(dirty_io_schedulers)</c></seealso>,
              <seealso marker="#system_info_schedulers_online">
              <c>erlang:system_info(schedulers_online)</c></seealso>, and
              <seealso marker="#system_flag_dirty_cpu_schedulers_online">
              <c>erlang:system_flag(dirty_cpu_schedulers_online,
              DirtyCPUSchedulersOnline)</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_dirty_io_schedulers"/>
            <c>dirty_io_schedulers</c></tag>
          <item>
            <p>Returns the number of dirty I/O schedulers as an integer.
              Dirty I/O schedulers execute I/O-bound native functions,
              such as NIFs and linked-in driver code, which cannot be
              managed cleanly by the normal emulator schedulers.</p>
            <p>This value can be set at startup by passing command-line
              argument <seealso marker="erts:erl#+SDio"><c>+SDio</c></seealso>
              in <c>erl(1)</c>.</p>
            <p>For more information, see
              <seealso marker="#system_info_dirty_cpu_schedulers">
              <c>erlang:system_info(dirty_cpu_schedulers)</c></seealso>,
              <seealso marker="#system_info_dirty_cpu_schedulers_online">
              <c>erlang:system_info(dirty_cpu_schedulers_online)</c></seealso>,
              and <seealso marker="#system_flag_dirty_cpu_schedulers_online">
              <c>erlang:system_flag(dirty_cpu_schedulers_online,
              DirtyCPUSchedulersOnline)</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_multi_scheduling"/>
            <c>multi_scheduling</c></tag>
          <item>
            <p>Returns one of the following:</p>
            <taglist>
              <tag><c>disabled</c></tag>
              <item>
                <p>The emulator has been started with only one scheduler thread.</p>
              </item>
              <tag><c>blocked</c></tag>
              <item>
                <p>The emulator has more than one scheduler thread,
                  but all scheduler threads except one are blocked.
                  That is, only one scheduler thread schedules
                  Erlang processes and executes Erlang code.</p>
              </item>
              <tag><c>blocked_normal</c></tag>
              <item>
                <p>The emulator has more than one scheduler thread,
                  but all normal scheduler threads except one are
                  blocked. Notice that dirty schedulers are not
                  blocked, and can schedule Erlang processes and
                  execute native code.</p>
              </item>
              <tag><c>enabled</c></tag>
              <item>
                <p>The emulator has more than one scheduler thread,
                  and no scheduler threads are blocked. That is,
                  all available scheduler threads schedule
                  Erlang processes and execute Erlang code.</p>
              </item>
            </taglist>
            <p>See also
              <seealso marker="#system_flag_multi_scheduling">
              <c>erlang:system_flag(multi_scheduling, BlockState)</c></seealso>,
              <seealso marker="#system_info_multi_scheduling_blockers">
              <c>erlang:system_info(multi_scheduling_blockers)</c></seealso>,
              <seealso marker="#system_info_normal_multi_scheduling_blockers">
              <c>erlang:system_info(normal_multi_scheduling_blockers)</c></seealso>,
              and <seealso marker="#system_info_schedulers">
              <c>erlang:system_info(schedulers)</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_multi_scheduling_blockers"/>
            <c>multi_scheduling_blockers</c></tag>
          <item>
            <p>Returns a list of <c><anno>Pid</anno></c>s when
              multi-scheduling is blocked, otherwise the empty list is
              returned. The <c><anno>Pid</anno></c>s in the list
              represent all the processes currently
              blocking multi-scheduling. A <c><anno>Pid</anno></c> occurs
              only once in the list, even if the corresponding
              process has blocked multiple times.</p>
            <p>See also
              <seealso marker="#system_flag_multi_scheduling">
              <c>erlang:system_flag(multi_scheduling, BlockState)</c></seealso>,
              <seealso marker="#system_info_multi_scheduling">
              <c>erlang:system_info(multi_scheduling)</c></seealso>,
              <seealso marker="#system_info_normal_multi_scheduling_blockers">
              <c>erlang:system_info(normal_multi_scheduling_blockers)</c></seealso>,
              and <seealso marker="#system_info_schedulers">
              <c>erlang:system_info(schedulers)</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_normal_multi_scheduling_blockers"/>
            <c>normal_multi_scheduling_blockers</c></tag>
          <item>
            <p>Returns a list of <c><anno>Pid</anno></c>s when
              normal multi-scheduling is blocked (that is, all normal schedulers
              but one is blocked), otherwise the empty list is returned.
              The <c><anno>Pid</anno></c>s in the list represent all the
              processes currently blocking normal multi-scheduling.
              A <c><anno>Pid</anno></c> occurs only once in the list, even if
              the corresponding process has blocked multiple times.</p>
            <p>See also
              <seealso marker="#system_flag_multi_scheduling">
              <c>erlang:system_flag(multi_scheduling, BlockState)</c></seealso>,
              <seealso marker="#system_info_multi_scheduling">
              <c>erlang:system_info(multi_scheduling)</c></seealso>,
              <seealso marker="#system_info_multi_scheduling_blockers">
              <c>erlang:system_info(multi_scheduling_blockers)</c></seealso>,
              and <seealso marker="#system_info_schedulers">
              <c>erlang:system_info(schedulers)</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_scheduler_bind_type"/>
            <c>scheduler_bind_type</c></tag>
          <item>
            <p>Returns information about how the user has requested
              schedulers to be bound or not bound.</p>
            <p>Notice that although a user has requested
              schedulers to be bound, they can silently have failed
              to bind. To inspect the scheduler bindings, call
              <seealso marker="#system_info_scheduler_bindings">
              <c>erlang:system_info(scheduler_bindings)</c></seealso>.</p>
            <p>For more information, see command-line argument
              <seealso marker="erts:erl#+sbt"><c>+sbt</c></seealso>
              in <c>erl(1)</c> and
              <seealso marker="#system_info_scheduler_bindings">
              <c>erlang:system_info(scheduler_bindings)</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_scheduler_bindings"/>
            <c>scheduler_bindings</c></tag>
          <item>
            <p>Returns information about the currently used scheduler
              bindings.</p>
            <p>A tuple of a size equal to
              <seealso marker="#system_info_schedulers">
              <c>erlang:system_info(schedulers)</c></seealso>
              is returned. The tuple elements are integers
              or the atom <c>unbound</c>. Logical processor identifiers
              are represented as integers. The <c>N</c>th
              element of the tuple equals the current binding for
              the scheduler with the scheduler identifier equal to
              <c>N</c>. For example, if the schedulers are bound,
              <c>element(erlang:system_info(scheduler_id),
              erlang:system_info(scheduler_bindings))</c> returns
              the identifier of the logical processor that the calling
              process is executing on.</p>
            <p>Notice that only schedulers online can be bound to logical
              processors.</p>
            <p>For more information, see command-line argument
              <seealso marker="erts:erl#+sbt"><c>+sbt</c></seealso>
              in <c>erl(1)</c> and
              <seealso marker="#system_info_schedulers_online">
              <c>erlang:system_info(schedulers_online)</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_scheduler_id"/>
            <c>scheduler_id</c></tag>
          <item>
            <p>Returns the scheduler ID (<c>SchedulerId</c>) of the
              scheduler thread that the calling process is executing
              on. <c><anno>SchedulerId</anno></c> is a positive integer,
              where <c><![CDATA[1 <= SchedulerId <=
              erlang:system_info(schedulers)]]></c>.</p>
            <p>See also
              <seealso marker="#system_info_schedulers">
              <c>erlang:system_info(schedulers)</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_schedulers"/>
            <c>schedulers</c></tag>
          <item>
            <p>Returns the number of scheduler threads used by
              the emulator. Scheduler threads online schedules Erlang
              processes and Erlang ports, and execute Erlang code
              and Erlang linked-in driver code.</p>
            <p>The number of scheduler threads is determined at
              emulator boot time and cannot be changed later.
              However, the number of schedulers online can
              be changed at any time.</p>
            <p>See also
              <seealso marker="#system_flag_schedulers_online">
              <c>erlang:system_flag(schedulers_online,
              SchedulersOnline)</c></seealso>,
              <seealso marker="#system_info_schedulers_online">
              <c>erlang:system_info(schedulers_online)</c></seealso>,
              <seealso marker="#system_info_scheduler_id">
              <c>erlang:system_info(scheduler_id)</c></seealso>,
              <seealso marker="#system_flag_multi_scheduling">
              <c>erlang:system_flag(multi_scheduling, BlockState)</c></seealso>,
              <seealso marker="#system_info_multi_scheduling">
              <c>erlang:system_info(multi_scheduling)</c></seealso>,
              <seealso marker="#system_info_normal_multi_scheduling_blockers">
              <c>erlang:system_info(normal_multi_scheduling_blockers)</c></seealso>
              and <seealso marker="#system_info_multi_scheduling_blockers">
              <c>erlang:system_info(multi_scheduling_blockers)</c></seealso>.
            </p>
          </item>
          <tag><marker id="system_info_schedulers_online"/>
            <c>schedulers_online</c></tag>
          <item>
            <p>Returns the number of schedulers online. The scheduler
              identifiers of schedulers online satisfy the relationship
              <c><![CDATA[1 <= SchedulerId <=
              erlang:system_info(schedulers_online)]]></c>.</p>
            <p>For more information, see
              <seealso marker="#system_info_schedulers">
              <c>erlang:system_info(schedulers)</c></seealso> and
              <seealso marker="#system_flag_schedulers_online">
              <c>erlang:system_flag(schedulers_online,
              SchedulersOnline)</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_smp_support"/>
            <c>smp_support</c></tag>
          <item>
            <p>Returns <c>true</c>.</p>
          </item>
          <tag><marker id="system_info_threads"/>
            <c>threads</c></tag>
          <item>
            <p>Returns <c>true</c>.</p>
          </item>
          <tag><marker id="system_info_thread_pool_size"/>
            <c>thread_pool_size</c></tag>
          <item>
            <marker id="system_info_thread_pool_size"></marker>
            <p>Returns the number of async threads in the async thread
              pool used for asynchronous driver calls
              (<seealso marker="erts:erl_driver#driver_async">
              <c>erl_driver:driver_async()</c></seealso>).
              The value is given as an integer.</p>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="system_info" arity="1" clause_i="14"
	    anchor="system_info_dist" since=""/>  <!-- creation -->
      <name name="system_info" arity="1" clause_i="16" since="OTP 18.0"/>  <!-- delayed_node_table_gc -->
      <name name="system_info" arity="1" clause_i="20" since=""/>  <!-- dist -->
      <name name="system_info" arity="1" clause_i="21" since="OTP R14B01"/>  <!-- dist_buf_busy_limit -->
      <name name="system_info" arity="1" clause_i="22" since=""/>  <!-- dist_ctrl -->
      <fsummary>Information about erlang distribution.</fsummary>
      <desc>
        <marker id="system_info_dist_tags"/>
        <p>Returns information about Erlang Distribution in the
        current system as specified by <c><anno>Item</anno></c>:</p>
        <taglist>
          <tag><marker id="system_info_creation"/>
            <c>creation</c></tag>
          <item>
            <p>Returns the creation of the local node as an integer.
              The creation is changed when a node is restarted. The
              creation of a node is stored in process identifiers, port
              identifiers, and references. This makes it (to some
              extent) possible to distinguish between identifiers from
              different incarnations of a node. The valid
              creations are integers in the range 1..3, but this will
              probably change in a future release. If the node is not
              alive, <c>0</c> is returned.</p>
          </item>
          <tag><marker id="system_info_delayed_node_table_gc"/>
            <c>delayed_node_table_gc</c></tag>
          <item>
            <p>Returns the amount of time in seconds garbage collection
              of an entry in a node table is delayed. This limit can be set
              on startup by passing command-line flag
              <seealso marker="erts:erl#+zdntgc"><c>+zdntgc</c></seealso>
              to <c>erl(1)</c>. For more information, see the documentation of
              the command-line flag.</p>
          </item>
          <tag><marker id="system_info_dist"/>
            <c>dist</c></tag>
          <item>
            <p>Returns a binary containing a string of distribution
              information formatted as in Erlang crash dumps. For more
              information, see section <seealso marker="erts:crash_dump">
              How to interpret the Erlang crash dumps</seealso>
              in the User's Guide.</p>
          </item>
          <tag><marker id="system_info_dist_buf_busy_limit"/>
            <c>dist_buf_busy_limit</c></tag>
          <item>
            <p>Returns the value of the distribution buffer busy limit
              in bytes. This limit can be set at startup by passing
              command-line flag
              <seealso marker="erts:erl#+zdbbl"><c>+zdbbl</c></seealso>
              to <c>erl(1)</c>.</p>
          </item>
          <tag><marker id="system_info_dist_ctrl"/>
            <c>dist_ctrl</c></tag>
          <item>
            <p>Returns a list of tuples
              <c>{<anno>Node</anno>, <anno>ControllingEntity</anno>}</c>,
              one entry for each connected remote node.
              <c><anno>Node</anno></c> is the node name
              and <c><anno>ControllingEntity</anno></c> is the port or process
              identifier responsible for the communication to that node.
              More specifically, <c><anno>ControllingEntity</anno></c> for
              nodes connected through TCP/IP (the normal case) is the socket
              used in communication with the specific node.</p>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <!-- <name name="system_info" arity="1" clause_i="1"/>   allocated_areas -->
      <!-- <name name="system_info" arity="1" clause_i="2"/>   allocated -->
      <!-- <name name="system_info" arity="1" clause_i="3"/>   {allocator, _} -->
      <!-- <name name="system_info" arity="1" clause_i="4"/>   alloc_util_allocators -->
      <!-- <name name="system_info" arity="1" clause_i="5"/>   {allocator_sizes, _} -->
      <!-- <name name="system_info" arity="1" clause_i="6"/>   atom_count -->
      <!-- <name name="system_info" arity="1" clause_i="7"/>   atom_limit -->
      <name name="system_info" arity="1" clause_i="8"
	    anchor="system_info_misc" since="OTP R14B"/>   <!-- build_type -->
      <name name="system_info" arity="1" clause_i="9" since=""/>   <!-- c_compiler_used -->
      <name name="system_info" arity="1" clause_i="10" since=""/>  <!-- check_io -->
      <name name="system_info" arity="1" clause_i="11" since=""/>  <!-- compat_rel -->
      <!-- <name name="system_info" arity="1" clause_i="12"/>  cpu_topology -->
      <!-- <name name="system_info" arity="1" clause_i="13"/>  {cpu_topology, _} -->
      <!-- <name name="system_info" arity="1" clause_i="14"/>  creation -->
      <name name="system_info" arity="1" clause_i="15" since=""/>  <!-- debug_compiled -->
      <!-- <name name="system_info" arity="1" clause_i="16"/>  delayed_node_table_gc -->
      <!-- <name name="system_info" arity="1" clause_i="17"/>  dirty_cpu_schedulers -->
      <!-- <name name="system_info" arity="1" clause_i="18"/>  dirty_cpu_schedulers_online -->
      <!-- <name name="system_info" arity="1" clause_i="19"/>  dirty_io_schedulers -->
      <!-- <name name="system_info" arity="1" clause_i="20"/>  dist -->
      <!-- <name name="system_info" arity="1" clause_i="21"/>  dist_buf_busy_limit -->
      <!-- <name name="system_info" arity="1" clause_i="22"/>  dist_ctrl -->
      <name name="system_info" arity="1" clause_i="23" since=""/>  <!-- driver_version -->
      <name name="system_info" arity="1" clause_i="24" since="OTP R15B01"/>  <!-- dynamic_trace -->
      <name name="system_info" arity="1" clause_i="25" since="OTP R15B01"/>  <!-- dynamic_trace_probes -->
      <!-- <name name="system_info" arity="1" clause_i="26"/>  end_time -->
      <!-- <name name="system_info" arity="1" clause_i="27"/>  elib_malloc -->
      <!-- <name name="system_info" arity="1" clause_i="28"/>  eager_check_io, removed -->
      <!-- <name name="system_info" arity="1" clause_i="29"/>  ets_count -->
      <!-- <name name="system_info" arity="1" clause_i="30"/>  ets_limit -->
      <!-- <name name="system_info" arity="1" clause_i="31"/>  fullsweep_after -->
      <!-- <name name="system_info" arity="1" clause_i="32"/>  garbage_collection -->
      <!-- <name name="system_info" arity="1" clause_i="33"/>  heap_sizes -->
      <!-- <name name="system_info" arity="1" clause_i="34"/>  heap_type -->
      <name name="system_info" arity="1" clause_i="35" since=""/>  <!-- info -->
      <name name="system_info" arity="1" clause_i="36" since=""/>  <!-- kernel_poll -->
      <name name="system_info" arity="1" clause_i="37" since=""/>  <!-- loaded -->
      <!-- <name name="system_info" arity="1" clause_i="38"/>  logical_processors -->
      <name name="system_info" arity="1" clause_i="39" since=""/>  <!-- machine -->
      <!-- <name name="system_info" arity="1" clause_i="40"/>  max_heap_size -->
      <!-- <name name="system_info" arity="1" clause_i="41"/>  message_queue_data -->
      <!-- <name name="system_info" arity="1" clause_i="42"/>  min_heap_size -->
      <!-- <name name="system_info" arity="1" clause_i="43"/>  min_bin_vheap_size -->
      <name name="system_info" arity="1" clause_i="44" since=""/>  <!-- modified_timing_level -->
      <!-- <name name="system_info" arity="1" clause_i="45"/>  multi_scheduling -->
      <!-- <name name="system_info" arity="1" clause_i="46"/>  multi_scheduling_blockers -->
      <name name="system_info" arity="1" clause_i="47" since="OTP 17.4"/>  <!-- nif_version -->
      <!-- n<name name="system_info" arity="1" clause_i="48"/>  ormal_multi_scheduling_blockers -->
      <name name="system_info" arity="1" clause_i="49" since=""/>  <!-- otp_release -->
      <!-- <name name="system_info" arity="1" clause_i="50"/>  os_monotonic_time_source -->
      <!-- <name name="system_info" arity="1" clause_i="51"/>  os_system_time_source -->
      <name name="system_info" arity="1" clause_i="52" since="OTP R16B"/>  <!-- port_parallelism -->
      <!-- <name name="system_info" arity="1" clause_i="53"/>  port_count -->
      <!-- <name name="system_info" arity="1" clause_i="54"/>  port_limit -->
      <!-- <name name="system_info" arity="1" clause_i="55"/>  process_count -->
      <!-- <name name="system_info" arity="1" clause_i="56"/>  process_limit -->
      <!-- <name name="system_info" arity="1" clause_i="57"/>  procs -->
      <!-- <name name="system_info" arity="1" clause_i="58"/>  scheduler_bind_type -->
      <!-- <name name="system_info" arity="1" clause_i="59"/>  scheduler_bindings -->
      <!-- <name name="system_info" arity="1" clause_i="60"/>  scheduler_id -->
      <!-- <name name="system_info" arity="1" clause_i="61"/>  schedulers -->
      <!-- <name name="system_info" arity="1" clause_i="62"/>  smp_support -->
      <!-- <name name="system_info" arity="1" clause_i="63"/>  start_time -->
      <name name="system_info" arity="1" clause_i="64" since=""/>  <!-- system_architecture -->
      <name name="system_info" arity="1" clause_i="65" since="OTP 21.3"/>  <!-- system_logger -->
      <name name="system_info" arity="1" clause_i="66" since=""/>  <!-- system_version -->
      <!-- <name name="system_info" arity="1" clause_i="67"/>  threads -->
      <!-- <name name="system_info" arity="1" clause_i="68"/>  thread_pool_size -->
      <!-- <name name="system_info" arity="1" clause_i="69"/>  time_correction -->
      <!-- <name name="system_info" arity="1" clause_i="70"/>  time_offset -->
      <!-- <name name="system_info" arity="1" clause_i="71"/>  time_warp_mode -->
      <!-- <name name="system_info" arity="1" clause_i="72"/>  tolerant_timeofday -->
      <name name="system_info" arity="1" clause_i="73" since=""/>  <!-- trace_control_word -->
      <!-- <name name="system_info" arity="1" clause_i="74"/>  update_cpu_info -->
      <name name="system_info" arity="1" clause_i="75" since=""/>  <!-- version -->
      <name name="system_info" arity="1" clause_i="76" since=""/>  <!-- wordsize -->
      <!-- <name name="system_info" arity="1" clause_i="77"/>  overview -->
      <fsummary>Information about the system.</fsummary>
      <desc>
        <marker id="system_info_misc_tags"/>
        <p>Returns various information about the current system
          (emulator) as specified by <c><anno>Item</anno></c>:</p>
        <taglist>
          <tag><marker id="system_info_build_type"/>
            <c>build_type</c></tag>
          <item>
            <p>Returns an atom describing the build type of the runtime
              system. This is normally the atom <c>opt</c> for optimized.
              Other possible return values are <c>debug</c>, <c>purify</c>,
              <c>quantify</c>, <c>purecov</c>, <c>gcov</c>, <c>valgrind</c>,
              <c>gprof</c>, and <c>lcnt</c>. Possible return values
              can be added or removed at any time without prior notice.</p>
          </item>
          <tag><marker id="system_info_c_compiler_used"/>
            <c>c_compiler_used</c></tag>
          <item>
            <p>Returns a two-tuple describing the C compiler used when
              compiling the runtime system. The first element is an
              atom describing the name of the compiler, or <c>undefined</c>
              if unknown. The second element is a term describing the
              version of the compiler, or <c>undefined</c> if unknown.</p>
          </item>
          <tag><marker id="system_info_check_io"/>
            <c>check_io</c></tag>
          <item>
            <p>Returns a list containing miscellaneous information
              about the emulators internal I/O checking. Notice that
              the content of the returned list can vary between
              platforms and over time. It is only guaranteed
              that a list is returned.</p>
          </item>
          <tag><marker id="system_info_compat_rel"/>
            <c>compat_rel</c></tag>
          <item>
            <p>Returns the compatibility mode of the local node as
              an integer. The integer returned represents the
              Erlang/OTP release that the current emulator has been
              set to be backward compatible with. The compatibility
              mode can be configured at startup by using command-line flag
              <seealso marker="erts:erl#compat_rel"><c>+R</c></seealso> in
              <c>erl(1)</c>.</p>
          </item>
          <tag><marker id="system_info_debug_compiled"/>
            <c>debug_compiled</c></tag>
          <item>
            <p>Returns <c>true</c> if the emulator has been
              debug-compiled, otherwise <c>false</c>.</p>
          </item>
          <tag><marker id="system_info_driver_version"/>
            <c>driver_version</c></tag>
          <item>
            <p>Returns a string containing the Erlang driver version
              used by the runtime system. It has the form
              <seealso marker="erts:erl_driver#version_management">
              "&lt;major ver&gt;.&lt;minor ver&gt;"</seealso>.</p>
          </item>
          <tag><marker id="system_info_dynamic_trace"/>
            <c>dynamic_trace</c></tag>
          <item>
            <p>Returns an atom describing the dynamic trace framework
              compiled into the virtual machine. It can be
              <c>dtrace</c>, <c>systemtap</c>, or <c>none</c>. For a
              commercial or standard build, it is always <c>none</c>.
              The other return values indicate a custom configuration
              (for example, <c>./configure --with-dynamic-trace=dtrace</c>).
              For more information about dynamic tracing, see
              <seealso marker="runtime_tools:dyntrace">
              <c>dyntrace(3)</c></seealso> manual page and the
              <c>README.dtrace</c>/<c>README.systemtap</c> files in the
              Erlang source code top directory.</p>
          </item>
          <tag><marker id="system_info_dynamic_trace_probes"/>
            <c>dynamic_trace_probes</c></tag>
          <item>
            <p>Returns a <c>boolean()</c> indicating if dynamic trace
              probes (<c>dtrace</c> or <c>systemtap</c>) are built into
              the emulator. This can only be <c>true</c> if the virtual
              machine was built for dynamic tracing (that is,
              <c>system_info(dynamic_trace)</c> returns
              <c>dtrace</c> or <c>systemtap</c>).</p>
          </item>
          <tag><marker id="system_info_info"/>
            <c>info</c></tag>
          <item>
            <p>Returns a binary containing a string of miscellaneous
              system information formatted as in Erlang crash dumps.
              For more information, see section
              <seealso marker="erts:crash_dump">
              How to interpret the Erlang crash dumps</seealso>
              in the User's Guide.</p>
          </item>
          <tag><marker id="system_info_kernel_poll"/>
            <c>kernel_poll</c></tag>
          <item>
            <p>Returns <c>true</c> if the emulator uses some kind of
              kernel-poll implementation, otherwise <c>false</c>.</p>
          </item>
          <tag><marker id="system_info_loaded"/>
            <c>loaded</c></tag>
          <item>
            <p>Returns a binary containing a string of loaded module
              information formatted as in Erlang crash dumps. For more
              information, see section
              <seealso marker="erts:crash_dump">How to interpret the Erlang
              crash dumps</seealso> in the User's Guide.</p>
          </item>
          <tag><marker id="system_info_machine"/>
            <c>machine</c></tag>
          <item>
            <p>Returns a string containing the Erlang machine name.</p>
          </item>
          <tag><marker id="system_info_modified_timing_level"/>
            <c>modified_timing_level</c></tag>
          <item>
            <p>Returns the modified timing-level (an integer) if
              modified timing is enabled, otherwise <c>undefined</c>.
              For more information about modified timing, see
              command-line flag
              <seealso marker="erts:erl#+T"><c>+T</c></seealso>
              in <c>erl(1)</c></p>
          </item>
          <tag><marker id="system_info_nif_version"/>
            <c>nif_version</c></tag>
          <item>
            <p>Returns a string containing the version of the Erlang NIF
              interface used by the runtime system. It is on the form
              "&lt;major ver&gt;.&lt;minor ver&gt;".</p>
          </item>
          <tag><marker id="system_info_otp_release"/>
            <c>otp_release</c></tag>
          <item>
            <marker id="system_info_otp_release"></marker>
            <p>Returns a string containing the OTP release number of the
              OTP release that the currently executing ERTS application
              is part of.</p>
            <p>As from Erlang/OTP 17, the OTP release number corresponds to
              the major OTP version number. No
              <c>erlang:system_info()</c> argument gives the exact OTP
              version. This is because the exact OTP version in the general case
              is difficult to determine. For more information, see the
              description of versions in
              <seealso marker="doc/system_principles:versions">
              System principles</seealso> in System Documentation.</p>
          </item>
          <tag><marker id="system_info_port_parallelism"/>
            <c>port_parallelism</c></tag>
          <item>
            <p>Returns the default port parallelism scheduling hint used.
              For more information, see command-line argument
              <seealso marker="erl#+spp"><c>+spp</c></seealso>
              in <c>erl(1)</c>.</p>
          </item>
          <tag><marker id="system_info_system_architecture"/>
            <c>system_architecture</c></tag>
          <item>
            <p>Returns a string containing the processor and OS
              architecture the emulator is built for.</p>
          </item>
          <tag><marker id="system_info_system_logger"/>
            <c>system_logger</c></tag>
          <item>
            <p>Returns the current <c>system_logger</c> as set by
            <seealso marker="#system_flag/2"><c>erlang:system_flag(system_logger, _)</c></seealso>.</p>
          </item>
          <tag><marker id="system_info_system_version"/>
            <c>system_version</c></tag>
          <item>
            <p>Returns a string containing version number and
              some important properties, such as the number of schedulers.</p>
          </item>
          <tag><marker id="system_info_trace_control_word"/>
            <c>trace_control_word</c></tag>
          <item>
            <p>Returns the value of the node trace control word. For
              more information, see function <c>get_tcw</c> in section
              <seealso marker="erts:match_spec#get_tcw">
              Match Specifications in Erlang</seealso> in the User's Guide.</p>
          </item>
          <tag><marker id="system_info_version"/>
            <c>version</c></tag>
          <item>
            <p>Returns a string containing the version number of the
              emulator.</p>
          </item>
          <tag><marker id="system_info_wordsize"/>
            <c>wordsize</c></tag>
          <item>
            <p>Same as <c>{wordsize, internal}</c>.</p>
          </item>
          <tag><c>{wordsize, internal}</c></tag>
          <item>
            <p>Returns the size of Erlang term words in bytes as an
              integer, that is, 4 is returned on a 32-bit architecture,
              and 8 is returned on a pure 64-bit architecture. On a
              halfword 64-bit emulator, 4 is returned, as the Erlang
              terms are stored using a virtual word size of half the
              system word size.</p>
          </item>
          <tag><c>{wordsize, external}</c></tag>
          <item>
            <p>Returns the true word size of the emulator, that is,
              the size of a pointer. The value is given in bytes
              as an integer. On a pure 32-bit architecture, 4 is
              returned. On both a half word and on a pure
              64-bit architecture, 8 is returned.</p>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="system_monitor" arity="0" since=""/>
      <fsummary>Current system performance monitoring settings.</fsummary>
      <type name="system_monitor_option"/>
      <desc>
        <p>Returns the current system monitoring settings set by
          <seealso marker="#system_monitor/2">
          <c>erlang:system_monitor/2</c></seealso>
          as <c>{<anno>MonitorPid</anno>, <anno>Options</anno>}</c>,
          or <c>undefined</c> if no settings exist. The order of the
          options can be different from the one that was set.</p>
      </desc>
    </func>

    <func>
      <name name="system_monitor" arity="1" since=""/>
      <fsummary>Set or clear system performance monitoring options.</fsummary>
      <type name="system_monitor_option"/>
      <desc>
        <p>When called with argument <c>undefined</c>, all
          system performance monitoring settings are cleared.</p>
        <p>Calling the function with <c>{<anno>MonitorPid</anno>,
          <anno>Options</anno>}</c> as argument is the same as calling
          <seealso marker="#system_monitor/2">
          <c>erlang:system_monitor(<anno>MonitorPid</anno>,
          <anno>Options</anno>)</c></seealso>.</p>
        <p>Returns the previous system monitor settings just like
          <seealso marker="#system_monitor/0">
          <c>erlang:system_monitor/0</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="system_monitor" arity="2" since=""/>
      <fsummary>Set system performance monitoring options.</fsummary>
      <type name="system_monitor_option"/>
      <desc>
        <p>Sets the system performance monitoring options.
          <c><anno>MonitorPid</anno></c> is a local process identifier (pid)
          receiving system monitor messages. The
          second argument is a list of monitoring options:</p>
        <taglist>
          <tag><c>{long_gc, Time}</c></tag>
          <item>
            <p>If a garbage collection in the system takes at least
              <c>Time</c> wall clock milliseconds, a message
              <c>{monitor, GcPid, long_gc, Info}</c> is sent to
              <c><anno>MonitorPid</anno></c>. <c>GcPid</c> is the pid that
              was garbage collected. <c>Info</c> is a list of two-element
              tuples describing the result of the garbage collection.</p>
            <p>One of the tuples is <c>{timeout, GcTime}</c>, where
              <c>GcTime</c> is the time for the garbage
              collection in milliseconds. The other tuples are
              tagged with <c>heap_size</c>, <c>heap_block_size</c>,
              <c>stack_size</c>, <c>mbuf_size</c>, <c>old_heap_size</c>,
              and <c>old_heap_block_size</c>. These tuples are
              explained in the description of trace message
              <seealso marker="#gc_minor_start"><c>gc_minor_start</c></seealso>
              (see <seealso marker="#trace/3"><c>erlang:trace/3</c></seealso>).
              New tuples can be added, and the order of the tuples in
              the <c>Info</c> list can be changed at any time without
              prior notice.</p>
          </item>
          <tag><c>{long_schedule, Time}</c></tag>
          <item>
            <p>If a process or port in the system runs uninterrupted
              for at least <c>Time</c> wall clock milliseconds, a
              message <c>{monitor, PidOrPort, long_schedule, Info}</c>
              is sent to <c>MonitorPid</c>. <c>PidOrPort</c> is the
              process or port that was running. <c>Info</c> is a
              list of two-element tuples describing the event.</p>
            <p>If a <c>pid()</c>, the tuples <c>{timeout, Millis}</c>,
              <c>{in, Location}</c>, and <c>{out, Location}</c> are
              present, where <c>Location</c> is either an MFA
              (<c>{Module, Function, Arity}</c>) describing the
              function where the process was scheduled in/out, or the
              atom <c>undefined</c>.</p>
            <p>If a <c>port()</c>, the
              tuples <c>{timeout, Millis}</c> and <c>{port_op,Op}</c>
              are present. <c>Op</c> is one of <c>proc_sig</c>,
              <c>timeout</c>, <c>input</c>, <c>output</c>,
              <c>event</c>, or <c>dist_cmd</c>, depending on which
              driver callback was executing.</p>
            <p><c>proc_sig</c> is an
              internal operation and is never to appear, while the
              others represent the corresponding driver callbacks
              <c>timeout</c>, <c>ready_input</c>, <c>ready_output</c>,
              <c>event</c>, and <c>outputv</c> (when the port
              is used by distribution). Value <c>Millis</c> in
              tuple <c>timeout</c> informs about the
              uninterrupted execution time of the process or port, which
              always is equal to or higher than the <c>Time</c> value
              supplied when starting the trace. New tuples can be
              added to the <c>Info</c> list in a future release. The
              order of the tuples in the list can be changed at any
              time without prior notice.</p>
            <p>This can be used to detect problems with NIFs or
              drivers that take too long to execute. 1 ms is
              considered a good maximum time for a driver callback
              or a NIF. However, a time-sharing system is usually to
              consider everything &lt; 100 ms as "possible" and
              fairly "normal". However, longer schedule times can
              indicate swapping or a misbehaving NIF/driver.
              Misbehaving NIFs and drivers can cause bad resource
              utilization and bad overall system performance.</p>
          </item>
          <tag><c>{large_heap, Size}</c></tag>
          <item>
            <p>If a garbage collection in the system results in
              the allocated size of a heap being at least <c>Size</c>
              words, a message <c>{monitor, GcPid, large_heap, Info}</c>
              is sent to <c><anno>MonitorPid</anno></c>.
              <c>GcPid</c> and <c>Info</c>
              are the same as for <c>long_gc</c> earlier, except that
              the tuple tagged with <c>timeout</c> is not present.</p>
            <p>The monitor message is sent if the sum of the sizes of
              all memory blocks allocated for all heap generations after
              a garbage collection is equal to or higher than <c>Size</c>.</p>
            <p>When a process is killed by
              <seealso marker="#process_flag_max_heap_size">
              <c>max_heap_size</c></seealso>, it is killed before the
              garbage collection is complete and thus no large heap message
              is sent.</p>
          </item>
          <tag><c>busy_port</c></tag>
          <item>
            <p>If a process in the system gets suspended because it
              sends to a busy port, a message
              <c>{monitor, SusPid, busy_port, Port}</c> is sent to
              <c><anno>MonitorPid</anno></c>. <c>SusPid</c> is the pid
              that got suspended when sending to <c>Port</c>.</p>
          </item>
          <tag><c>busy_dist_port</c></tag>
          <item>
            <p>If a process in the system gets suspended because it
              sends to a process on a remote node whose inter-node
              communication was handled by a busy port, a message
              <c>{monitor, SusPid, busy_dist_port, Port}</c> is sent to
              <c><anno>MonitorPid</anno></c>. <c>SusPid</c> is the pid
              that got suspended when sending through the inter-node
              communication port <c>Port</c>.</p>
          </item>
        </taglist>
        <p>Returns the previous system monitor settings just like
          <seealso marker="#system_monitor/0">
          <c>erlang:system_monitor/0</c></seealso>.</p>
	<p>The arguments to <c>system_monitor/2</c> specifies how all
	  system monitoring on the node should be done, not how it should be
	  changed. This means only one process at a time
	  (<c><anno>MonitorPid</anno></c>) can be the receiver of system monitor
	  messages. Also, the way to clear a specific monitor option
	  is to not include it in the list <c><anno>Options</anno></c>. All
	  system monitoring will, however, be cleared if the process identified by
	  <c><anno>MonitorPid</anno></c> terminates.</p>
	<p>There are no special option values (like zero) to clear an option.
	  Some of the options have a unspecified minimum value. Lower values
	  will be adjusted to the minimum value. For example, it is currently not
	  possible to monitor all garbage collections with <c>{long_gc, 0}</c>.</p>
        <note>
          <p>If a monitoring process gets so large that it itself
            starts to cause system monitor messages when garbage
            collecting, the messages enlarge the process
            message queue and probably make the problem worse.</p>
          <p>Keep the monitoring process neat and do not set the system
            monitor limits too tight.</p>
        </note>
        <p>Failures:</p>
        <taglist>
          <tag><c>badarg</c></tag>
          <item>If <c><anno>MonitorPid</anno></c> does not exist.</item>
          <tag><c>badarg</c></tag>
          <item>If <c><anno>MonitorPid</anno></c> is not a local process.</item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="system_profile" arity="0" since=""/>
      <fsummary>Current system profiling settings.</fsummary>
      <type name="system_profile_option"/>
      <desc>
        <p>Returns the current system profiling settings set by
          <seealso marker="#system_profile/2">
          <c>erlang:system_profile/2</c></seealso>
          as <c>{<anno>ProfilerPid</anno>, <anno>Options</anno>}</c>,
          or <c>undefined</c> if there
          are no settings. The order of the options can be different
          from the one that was set.</p>
      </desc>
    </func>

    <func>
      <name name="system_profile" arity="2" since=""/>
      <fsummary>Current system profiling settings.</fsummary>
      <type name="system_profile_option"/>
      <desc>
        <p>Sets system profiler options. <c><anno>ProfilerPid</anno></c>
          is a local process identifier (pid) or port receiving profiling
          messages. The receiver is excluded from all profiling.
          The second argument is a list of profiling options:</p>
        <taglist>
          <tag><c>exclusive</c></tag>
          <item>
            <p>If a synchronous call to a port from a process is done, the
              calling process is considered not runnable during the call
              runtime to the port. The calling process is notified as
              <c>inactive</c>, and later <c>active</c> when the port
              callback returns.</p>
          </item>
          <tag><c>monotonic_timestamp</c></tag>
          <item>
            <p>Time stamps in profile messages use
              <seealso marker="time_correction#Erlang_Monotonic_Time">Erlang
              monotonic time</seealso>. The time stamp (Ts) has the same
              format and value as produced by
              <c>erlang:monotonic_time(nanosecond)</c>.</p>
          </item>
          <tag><c>runnable_procs</c></tag>
          <item>
            <p>If a process is put into or removed from the run queue, a
              message, <c>{profile, Pid, State, Mfa, Ts}</c>, is sent to
              <c><anno>ProfilerPid</anno></c>. Running processes that
              are reinserted into the run queue after having been
              pre-empted do not trigger this message.</p>
          </item>
          <tag><c>runnable_ports</c></tag>
          <item>
            <p>If a port is put into or removed from the run queue, a 
              message, <c>{profile, Port, State, 0, Ts}</c>, is sent to
              <c><anno>ProfilerPid</anno></c>.</p>
          </item>
          <tag><c>scheduler</c></tag>
          <item>
            <p>If a scheduler is put to sleep or awoken, a message,
              <c>{profile, scheduler, Id, State, NoScheds, Ts}</c>, is
              sent to <c><anno>ProfilerPid</anno></c>.</p>
          </item>
          <tag><c>strict_monotonic_timestamp</c></tag>
          <item>
            <p>Time stamps in profile messages consist of
              <seealso marker="time_correction#Erlang_Monotonic_Time">Erlang
              monotonic time</seealso> and a monotonically increasing
              integer. The time stamp (Ts) has the same format and value
              as produced by <c>{erlang:monotonic_time(nanosecond),
              erlang:unique_integer([monotonic])}</c>.</p>
          </item>
          <tag><c>timestamp</c></tag>
          <item>
            <p>Time stamps in profile messages include a
              time stamp (Ts) that has the same form as returned by
              <c>erlang:now()</c>. This is also the default if no
              time stamp flag is specified. If <c>cpu_timestamp</c> has
              been enabled through
              <seealso marker="#trace/3"><c>erlang:trace/3</c></seealso>,
              this also effects the time stamp produced in profiling messages
              when flag <c>timestamp</c> is enabled.</p>
          </item>
        </taglist>
        <note>
          <p><c>erlang:system_profile</c> behavior can change
            in a future release.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="system_time" arity="0" since="OTP 18.0"/>
      <fsummary>Current Erlang system time.</fsummary>
      <desc>
        <p>Returns current
          <seealso marker="time_correction#Erlang_System_Time">
          Erlang system time</seealso> in <c>native</c>
          <seealso marker="#type_time_unit">time unit</seealso>.</p>
        <p>Calling <c>erlang:system_time()</c> is equivalent to
          <seealso marker="#monotonic_time/0">
          <c>erlang:monotonic_time()</c></seealso><c> +
          </c><seealso marker="#time_offset/0">
          <c>erlang:time_offset()</c></seealso>.</p>
        <note>
          <p>This time is <em>not</em> a monotonically increasing time
            in the general case. For more information, see the documentation of
            <seealso marker="time_correction#Time_Warp_Modes">
            time warp modes</seealso> in the User's Guide.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="system_time" arity="1" since="OTP 18.0"/>
      <fsummary>Current Erlang system time.</fsummary>
      <desc>
        <p>Returns current
          <seealso marker="time_correction#Erlang_System_Time">
          Erlang system time</seealso>
          converted into the <c><anno>Unit</anno></c> passed as argument.</p>
        <p>Calling <c>erlang:system_time(<anno>Unit</anno>)</c> is equivalent
          to <seealso marker="#convert_time_unit/3">
          <c>erlang:convert_time_unit</c></seealso><c>(</c><seealso
          marker="#system_time/0"><c>erlang:system_time()</c></seealso><c>,
          native, <anno>Unit</anno>)</c>.</p>
        <note>
          <p>This time is <em>not</em> a monotonically increasing time
            in the general case. For more information, see the documentation of
            <seealso marker="time_correction#Time_Warp_Modes">
            time warp modes</seealso> in the User's Guide.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="term_to_binary" arity="1" since=""/>
      <fsummary>Encode a term to an Erlang external term format binary.
      </fsummary>
      <desc>
        <p>Returns a binary data object that is the result of encoding
          <c><anno>Term</anno></c> according to the
          <seealso marker="erts:erl_ext_dist">Erlang external
          term format.</seealso></p>
        <p>This can be used for various purposes, for example,
          writing a term to a file in an efficient way, or sending an
          Erlang term to some type of communications channel not
          supported by distributed Erlang.</p>
        <pre>
> <input>Bin = term_to_binary(hello).</input>
&lt;&lt;131,100,0,5,104,101,108,108,111>>
> <input>hello = binary_to_term(Bin).</input>
hello
</pre>
        <p>See also <seealso marker="#binary_to_term/1">
          <c>binary_to_term/1</c></seealso>.</p>
        <note>
          <p>There is no guarantee that this function will return
            the same encoded representation for the same term.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="term_to_binary" arity="2" since=""/>
      <fsummary>Encode a term to en Erlang external term format binary.
      </fsummary>
      <desc>
        <p>Returns a binary data object that is the result of encoding
          <c><anno>Term</anno></c> according to the Erlang external
          term format.</p>
        <p>If option <c>compressed</c> is provided, the external term
          format is compressed. The compressed format is automatically
          recognized by <c>binary_to_term/1</c> as from Erlang/OTP R7B.</p>
        <p>A compression level can be specified by giving option
          <c>{compressed, <anno>Level</anno>}</c>.
          <c><anno>Level</anno></c> is an integer
          with range 0..9, where:</p>
        <list type="bulleted">
          <item><p><c>0</c> - No compression is done (it is the same as
            giving no <c>compressed</c> option).</p></item>
          <item><p><c>1</c> - Takes least time but may not compress
            as well as the higher levels.</p></item>
          <item><p><c>6</c> - Default level when option <c>compressed</c>
            is provided.</p></item>
          <item><p><c>9</c> - Takes most time and tries to produce a smaller
            result. Notice "tries" in the preceding sentence; depending
            on the input term, level 9 compression either does or does
            not produce a smaller result than level 1 compression.</p></item>
        </list>
        <p>Option <c>{minor_version, <anno>Version</anno>}</c>
          can be used to control some
          encoding details. This option was introduced in Erlang/OTP R11B-4.
          The valid values for <c><anno>Version</anno></c> are:</p>
	  <taglist>
	    <tag><c>0</c></tag>
	    <item>
              <p>Floats are encoded using a textual representation.
	      This option is useful to ensure that releases before Erlang/OTP
	      R11B-4 can decode resulting binary.</p>
	      <p>This version encode atoms that can be represented by a
	      latin1 string using latin1 encoding while only atoms that
	      cannot be represented by latin1 are encoded using utf8.</p>
	    </item>
	    <tag><c>1</c></tag>
	    <item>
              <p>This is as of Erlang/OTP 17.0 the default. It forces any floats
	      in the term to be encoded in a more space-efficient and exact way
	      (namely in the 64-bit IEEE format, rather than converted to a
	      textual representation). As from Erlang/OTP R11B-4,
	      <c>binary_to_term/1</c> can decode this representation.</p>
	      <p>This version encode atoms that can be represented by a
	      latin1 string using latin1 encoding while only atoms that
	      cannot be represented by latin1 are encoded using utf8.</p>
	    </item>
	    <tag><c>2</c></tag>
	    <item>
              <p>Drops usage of the latin1 atom encoding and unconditionally
	      use utf8 encoding for all atoms. This will be changed to the
	      default in a future major release of Erlang/OTP. Erlang/OTP
	      systems as of R16B can decode this representation.</p>
	    </item>
	  </taglist>
        <p>See also <seealso marker="#binary_to_term/1">
          <c>binary_to_term/1</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="throw" arity="1" since=""/>
      <fsummary>Throw an exception.</fsummary>
      <desc>
        <p>A non-local return from a function. If evaluated within a
          <c>catch</c>, <c>catch</c> returns value <c><anno>Any</anno></c>.
          Example:</p>
        <pre>
> <input>catch throw({hello, there}).</input>
{hello,there}</pre>
        <p>Failure: <c>nocatch</c> if not evaluated within a catch.</p>
      </desc>
    </func>

    <func>
      <name name="time" arity="0" since=""/>
      <fsummary>Current time.</fsummary>
      <desc>
        <p>Returns the current time as <c>{Hour, Minute, Second}</c>.</p>
        <p>The time zone and Daylight Saving Time correction depend on
          the underlying OS. Example:</p>
        <pre>
> <input>time().</input>
{9,42,44}</pre>
      </desc>
    </func>

    <func>
      <name name="time_offset" arity="0" since="OTP 18.0"/>
      <fsummary>Current time offset.</fsummary>
      <desc>
        <p>Returns the current time offset between
          <seealso marker="time_correction#Erlang_Monotonic_Time">
          Erlang monotonic time</seealso> and
          <seealso marker="time_correction#Erlang_System_Time">
          Erlang system time</seealso> in
          <c>native</c> <seealso marker="#type_time_unit">time unit</seealso>.
          Current time offset added to an Erlang monotonic time gives
          corresponding Erlang system time.</p>
        <p>The time offset may or may not change during operation depending
          on the <seealso marker="time_correction#Time_Warp_Modes">time
          warp mode</seealso> used.</p>
        <note>
          <p>A change in time offset can be observed at slightly
            different points in time by different processes.</p>
          <p>If the runtime system is in
            <seealso marker="time_correction#Multi_Time_Warp_Mode">multi-time
            warp mode</seealso>, the time offset is changed when
            the runtime system detects that the
            <seealso marker="time_correction#OS_System_Time">OS system
            time</seealso> has changed. The runtime system will, however,
            not detect this immediately when it occurs. A task checking
            the time offset is scheduled to execute at least once a minute;
            so, under normal operation this is to be detected within a
            minute, but during heavy load it can take longer time.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="time_offset" arity="1" since="OTP 18.0"/>
      <fsummary>Current time offset.</fsummary>
      <desc>
        <p>Returns the current time offset between
          <seealso marker="time_correction#Erlang_Monotonic_Time">
          Erlang monotonic time</seealso> and
          <seealso marker="time_correction#Erlang_System_Time">
          Erlang system time</seealso>
          converted into the <c><anno>Unit</anno></c> passed as argument.</p>
        <p>Same as calling
          <seealso marker="#convert_time_unit/3">
          <c>erlang:convert_time_unit</c></seealso><c>(</c><seealso marker="#time_offset/0">
          <c>erlang:time_offset()</c></seealso><c>, native,
          <anno>Unit</anno>)</c>
          however optimized for commonly used <c><anno>Unit</anno></c>s.</p>
      </desc>
    </func>

    <func>
      <name name="timestamp" arity="0" since="OTP 18.0"/>
      <fsummary>Current Erlang System time.</fsummary>
      <type name="timestamp"/>
      <desc>
        <p>Returns current
          <seealso marker="time_correction#Erlang_System_Time">
          Erlang system time</seealso>
          on the format <c>{MegaSecs, Secs, MicroSecs}</c>. This format is 
          the same as <seealso marker="kernel:os#timestamp/0">
          <c>os:timestamp/0</c></seealso>
          and the deprecated <seealso marker="#now/0">
          <c>erlang:now/0</c></seealso>
          use. The reason for the existence of <c>erlang:timestamp()</c> is
          purely to simplify use for existing code that assumes this time stamp
          format. Current Erlang system time can more efficiently be retrieved
          in the time unit of your choice using
          <seealso marker="#system_time/1">
          <c>erlang:system_time/1</c></seealso>.</p>
        <p>The <c>erlang:timestamp()</c> BIF is equivalent to:</p>
<code type="none">
timestamp() ->
    ErlangSystemTime = erlang:system_time(microsecond),
    MegaSecs = ErlangSystemTime div 1000000000000,
    Secs = ErlangSystemTime div 1000000 - MegaSecs*1000000,
    MicroSecs = ErlangSystemTime rem 1000000,
    {MegaSecs, Secs, MicroSecs}.</code>
        <p>It, however, uses a native implementation that does
          not build garbage on the heap and with slightly better
          performance.</p>
        <note>
          <p>This time is <em>not</em> a monotonically increasing time
            in the general case. For more information, see the documentation of
            <seealso marker="time_correction#Time_Warp_Modes">
            time warp modes</seealso> in the User's Guide.</p>
	</note>
      </desc>
    </func>

    <func>
      <name name="tl" arity="1" since=""/>
      <fsummary>Tail of a list.</fsummary>
      <desc>
        <p>Returns the tail of <c><anno>List</anno></c>, that is,
          the list minus the first element, for example:</p>
        <pre>
> <input>tl([geesties, guilies, beasties]).</input>
[guilies, beasties]</pre>
        <p>Allowed in guard tests.</p>
        <p>Failure: <c>badarg</c> if <c><anno>List</anno></c>
          is the empty list <c>[]</c>.</p>
      </desc>
    </func>

    <func>
      <name name="trace" arity="3" since=""/>
      <fsummary>Set trace flags for a process or processes.</fsummary>
      <type name="trace_flag"/>
      <desc>
        <p>Turns on (if <c><anno>How</anno> == true</c>) or off (if
          <c><anno>How</anno> == false</c>) the trace flags in
          <c><anno>FlagList</anno></c> for
          the process or processes represented by
          <c><anno>PidPortSpec</anno></c>.</p>
        <p><c><anno>PidPortSpec</anno></c> is either a process identifier
          (pid) for a local process, a port identifier,
          or one of the following atoms:</p>
        <taglist>
          <tag><c>all</c></tag>
          <item>All currently existing processes and ports and all that
            will be created in the future.
          </item>
          <tag><c>processes</c></tag>
          <item>All currently existing processes and all that will be created
            in the future.
          </item>
          <tag><c>ports</c></tag>
          <item>All currently existing ports and all that will be created in
            the future.
          </item>
          <tag><c>existing</c></tag>
          <item>All currently existing processes and ports.
          </item>
          <tag><c>existing_processes</c></tag>
          <item>All currently existing processes.
          </item>
          <tag><c>existing_ports</c></tag>
          <item>All currently existing ports.
          </item>
          <tag><c>new</c></tag>
          <item>All processes and ports that will be created in the future.
          </item>
          <tag><c>new_processes</c></tag>
          <item>All processes that will be created in the future.
          </item>
          <tag><c>new_ports</c></tag>
          <item>All ports that will be created in the future.
          </item>
        </taglist>
        <p><c><anno>FlagList</anno></c> can contain any number of the
          following flags (the "message tags" refers to the list of
          <seealso marker="#trace_3_trace_messages">
          <c>trace messages</c></seealso>):</p>
        <taglist>
          <tag><c>all</c></tag>
          <item>
            <p>Sets all trace flags except <c>tracer</c> and
              <c>cpu_timestamp</c>, which are in their nature different
              than the others.</p>
          </item>
          <tag><c>send</c></tag>
          <item>
            <p>Traces sending of messages.</p>
            <p>Message tags:
              <seealso marker="#trace_3_trace_messages_send">
              <c>send</c></seealso> and
              <seealso marker="#trace_3_trace_messages_send_to_non_existing_process">
              <c>send_to_non_existing_process</c></seealso>.</p>
          </item>
          <tag><c>'receive'</c></tag>
          <item>
            <p>Traces receiving of messages.</p>
            <p>Message tags:
              <seealso marker="#trace_3_trace_messages_receive">
                <c>'receive'</c></seealso>.</p>
          </item>
          <tag><c>call</c></tag>
          <item>
            <p>Traces certain function calls. Specify which function
              calls to trace by calling <seealso marker="#trace_pattern/3">
              <c>erlang:trace_pattern/3</c></seealso>.</p>
            <p>Message tags:
              <seealso marker="#trace_3_trace_messages_call">
              <c>call</c></seealso> and
              <seealso marker="#trace_3_trace_messages_return_from">
              <c>return_from</c></seealso>.</p>
          </item>
          <tag><c>silent</c></tag>
          <item>
            <p>Used with the <c>call</c> trace flag.
              The <c>call</c>, <c>return_from</c>, and <c>return_to</c>
              trace messages are inhibited if this flag is set, but they
              are executed as normal if there are match specifications.</p>
            <p>Silent mode is inhibited by executing
              <c>erlang:trace(_, false, [silent|_])</c>,
              or by a match specification executing the function
              <c>{silent, false}</c>.</p>
            <p>The <c>silent</c> trace flag facilitates setting up
              a trace on many or even all processes in the system.
              The trace can then be activated and deactivated using the match
              specification function <c>{silent,Bool}</c>, giving
              a high degree of control of which functions with which 
              arguments that trigger the trace.</p>
            <p>Message tags:
              <seealso marker="#trace_3_trace_messages_call">
              <c>call</c></seealso>,
              <seealso marker="#trace_3_trace_messages_return_from">
              <c>return_from</c></seealso>, and
              <seealso marker="#trace_3_trace_messages_return_to">
              <c>return_to</c></seealso>. Or rather, the absence of.</p>
          </item>
          <tag><c>return_to</c></tag>
          <item>
            <p>Used with the <c>call</c> trace flag.
              Traces the return from a traced function back to
              its caller. Only works for functions traced with
              option <c>local</c> to <seealso marker="#trace_pattern/3">
              <c>erlang:trace_pattern/3</c></seealso>.</p>
            <p>The semantics is that a trace message is sent when a
              call traced function returns, that is, when a
              chain of tail recursive calls ends. Only one trace
              message is sent per chain of tail recursive calls,
              so the properties of tail recursiveness for
              function calls are kept while tracing with this flag.
              Using <c>call</c> and <c>return_to</c> trace together
              makes it possible to know exactly in which function a
              process executes at any time.</p>
            <p>To get trace messages containing return values from
              functions, use the <c>{return_trace}</c> match
              specification action instead.</p>
            <p>Message tags:
              <seealso marker="#trace_3_trace_messages_return_to">
              <c>return_to</c></seealso>.</p>
          </item>
          <tag><c>procs</c></tag>
          <item>
            <p>Traces process-related events.</p>
            <p>Message tags:
              <seealso marker="#trace_3_trace_messages_spawn">
              <c>spawn</c></seealso>,
              <seealso marker="#trace_3_trace_messages_spawned">
              <c>spawned</c></seealso>,
              <seealso marker="#trace_3_trace_messages_exit">
              <c>exit</c></seealso>,
              <seealso marker="#trace_3_trace_messages_register">
              <c>register</c></seealso>,
              <seealso marker="#trace_3_trace_messages_unregister">
              <c>unregister</c></seealso>,
              <seealso marker="#trace_3_trace_messages_link">
              <c>link</c></seealso>,
              <seealso marker="#trace_3_trace_messages_unlink">
              <c>unlink</c></seealso>,
              <seealso marker="#trace_3_trace_messages_getting_linked">
              <c>getting_linked</c></seealso>, and
              <seealso marker="#trace_3_trace_messages_getting_unlinked">
              <c>getting_unlinked</c></seealso>.</p>
          </item>
          <tag><c>ports</c></tag>
          <item>
            <p>Traces port-related events.</p>
            <p>Message tags:
              <seealso marker="#trace_3_trace_messages_open">
              <c>open</c></seealso>,
              <seealso marker="#trace_3_trace_messages_closed">
              <c>closed</c></seealso>,
              <seealso marker="#trace_3_trace_messages_register">
              <c>register</c></seealso>,
              <seealso marker="#trace_3_trace_messages_unregister">
              <c>unregister</c></seealso>,
              <seealso marker="#trace_3_trace_messages_getting_linked">
              <c>getting_linked</c></seealso>, and
              <seealso marker="#trace_3_trace_messages_getting_unlinked">
              <c>getting_unlinked</c></seealso>.</p>
          </item>
          <tag><c>running</c></tag>
          <item>
            <p>Traces scheduling of processes.</p>
            <p>Message tags:
              <seealso marker="#trace_3_trace_messages_in_proc">
              <c>in</c></seealso> and
              <seealso marker="#trace_3_trace_messages_out_proc">
              <c>out</c></seealso>.</p>
          </item>
          <tag><c>exiting</c></tag>
          <item>
            <p>Traces scheduling of exiting processes.</p>
            <p>Message tags:
              <seealso marker="#trace_3_trace_messages_in_exiting_proc">
              <c>in_exiting</c></seealso>,
              <seealso marker="#trace_3_trace_messages_out_exiting_proc">
              <c>out_exiting</c></seealso>, and
              <seealso marker="#trace_3_trace_messages_out_exited_proc">
              <c>out_exited</c></seealso>.</p>
          </item>
          <tag><c>running_procs</c></tag>
          <item>
            <p>Traces scheduling of processes just like <c>running</c>.
              However, this option also includes schedule events when the
              process executes within the context of a port without
              being scheduled out itself.</p>
            <p>Message tags:
              <seealso marker="#trace_3_trace_messages_in_proc">
              <c>in</c></seealso> and
              <seealso marker="#trace_3_trace_messages_out_proc">
              <c>out</c></seealso>.</p>
          </item>
          <tag><c>running_ports</c></tag>
          <item>
            <p>Traces scheduling of ports.</p>
            <p>Message tags:
              <seealso marker="#trace_3_trace_messages_in_port">
              <c>in</c></seealso> and
              <seealso marker="#trace_3_trace_messages_out_port">
              <c>out</c></seealso>.</p>
          </item>
          <tag><c>garbage_collection</c></tag>
          <item>
            <p>Traces garbage collections of processes.</p>
            <p>Message tags:
              <seealso marker="#trace_3_trace_messages_gc_minor_start">
              <c>gc_minor_start</c></seealso>,
              <seealso marker="#trace_3_trace_messages_gc_max_heap_size">
              <c>gc_max_heap_size</c></seealso>, and
              <seealso marker="#trace_3_trace_messages_gc_minor_end">
              <c>gc_minor_end</c></seealso>.</p>
          </item>
          <tag><c>timestamp</c></tag>
          <item>
            <p>Includes a time stamp in all trace messages. The
              time stamp (Ts) has the same form as returned by
              <c>erlang:now()</c>.</p>
          </item>
          <tag><c>cpu_timestamp</c></tag>
          <item>
            <p>A global trace flag for the Erlang node that makes all
              trace time stamps using flag <c>timestamp</c> to be
              in CPU time, not wall clock time. That is, <c>cpu_timestamp</c>
              is not be used if <c>monotonic_timestamp</c> or
              <c>strict_monotonic_timestamp</c> is enabled.
              Only allowed with <c><anno>PidPortSpec</anno>==all</c>. If the
              host machine OS does not support high-resolution
              CPU time measurements, <c>trace/3</c> exits with
              <c>badarg</c>. Notice that most OS do
              not synchronize this value across cores, so be prepared
              that time can seem to go backwards when using this option.</p>
          </item>
          <tag><c>monotonic_timestamp</c></tag>
          <item>
            <p>Includes an
              <seealso marker="time_correction#Erlang_Monotonic_Time">Erlang
              monotonic time</seealso> time stamp in all trace messages. The
              time stamp (Ts) has the same format and value as produced by
              <seealso marker="#monotonic_time-1">
              <c>erlang:monotonic_time(nanosecond)</c></seealso>.
              This flag overrides flag <c>cpu_timestamp</c>.</p>
          </item>
          <tag><c>strict_monotonic_timestamp</c></tag>
          <item>
            <p>Includes an time stamp consisting of
              <seealso marker="time_correction#Erlang_Monotonic_Time">Erlang
              monotonic time</seealso> and a monotonically increasing
              integer in all trace messages. The time stamp (Ts) has the
              same format and value as produced by <c>{</c>
              <seealso marker="#monotonic_time-1">
              <c>erlang:monotonic_time(nanosecond)</c></seealso><c>,</c>
              <seealso marker="#unique_integer-1">
              <c>erlang:unique_integer([monotonic])</c></seealso><c>}</c>.
              This flag overrides flag <c>cpu_timestamp</c>.</p>
          </item>
          <tag><c>arity</c></tag>
          <item>
            <p>Used with the <c>call</c> trace flag.
              <c>{M, F, Arity}</c> is specified instead of
              <c>{M, F, Args}</c> in call trace messages.</p>
          </item>
          <tag><c>set_on_spawn</c></tag>
          <item>
            <p>Makes any process created by a traced process inherit
              its trace flags, including flag <c>set_on_spawn</c>.</p>
          </item>
          <tag><c>set_on_first_spawn</c></tag>
          <item>
            <p>Makes the first process created by a traced process
              inherit its trace flags, excluding flag
              <c>set_on_first_spawn</c>.</p>
          </item>
          <tag><c>set_on_link</c></tag>
          <item>
            <p>Makes any process linked by a traced process inherit its
              trace flags, including flag <c>set_on_link</c>.</p>
          </item>
          <tag><c>set_on_first_link</c></tag>
          <item>
            <p>Makes the first process linked to by a traced process
              inherit its trace flags, excluding flag
              <c>set_on_first_link</c>.</p>
          </item>
          <tag><c>{tracer, Tracer}</c></tag>
          <item>
            <p>Specifies where to send the trace messages. <c>Tracer</c>
              must be the process identifier of a local process
              or the port identifier of a local port.</p>
          </item>
          <tag><c>{tracer, TracerModule, TracerState}</c></tag>
          <item>
            <p>Specifies that a tracer module is to be called
              instead of sending a trace message. The tracer module
              can then ignore or change the trace message. For more details
              on how to write a tracer module, see
              <seealso marker="erts:erl_tracer"><c>erl_tracer(3)</c></seealso>.</p>
          </item>
        </taglist>
        <p>If no <c>tracer</c> is specified, the calling process
          receives all the trace messages.</p>
        <p>The effect of combining <c>set_on_first_link</c> with
          <c>set_on_link</c> is the same as
          <c>set_on_first_link</c> alone. Likewise for
          <c>set_on_spawn</c> and <c>set_on_first_spawn</c>.</p>
        <p>The tracing process receives the <em>trace messages</em> described
          in the following list. <c>Pid</c> is the process identifier of the
          traced process in which the traced event has occurred. The
          third tuple element is the message tag.</p>
        <p>If flag <c>timestamp</c>, <c>strict_monotonic_timestamp</c>, or
          <c>monotonic_timestamp</c> is specified, the first tuple
          element is <c>trace_ts</c> instead, and the time stamp
          is added as an extra element last in the message tuple. If
          multiple time stamp flags are passed, <c>timestamp</c> has
          precedence over <c>strict_monotonic_timestamp</c>, which
          in turn has precedence over <c>monotonic_timestamp</c>. All
          time stamp flags are remembered, so if two are passed
          and the one with highest precedence later is disabled,
          the other one becomes active.</p>
        <p>If a match specification (applicable only for <c>call</c>, <c>send</c>
          and <c>'receive'</c> tracing) contains a <c>{message}</c> action
          function with a non-boolean value, that value is added as an extra
          element to the message tuple either in the last position or before
          the timestamp (if it is present).</p>
        <p>Trace messages:</p>
        <marker id="trace_3_trace_messages"></marker>
        <taglist>
          <tag>
            <marker id="trace_3_trace_messages_send"></marker>
            <c>{trace, PidPort, send, Msg, To}</c>
          </tag>
          <item>
            <p>When <c>PidPort</c> sends message <c>Msg</c> to
              process <c>To</c>.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_send_to_non_existing_process"/>
            <c>{trace, PidPort, send_to_non_existing_process, Msg, To}</c>
          </tag>
          <item>
            <p>When <c>PidPort</c> sends message <c>Msg</c> to
              the non-existing process <c>To</c>.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_receive"></marker>
            <c>{trace, PidPort, 'receive', Msg}</c>
          </tag>
          <item>
            <p>When <c>PidPort</c> receives message <c>Msg</c>.
              If <c>Msg</c> is set to time-out, a receive
              statement can have timed out, or the process received
              a message with the payload <c>timeout</c>.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_call"></marker>
            <c>{trace, Pid, call, {M, F, Args}}</c>
          </tag>
          <item>
            <p>When <c>Pid</c> calls a traced function. The return
              values of calls are never supplied, only the call and its
              arguments.</p>
            <p>Trace flag <c>arity</c> can be used to
              change the contents of this message, so that <c>Arity</c>
              is specified instead of <c>Args</c>.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_return_to"></marker>
            <c>{trace, Pid, return_to, {M, F, Arity}}</c>
          </tag>
          <item>
            <p>When <c>Pid</c> returns <em>to</em> the specified
              function. This trace message is sent if both
              the flags <c>call</c> and <c>return_to</c> are set,
              and the function is set to be traced on <em>local</em>
              function calls. The message is only sent when returning
              from a chain of tail recursive function calls, where at
              least one call generated a <c>call</c> trace message
              (that is, the functions match specification matched, and
              <c>{message, false}</c> was not an action).</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_return_from"></marker>
            <c>{trace, Pid, return_from, {M, F, Arity}, ReturnValue}</c>
          </tag>
          <item>
            <p>When <c>Pid</c> returns <em>from</em> the specified
              function. This trace message is sent if flag <c>call</c>
              is set, and the function has a match specification
              with a <c>return_trace</c> or <c>exception_trace</c> action.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_exception_from"></marker>
            <c>{trace, Pid, exception_from, {M, F, Arity}, {Class, Value}}</c>
          </tag>
          <item>
            <p>When <c>Pid</c> exits <em>from</em> the specified
              function because of an exception. This trace message is
              sent if flag <c>call</c> is set, and the function has 
              a match specification with an <c>exception_trace</c> action.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_spawn"></marker>
            <c>{trace, Pid, spawn, Pid2, {M, F, Args}}</c>
          </tag>
          <item>
            <p>When <c>Pid</c> spawns a new process <c>Pid2</c> with
              the specified function call as entry point.</p>
            <p><c>Args</c> is supposed to be the argument list,
              but can be any term if the spawn is erroneous.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_spawned"></marker>
            <c>{trace, Pid, spawned, Pid2, {M, F, Args}}</c>
          </tag>
          <item>
            <p>When <c>Pid</c> is spawned by process <c>Pid2</c> with
              the specified function call as entry point.</p>
            <p><c>Args</c> is supposed to be the argument list,
              but can be any term if the spawn is erroneous.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_exit"></marker>
            <c>{trace, Pid, exit, Reason}</c>
          </tag>
          <item>
            <p>When <c>Pid</c> exits with reason <c>Reason</c>.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_register"></marker>
            <c>{trace, PidPort, register, RegName}</c>
          </tag>
          <item>
            <p>When <c>PidPort</c> gets the name <c>RegName</c> registered.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_unregister"></marker>
            <c>{trace, PidPort, unregister, RegName}</c>
          </tag>
          <item>
            <p>When <c>PidPort</c> gets the name <c>RegName</c> unregistered.
              This is done automatically when a registered
              process or port exits.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_link"></marker>
            <c>{trace, Pid, link, Pid2}</c>
          </tag>
          <item>
            <p>When <c>Pid</c> links to a process <c>Pid2</c>.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_unlink"></marker>
            <c>{trace, Pid, unlink, Pid2}</c>
          </tag>
          <item>
            <p>When <c>Pid</c> removes the link from a process
              <c>Pid2</c>.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_getting_linked"></marker>
            <c>{trace, PidPort, getting_linked, Pid2}</c>
          </tag>
          <item>
            <p>When <c>PidPort</c> gets linked to a process <c>Pid2</c>.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_getting_unlinked"></marker>
            <c>{trace, PidPort, getting_unlinked, Pid2}</c>
          </tag>
          <item>
            <p>When <c>PidPort</c> gets unlinked from a process <c>Pid2</c>.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_exit"></marker>
            <c>{trace, Pid, exit, Reason}</c>
          </tag>
          <item>
            <p>When <c>Pid</c> exits with reason <c>Reason</c>.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_open"></marker>
            <c>{trace, Port, open, Pid, Driver}</c>
          </tag>
          <item>
            <p>When <c>Pid</c> opens a new port <c>Port</c> with
              the running <c>Driver</c>.</p>
            <p><c>Driver</c> is the name of the driver as an atom.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_closed"></marker>
            <c>{trace, Port, closed, Reason}</c>
          </tag>
          <item>
            <p>When <c>Port</c> closes with <c>Reason</c>.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_in_proc"></marker>
            <marker id="trace_3_trace_messages_in_exiting_proc"></marker>
            <c>{trace, Pid, in | in_exiting, {M, F, Arity} | 0}</c>
          </tag>
          <item>
            <p>When <c>Pid</c> is scheduled to run. The process
              runs in function <c>{M, F, Arity}</c>. On some rare
              occasions, the current function cannot be determined,
              then the last element is <c>0</c>.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_out_proc"></marker>
            <marker id="trace_3_trace_messages_out_exiting_proc"></marker>
            <marker id="trace_3_trace_messages_out_exited_proc"></marker>
            <c>{trace, Pid, out | out_exiting | out_exited, {M, F, Arity}
            | 0}</c>
          </tag>
          <item>
            <p>When <c>Pid</c> is scheduled out. The process was
              running in function {M, F, Arity}. On some rare occasions,
              the current function cannot be determined, then the last
              element is <c>0</c>.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_in_port"></marker>
            <c>{trace, Port, in, Command | 0}</c>
          </tag>
          <item>
            <p>When <c>Port</c> is scheduled to run. <c>Command</c> is the
              first thing the port will execute, it can however run several
              commands before being scheduled out. On some rare
              occasions, the current function cannot be determined,
              then the last element is <c>0</c>.</p>
            <p>The possible commands are <c>call</c>, <c>close</c>,
              <c>command</c>, <c>connect</c>, <c>control</c>, <c>flush</c>,
              <c>info</c>, <c>link</c>, <c>open</c>, and <c>unlink</c>.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_out_port"></marker>
            <c>{trace, Port, out, Command | 0}</c>
          </tag>
          <item>
            <p>When <c>Port</c> is scheduled out. The last command run
              was <c>Command</c>. On some rare occasions,
              the current function cannot be determined, then the last
              element is <c>0</c>. <c>Command</c> can contain the same
              commands as <c>in</c></p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_gc_minor_start"></marker>
            <c>{trace, Pid, gc_minor_start, Info}</c>
          </tag>
          <item>
          <marker id="gc_minor_start"></marker>
            <p>Sent when a young garbage collection is about to be started.
              <c>Info</c> is a list of two-element tuples, where
              the first element is a key, and the second is the value.
              Do not depend on any order of the tuples.
              The following keys are defined:</p>
            <taglist>
              <tag><c>heap_size</c></tag>
              <item>The size of the used part of the heap.</item>
              <tag><c>heap_block_size</c></tag>
              <item>The size of the memory block used for storing
                the heap and the stack.</item>
              <tag><c>old_heap_size</c></tag>
              <item>The size of the used part of the old heap.</item>
              <tag><c>old_heap_block_size</c></tag>
              <item>The size of the memory block used for storing
                the old heap.</item>
              <tag><c>stack_size</c></tag>
              <item>The size of the stack.</item>
              <tag><c>recent_size</c></tag>
              <item>The size of the data that survived the previous garbage
                collection.</item>
              <tag><c>mbuf_size</c></tag>
              <item>The combined size of message buffers associated with
                the process.</item>
              <tag><c>bin_vheap_size</c></tag>
              <item>The total size of unique off-heap binaries referenced
                from the process heap.</item>
              <tag><c>bin_vheap_block_size</c></tag>
              <item>The total size of binaries allowed in the virtual
                heap in the process before doing a garbage collection.</item>
              <tag><c>bin_old_vheap_size</c></tag>
              <item>The total size of unique off-heap binaries referenced
                from the process old heap.</item>
              <tag><c>bin_old_vheap_block_size</c></tag>
              <item>The total size of binaries allowed in the virtual
                old heap in the process before doing a garbage
                collection.</item>
            </taglist>
            <p>All sizes are in words.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_gc_max_heap_size"></marker>
            <c>{trace, Pid, gc_max_heap_size, Info}</c>
          </tag>
          <item>
            <p>Sent when the <seealso marker="#process_flag_max_heap_size">
              <c>max_heap_size</c></seealso>
              is reached during garbage collection. <c>Info</c> contains the
              same kind of list as in message <c>gc_start</c>,
              but the sizes reflect the sizes that triggered
              <c>max_heap_size</c> to be reached.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_gc_minor_end"></marker>
            <c>{trace, Pid, gc_minor_end, Info}</c>
          </tag>
          <item>
            <p>Sent when young garbage collection is finished. <c>Info</c>
              contains the same kind of list as in message
              <c>gc_minor_start</c>,
              but the sizes reflect the new sizes after
              garbage collection.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_gc_major_start"></marker>
            <c>{trace, Pid, gc_major_start, Info}</c>
          </tag>
          <item>
            <p>Sent when fullsweep garbage collection is about to be started.
              <c>Info</c> contains the same kind of list as in message
              <c>gc_minor_start</c>.</p>
          </item>
          <tag>
            <marker id="trace_3_trace_messages_gc_major_end"></marker>
            <c>{trace, Pid, gc_major_end, Info}</c>
          </tag>
          <item>
            <p>Sent when fullsweep garbage collection is finished. <c>Info</c>
              contains the same kind of list as in message
              <c>gc_minor_start</c>, but the sizes reflect the new sizes after
              a fullsweep garbage collection.</p>
          </item>
        </taglist>
        <p>If the tracing process/port dies or the tracer module returns
          <c>remove</c>, the flags are silently removed.</p>
        <p>Each process can only be traced by one tracer. Therefore,
          attempts to trace an already traced process fail.</p>
        <p>Returns a number indicating the number of processes that
          matched <c><anno>PidPortSpec</anno></c>.
          If <c><anno>PidPortSpec</anno></c> is a process
          identifier, the return value is <c>1</c>.
          If <c><anno>PidPortSpec</anno></c>
          is <c>all</c> or <c>existing</c>, the return value is
          the number of processes running.
          If <c><anno>PidPortSpec</anno></c> is <c>new</c>, the return value is
          <c>0</c>.</p>
        <p>Failure: <c>badarg</c> if the specified arguments are
          not supported. For example, <c>cpu_timestamp</c> is not
          supported on all platforms.</p>
      </desc>
    </func>

    <func>
      <name name="trace_delivered" arity="1" since=""/>
      <fsummary>Notification when trace has been delivered.</fsummary>
      <desc>
        <p>The delivery of trace messages (generated by
          <seealso marker="#trace/3"><c>erlang:trace/3</c></seealso>,
          <seealso marker="kernel:seq_trace"><c>seq_trace(3)</c></seealso>,
          or <seealso marker="#system_profile/2">
          <c>erlang:system_profile/2</c></seealso>)
          is dislocated on the time-line
          compared to other events in the system. If you know that
          <c><anno>Tracee</anno></c> has passed some specific point
          in its execution,
          and you want to know when at least all trace messages
          corresponding to events up to this point have reached the
          tracer, use <c>erlang:trace_delivered(<anno>Tracee</anno>)</c>.</p>
        <p>When it is guaranteed that all trace messages are delivered to
          the tracer up to the point that <c><anno>Tracee</anno></c> reached
          at the time of the call to
          <c>erlang:trace_delivered(<anno>Tracee</anno>)</c>, then a
          <c>{trace_delivered, <anno>Tracee</anno>, <anno>Ref</anno>}</c>
          message is sent to the caller of
          <c>erlang:trace_delivered(<anno>Tracee</anno>)</c> .</p>
        <p>Notice that message <c>trace_delivered</c> does <em>not</em>
          imply that trace messages have been delivered.
          Instead it implies that all trace messages that
          <em>are to be delivered</em> have been delivered.
          It is not an error if <c><anno>Tracee</anno></c> is not, and
          has not been traced by someone, but if this is the case,
          <em>no</em> trace messages have been delivered when the
          <c>trace_delivered</c> message arrives.</p>
        <p>Notice that <c><anno>Tracee</anno></c> must refer
          to a process currently
          or previously existing on the same node as the caller of
          <c>erlang:trace_delivered(<anno>Tracee</anno>)</c> resides on.
          The special <c><anno>Tracee</anno></c> atom <c>all</c>
          denotes all processes that currently are traced in the node.</p>
        <p>When used together with a <seealso marker="erts:erl_tracer">
          Tracer Module</seealso>, any message sent in the trace callback
          is guaranteed to have reached its recipient before the
          <c>trace_delivered</c> message is sent.</p>
        <p>Example: Process <c>A</c> is <c><anno>Tracee</anno></c>,
          port <c>B</c> is tracer, and process <c>C</c> is the port
          owner of <c>B</c>. <c>C</c> wants to close <c>B</c> when
          <c>A</c> exits. To ensure that the trace is not truncated,
          <c>C</c> can call <c>erlang:trace_delivered(A)</c> when
          <c>A</c> exits, and wait for message <c>{trace_delivered, A,
          <anno>Ref</anno>}</c> before closing <c>B</c>.</p>
        <p>Failure: <c>badarg</c> if <c><anno>Tracee</anno></c>
          does not refer to a
          process (dead or alive) on the same node as the caller of
          <c>erlang:trace_delivered(<anno>Tracee</anno>)</c> resides on.</p>
      </desc>
    </func>

    <func>
      <name name="trace_info" arity="2" since=""/>
      <fsummary>Trace information about a process or function.</fsummary>
      <type name="trace_info_return"/>
      <type name="trace_info_item_result"/>
      <type name="trace_info_flag"/>
      <type name="trace_match_spec"/>
      <type name="match_variable"/>
      <type_desc name="match_variable">
        Approximation of '$1' | '$2' | '$3' | ...
      </type_desc>
      <desc>
        <p>Returns trace information about a port, process, function, or
          event.</p>
        <p><em>To get information about a port or process</em>,
          <c><anno>PidPortFuncEvent</anno></c> is to
          be a process identifier (pid), port identifier, or one of
          the atoms <c>new</c>, <c>new_processes</c>, or <c>new_ports</c>. The
          atom <c>new</c> or <c>new_processes</c> means that the default trace
          state for processes to be created is returned. The atom
          <c>new_ports</c> means that the default trace state for ports to be
          created is returned.</p>
        <p>Valid <c>Item</c>s for ports and processes:</p>
        <taglist>
          <tag><c>flags</c></tag>
          <item>
            <p>Returns a list of atoms indicating what kind of traces is
              enabled for the process. The list is empty if no
              traces are enabled, and one or more of the followings
              atoms if traces are enabled: <c>send</c>,
              <c>'receive'</c>, <c>set_on_spawn</c>, <c>call</c>,
              <c>return_to</c>, <c>procs</c>, <c>ports</c>,
              <c>set_on_first_spawn</c>,
              <c>set_on_link</c>, <c>running</c>, <c>running_procs</c>,
              <c>running_ports</c>, <c>silent</c>, <c>exiting</c>,
              <c>monotonic_timestamp</c>, <c>strict_monotonic_timestamp</c>,
              <c>garbage_collection</c>, <c>timestamp</c>, and
              <c>arity</c>. The order is arbitrary.</p>
          </item>
          <tag><c>tracer</c></tag>
          <item>
            <p>Returns the identifier for process, port, or a tuple containing
              the tracer module and tracer state tracing this
              process. If this process is not traced, the return
              value is <c>[]</c>.</p>
          </item>
        </taglist>
        <p><em>To get information about a function</em>,
          <c><anno>PidPortFuncEvent</anno></c> is to
          be the three-element tuple <c>{Module, Function, Arity}</c> or
          the atom <c>on_load</c>. No wildcards are allowed. Returns
          <c>undefined</c> if the function does not exist, or
          <c>false</c> if the function is not traced.
          If <c><anno>PidPortFuncEvent</anno></c>
          is <c>on_load</c>, the information returned refers to
          the default value for code that will be loaded.</p>
        <p>Valid <c>Item</c>s for functions:</p>
        <taglist>
          <tag><c>traced</c></tag>
          <item>
            <p>Returns <c>global</c> if this function is traced on
              global function calls, <c>local</c> if this function is
              traced on local function calls (that is, local and global
              function calls), and <c>false</c> if local or
              global function calls are not traced.</p>
          </item>
          <tag><c>match_spec</c></tag>
          <item>
            <p>Returns the match specification for this function, if it
              has one. If the function is locally or globally traced but
              has no match specification defined, the returned value
              is <c>[]</c>.</p>
          </item>
          <tag><c>meta</c></tag>
          <item>
            <p>Returns the meta-trace tracer process, port, or trace module
              for this function, if it has one. If the function is not
              meta-traced, the returned value is <c>false</c>. If
              the function is meta-traced but has once detected that
              the tracer process is invalid, the returned value is
              <c>[]</c>.</p>
          </item>
          <tag><c>meta_match_spec</c></tag>
          <item>
            <p>Returns the meta-trace match specification for this
              function, if it has one. If the function is meta-traced
              but has no match specification defined, the returned
              value is <c>[]</c>.</p>
          </item>
          <tag><c>call_count</c></tag>
          <item>
            <p>Returns the call count value for this function or
              <c>true</c> for the pseudo function <c>on_load</c> if call
              count tracing is active. Otherwise <c>false</c> is returned.</p>
            <p>See also <seealso marker="#trace_pattern/3">
              <c>erlang:trace_pattern/3</c></seealso>.</p>
          </item>
          <tag><c>call_time</c></tag>
          <item>
            <p>Returns the call time values for this function or
              <c>true</c> for the pseudo function <c>on_load</c> if call
              time tracing is active. Otherwise <c>false</c> is returned.
              The call time values returned, <c>[{Pid, Count, S, Us}]</c>,
              is a list of each process that executed the function
              and its specific counters.</p>
            <p>See also
              <seealso marker="#trace_pattern/3">
              <c>erlang:trace_pattern/3</c></seealso>.</p>
          </item>
          <tag><c>all</c></tag>
          <item>
            <p>Returns a list containing the
              <c>{<anno>Item</anno>, Value}</c> tuples
              for all other items, or returns <c>false</c> if no tracing
              is active for this function.</p>
          </item>
        </taglist>
        <p><em>To get information about an event</em>,
          <c><anno>PidPortFuncEvent</anno></c> is to
          be one of the atoms <c>send</c> or <c>'receive'</c>.</p>
        <p>One valid <c>Item</c> for events exists:</p>
        <taglist>
          <tag><c>match_spec</c></tag>
          <item>
            <p>Returns the match specification for this event, if it
              has one, or <c>true</c> if no match specification has been
              set.</p>
          </item>
        </taglist>
        <p>The return value is <c>{<anno>Item</anno>, Value}</c>, where
          <c>Value</c> is the requested information as described earlier.
          If a pid for a dead process was specified, or the name of a
          non-existing function, <c>Value</c> is <c>undefined</c>.</p>
      </desc>
    </func>

    <func>
      <name name="trace_pattern" arity="2" clause_i="1" since=""/>
      <fsummary>Set trace patterns for call, send, or 'receive' tracing.
      </fsummary>
      <type name="trace_pattern_mfa"/>
      <type name="trace_match_spec"/>
      <type_desc name="match_variable">
        Approximation of '$1' | '$2' | '$3' | ...
      </type_desc>
      <type name="match_variable"/>
      <desc>
        <p>The same as
          <seealso marker="#trace_pattern/3">
          <c>erlang:trace_pattern(Event, MatchSpec, [])</c></seealso>,
          retained for backward compatibility.</p>
      </desc>
    </func>

    <func>
      <name name="trace_pattern" arity="3" clause_i="1" since="OTP 19.0"/>
      <fsummary>Set trace pattern for message sending.</fsummary>
      <type name="trace_match_spec"/>
      <type name="match_variable"/>
      <type_desc name="match_variable">
        Approximation of '$1' | '$2' | '$3' | ...
      </type_desc>
      <desc>
        <p>Sets trace pattern for <em>message sending</em>.
          Must be combined with
          <seealso marker="#trace/3"><c>erlang:trace/3</c></seealso>
          to set the <c>send</c> trace flag for one or more processes.
          By default all messages sent from <c>send</c> traced processes
          are traced. To limit
          traced send events based on the message content, the sender
          and/or the receiver, use <c>erlang:trace_pattern/3</c>.</p>
        <p>Argument <c><anno>MatchSpec</anno></c> can take the
          following forms:</p>
        <taglist>
          <tag><c><anno>MatchSpecList</anno></c></tag>
          <item>
            <p>A list of match specifications. The matching is done
              on the list <c>[Receiver, Msg]</c>. <c>Receiver</c>
              is the process or port identity of the receiver and
              <c>Msg</c> is the message term. The pid of the sending
              process can be accessed with the guard function
              <c>self/0</c>. An empty list is the same as <c>true</c>.
              For more information, see section
              <seealso marker="erts:match_spec">
              Match Specifications in Erlang</seealso> in the User's Guide.</p>
          </item>
          <tag><c>true</c></tag>
          <item>
            <p>Enables tracing for all sent messages (from <c>send</c>
              traced processes). Any match specification is
              removed. <em>This is the default</em>.</p>
          </item>
          <tag><c>false</c></tag>
          <item>
            <p>Disables tracing for all sent messages.
              Any match specification is removed.</p>
          </item>
        </taglist>
        <p>Argument <c><anno>FlagList</anno></c> must be <c>[]</c>
          for send tracing.</p>
        <p>The return value is always <c>1</c>.</p>
        <p>Examples:</p>
        <p>Only trace messages to a specific process <c>Pid</c>:</p>
        <pre>
> <input>erlang:trace_pattern(send, [{[Pid, '_'],[],[]}], []).</input>
1</pre>
        <p>Only trace messages matching <c>{reply, _}</c>:</p>
        <pre>
> <input>erlang:trace_pattern(send, [{['_', {reply,'_'}],[],[]}], []).</input>
1</pre>
        <p>Only trace messages sent to the sender itself:</p>
        <pre>
> <input>erlang:trace_pattern(send, [{['$1', '_'],[{'=:=','$1',{self}}],[]}], []).</input>
1</pre>
        <p>Only trace messages sent to other nodes:</p>
        <pre>
> <input>erlang:trace_pattern(send, [{['$1', '_'],[{'=/=',{node,'$1'},{node}}],[]}], []).</input>
1</pre>
        <note>
          <p>A match specification for <c>send</c> trace can use
            all guard and body functions except <c>caller</c>.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="trace_pattern" arity="3" clause_i="2" since="OTP 19.0"/>
      <fsummary>Set trace pattern for tracing of message receiving.</fsummary>
      <type name="trace_match_spec"/>
      <type name="match_variable"/>
      <type_desc name="match_variable">
        Approximation of '$1' | '$2' | '$3' | ...
      </type_desc>
      <desc>
        <p>Sets trace pattern for <em>message receiving</em>.
          Must be combined with
          <seealso marker="#trace/3"><c>erlang:trace/3</c></seealso>
          to set the <c>'receive'</c> trace flag for one or more processes.
          By default all messages received by <c>'receive'</c> traced
          processes are traced. To limit
          traced receive events based on the message content, the sender
          and/or the receiver, use <c>erlang:trace_pattern/3</c>.</p>
        <p>Argument <c><anno>MatchSpec</anno></c> can take the
          following forms:</p>
        <taglist>
          <tag><c><anno>MatchSpecList</anno></c></tag>
          <item>
            <p>A list of match specifications. The matching is done
              on the list <c>[Node, Sender, Msg]</c>. <c>Node</c>
              is the node name of the sender. <c>Sender</c> is the
              process or port identity of the sender, or the atom
              <c>undefined</c> if the sender is not known (which can
              be the case for remote senders). <c>Msg</c> is the
              message term. The pid of the receiving process can be
              accessed with the guard function <c>self/0</c>. An empty
              list is the same as <c>true</c>. For more information, see
              section <seealso marker="erts:match_spec">
              Match Specifications in Erlang</seealso> in the User's Guide.</p>
          </item>
          <tag><c>true</c></tag>
          <item>
            <p>Enables tracing for all received messages (to <c>'receive'</c>
              traced processes). Any match specification is
              removed. <em>This is the default</em>.</p>
          </item>
          <tag><c>false</c></tag>
          <item>
            <p>Disables tracing for all received messages.
              Any match specification is removed.</p>
          </item>
        </taglist>
        <p>Argument <c><anno>FlagList</anno></c> must be <c>[]</c>
          for receive tracing.</p>
        <p>The return value is always <c>1</c>.</p>
        <p>Examples:</p>
        <p>Only trace messages from a specific process <c>Pid</c>:</p>
        <pre>
> <input>erlang:trace_pattern('receive', [{['_',Pid, '_'],[],[]}], []).</input>
1</pre>
        <p>Only trace messages matching <c>{reply, _}</c>:</p>
        <pre>
> <input>erlang:trace_pattern('receive', [{['_','_', {reply,'_'}],[],[]}], []).</input>
1</pre>
        <p>Only trace messages from other nodes:</p>
        <pre>
> <input>erlang:trace_pattern('receive', [{['$1', '_', '_'],[{'=/=','$1',{node}}],[]}], []).</input>
1</pre>
        <note>
          <p>A match specification for <c>'receive'</c> trace can
            use all guard and body functions except <c>caller</c>,
            <c>is_seq_trace</c>, <c>get_seq_token</c>, <c>set_seq_token</c>,
            <c>enable_trace</c>, <c>disable_trace</c>, <c>trace</c>,
            <c>silent</c>, and <c>process_dump</c>.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="trace_pattern" arity="3" clause_i="3" since=""/>
      <fsummary>Set trace patterns for tracing of function calls.</fsummary>
      <type name="trace_pattern_mfa"/>
      <type name="trace_match_spec"/>
      <type name="trace_pattern_flag"/>
      <type name="match_variable"/>
      <type_desc name="match_variable">
        Approximation of '$1' | '$2' | '$3' | ...
      </type_desc>
      <desc>
        <p>Enables or disables <em>call tracing</em> for one or more functions.
          Must be combined with
          <seealso marker="#trace/3"><c>erlang:trace/3</c></seealso>
          to set the <c>call</c> trace flag
          for one or more processes.</p>
        <p>Conceptually, call tracing works as follows. Inside
          the Erlang virtual machine, a set of processes and
          a set of functions are to be traced. If a traced process
          calls a traced function, the trace action is taken.
          Otherwise, nothing happens.</p>
        <p>To add or remove one or more processes to the set of traced
          processes, use
          <seealso marker="#trace/3"><c>erlang:trace/3</c></seealso>.</p>
        <p>To add or remove functions to the set of traced
          functions, use <c>erlang:trace_pattern/3</c>.</p>
        <p>The BIF <c>erlang:trace_pattern/3</c> can also add match
          specifications to a function. A match specification
          comprises a pattern that the function arguments must
          match, a guard expression that must evaluate to <c>true</c>,
          and an action to be performed. The default action is to send a
          trace message. If the pattern does not match or the guard
          fails, the action is not executed.</p>
        <p>Argument <c><anno>MFA</anno></c> is to be a tuple, such as
          <c>{Module, Function, Arity}</c>, or the atom <c>on_load</c>
          (described below). It can be the module, function,
          and arity for a function (or a BIF in any module).
          The atom <c>'_'</c> can be used as a wildcard in any of the
          following ways:</p>
        <taglist>
          <tag><c>{Module,Function,'_'}</c></tag>
          <item>
            <p>All functions of any arity named <c>Function</c>
              in module <c>Module</c>.</p>
          </item>
          <tag><c>{Module,'_','_'}</c></tag>
          <item>
            <p>All functions in module <c>Module</c>.</p>
          </item>
          <tag><c>{'_','_','_'}</c></tag>
          <item>
            <p>All functions in all loaded modules.</p>
          </item>
        </taglist>
        <p>Other combinations, such as <c>{Module,'_',Arity}</c>, are
          not allowed. Local functions match wildcards only if
          option <c>local</c> is in <c><anno>FlagList</anno></c>.</p>
        <p>If argument <c><anno>MFA</anno></c> is the atom <c>on_load</c>,
          the match specification and flag list are used on all
          modules that are newly loaded.</p>
        <p>Argument <c><anno>MatchSpec</anno></c> can take the
          following forms:</p>
        <taglist>
          <tag><c>false</c></tag>
          <item>
            <p>Disables tracing for the matching functions.
              Any match specification is removed.</p>
          </item>
          <tag><c>true</c></tag>
          <item>
            <p>Enables tracing for the matching functions.
              Any match specification is removed.</p>
          </item>
          <tag><c><anno>MatchSpecList</anno></c></tag>
          <item>
            <p>A list of match specifications. An empty list is
              equivalent to <c>true</c>. For a description of match
              specifications, see section <seealso marker="erts:match_spec">
              Match Specifications in Erlang</seealso> in the User's Guide.</p>
          </item>
          <tag><c>restart</c></tag>
          <item>
            <p>For the <c><anno>FlagList</anno></c> options <c>call_count</c>
              and <c>call_time</c>: restarts
              the existing counters. The behavior is undefined
              for other <c><anno>FlagList</anno></c> options.</p>
          </item>
          <tag><c>pause</c></tag>
          <item>
            <p>For the <c><anno>FlagList</anno></c> options
              <c>call_count</c> and <c>call_time</c>: pauses
              the existing counters. The behavior is undefined for
              other <c><anno>FlagList</anno></c> options.</p>
          </item>
        </taglist>
        <p>Parameter <c><anno>FlagList</anno></c> is a list of options.
          The following are the valid options:</p>
        <taglist>
          <tag><c>global</c></tag>
          <item>
            <p>Turns on or off call tracing for global function calls
              (that is, calls specifying the module explicitly). Only
              exported functions match and only global calls
              generate trace messages. <em>This is the default</em>.</p>
          </item>
          <tag><c>local</c></tag>
          <item>
            <p>Turns on or off call tracing for all types of function
              calls. Trace messages are sent whenever any of
              the specified functions are called, regardless of how they
              are called. If flag <c>return_to</c> is set for
              the process, a <c>return_to</c> message is also sent
              when this function returns to its caller.</p>
          </item>
          <tag><c>meta | {meta, <anno>Pid</anno>} |
            {meta, <anno>TracerModule</anno>, <anno>TracerState</anno>}</c>
          </tag>
          <item>
            <p>Turns on or off meta-tracing for all types of function
              calls. Trace messages are sent to the tracer whenever any of
              the specified functions are called. If no tracer is specified,
              <c>self()</c> is used as a default tracer process.</p>
            <p>Meta-tracing traces all processes and does not care
              about the process trace flags set by <c>erlang:trace/3</c>,
              the trace flags are instead fixed to
              <c>[call, timestamp]</c>.</p>
            <p>The match specification function <c>{return_trace}</c>
              works with meta-trace and sends its trace message to the
              same tracer.</p>
          </item>
          <tag><c>call_count</c></tag>
          <item>
            <p>Starts (<c><anno>MatchSpec</anno> == true</c>) or stops
              (<c><anno>MatchSpec</anno> == false</c>)
              call count tracing for all
              types of function calls. For every function, a counter is
              incremented when the function is called, in any process.
              No process trace flags need to be activated.</p>
            <p>If call count tracing is started while already running,
              the count is restarted from zero. To pause running
              counters, use <c><anno>MatchSpec</anno> == pause</c>.
              Paused and running counters can be restarted from zero with
              <c><anno>MatchSpec</anno> == restart</c>.</p>
            <p>To read the counter value, use
              <seealso marker="#trace_info/2">
              <c>erlang:trace_info/2</c></seealso>.</p>
          </item>
          <tag><c>call_time</c></tag>
          <item>
            <p>Starts (<c><anno>MatchSpec</anno> == true</c>) or stops
              (<c><anno>MatchSpec</anno> == false</c>) call time
              tracing for all
              types of function calls. For every function, a counter is
              incremented when the function is called.
              Time spent in the function is accumulated in
              two other counters, seconds and microseconds.
              The counters are stored for each call traced process.</p>
            <p>If call time tracing is started while already running,
              the count and time restart from zero. To pause
              running counters, use <c><anno>MatchSpec</anno> == pause</c>.
              Paused and running counters can be restarted from zero with
              <c><anno>MatchSpec</anno> == restart</c>.</p>
            <p>To read the counter value, use
              <seealso marker="#trace_info/2">
              <c>erlang:trace_info/2</c></seealso>.</p>
          </item>
        </taglist>
        <p>The options <c>global</c> and <c>local</c> are mutually
          exclusive, and <c>global</c> is the default (if no options are
          specified). The options <c>call_count</c> and <c>meta</c>
          perform a kind of local tracing, and cannot be combined
          with <c>global</c>. A function can be globally or
          locally traced. If global tracing is specified for a
          set of functions, then local, meta, call time, and call count
          tracing for the matching set of local functions is
          disabled, and conversely.</p>
        <p>When disabling trace, the option must match the type of trace
          set on the function. That is, local tracing must be
          disabled with option <c>local</c> and global tracing with
          option <c>global</c> (or no option), and so on.</p>
        <p>Part of a match specification list cannot be changed directly.
          If a function has a match specification, it can be replaced
          with a new one. To change an existing match specification,
          use the BIF
          <seealso marker="#trace_info/2"><c>erlang:trace_info/2</c></seealso>
          to retrieve the existing match specification.</p>
        <p>Returns the number of functions matching
          argument <c><anno>MFA</anno></c>. This is zero if none matched.</p>
      </desc>
    </func>

    <func>
      <name name="trunc" arity="1" since=""/>
      <fsummary>Return an integer by truncating a number.</fsummary>
      <desc>
        <p>Returns an integer by truncating <c><anno>Number</anno></c>,
          for example:</p>
        <pre>
> <input>trunc(5.5).</input>
5</pre>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="tuple_size" arity="1" since=""/>
      <fsummary>Return the size of a tuple.</fsummary>
      <desc>
        <p>Returns an integer that is the number of elements in
          <c><anno>Tuple</anno></c>, for example:</p>
        <pre>
> <input>tuple_size({morni, mulle, bwange}).</input>
3</pre>
        <p>Allowed in guard tests.</p>
      </desc>
    </func>

    <func>
      <name name="tuple_to_list" arity="1" since=""/>
      <fsummary>Convert a tuple to a list.</fsummary>
      <desc>
        <p>Returns a list corresponding to <c><anno>Tuple</anno></c>.
          <c><anno>Tuple</anno></c> can contain any Erlang terms.
          Example:</p>
        <pre>
> <input>tuple_to_list({share, {'Ericsson_B', 163}}).</input>
[share,{'Ericsson_B',163}]</pre>
      </desc>
    </func>

    <func>
      <name name="unique_integer" arity="0" since="OTP 18.0"/>
      <fsummary>Get a unique integer value.</fsummary>
      <desc>
        <p>Generates and returns an
          <seealso marker="doc/efficiency_guide:advanced#unique_integers">
          integer unique on current runtime system instance</seealso>.
          The same as calling
          <seealso marker="#unique_integer/1">
          <c>erlang:unique_integer([])</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name name="unique_integer" arity="1" since="OTP 18.0"/>
      <fsummary>Get a unique integer value.</fsummary>
      <desc>
        <p>Generates and returns an
          <seealso marker="doc/efficiency_guide:advanced#unique_integers">
          integer unique on current runtime system
          instance</seealso>. The integer is unique in the
          sense that this BIF, using the same set of
          modifiers, does not return the same integer more
          than once on the current runtime system instance.
          Each integer value can of course be constructed
          by other means.</p>
        <p>By default, when <c>[]</c> is passed as
          <c><anno>ModifierList</anno></c>, both negative and
          positive integers can be returned. This
          to use the range of integers that do
          not need heap memory allocation as much as possible.
          By default the returned integers are also only
          guaranteed to be unique, that is, any returned integer
          can be smaller or larger than previously
          returned integers.</p>
        <p><c><anno>Modifier</anno></c>s:</p>
        <taglist>
          <tag>positive</tag>
          <item>
            <p>Returns only positive integers.</p>
            <p>Notice that by passing the <c>positive</c> modifier
              you will get heap allocated integers (bignums) quicker.</p>
          </item>
          <tag>monotonic</tag>
          <item>
            <p>Returns <seealso
              marker="time_correction#Strictly_Monotonically_Increasing">
              strictly monotonically increasing</seealso> integers
              corresponding to creation time. That is, the integer
              returned is always larger than previously
              returned integers on the current runtime system
              instance.</p>
            <p>These values can be used to determine order between events
              on the runtime system instance. That is, if both
              <c>X = erlang:unique_integer([monotonic])</c> and
              <c>Y = erlang:unique_integer([monotonic])</c> are
              executed by different processes (or the same
              process) on the same runtime system instance and
              <c>X &lt; Y</c>, we know that <c>X</c> was created
              before <c>Y</c>.</p>
            <warning>
              <p>Strictly monotonically increasing values
                are inherently quite expensive to generate and scales
                poorly. This is because the values need to be synchronized
                between CPU cores. That is, do not pass the <c>monotonic</c>
                modifier unless you really need strictly monotonically
                increasing values.</p>
            </warning>
        </item>
        </taglist>
        <p>All valid <c><anno>Modifier</anno></c>s
          can be combined. Repeated (valid)
          <c><anno>Modifier</anno></c>s in the <c>ModifierList</c>
          are ignored.</p>
        <note>
          <p>The set of integers returned by
            <c>erlang:unique_integer/1</c> using different sets of
            <c><anno>Modifier</anno></c>s <em>will overlap</em>.
            For example, by calling <c>unique_integer([monotonic])</c>,
            and <c>unique_integer([positive, monotonic])</c>
            repeatedly, you will eventually see some integers that are
            returned by both calls.</p>
        </note>
        <p>Failures:</p>
        <taglist>
          <tag><c>badarg</c></tag>
          <item>if <c><anno>ModifierList</anno></c> is not a
            proper list.</item>
          <tag><c>badarg</c></tag>
          <item>if <c><anno>Modifier</anno></c> is not a
            valid modifier.</item>
        </taglist>
      </desc>
    </func>

    <func>
      <name name="universaltime" arity="0" since=""/>
      <fsummary>Current date and time according to Universal Time Coordinated
        (UTC).</fsummary>
      <desc>
        <p>Returns the current date and time according to Universal
          Time Coordinated (UTC) in the form
          <c>{{Year, Month, Day}, {Hour, Minute, Second}}</c> if
          supported by the underlying OS.
          Otherwise <c>erlang:universaltime()</c> is equivalent to
          <c>erlang:localtime()</c>. Example:</p>
        <pre>
> <input>erlang:universaltime().</input>
{{1996,11,6},{14,18,43}}</pre>
      </desc>
    </func>

    <func>
      <name name="universaltime_to_localtime" arity="1" since=""/>
      <fsummary>Convert from Universal Time Coordinated (UTC) to local date
        and time.</fsummary>
      <desc>
        <p>Converts Universal Time Coordinated (UTC) date and time to
          local date and time in the form
          <c>{{Year, Month, Day}, {Hour, Minute, Second}}</c> if
          supported by the underlying OS.
          Otherwise no conversion is done, and
          <c><anno>Universaltime</anno></c> is returned. Example:</p>
        <pre>
> <input>erlang:universaltime_to_localtime({{1996,11,6},{14,18,43}}).</input>
{{1996,11,7},{15,18,43}}</pre>
        <p>Failure: <c>badarg</c> if <c>Universaltime</c> denotes
          an invalid date and time.</p>
      </desc>
    </func>

    <func>
      <name name="unlink" arity="1" since=""/>
      <fsummary>Remove a link to another process or port.</fsummary>
      <desc>
        <p>Removes the link, if there is one, between the calling
          process and the process or port referred to by
          <c><anno>Id</anno></c>.</p>
        <p>Returns <c>true</c> and does not fail, even if there is no
          link to <c><anno>Id</anno></c>, or if <c><anno>Id</anno></c>
          does not exist.</p>
        <p>Once <c>unlink(<anno>Id</anno>)</c> has returned,
          it is guaranteed that
          the link between the caller and the entity referred to by
          <c><anno>Id</anno></c> has no effect on the caller
          in the future (unless
          the link is setup again). If the caller is trapping exits, an
          <c>{'EXIT', <anno>Id</anno>, _}</c> message from the link
          can have been placed in the caller's message queue before
          the call.</p>
        <p>Notice that the <c>{'EXIT', <anno>Id</anno>, _}</c>
          message can be the
          result of the link, but can also be the result of <c>Id</c>
          calling <c>exit/2</c>. Therefore, it <em>can</em> be
          appropriate to clean up the message queue when trapping exits
          after the call to <c>unlink(<anno>Id</anno>)</c>, as follows:</p>
        <code type="none">
unlink(Id),
receive
    {'EXIT', Id, _} ->
        true
after 0 ->
        true
end</code>
        <note>
          <p>Before Erlang/OTP R11B (ERTS 5.5) <c>unlink/1</c>
            behaved completely asynchronously, that is, the link was active
            until the "unlink signal" reached the linked entity. This
            had an undesirable effect, as you could never know when
            you were guaranteed <em>not</em> to be effected by the link.</p>
          <p>The current behavior can be viewed as two combined operations:
            asynchronously send an "unlink signal" to the linked entity
            and ignore any future results of the link.</p>
        </note>
      </desc>
    </func>

    <func>
      <name name="unregister" arity="1" since=""/>
      <fsummary>Remove the registered name for a process (or port).</fsummary>
      <desc>
        <p>Removes the registered name <c><anno>RegName</anno></c>
          associated with a
          process identifier or a port identifier, for example:</p>
        <pre>
> <input>unregister(db).</input>
true</pre>
        <p>Users are advised not to unregister system processes.</p>
        <p>Failure: <c>badarg</c> if <c>RegName</c> is not a registered
          name.</p>
      </desc>
    </func>

    <func>
      <name name="whereis" arity="1" since=""/>
      <fsummary>Get the pid (or port) with a specified registered name.
      </fsummary>
      <desc>
        <p>Returns the process identifier or port identifier with
          the registered name <c>RegName</c>. Returns <c>undefined</c>
          if the name is not registered. Example:</p>
        <pre>
> <input>whereis(db).</input>
&lt;0.43.0></pre>
      </desc>
    </func>

    <func>
      <name name="yield" arity="0" since=""/>
      <fsummary>Let other processes get a chance to execute.</fsummary>
      <desc>
        <p>Voluntarily lets other processes (if any) get a chance to
          execute. Using this function is similar to
          <c>receive after 1 -> ok end</c>, except that <c>yield()</c>
          is faster.</p>
        <warning>
          <p>There is seldom or never any need to use this BIF
            as other processes have a chance to run in another scheduler
            thread anyway.
            Using this BIF without a thorough grasp of how the scheduler
            works can cause performance degradation.</p>
        </warning>
      </desc>
    </func>
  </funcs>
</erlref>
